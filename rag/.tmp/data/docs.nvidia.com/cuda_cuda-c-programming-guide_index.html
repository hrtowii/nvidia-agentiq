<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<meta content="The programming guide to the CUDA model and interface." name="description" />
<meta content="CUDA C++, CUDA C++ programming model, CUDA C++ programming interface, CUDA C++ performance guidelines, CUDA C++ language extensions, CUDA C++ mathematical functions, __global__, execution configuration, memory hierarchy, threads, heterogeneous programming, compute capability, SM version, Pascal, NVIDIA Ampere GPU, Volta, Maxwell, Turing, Tesla, Fermi, Hopper, Ada, environment variables, CUDA_VISIBLE_DEVICES, CUDA_MANAGED_FORCE_DEVICE_ALLOC, CUDA_DEVICE_ORDER, CUDA_CACHE_DISABLE, CUDA_CACHE_PATH, CUDA_CACHE_MAXSIZE, CUDA_FORCE_PTX_JIT, CUDA_DISABLE_PTX_JIT, CUDA_FORCE_JIT, CUDA_DISABLE_JIT, CUDA_LAUNCH_BLOCKING, CUDA_DEVICE_MAX_CONNECTIONS, CUDA_AUTO_BOOST, CUDA_DEVICE_WAITS_ON_EXCEPTION, CUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT, CUDA_MODULE_LOADING, CUDA_FORCE_PRELOAD_LIBRARIES" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. Introduction &mdash; CUDA C++ Programming Guide</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
      <link rel="stylesheet" href="../_static/omni-style.css" type="text/css" />
      <link rel="stylesheet" href="../_static/api-styles.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tables.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/mermaid-init.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/design-tabs.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script src="../_static/version.js"></script>
        <script src="../_static/social-media.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Contents" href="contents.html" />
 


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


<a href="contents.html">
  <img src="../_static/Logo_and_CUDA.png" class="logo" alt="Logo"/>
</a>

<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-benefits-of-using-gpus">1.1. The Benefits of Using GPUs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cuda-a-general-purpose-parallel-computing-platform-and-programming-model">1.2. CUDAÂ®: A General-Purpose Parallel Computing Platform and Programming Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-scalable-programming-model">1.3. A Scalable Programming Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#document-structure">1.4. Document Structure</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#programming-model">2. Programming Model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#kernels">2.1. Kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#thread-hierarchy">2.2. Thread Hierarchy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thread-block-clusters">2.2.1. Thread Block Clusters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-hierarchy">2.3. Memory Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#heterogeneous-programming">2.4. Heterogeneous Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-simt-programming-model">2.5. Asynchronous SIMT Programming Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-operations">2.5.1. Asynchronous Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability">2.6. Compute Capability</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#programming-interface">3. Programming Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#compilation-with-nvcc">3.1. Compilation with NVCC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compilation-workflow">3.1.1. Compilation Workflow</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#offline-compilation">3.1.1.1. Offline Compilation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#just-in-time-compilation">3.1.1.2. Just-in-Time Compilation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#binary-compatibility">3.1.2. Binary Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ptx-compatibility">3.1.3. PTX Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-compatibility">3.1.4. Application Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-compatibility">3.1.5. C++ Compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bit-compatibility">3.1.6. 64-Bit Compatibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cuda-runtime">3.2. CUDA Runtime</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">3.2.1. Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-memory">3.2.2. Device Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-memory-l2-access-management">3.2.3. Device Memory L2 Access Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#l2-cache-set-aside-for-persisting-accesses">3.2.3.1. L2 Cache Set-Aside for Persisting Accesses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#l2-policy-for-persisting-accesses">3.2.3.2. L2 Policy for Persisting Accesses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#l2-access-properties">3.2.3.3. L2 Access Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#l2-persistence-example">3.2.3.4. L2 Persistence Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reset-l2-access-to-normal">3.2.3.5. Reset L2 Access to Normal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#manage-utilization-of-l2-set-aside-cache">3.2.3.6. Manage Utilization of L2 set-aside cache</a></li>
<li class="toctree-l4"><a class="reference internal" href="#query-l2-cache-properties">3.2.3.7. Query L2 cache Properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-l2-cache-set-aside-size-for-persisting-memory-access">3.2.3.8. Control L2 Cache Set-Aside Size for Persisting Memory Access</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory">3.2.4. Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributed-shared-memory">3.2.5. Distributed Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#page-locked-host-memory">3.2.6. Page-Locked Host Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#portable-memory">3.2.6.1. Portable Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-combining-memory">3.2.6.2. Write-Combining Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mapped-memory">3.2.6.3. Mapped Memory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#memory-synchronization-domains">3.2.7. Memory Synchronization Domains</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-fence-interference">3.2.7.1. Memory Fence Interference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#isolating-traffic-with-domains">3.2.7.2. Isolating Traffic with Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-domains-in-cuda">3.2.7.3. Using Domains in CUDA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-concurrent-execution">3.2.8. Asynchronous Concurrent Execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#concurrent-execution-between-host-and-device">3.2.8.1. Concurrent Execution between Host and Device</a></li>
<li class="toctree-l4"><a class="reference internal" href="#concurrent-kernel-execution">3.2.8.2. Concurrent Kernel Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overlap-of-data-transfer-and-kernel-execution">3.2.8.3. Overlap of Data Transfer and Kernel Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#concurrent-data-transfers">3.2.8.4. Concurrent Data Transfers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streams">3.2.8.5. Streams</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#creation-and-destruction-of-streams">3.2.8.5.1. Creation and Destruction of Streams</a></li>
<li class="toctree-l5"><a class="reference internal" href="#default-stream">3.2.8.5.2. Default Stream</a></li>
<li class="toctree-l5"><a class="reference internal" href="#explicit-synchronization">3.2.8.5.3. Explicit Synchronization</a></li>
<li class="toctree-l5"><a class="reference internal" href="#implicit-synchronization">3.2.8.5.4. Implicit Synchronization</a></li>
<li class="toctree-l5"><a class="reference internal" href="#overlapping-behavior">3.2.8.5.5. Overlapping Behavior</a></li>
<li class="toctree-l5"><a class="reference internal" href="#host-functions-callbacks">3.2.8.5.6. Host Functions (Callbacks)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#stream-priorities">3.2.8.5.7. Stream Priorities</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#programmatic-dependent-launch-and-synchronization">3.2.8.6. Programmatic Dependent Launch and Synchronization</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#background">3.2.8.6.1. Background</a></li>
<li class="toctree-l5"><a class="reference internal" href="#api-description">3.2.8.6.2. API Description</a></li>
<li class="toctree-l5"><a class="reference internal" href="#use-in-cuda-graphs">3.2.8.6.3. Use in CUDA Graphs</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#cuda-graphs">3.2.8.7. CUDA Graphs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#graph-structure">3.2.8.7.1. Graph Structure</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#node-types">3.2.8.7.1.1. Node Types</a></li>
<li class="toctree-l6"><a class="reference internal" href="#edge-data">3.2.8.7.1.2. Edge Data</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#creating-a-graph-using-graph-apis">3.2.8.7.2. Creating a Graph Using Graph APIs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#creating-a-graph-using-stream-capture">3.2.8.7.3. Creating a Graph Using Stream Capture</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#cross-stream-dependencies-and-events">3.2.8.7.3.1. Cross-stream Dependencies and Events</a></li>
<li class="toctree-l6"><a class="reference internal" href="#prohibited-and-unhandled-operations">3.2.8.7.3.2. Prohibited and Unhandled Operations</a></li>
<li class="toctree-l6"><a class="reference internal" href="#invalidation">3.2.8.7.3.3. Invalidation</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#cuda-user-objects">3.2.8.7.4. CUDA User Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#updating-instantiated-graphs">3.2.8.7.5. Updating Instantiated Graphs</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#graph-update-limitations">3.2.8.7.5.1. Graph Update Limitations</a></li>
<li class="toctree-l6"><a class="reference internal" href="#whole-graph-update">3.2.8.7.5.2. Whole Graph Update</a></li>
<li class="toctree-l6"><a class="reference internal" href="#individual-node-update">3.2.8.7.5.3. Individual Node Update</a></li>
<li class="toctree-l6"><a class="reference internal" href="#individual-node-enable">3.2.8.7.5.4. Individual Node Enable</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#using-graph-apis">3.2.8.7.6. Using Graph APIs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#device-graph-launch">3.2.8.7.7. Device Graph Launch</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#device-graph-creation">3.2.8.7.7.1. Device Graph Creation</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#device-graph-requirements">3.2.8.7.7.1.1. Device Graph Requirements</a></li>
<li class="toctree-l7"><a class="reference internal" href="#device-graph-upload">3.2.8.7.7.1.2. Device Graph Upload</a></li>
<li class="toctree-l7"><a class="reference internal" href="#device-graph-update">3.2.8.7.7.1.3. Device Graph Update</a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="#device-launch">3.2.8.7.7.2. Device Launch</a><ul>
<li class="toctree-l7"><a class="reference internal" href="#device-launch-modes">3.2.8.7.7.2.1. Device Launch Modes</a><ul>
<li class="toctree-l8"><a class="reference internal" href="#fire-and-forget-launch">3.2.8.7.7.2.1.1. Fire and Forget Launch</a></li>
<li class="toctree-l8"><a class="reference internal" href="#graph-execution-environments">3.2.8.7.7.2.1.2. Graph Execution Environments</a></li>
<li class="toctree-l8"><a class="reference internal" href="#tail-launch">3.2.8.7.7.2.1.3. Tail Launch</a><ul>
<li class="toctree-l9"><a class="reference internal" href="#tail-self-launch">3.2.8.7.7.2.1.3.1. Tail Self-launch</a></li>
</ul>
</li>
<li class="toctree-l8"><a class="reference internal" href="#sibling-launch">3.2.8.7.7.2.1.4. Sibling Launch</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#conditional-graph-nodes">3.2.8.7.8. Conditional Graph Nodes</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#conditional-handles">3.2.8.7.8.1. Conditional Handles</a></li>
<li class="toctree-l6"><a class="reference internal" href="#condtional-node-body-graph-requirements">3.2.8.7.8.2. Condtional Node Body Graph Requirements</a></li>
<li class="toctree-l6"><a class="reference internal" href="#conditional-if-nodes">3.2.8.7.8.3. Conditional IF Nodes</a></li>
<li class="toctree-l6"><a class="reference internal" href="#conditional-while-nodes">3.2.8.7.8.4. Conditional WHILE Nodes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#events">3.2.8.8. Events</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#creation-and-destruction-of-events">3.2.8.8.1. Creation and Destruction of Events</a></li>
<li class="toctree-l5"><a class="reference internal" href="#elapsed-time">3.2.8.8.2. Elapsed Time</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#synchronous-calls">3.2.8.9. Synchronous Calls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multi-device-system">3.2.9. Multi-Device System</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-enumeration">3.2.9.1. Device Enumeration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-selection">3.2.9.2. Device Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#stream-and-event-behavior">3.2.9.3. Stream and Event Behavior</a></li>
<li class="toctree-l4"><a class="reference internal" href="#peer-to-peer-memory-access">3.2.9.4. Peer-to-Peer Memory Access</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#iommu-on-linux">3.2.9.4.1. IOMMU on Linux</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#peer-to-peer-memory-copy">3.2.9.5. Peer-to-Peer Memory Copy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unified-virtual-address-space">3.2.10. Unified Virtual Address Space</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interprocess-communication">3.2.11. Interprocess Communication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-checking">3.2.12. Error Checking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call-stack">3.2.13. Call Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="#texture-and-surface-memory">3.2.14. Texture and Surface Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#texture-memory">3.2.14.1. Texture Memory</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#texture-object-api">3.2.14.1.1. Texture Object API</a></li>
<li class="toctree-l5"><a class="reference internal" href="#bit-floating-point-textures">3.2.14.1.2. 16-Bit Floating-Point Textures</a></li>
<li class="toctree-l5"><a class="reference internal" href="#layered-textures">3.2.14.1.3. Layered Textures</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cubemap-textures">3.2.14.1.4. Cubemap Textures</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cubemap-layered-textures">3.2.14.1.5. Cubemap Layered Textures</a></li>
<li class="toctree-l5"><a class="reference internal" href="#texture-gather">3.2.14.1.6. Texture Gather</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#surface-memory">3.2.14.2. Surface Memory</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#surface-object-api">3.2.14.2.1. Surface Object API</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cubemap-surfaces">3.2.14.2.2. Cubemap Surfaces</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cubemap-layered-surfaces">3.2.14.2.3. Cubemap Layered Surfaces</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#cuda-arrays">3.2.14.3. CUDA Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#read-write-coherency">3.2.14.4. Read/Write Coherency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#graphics-interoperability">3.2.15. Graphics Interoperability</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#opengl-interoperability">3.2.15.1. OpenGL Interoperability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#direct3d-interoperability">3.2.15.2. Direct3D Interoperability</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#direct3d-9-version">3.2.15.2.1. Direct3D 9 Version</a></li>
<li class="toctree-l5"><a class="reference internal" href="#direct3d-10-version">3.2.15.2.2. Direct3D 10 Version</a></li>
<li class="toctree-l5"><a class="reference internal" href="#direct3d-11-version">3.2.15.2.3. Direct3D 11 Version</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#sli-interoperability">3.2.15.3. SLI Interoperability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#external-resource-interoperability">3.2.16. External Resource Interoperability</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#vulkan-interoperability">3.2.16.1. Vulkan Interoperability</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#matching-device-uuids">3.2.16.1.1. Matching device UUIDs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-memory-objects">3.2.16.1.2. Importing Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-buffers-onto-imported-memory-objects">3.2.16.1.3. Mapping Buffers onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-mipmapped-arrays-onto-imported-memory-objects">3.2.16.1.4. Mapping Mipmapped Arrays onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-synchronization-objects">3.2.16.1.5. Importing Synchronization Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#signaling-waiting-on-imported-synchronization-objects">3.2.16.1.6. Signaling/Waiting on Imported Synchronization Objects</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#opengl-interoperability-ext-res-int">3.2.16.2. OpenGL Interoperability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#direct3d-12-interoperability">3.2.16.3. Direct3D 12 Interoperability</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#matching-device-luids">3.2.16.3.1. Matching Device LUIDs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-memory-objects-dir3d-12-int">3.2.16.3.2. Importing Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-buffers-onto-imported-memory-objects-dir3d-12-int">3.2.16.3.3. Mapping Buffers onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-12-int">3.2.16.3.4. Mapping Mipmapped Arrays onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-synchronization-objects-dir3d-12-int">3.2.16.3.5. Importing Synchronization Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#signaling-waiting-on-imported-synchronization-objects-dir3d-12-int">3.2.16.3.6. Signaling/Waiting on Imported Synchronization Objects</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#direct3d-11-interoperability">3.2.16.4. Direct3D 11 Interoperability</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#matching-device-luids-dir3d-11-int">3.2.16.4.1. Matching Device LUIDs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-memory-objects-dir3d-11-int">3.2.16.4.2. Importing Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-buffers-onto-imported-memory-objects-dir3d-11-int">3.2.16.4.3. Mapping Buffers onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-11-int">3.2.16.4.4. Mapping Mipmapped Arrays onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-synchronization-objects-dir3d-11-int">3.2.16.4.5. Importing Synchronization Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#signaling-waiting-on-imported-synchronization-objects-dir3d-11-int">3.2.16.4.6. Signaling/Waiting on Imported Synchronization Objects</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#nvidia-software-communication-interface-interoperability-nvsci">3.2.16.5. NVIDIA Software Communication Interface Interoperability (NVSCI)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#importing-memory-objects-nvsci">3.2.16.5.1. Importing Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-buffers-onto-imported-memory-objects-nvsci">3.2.16.5.2. Mapping Buffers onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-nvsci">3.2.16.5.3. Mapping Mipmapped Arrays onto Imported Memory Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#importing-synchronization-objects-nvsci">3.2.16.5.4. Importing Synchronization Objects</a></li>
<li class="toctree-l5"><a class="reference internal" href="#signaling-waiting-on-imported-synchronization-objects-nvsci">3.2.16.5.5. Signaling/Waiting on Imported Synchronization Objects</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#versioning-and-compatibility">3.3. Versioning and Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compute-modes">3.4. Compute Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mode-switches">3.5. Mode Switches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tesla-compute-cluster-mode-for-windows">3.6. Tesla Compute Cluster Mode for Windows</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#hardware-implementation">4. Hardware Implementation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simt-architecture">4.1. SIMT Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-multithreading">4.2. Hardware Multithreading</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#performance-guidelines">5. Performance Guidelines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overall-performance-optimization-strategies">5.1. Overall Performance Optimization Strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#maximize-utilization">5.2. Maximize Utilization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#application-level">5.2.1. Application Level</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-level">5.2.2. Device Level</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiprocessor-level">5.2.3. Multiprocessor Level</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#occupancy-calculator">5.2.3.1. Occupancy Calculator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maximize-memory-throughput">5.3. Maximize Memory Throughput</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer-between-host-and-device">5.3.1. Data Transfer between Host and Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-memory-accesses">5.3.2. Device Memory Accesses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#maximize-instruction-throughput">5.4. Maximize Instruction Throughput</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-instructions">5.4.1. Arithmetic Instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow-instructions">5.4.2. Control Flow Instructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronization-instruction">5.4.3. Synchronization Instruction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#minimize-memory-thrashing">5.5. Minimize Memory Thrashing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#cuda-enabled-gpus">6. CUDA-Enabled GPUs</a></li>
<li class="toctree-l1"><a class="reference internal" href="#c-language-extensions">7. C++ Language Extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#function-execution-space-specifiers">7.1. Function Execution Space Specifiers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#global">7.1.1. __global__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device">7.1.2. __device__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host">7.1.3. __host__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#undefined-behavior">7.1.4. Undefined behavior</a></li>
<li class="toctree-l3"><a class="reference internal" href="#noinline-and-forceinline">7.1.5. __noinline__ and __forceinline__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inline-hint">7.1.6. __inline_hint__</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#variable-memory-space-specifiers">7.2. Variable Memory Space Specifiers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#device-variable-specifier">7.2.1. __device__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constant">7.2.2. __constant__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared">7.2.3. __shared__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grid-constant">7.2.4. __grid_constant__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#managed">7.2.5. __managed__</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restrict">7.2.6. __restrict__</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#built-in-vector-types">7.3. Built-in Vector Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#char-short-int-long-longlong-float-double">7.3.1. char, short, int, long, longlong, float, double</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dim3">7.3.2. dim3</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#built-in-variables">7.4. Built-in Variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#griddim">7.4.1. gridDim</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blockidx">7.4.2. blockIdx</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blockdim">7.4.3. blockDim</a></li>
<li class="toctree-l3"><a class="reference internal" href="#threadidx">7.4.4. threadIdx</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warpsize">7.4.5. warpSize</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-fence-functions">7.5. Memory Fence Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-functions">7.6. Synchronization Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-functions">7.7. Mathematical Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#texture-functions">7.8. Texture Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#texture-object-api-appendix">7.8.1. Texture Object API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tex1dfetch">7.8.1.1. tex1Dfetch()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1d">7.8.1.2. tex1D()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1dlod">7.8.1.3. tex1DLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1dgrad">7.8.1.4. tex1DGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2d">7.8.1.5. tex2D()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2d-for-sparse-cuda-arrays">7.8.1.6. tex2D() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dgather">7.8.1.7. tex2Dgather()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dgather-for-sparse-cuda-arrays">7.8.1.8. tex2Dgather() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dgrad">7.8.1.9. tex2DGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dgrad-for-sparse-cuda-arrays">7.8.1.10. tex2DGrad() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlod">7.8.1.11. tex2DLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlod-for-sparse-cuda-arrays">7.8.1.12. tex2DLod() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3d">7.8.1.13. tex3D()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3d-for-sparse-cuda-arrays">7.8.1.14. tex3D() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3dlod">7.8.1.15. tex3DLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3dlod-for-sparse-cuda-arrays">7.8.1.16. tex3DLod() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3dgrad">7.8.1.17. tex3DGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex3dgrad-for-sparse-cuda-arrays">7.8.1.18. tex3DGrad() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1dlayered">7.8.1.19. tex1DLayered()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1dlayeredlod">7.8.1.20. tex1DLayeredLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex1dlayeredgrad">7.8.1.21. tex1DLayeredGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayered">7.8.1.22. tex2DLayered()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayered-for-sparse-cuda-arrays">7.8.1.23. tex2DLayered() for Sparse CUDA Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayeredlod">7.8.1.24. tex2DLayeredLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayeredlod-for-sparse-cuda-arrays">7.8.1.25. tex2DLayeredLod() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayeredgrad">7.8.1.26. tex2DLayeredGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tex2dlayeredgrad-for-sparse-cuda-arrays">7.8.1.27. tex2DLayeredGrad() for sparse CUDA arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemap">7.8.1.28. texCubemap()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemapgrad">7.8.1.29. texCubemapGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemaplod">7.8.1.30. texCubemapLod()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemaplayered">7.8.1.31. texCubemapLayered()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemaplayeredgrad">7.8.1.32. texCubemapLayeredGrad()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#texcubemaplayeredlod">7.8.1.33. texCubemapLayeredLod()</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#surface-functions">7.9. Surface Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#surface-object-api-appendix">7.9.1. Surface Object API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#surf1dread">7.9.1.1. surf1Dread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf1dwrite">7.9.1.2. surf1Dwrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf2dread">7.9.1.3. surf2Dread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf2dwrite">7.9.1.4. surf2Dwrite()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf3dread">7.9.1.5. surf3Dread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf3dwrite">7.9.1.6. surf3Dwrite()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf1dlayeredread">7.9.1.7. surf1DLayeredread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf1dlayeredwrite">7.9.1.8. surf1DLayeredwrite()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf2dlayeredread">7.9.1.9. surf2DLayeredread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surf2dlayeredwrite">7.9.1.10. surf2DLayeredwrite()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surfcubemapread">7.9.1.11. surfCubemapread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surfcubemapwrite">7.9.1.12. surfCubemapwrite()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surfcubemaplayeredread">7.9.1.13. surfCubemapLayeredread()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#surfcubemaplayeredwrite">7.9.1.14. surfCubemapLayeredwrite()</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#read-only-data-cache-load-function">7.10. Read-Only Data Cache Load Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#load-functions-using-cache-hints">7.11. Load Functions Using Cache Hints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#store-functions-using-cache-hints">7.12. Store Functions Using Cache Hints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#time-function">7.13. Time Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#atomic-functions">7.14. Atomic Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-functions">7.14.1. Arithmetic Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomicadd">7.14.1.1. atomicAdd()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicsub">7.14.1.2. atomicSub()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicexch">7.14.1.3. atomicExch()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicmin">7.14.1.4. atomicMin()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicmax">7.14.1.5. atomicMax()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicinc">7.14.1.6. atomicInc()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicdec">7.14.1.7. atomicDec()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomiccas">7.14.1.8. atomicCAS()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-exchange">7.14.1.9. __nv_atomic_exchange()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-exchange-n">7.14.1.10. __nv_atomic_exchange_n()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-compare-exchange">7.14.1.11. __nv_atomic_compare_exchange()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-compare-exchange-n">7.14.1.12. __nv_atomic_compare_exchange_n()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-add-and-nv-atomic-add">7.14.1.13. __nv_atomic_fetch_add() and __nv_atomic_add()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-sub-and-nv-atomic-sub">7.14.1.14. __nv_atomic_fetch_sub() and __nv_atomic_sub()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-min-and-nv-atomic-min">7.14.1.15. __nv_atomic_fetch_min() and __nv_atomic_min()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-max-and-nv-atomic-max">7.14.1.16. __nv_atomic_fetch_max() and __nv_atomic_max()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bitwise-functions">7.14.2. Bitwise Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#atomicand">7.14.2.1. atomicAnd()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicor">7.14.2.2. atomicOr()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomicxor">7.14.2.3. atomicXor()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-or-and-nv-atomic-or">7.14.2.4. __nv_atomic_fetch_or() and __nv_atomic_or()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-xor-and-nv-atomic-xor">7.14.2.5. __nv_atomic_fetch_xor() and __nv_atomic_xor()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-fetch-and-and-nv-atomic-and">7.14.2.6. __nv_atomic_fetch_and() and __nv_atomic_and()</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-atomic-functions">7.14.3. Other atomic functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-load">7.14.3.1. __nv_atomic_load()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-load-n">7.14.3.2. __nv_atomic_load_n()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-store">7.14.3.3. __nv_atomic_store()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-store-n">7.14.3.4. __nv_atomic_store_n()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nv-atomic-thread-fence">7.14.3.5. __nv_atomic_thread_fence()</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#address-space-predicate-functions">7.15. Address Space Predicate Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#isglobal">7.15.1. __isGlobal()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#isshared">7.15.2. __isShared()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#isconstant">7.15.3. __isConstant()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#isgridconstant">7.15.4. __isGridConstant()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#islocal">7.15.5. __isLocal()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#address-space-conversion-functions">7.16. Address Space Conversion Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cvta-generic-to-global">7.16.1. __cvta_generic_to_global()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-generic-to-shared">7.16.2. __cvta_generic_to_shared()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-generic-to-constant">7.16.3. __cvta_generic_to_constant()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-generic-to-local">7.16.4. __cvta_generic_to_local()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-global-to-generic">7.16.5. __cvta_global_to_generic()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-shared-to-generic">7.16.6. __cvta_shared_to_generic()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-constant-to-generic">7.16.7. __cvta_constant_to_generic()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cvta-local-to-generic">7.16.8. __cvta_local_to_generic()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#alloca-function">7.17. Alloca Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synopsis">7.17.1. Synopsis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#description">7.17.2. Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example">7.17.3. Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compiler-optimization-hint-functions">7.18. Compiler Optimization Hint Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#builtin-assume-aligned">7.18.1. __builtin_assume_aligned()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#builtin-assume">7.18.2. __builtin_assume()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assume">7.18.3. __assume()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#builtin-expect">7.18.4. __builtin_expect()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#builtin-unreachable">7.18.5. __builtin_unreachable()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restrictions">7.18.6. Restrictions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#warp-vote-functions">7.19. Warp Vote Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#warp-match-functions">7.20. Warp Match Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synopsis-match">7.20.1. Synopsis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warp-description-match">7.20.2. Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#warp-reduce-functions">7.21. Warp Reduce Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warp-reduce-synopsis">7.21.1. Synopsis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warp-reduce-description">7.21.2. Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#warp-shuffle-functions">7.22. Warp Shuffle Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warp-shuffle-synopsis">7.22.1. Synopsis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#warp-shuffle-description">7.22.2. Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">7.22.3. Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#broadcast-of-a-single-value-across-a-warp">7.22.3.1. Broadcast of a single value across a warp</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inclusive-plus-scan-across-sub-partitions-of-8-threads">7.22.3.2. Inclusive plus-scan across sub-partitions of 8 threads</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reduction-across-a-warp">7.22.3.3. Reduction across a warp</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#nanosleep-function">7.23. Nanosleep Function</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nanosleep-synopsis">7.23.1. Synopsis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nanosleep-description">7.23.2. Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nanosleep-example">7.23.3. Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#warp-matrix-functions">7.24. Warp Matrix Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#wmma-description">7.24.1. Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternate-floating-point">7.24.2. Alternate Floating Point</a></li>
<li class="toctree-l3"><a class="reference internal" href="#double-precision">7.24.3. Double Precision</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sub-byte-operations">7.24.4. Sub-byte Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wmma-restrictions">7.24.5. Restrictions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#element-types-and-matrix-sizes">7.24.6. Element Types and Matrix Sizes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wmma-example">7.24.7. Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dpx">7.25. DPX</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dpx-example">7.25.1. Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-barrier">7.26. Asynchronous Barrier</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simple-synchronization-pattern">7.26.1. Simple Synchronization Pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#temporal-splitting-and-five-stages-of-synchronization">7.26.2. Temporal Splitting and Five Stages of Synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bootstrap-initialization-expected-arrival-count-and-participation">7.26.3. Bootstrap Initialization, Expected Arrival Count, and Participation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-barrier-s-phase-arrival-countdown-completion-and-reset">7.26.4. A Barrierâs Phase: Arrival, Countdown, Completion, and Reset</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spatial-partitioning-also-known-as-warp-specialization">7.26.5. Spatial Partitioning (also known as Warp Specialization)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#early-exit-dropping-out-of-participation">7.26.6. Early Exit (Dropping out of Participation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#completion-function">7.26.7. Completion Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-barrier-primitives-interface">7.26.8. Memory Barrier Primitives Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-types">7.26.8.1. Data Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-barrier-primitives-api">7.26.8.2. Memory Barrier Primitives API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-data-copies">7.27. Asynchronous Data Copies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#memcpy-async-api">7.27.1. <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-and-compute-pattern-staging-data-through-shared-memory">7.27.2. Copy and Compute Pattern - Staging Data Through Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#without-memcpy-async">7.27.3. Without <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#with-memcpy-async">7.27.4. With <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-data-copies-using-cuda-barrier">7.27.5. Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance-guidance-for-memcpy-async">7.27.6. Performance Guidance for <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#alignment">7.27.6.1. Alignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#trivially-copyable">7.27.6.2. Trivially copyable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#warp-entanglement-commit">7.27.6.3. Warp Entanglement - Commit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#warp-entanglement-wait">7.27.6.4. Warp Entanglement - Wait</a></li>
<li class="toctree-l4"><a class="reference internal" href="#warp-entanglement-arrive-on">7.27.6.5. Warp Entanglement - Arrive-On</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keep-commit-and-arrive-on-operations-converged">7.27.6.6. Keep Commit and Arrive-On Operations Converged</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-data-copies-using-cuda-pipeline">7.28. Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#single-stage-asynchronous-data-copies-using-cuda-pipeline">7.28.1. Single-Stage Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-stage-asynchronous-data-copies-using-cuda-pipeline">7.28.2. Multi-Stage Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline-interface">7.28.3. Pipeline Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline-primitives-interface">7.28.4. Pipeline Primitives Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memcpy-async-primitive">7.28.4.1. <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> Primitive</a></li>
<li class="toctree-l4"><a class="reference internal" href="#commit-primitive">7.28.4.2. Commit Primitive</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wait-primitive">7.28.4.3. Wait Primitive</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arrive-on-barrier-primitive">7.28.4.4. Arrive On Barrier Primitive</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-data-copies-using-the-tensor-memory-accelerator-tma">7.29. Asynchronous Data Copies using the Tensor Memory Accelerator (TMA)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-tma-to-transfer-one-dimensional-arrays">7.29.1. Using TMA to transfer one-dimensional arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-tma-to-transfer-multi-dimensional-arrays">7.29.2. Using TMA to transfer multi-dimensional arrays</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multi-dimensional-tma-ptx-wrappers">7.29.2.1. Multi-dimensional TMA PTX wrappers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tma-swizzle">7.29.3. TMA Swizzle</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-matrix-transpose">7.29.3.1. Example âMatrix Transposeâ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-swizzle-modes">7.29.3.2. The Swizzle Modes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#encoding-a-tensor-map-on-device">7.30. Encoding a Tensor Map on Device</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#device-side-encoding-and-modification-of-a-tensor-map">7.30.1. Device-side Encoding and Modification of a Tensor Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#usage-of-a-modified-tensor-map">7.30.2. Usage of a Modified Tensor Map</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-template-tensor-map-value-using-the-driver-api">7.30.3. Creating a Template Tensor Map Value Using the Driver API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#profiler-counter-function">7.31. Profiler Counter Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assertion">7.32. Assertion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trap-function">7.33. Trap function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#breakpoint-function">7.34. Breakpoint Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formatted-output">7.35. Formatted Output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#format-specifiers">7.35.1. Format Specifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">7.35.2. Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#associated-host-side-api">7.35.3. Associated Host-Side API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#format-specifier-examples">7.35.4. Examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-global-memory-allocation-and-operations">7.36. Dynamic Global Memory Allocation and Operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#heap-memory-allocation">7.36.1. Heap Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interoperability-with-host-memory-api">7.36.2. Interoperability with Host Memory API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-per-thread">7.36.3. Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#per-thread-allocation">7.36.3.1. Per Thread Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#per-thread-block-allocation">7.36.3.2. Per Thread Block Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocation-persisting-between-kernel-launches">7.36.3.3. Allocation Persisting Between Kernel Launches</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#execution-configuration">7.37. Execution Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#launch-bounds">7.38. Launch Bounds</a></li>
<li class="toctree-l2"><a class="reference internal" href="#maximum-number-of-registers-per-thread">7.39. Maximum Number of Registers per Thread</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pragma-unroll">7.40. #pragma unroll</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simd-video-instructions">7.41. SIMD Video Instructions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#diagnostic-pragmas">7.42. Diagnostic Pragmas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-abi-pragmas">7.43. Custom ABI Pragmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#cooperative-groups">8. Cooperative Groups</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-cg">8.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-s-new-in-cooperative-groups">8.2. Whatâs New in Cooperative Groups</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cuda-12-2">8.2.1. CUDA 12.2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cuda-12-1">8.2.2. CUDA 12.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cuda-12-0">8.2.3. CUDA 12.0</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#deprecated-items">8.3. Deprecated items</a></li>
<li class="toctree-l2"><a class="reference internal" href="#programming-model-concept">8.4. Programming Model Concept</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#composition-example">8.4.1. Composition Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#group-types">8.5. Group Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#implicit-groups">8.5.1. Implicit Groups</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thread-block-group">8.5.1.1. Thread Block Group</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cluster-group">8.5.1.2. Cluster Group</a></li>
<li class="toctree-l4"><a class="reference internal" href="#grid-group">8.5.1.3. Grid Group</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-grid-group">8.5.1.4. Multi Grid Group</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-groups">8.5.2. Explicit Groups</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thread-block-tile">8.5.2.1. Thread Block Tile</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#warp-synchronous-code-pattern">8.5.2.1.1. Warp-Synchronous Code Pattern</a></li>
<li class="toctree-l5"><a class="reference internal" href="#single-thread-group">8.5.2.1.2. Single Thread Group</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#coalesced-groups">8.5.2.2. Coalesced Groups</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#discovery-pattern">8.5.2.2.1. Discovery Pattern</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#group-partitioning">8.6. Group Partitioning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tiled-partition">8.6.1. <code class="docutils literal notranslate"><span class="pre">tiled_partition</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#labeled-partition">8.6.2. <code class="docutils literal notranslate"><span class="pre">labeled_partition</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-partition">8.6.3. <code class="docutils literal notranslate"><span class="pre">binary_partition</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#group-collectives">8.7. Group Collectives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synchronization">8.7.1. Synchronization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#barrier-arrive-and-barrier-wait">8.7.1.1. <code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#sync">8.7.1.2. <code class="docutils literal notranslate"><span class="pre">sync</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer">8.7.2. Data Transfer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memcpy-async">8.7.2.1. <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#wait-and-wait-prior">8.7.2.2. <code class="docutils literal notranslate"><span class="pre">wait</span> <span class="pre">and</span> <span class="pre">wait_prior</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-manipulation">8.7.3. Data Manipulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reduce">8.7.3.1. <code class="docutils literal notranslate"><span class="pre">reduce</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#reduce-operators">8.7.3.2. <code class="docutils literal notranslate"><span class="pre">Reduce</span></code> Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inclusive-scan-and-exclusive-scan">8.7.3.3. <code class="docutils literal notranslate"><span class="pre">inclusive_scan</span></code> and <code class="docutils literal notranslate"><span class="pre">exclusive_scan</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#execution-control">8.7.4. Execution control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#invoke-one-and-invoke-one-broadcast">8.7.4.1. <code class="docutils literal notranslate"><span class="pre">invoke_one</span></code> and <code class="docutils literal notranslate"><span class="pre">invoke_one_broadcast</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#grid-synchronization">8.8. Grid Synchronization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-device-synchronization">8.9. Multi-Device Synchronization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#cluster-launch-control">9. Cluster Launch Control</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-clc">9.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cluster-launch-control-api-details">9.2. Cluster Launch Control API Details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#thread-block-cancellation-steps">9.2.1. Thread block cancellation steps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-block-cancellation-constraints">9.2.2. Thread block cancellation constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-example-vector-scalar-multiplication">9.2.3. Kernel Example: Vector-Scalar Multiplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cluster-launch-control-for-thread-block-clusters">9.2.4. Cluster Launch Control for Thread Block Clusters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#cuda-dynamic-parallelism">10. CUDA Dynamic Parallelism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-cuda-dynamic-parallelism">10.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">10.1.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#glossary">10.1.2. Glossary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#execution-environment-and-memory-model">10.2. Execution Environment and Memory Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#execution-environment">10.2.1. Execution Environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parent-and-child-grids">10.2.1.1. Parent and Child Grids</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scope-of-cuda-primitives">10.2.1.2. Scope of CUDA Primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-parallelism-synchronization">10.2.1.3. Synchronization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streams-and-events">10.2.1.4. Streams and Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ordering-and-concurrency">10.2.1.5. Ordering and Concurrency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-management">10.2.1.6. Device Management</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#memory-model">10.2.2. Memory Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#coherence-and-consistency">10.2.2.1. Coherence and Consistency</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#global-memory">10.2.2.1.1. Global Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#zero-copy-memory">10.2.2.1.2. Zero Copy Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#constant-memory">10.2.2.1.3. Constant Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#shared-and-local-memory">10.2.2.1.4. Shared and Local Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#local-memory">10.2.2.1.5. Local Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#texture-memory-cdp">10.2.2.1.6. Texture Memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#programming-interface-cdp">10.3. Programming Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cuda-c-reference">10.3.1. CUDA C++ Reference</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-side-kernel-launch">10.3.1.1. Device-Side Kernel Launch</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#launches-are-asynchronous">10.3.1.1.1. Launches are Asynchronous</a></li>
<li class="toctree-l5"><a class="reference internal" href="#launch-environment-configuration">10.3.1.1.2. Launch Environment Configuration</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#streams-cdp">10.3.1.2. Streams</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#the-implicit-null-stream">10.3.1.2.1. The Implicit (NULL) Stream</a></li>
<li class="toctree-l5"><a class="reference internal" href="#the-fire-and-forget-stream">10.3.1.2.2. The Fire-and-Forget Stream</a></li>
<li class="toctree-l5"><a class="reference internal" href="#the-tail-launch-stream">10.3.1.2.3. The Tail Launch Stream</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#events-cdp">10.3.1.3. Events</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronization-programming-interface">10.3.1.4. Synchronization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-management-programming">10.3.1.5. Device Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-declarations">10.3.1.6. Memory Declarations</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#device-and-constant-memory">10.3.1.6.1. Device and Constant Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#textures-and-surfaces">10.3.1.6.2. Textures and Surfaces</a></li>
<li class="toctree-l5"><a class="reference internal" href="#shared-memory-variable-declarations">10.3.1.6.3. Shared Memory Variable Declarations</a></li>
<li class="toctree-l5"><a class="reference internal" href="#symbol-addresses">10.3.1.6.4. Symbol Addresses</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#api-errors-and-launch-failures">10.3.1.7. API Errors and Launch Failures</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#launch-setup-apis">10.3.1.7.1. Launch Setup APIs</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#api-reference">10.3.1.8. API Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#device-side-launch-from-ptx">10.3.2. Device-side Launch from PTX</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel-launch-apis">10.3.2.1. Kernel Launch APIs</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#cudalaunchdevice">10.3.2.1.1. cudaLaunchDevice</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cudagetparameterbuffer">10.3.2.1.2. cudaGetParameterBuffer</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#parameter-buffer-layout">10.3.2.2. Parameter Buffer Layout</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#toolkit-support-for-dynamic-parallelism">10.3.3. Toolkit Support for Dynamic Parallelism</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#including-device-runtime-api-in-cuda-code">10.3.3.1. Including Device Runtime API in CUDA Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling-and-linking">10.3.3.2. Compiling and Linking</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#programming-guidelines">10.4. Programming Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basics">10.4.1. Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performance">10.4.2. Performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-parallelism-enabled-kernel-overhead">10.4.2.1. Dynamic-parallelism-enabled Kernel Overhead</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-restrictions-and-limitations">10.4.3. Implementation Restrictions and Limitations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#runtime">10.4.3.1. Runtime</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#memory-footprint">10.4.3.1.1. Memory Footprint</a></li>
<li class="toctree-l5"><a class="reference internal" href="#pending-kernel-launches">10.4.3.1.2. Pending Kernel Launches</a></li>
<li class="toctree-l5"><a class="reference internal" href="#configuration-options">10.4.3.1.3. Configuration Options</a></li>
<li class="toctree-l5"><a class="reference internal" href="#memory-allocation-and-lifetime">10.4.3.1.4. Memory Allocation and Lifetime</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sm-id-and-warp-id">10.4.3.1.5. SM Id and Warp Id</a></li>
<li class="toctree-l5"><a class="reference internal" href="#ecc-errors">10.4.3.1.6. ECC Errors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cdp2-vs-cdp1">10.5. CDP2 vs CDP1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#differences-between-cdp1-and-cdp2">10.5.1. Differences Between CDP1 and CDP2</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compatibility-and-interoperability">10.5.2. Compatibility and Interoperability</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#legacy-cuda-dynamic-parallelism-cdp1">10.6. Legacy CUDA Dynamic Parallelism (CDP1)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#execution-environment-and-memory-model-cdp1">10.6.1. Execution Environment and Memory Model (CDP1)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#execution-environment-cdp1">10.6.1.1. Execution Environment (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#parent-and-child-grids-cdp1">10.6.1.1.1. Parent and Child Grids (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#scope-of-cuda-primitives-cdp1">10.6.1.1.2. Scope of CUDA Primitives (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#synchronization-cdp1">10.6.1.1.3. Synchronization (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#streams-and-events-cdp1">10.6.1.1.4. Streams and Events (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#ordering-and-concurrency-cdp1">10.6.1.1.5. Ordering and Concurrency (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#device-management-cdp1">10.6.1.1.6. Device Management (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#memory-model-cdp1">10.6.1.2. Memory Model (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#coherence-and-consistency-cdp1">10.6.1.2.1. Coherence and Consistency (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#global-memory-cdp1">10.6.1.2.1.1. Global Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#zero-copy-memory-cdp1">10.6.1.2.1.2. Zero Copy Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#constant-memory-cdp1">10.6.1.2.1.3. Constant Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#shared-and-local-memory-cdp1">10.6.1.2.1.4. Shared and Local Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#local-memory-cdp1">10.6.1.2.1.5. Local Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#texture-memory-cdp1">10.6.1.2.1.6. Texture Memory (CDP1)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#programming-interface-cdp1">10.6.2. Programming Interface (CDP1)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cuda-c-reference-cdp1">10.6.2.1. CUDA C++ Reference (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#device-side-kernel-launch-cdp1">10.6.2.1.1. Device-Side Kernel Launch (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#launches-are-asynchronous-cdp1">10.6.2.1.1.1. Launches are Asynchronous (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#launch-environment-configuration-cdp1">10.6.2.1.1.2. Launch Environment Configuration (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#streams-cdp1">10.6.2.1.2. Streams (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#the-implicit-null-stream-cdp1">10.6.2.1.2.1. The Implicit (NULL) Stream (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#events-cdp1">10.6.2.1.3. Events (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#synchronization-programming-interface-cdp1">10.6.2.1.4. Synchronization (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#block-wide-synchronization-cdp1">10.6.2.1.4.1. Block Wide Synchronization (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#device-management-programming-cdp1">10.6.2.1.5. Device Management (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#memory-declarations-cdp1">10.6.2.1.6. Memory Declarations (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#device-and-constant-memory-cdp1">10.6.2.1.6.1. Device and Constant Memory (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#textures-and-surfaces-cdp1">10.6.2.1.6.2. Textures and Surfaces (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#shared-memory-variable-declarations-cdp1">10.6.2.1.6.3. Shared Memory Variable Declarations (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#symbol-addresses-cdp1">10.6.2.1.6.4. Symbol Addresses (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#api-errors-and-launch-failures-cdp1">10.6.2.1.7. API Errors and Launch Failures (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#launch-setup-apis-cdp1">10.6.2.1.7.1. Launch Setup APIs (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#api-reference-cdp1">10.6.2.1.8. API Reference (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#device-side-launch-from-ptx-cdp1">10.6.2.2. Device-side Launch from PTX (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#kernel-launch-apis-cdp1">10.6.2.2.1. Kernel Launch APIs (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#cudalaunchdevice-cdp1">10.6.2.2.1.1. cudaLaunchDevice (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#cudagetparameterbuffer-cdp1">10.6.2.2.1.2. cudaGetParameterBuffer (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="#parameter-buffer-layout-cdp1">10.6.2.2.2. Parameter Buffer Layout (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#toolkit-support-for-dynamic-parallelism-cdp1">10.6.2.3. Toolkit Support for Dynamic Parallelism (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#including-device-runtime-api-in-cuda-code-cdp1">10.6.2.3.1. Including Device Runtime API in CUDA Code (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#compiling-and-linking-cdp1">10.6.2.3.2. Compiling and Linking (CDP1)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#programming-guidelines-cdp1">10.6.3. Programming Guidelines (CDP1)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basics-cdp1">10.6.3.1. Basics (CDP1)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performance-cdp1">10.6.3.2. Performance (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#synchronization-performance-cdp1">10.6.3.2.1. Synchronization (CDP1)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#dynamic-parallelism-enabled-kernel-overhead-cdp1">10.6.3.2.2. Dynamic-parallelism-enabled Kernel Overhead (CDP1)</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-restrictions-and-limitations-cdp1">10.6.3.3. Implementation Restrictions and Limitations (CDP1)</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#runtime-cdp1">10.6.3.3.1. Runtime (CDP1)</a><ul>
<li class="toctree-l6"><a class="reference internal" href="#memory-footprint-cdp1">10.6.3.3.1.1. Memory Footprint (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#nesting-and-synchronization-depth-cdp1">10.6.3.3.1.2. Nesting and Synchronization Depth (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#pending-kernel-launches-cdp1">10.6.3.3.1.3. Pending Kernel Launches (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#configuration-options-cdp1">10.6.3.3.1.4. Configuration Options (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#memory-allocation-and-lifetime-cdp1">10.6.3.3.1.5. Memory Allocation and Lifetime (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#sm-id-and-warp-id-cdp1">10.6.3.3.1.6. SM Id and Warp Id (CDP1)</a></li>
<li class="toctree-l6"><a class="reference internal" href="#ecc-errors-cdp1">10.6.3.3.1.7. ECC Errors (CDP1)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#virtual-memory-management">11. Virtual Memory Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-virtual-memory-management">11.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#query-for-support">11.2. Query for Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allocating-physical-memory">11.3. Allocating Physical Memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shareable-memory-allocations">11.3.1. Shareable Memory Allocations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-type">11.3.2. Memory Type</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compressible-memory">11.3.2.1. Compressible Memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#reserving-a-virtual-address-range">11.4. Reserving a Virtual Address Range</a></li>
<li class="toctree-l2"><a class="reference internal" href="#virtual-aliasing-support">11.5. Virtual Aliasing Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mapping-memory">11.6. Mapping Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-access-rights">11.7. Controlling Access Rights</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fabric-memory">11.8. Fabric Memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#querying-fabric-mem-support">11.8.1. Query for Support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multicast-support">11.9. Multicast Support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#querying-multicast-obj-mem-support">11.9.1. Query for Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-multicast-objects">11.9.2. Allocating Multicast Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-devices-to-multicast-objects">11.9.3. Add Devices to Multicast Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bind-memory-to-multicast-objects">11.9.4. Bind Memory to Multicast Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#use-multicast-mappings">11.9.5. Use Multicast Mappings</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#stream-ordered-memory-allocator">12. Stream Ordered Memory Allocator</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#stream-ordered-memory-allocator-intro">12.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stream-ordered-querying-memory-support">12.2. Query for Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api-fundamentals-cudamallocasync-and-cudafreeasync">12.3. API Fundamentals (cudaMallocAsync and cudaFreeAsync)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-pools-and-the-cudamempool-t">12.4. Memory Pools and the cudaMemPool_t</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-implicit-pools">12.5. Default/Implicit Pools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explicit-pools">12.6. Explicit Pools</a></li>
<li class="toctree-l2"><a class="reference internal" href="#physical-page-caching-behavior">12.7. Physical Page Caching Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="#resource-usage-statistics">12.8. Resource Usage Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-reuse-policies">12.9. Memory Reuse Policies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cudamempoolreusefolloweventdependencies">12.9.1. cudaMemPoolReuseFollowEventDependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cudamempoolreuseallowopportunistic">12.9.2. cudaMemPoolReuseAllowOpportunistic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cudamempoolreuseallowinternaldependencies">12.9.3. cudaMemPoolReuseAllowInternalDependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disabling-reuse-policies">12.9.4. Disabling Reuse Policies</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#device-accessibility-for-multi-gpu-support">12.10. Device Accessibility for Multi-GPU Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ipc-memory-pools">12.11. IPC Memory Pools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-sharing-ipc-memory-pools">12.11.1. Creating and Sharing IPC Memory Pools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#set-access-in-the-importing-process">12.11.2. Set Access in the Importing Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-sharing-allocations-from-an-exported-pool">12.11.3. Creating and Sharing Allocations from an Exported Pool</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-export-pool-limitations">12.11.4. IPC Export Pool Limitations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ipc-import-pool-limitations">12.11.5. IPC Import Pool Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-api-actions">12.12. Synchronization API Actions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#addendums">12.13. Addendums</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cudamemcpyasync-current-context-device-sensitivity">12.13.1. cudaMemcpyAsync Current Context/Device Sensitivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cupointergetattribute-query">12.13.2. cuPointerGetAttribute Query</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cugraphaddmemsetnode">12.13.3. cuGraphAddMemsetNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-attributes">12.13.4. Pointer Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#graph-memory-nodes">13. Graph Memory Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#graph-memory-nodes-intro">13.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#support-and-compatibility">13.2. Support and Compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="#api-fundamentals">13.3. API Fundamentals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-node-apis">13.3.1. Graph Node APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stream-capture">13.3.2. Stream Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-and-freeing-graph-memory-outside-of-the-allocating-graph">13.3.3. Accessing and Freeing Graph Memory Outside of the Allocating Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cudagraphinstantiateflagautofreeonlaunch">13.3.4. cudaGraphInstantiateFlagAutoFreeOnLaunch</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#optimized-memory-reuse">13.4. Optimized Memory Reuse</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#address-reuse-within-a-graph">13.4.1. Address Reuse within a Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physical-memory-management-and-sharing">13.4.2. Physical Memory Management and Sharing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#performance-considerations">13.5. Performance Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#first-launch-cudagraphupload">13.5.1. First Launch / cudaGraphUpload</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#physical-memory-footprint">13.6. Physical Memory Footprint</a></li>
<li class="toctree-l2"><a class="reference internal" href="#peer-access">13.7. Peer Access</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#peer-access-with-graph-node-apis">13.7.1. Peer Access with Graph Node APIs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#peer-access-with-stream-capture">13.7.2. Peer Access with Stream Capture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-nodes-in-child-graphs">13.8. Memory Nodes in Child Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#mathematical-functions-appendix">14. Mathematical Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#standard-functions">14.1. Standard Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intrinsic-functions">14.2. Intrinsic Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#c-language-support">15. C++ Language Support</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#c-11-language-features">15.1. C++11 Language Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#c-14-language-features">15.2. C++14 Language Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#c-17-language-features">15.3. C++17 Language Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#c-20-language-features">15.4. C++20 Language Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="#language-restrictions">15.5. Restrictions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#host-compiler-extensions">15.5.1. Host Compiler Extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preprocessor-symbols">15.5.2. Preprocessor Symbols</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cuda-arch">15.5.2.1. __CUDA_ARCH__</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#qualifiers">15.5.3. Qualifiers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-memory-space-specifiers">15.5.3.1. Device Memory Space Specifiers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#managed-memory-space-specifier">15.5.3.2. __managed__ Memory Space Specifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volatile-qualifier">15.5.3.3. Volatile Qualifier</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pointers">15.5.4. Pointers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators">15.5.5. Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#assignment-operator">15.5.5.1. Assignment Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-operator">15.5.5.2. Address Operator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#run-time-type-information-rtti">15.5.6. Run Time Type Information (RTTI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exception-handling">15.5.7. Exception Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standard-library">15.5.8. Standard Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#namespace-reservations">15.5.9. Namespace Reservations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">15.5.10. Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#external-linkage">15.5.10.1. External Linkage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implicitly-declared-and-explicitly-defaulted-functions">15.5.10.2. Implicitly-declared and explicitly-defaulted functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-parameters">15.5.10.3. Function Parameters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#global-function-argument-processing">15.5.10.3.1. <code class="docutils literal notranslate"><span class="pre">__global__</span></code> Function Argument Processing</a></li>
<li class="toctree-l5"><a class="reference internal" href="#toolkit-and-driver-compatibility">15.5.10.3.2. Toolkit and Driver Compatibility</a></li>
<li class="toctree-l5"><a class="reference internal" href="#link-compatibility-across-toolkit-revisions">15.5.10.3.3. Link Compatibility across Toolkit Revisions</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#static-variables-within-function">15.5.10.4. Static Variables within Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-pointers">15.5.10.5. Function Pointers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-recursion">15.5.10.6. Function Recursion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#friend-functions">15.5.10.7. Friend Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operator-function">15.5.10.8. Operator Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocation-and-deallocation-functions">15.5.10.9. Allocation and Deallocation Functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes">15.5.11. Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-members">15.5.11.1. Data Members</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-members">15.5.11.2. Function Members</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtual-functions">15.5.11.3. Virtual Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#virtual-base-classes">15.5.11.4. Virtual Base Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#anonymous-unions">15.5.11.5. Anonymous Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#windows-specific">15.5.11.6. Windows-Specific</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#templates">15.5.12. Templates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trigraphs-and-digraphs">15.5.13. Trigraphs and Digraphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#const-qualified-variables">15.5.14. Const-qualified variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#long-double">15.5.15. Long Double</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deprecation-annotation">15.5.16. Deprecation Annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#noreturn-annotation">15.5.17. Noreturn Annotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#likely-unlikely-standard-attributes">15.5.18. [[likely]] / [[unlikely]] Standard Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#const-and-pure-gnu-attributes">15.5.19. const and pure GNU Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nv-pure-attribute">15.5.20. __nv_pure__ Attribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="#intel-host-compiler-specific">15.5.21. Intel Host Compiler Specific</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-11-features">15.5.22. C++11 Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#lambda-expressions">15.5.22.1. Lambda Expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#std-initializer-list">15.5.22.2. std::initializer_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rvalue-references">15.5.22.3. Rvalue references</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constexpr-functions-and-function-templates">15.5.22.4. Constexpr functions and function templates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constexpr-variables">15.5.22.5. Constexpr variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inline-namespaces">15.5.22.6. Inline namespaces</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#inline-unnamed-namespaces">15.5.22.6.1. Inline unnamed namespaces</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#thread-local">15.5.22.7. thread_local</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-functions-and-function-templates">15.5.22.8. __global__ functions and function templates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#managed-and-shared-variables">15.5.22.9. __managed__ and __shared__ variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defaulted-functions">15.5.22.10. Defaulted functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-14-features">15.5.23. C++14 Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functions-with-deduced-return-type">15.5.23.1. Functions with deduced return type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variable-templates">15.5.23.2. Variable templates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-17-features">15.5.24. C++17 Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#inline-variable">15.5.24.1. Inline Variable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structured-binding">15.5.24.2. Structured Binding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-20-features">15.5.25. C++20 Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-support">15.5.25.1. Module support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coroutine-support">15.5.25.2. Coroutine support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#three-way-comparison-operator">15.5.25.3. Three-way comparison operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#consteval-functions">15.5.25.4. Consteval functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphic-function-wrappers">15.6. Polymorphic Function Wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#extended-lambdas">15.7. Extended Lambdas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extended-lambda-type-traits">15.7.1. Extended Lambda Type Traits</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extended-lambda-restrictions">15.7.2. Extended Lambda Restrictions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notes-on-host-device-lambdas">15.7.3. Notes on __host__ __device__ lambdas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#this-capture-by-value">15.7.4. *this Capture By Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additional-notes">15.7.5. Additional Notes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#relaxed-constexpr-expt-relaxed-constexpr">15.8. Relaxed Constexpr (-expt-relaxed-constexpr)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#code-samples">15.9. Code Samples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-aggregation-class">15.9.1. Data Aggregation Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#derived-class">15.9.2. Derived Class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#class-template">15.9.3. Class Template</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-template">15.9.4. Function Template</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functor-class">15.9.5. Functor Class</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#texture-fetching">16. Texture Fetching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#nearest-point-sampling">16.1. Nearest-Point Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linear-filtering">16.2. Linear Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#table-lookup">16.3. Table Lookup</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#compute-capabilities">17. Compute Capabilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#feature-availability">17.1. Feature Availability</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-specific-features">17.1.1. Architecture-Specific Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#family-specific-features">17.1.2. Family-Specific Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#feature-set-compiler-targets">17.1.3. Feature Set Compiler Targets</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#features-and-technical-specifications">17.2. Features and Technical Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#floating-point-standard">17.3. Floating-Point Standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-5-x">17.4. Compute Capability 5.x</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture">17.4.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-5-x">17.4.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-5-x">17.4.3. Shared Memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-6-x">17.5. Compute Capability 6.x</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-6-x">17.5.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-6-x">17.5.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-6-x">17.5.3. Shared Memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-7-x">17.6. Compute Capability 7.x</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-7-x">17.6.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#independent-thread-scheduling">17.6.2. Independent Thread Scheduling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-7-x">17.6.3. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-7-x">17.6.4. Shared Memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-8-x">17.7. Compute Capability 8.x</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-8-x">17.7.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-8-x">17.7.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-8-x">17.7.3. Shared Memory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-9-0">17.8. Compute Capability 9.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-9-0">17.8.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-9-0">17.8.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-9-0">17.8.3. Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#features-accelerating-specialized-computations">17.8.4. Features Accelerating Specialized Computations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-10-x">17.9. Compute Capability 10.x</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-10-x">17.9.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-10-x">17.9.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-10-x">17.9.3. Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#features-accelerating-specialized-computations-10-x">17.9.4. Features Accelerating Specialized Computations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-capability-12-0">17.10. Compute Capability 12.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#architecture-12-x">17.10.1. Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-memory-12-x">17.10.2. Global Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shared-memory-12-x">17.10.3. Shared Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#features-accelerating-specialized-computations-12-x">17.10.4. Features Accelerating Specialized Computations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#driver-api">18. Driver API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#context">18.1. Context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module">18.2. Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#kernel-execution">18.3. Kernel Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interoperability-between-runtime-and-driver-apis">18.4. Interoperability between Runtime and Driver APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#driver-entry-point-access">18.5. Driver Entry Point Access</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction-driver-entry-point-access">18.5.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-function-typedefs">18.5.2. Driver Function Typedefs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-function-retrieval">18.5.3. Driver Function Retrieval</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-the-driver-api">18.5.3.1. Using the Driver API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-the-runtime-api">18.5.3.2. Using the Runtime API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#retrieve-per-thread-default-stream-versions">18.5.3.3. Retrieve Per-thread Default Stream Versions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-new-cuda-features">18.5.3.4. Access New CUDA features</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#potential-implications-with-cugetprocaddress">18.5.4. Potential Implications with cuGetProcAddress</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implications-with-cugetprocaddress-vs-implicit-linking">18.5.4.1. Implications with cuGetProcAddress vs Implicit Linking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compile-time-vs-runtime-version-usage-in-cugetprocaddress">18.5.4.2. Compile Time vs Runtime Version Usage in cuGetProcAddress</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api-version-bumps-with-explicit-version-checks">18.5.4.3. API Version Bumps with Explicit Version Checks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#issues-with-runtime-api-usage">18.5.4.4. Issues with Runtime API Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#issues-with-runtime-api-and-dynamic-versioning">18.5.4.5. Issues with Runtime API and Dynamic Versioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#issues-with-runtime-api-allowing-cuda-version">18.5.4.6. Issues with Runtime API allowing CUDA Version</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implications-to-api-abi">18.5.4.7. Implications to API/ABI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#determining-cugetprocaddress-failure-reasons">18.5.5. Determining cuGetProcAddress Failure Reasons</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#cuda-environment-variables">19. CUDA Environment Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="#error-log-management">20. Error Log Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id445">20.1. Background</a></li>
<li class="toctree-l2"><a class="reference internal" href="#activation">20.2. Activation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output">20.3. Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id446">20.4. API Description</a></li>
<li class="toctree-l2"><a class="reference internal" href="#limitations-and-known-issues">20.5. Limitations and Known Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#unified-memory-programming">21. Unified Memory Programming</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#unified-memory-introduction">21.1. Unified Memory Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#system-requirements-for-unified-memory">21.1.1. System Requirements for Unified Memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#um-opt-in">21.1.2. Programming Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#allocation-apis-for-system-allocated-memory">21.1.2.1. Allocation APIs for System-Allocated Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#allocation-api-for-cuda-managed-memory-cudamallocmanaged">21.1.2.2. Allocation API for CUDA Managed Memory: <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-scope-managed-variables-using-managed">21.1.2.3. Global-Scope Managed Variables Using <code class="docutils literal notranslate"><span class="pre">__managed__</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#difference-between-unified-memory-and-mapped-memory">21.1.2.4. Difference between Unified Memory and Mapped Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#um-pointer-attributes">21.1.2.5. Pointer Attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-detection-of-unified-memory-support-level">21.1.2.6. Runtime detection of Unified Memory Support Level</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpu-memory-oversubscription">21.1.2.7. GPU Memory Oversubscription</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performance-hints">21.1.2.8. Performance Hints</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#data-prefetching">21.1.2.8.1. Data Prefetching</a></li>
<li class="toctree-l5"><a class="reference internal" href="#data-usage-hints">21.1.2.8.2. Data Usage Hints</a></li>
<li class="toctree-l5"><a class="reference internal" href="#querying-data-usage-attributes-on-managed-memory">21.1.2.8.3. Querying Data Usage Attributes on Managed Memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unified-memory-on-devices-with-full-cuda-unified-memory-support">21.2. Unified memory on devices with full CUDA Unified Memory support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#system-allocated-memory-in-depth-examples">21.2.1. System-Allocated Memory: in-depth examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#file-backed-unified-memory">21.2.1.1. File-backed Unified Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inter-process-communication-ipc-with-unified-memory">21.2.1.2. Inter-Process Communication (IPC) with Unified Memory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance-tuning">21.2.2. Performance Tuning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-paging-and-page-sizes">21.2.2.1. Memory Paging and Page Sizes</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#choosing-the-right-page-size">21.2.2.1.1. Choosing the right page size</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cpu-and-gpu-page-tables-hardware-coherency-vs-software-coherency">21.2.2.1.2. CPU and GPU page tables: hardware coherency vs. software coherency</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#direct-unified-memory-access-from-host">21.2.2.2. Direct Unified Memory Access from host</a></li>
<li class="toctree-l4"><a class="reference internal" href="#host-native-atomics">21.2.2.3. Host Native Atomics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#atomic-accesses-synchronization-primitives">21.2.2.4. Atomic accesses &amp; synchronization primitives</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memcpy-memset-behavior-with-unified-memory">21.2.2.5. Memcpy()/Memset() Behavior With Unified Memory</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unified-memory-on-devices-without-full-cuda-unified-memory-support">21.3. Unified memory on devices without full CUDA Unified Memory support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unified-memory-on-devices-with-only-cuda-managed-memory-support">21.3.1. Unified memory on devices with only CUDA Managed Memory support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unified-memory-on-windows-or-devices-with-compute-capability-5-x">21.3.2. Unified memory on Windows or devices with compute capability 5.x</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-migration-and-coherency">21.3.2.1. Data Migration and Coherency</a></li>
<li class="toctree-l4"><a class="reference internal" href="#um-legacy-oversubscription">21.3.2.2. GPU Memory Oversubscription</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-gpu">21.3.2.3. Multi-GPU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coherency-and-concurrency">21.3.2.4. Coherency and Concurrency</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#gpu-exclusive-access-to-managed-memory">21.3.2.4.1. GPU Exclusive Access To Managed Memory</a></li>
<li class="toctree-l5"><a class="reference internal" href="#explicit-synchronization-and-logical-gpu-activity">21.3.2.4.2. Explicit Synchronization and Logical GPU Activity</a></li>
<li class="toctree-l5"><a class="reference internal" href="#managing-data-visibility-and-concurrent-cpu-gpu-access-with-streams">21.3.2.4.3. Managing Data Visibility and Concurrent CPU + GPU Access with Streams</a></li>
<li class="toctree-l5"><a class="reference internal" href="#stream-association-examples">21.3.2.4.4. Stream Association Examples</a></li>
<li class="toctree-l5"><a class="reference internal" href="#stream-attach-with-multithreaded-host-programs">21.3.2.4.5. Stream Attach With Multithreaded Host Programs</a></li>
<li class="toctree-l5"><a class="reference internal" href="#advanced-topic-modular-programs-and-data-access-constraints">21.3.2.4.6. Advanced Topic: Modular Programs and Data Access Constraints</a></li>
<li class="toctree-l5"><a class="reference internal" href="#memcpy-memset-behavior-with-stream-associated-unified-memory">21.3.2.4.7. Memcpy()/Memset() Behavior With Stream-associated Unified Memory</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#lazy-loading">22. Lazy Loading</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-lazy-loading">22.1. What is Lazy Loading?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lazy-loading-version-support">22.2. Lazy Loading version support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#driver">22.2.1. Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#toolkit">22.2.2. Toolkit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiler">22.2.3. Compiler</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#triggering-loading-of-kernels-in-lazy-mode">22.3. Triggering loading of kernels in lazy mode</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cuda-driver-api">22.3.1. CUDA Driver API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cuda-runtime-api">22.3.2. CUDA Runtime API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#querying-whether-lazy-loading-is-turned-on">22.4. Querying whether Lazy Loading is Turned On</a></li>
<li class="toctree-l2"><a class="reference internal" href="#possible-issues-when-adopting-lazy-loading">22.5. Possible Issues when Adopting Lazy Loading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#concurrent-execution">22.5.1. Concurrent Execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocators">22.5.2. Allocators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#autotuning">22.5.3. Autotuning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#extended-gpu-memory">23. Extended GPU Memory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#preliminaries">23.1. Preliminaries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#egm-platforms-system-topology">23.1.1. EGM Platforms: System topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#socket-identifiers-what-are-they-how-to-access-them">23.1.2. Socket Identifiers: What are they? How to access them?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocators-and-egm-support">23.1.3. Allocators and EGM support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-management-extensions-to-current-apis">23.1.4. Memory management extensions to current APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-egm-interface">23.2. Using the EGM Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#single-node-single-gpu">23.2.1. Single-Node, Single-GPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#single-node-multi-gpu">23.2.2. Single-Node, Multi-GPU</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-vmm-apis">23.2.2.1. Using VMM APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-cuda-memory-pool">23.2.2.2. Using CUDA Memory Pool</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multi-node-single-gpu">23.2.3. Multi-Node, Single-GPU</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#notices">24. Notices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notice">24.1. Notice</a></li>
<li class="toctree-l2"><a class="reference internal" href="#opencl">24.2. OpenCL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trademarks">24.3. Trademarks</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html">CUDA C++ Programming Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">


  

<li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
  
<li><span class="section-number">1. </span>Introduction</li>

      <li class="wy-breadcrumbs-aside">
      </li>
<li class="wy-breadcrumbs-aside">


  <span>v12.9 |</span>



  <a href="../pdf/CUDA_C_Programming_Guide.pdf" class="reference external">PDF</a>



  <span>|</span>



  <a href="https://developer.nvidia.com/cuda-toolkit-archive" class="reference external">Archive</a>


  <span>&nbsp;</span>
</li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p class="rubric-h1 rubric">CUDA C++ Programming Guide</p>
<p>The programming guide to the CUDA model and interface.</p>
<p class="rubric-h2 rubric">Revision History</p>
<table class="colwidths-given docutils align-default" id="id451">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Revision History</span><a class="headerlink" href="#id451" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Version</p></th>
<th class="head"><p>Changes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12.9</p></td>
<td><p>Added section <a class="reference internal" href="#error-log-management"><span class="std std-ref">Error Log Management</span></a> and CUDA_LOG_FILE to <a class="reference internal" href="#env-vars"><span class="std std-ref">CUDA Environment Variables</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>12.8</p></td>
<td><p>Added section <a class="reference internal" href="#tma-swizzle"><span class="std std-ref">TMA Swizzle</span></a></p></td>
</tr>
</tbody>
</table>
<section id="introduction">
<span id="id1"></span><h1><span class="section-number">1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">ï</a></h1>
<section id="the-benefits-of-using-gpus">
<span id="from-graphics-processing-to-general-purpose-parallel-computing"></span><h2><span class="section-number">1.1. </span>The Benefits of Using GPUs<a class="headerlink" href="#the-benefits-of-using-gpus" title="Permalink to this headline">ï</a></h2>
<p>The Graphics Processing Unit (GPU)<a class="footnote-reference brackets" href="#fn1" id="id2">1</a> provides much higher instruction throughput and memory bandwidth than the CPU within a similar price and power envelope. Many applications leverage these higher capabilities to run faster on the GPU than on the CPU (see <a class="reference external" href="https://www.nvidia.com/object/gpu-applications.html">GPU Applications</a>). Other computing devices, like FPGAs, are also very energy efficient, but offer much less programming flexibility than GPUs.</p>
<p>This difference in capabilities between the GPU and the CPU exists because they are designed with different goals in mind. While the CPU is designed to excel at executing a sequence of operations, called a <em>thread</em>, as fast as possible and can execute a few tens of these threads in parallel, the GPU is designed to excel at executing thousands of them in parallel (amortizing the slower single-thread performance to achieve greater throughput).</p>
<p>The GPU is specialized for highly parallel computations and therefore designed such that more transistors are devoted to data processing rather than data caching and flow control. The schematic <a class="reference internal" href="#from-graphics-processing-to-general-purpose-parallel-computing-gpu-devotes-more-transistors-to-data-processing"><span class="std std-ref">Figure 1</span></a> shows an example distribution of chip resources for a CPU versus a GPU.</p>
<figure class="align-center" id="from-graphics-processing-to-general-purpose-parallel-computing-gpu-devotes-more-transistors-to-data-processing">
<a class="reference internal image-reference" href="_images/gpu-devotes-more-transistors-to-data-processing.png"><img alt="The GPU Devotes More Transistors to Data Processing" src="_images/gpu-devotes-more-transistors-to-data-processing.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 1 </span><span class="caption-text">The GPU Devotes More Transistors to Data Processing</span><a class="headerlink" href="#from-graphics-processing-to-general-purpose-parallel-computing-gpu-devotes-more-transistors-to-data-processing" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>Devoting more transistors to data processing, for example, floating-point computations, is beneficial for highly parallel computations; the GPU can hide memory access latencies with computation, instead of relying on large data caches and complex flow control to avoid long memory access latencies, both of which are expensive in terms of transistors.</p>
<p>In general, an application has a mix of parallel parts and sequential parts, so systems are designed with a mix of GPUs and CPUs in order to maximize overall performance. Applications with a high degree of parallelism can exploit this massively parallel nature of the GPU to achieve higher performance than on the CPU.</p>
</section>
<section id="cuda-a-general-purpose-parallel-computing-platform-and-programming-model">
<span id="cuda-general-purpose-parallel-computing-architecture"></span><h2><span class="section-number">1.2. </span>CUDAÂ®: A General-Purpose Parallel Computing Platform and Programming Model<a class="headerlink" href="#cuda-a-general-purpose-parallel-computing-platform-and-programming-model" title="Permalink to this headline">ï</a></h2>
<p>In November 2006, NVIDIA<sup>Â®</sup> introduced CUDA<sup>Â®</sup>, a general purpose parallel computing platform and programming model that leverages the parallel compute engine in NVIDIA GPUs to solve many complex computational problems in a more efficient way than on a CPU.</p>
<p>CUDA comes with a software environment that allows developers to use C++ as a high-level programming language. As illustrated by <a class="reference internal" href="#cuda-general-purpose-parallel-computing-architecture-cuda-is-designed-to-support-various-languages-and-application-programming-interfaces"><span class="std std-ref">Figure 2</span></a>, other languages, application programming interfaces, or directives-based approaches are supported, such as FORTRAN, DirectCompute, OpenACC.</p>
<figure class="align-center" id="cuda-general-purpose-parallel-computing-architecture-cuda-is-designed-to-support-various-languages-and-application-programming-interfaces">
<a class="reference internal image-reference" href="_images/gpu-computing-applications.png"><img alt="GPU Computing Applications. CUDA is designed to support various languages and application programming interfaces." src="_images/gpu-computing-applications.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 2 </span><span class="caption-text">GPU Computing Applications. CUDA is designed to support various languages and application programming interfaces.</span><a class="headerlink" href="#cuda-general-purpose-parallel-computing-architecture-cuda-is-designed-to-support-various-languages-and-application-programming-interfaces" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="a-scalable-programming-model">
<span id="scalable-programming-model"></span><h2><span class="section-number">1.3. </span>A Scalable Programming Model<a class="headerlink" href="#a-scalable-programming-model" title="Permalink to this headline">ï</a></h2>
<p>The advent of multicore CPUs and manycore GPUs means that mainstream processor chips are now parallel systems. The challenge is to develop application software that transparently scales its parallelism to leverage the increasing number of processor cores, much as 3D graphics applications transparently scale their parallelism to manycore GPUs with widely varying numbers of cores.</p>
<p>The CUDA parallel programming model is designed to overcome this challenge while maintaining a low learning curve for programmers familiar with standard programming languages such as C.</p>
<p>At its core are three key abstractions â a hierarchy of thread groups, shared memories, and barrier synchronization â that are simply exposed to the programmer as a minimal set of language extensions.</p>
<p>These abstractions provide fine-grained data parallelism and thread parallelism, nested within coarse-grained data parallelism and task parallelism. They guide the programmer to partition the problem into coarse sub-problems that can be solved independently in parallel by blocks of threads, and each sub-problem into finer pieces that can be solved cooperatively in parallel by all threads within the block.</p>
<p>This decomposition preserves language expressivity by allowing threads to cooperate when solving each sub-problem, and at the same time enables automatic scalability. Indeed, each block of threads can be scheduled on any of the available multiprocessors within a GPU, in any order, concurrently or sequentially, so that a compiled CUDA program can execute on any number of multiprocessors as illustrated by <a class="reference internal" href="#scalable-programming-model-automatic-scalability"><span class="std std-ref">Figure 3</span></a>, and only the runtime system needs to know the physical multiprocessor count.</p>
<p>This scalable programming model allows the GPU architecture to span a wide market range by simply scaling the number of multiprocessors and memory partitions: from the high-performance enthusiast GeForce GPUs and professional Quadro and Tesla computing products to a variety of inexpensive, mainstream GeForce GPUs (see <a class="reference internal" href="#cuda-enabled-gpus"><span class="std std-ref">CUDA-Enabled GPUs</span></a> for a list of all CUDA-enabled GPUs).</p>
<figure class="align-center" id="scalable-programming-model-automatic-scalability">
<img alt="Automatic Scalability" src="_images/automatic-scalability.png" />
<figcaption>
<p><span class="caption-number">Figure 3 </span><span class="caption-text">Automatic Scalability</span><a class="headerlink" href="#scalable-programming-model-automatic-scalability" title="Permalink to this image">ï</a></p>
<div class="legend">
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A GPU is built around an array of Streaming Multiprocessors (SMs) (see <a class="reference internal" href="#hardware-implementation"><span class="std std-ref">Hardware Implementation</span></a> for more details). A multithreaded program is partitioned into blocks of threads that execute independently from each other, so that a GPU with more multiprocessors will automatically execute the program in less time than a GPU with fewer multiprocessors.</p>
</div>
</div>
</figcaption>
</figure>
</section>
<section id="document-structure">
<span id="id3"></span><h2><span class="section-number">1.4. </span>Document Structure<a class="headerlink" href="#document-structure" title="Permalink to this headline">ï</a></h2>
<p>This document is organized into the following sections:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a> is a general introduction to CUDA.</p></li>
<li><p><a class="reference internal" href="#programming-model"><span class="std std-ref">Programming Model</span></a> outlines the CUDA programming model.</p></li>
<li><p><a class="reference internal" href="#programming-interface"><span class="std std-ref">Programming Interface</span></a> describes the programming interface.</p></li>
<li><p><a class="reference internal" href="#hardware-implementation"><span class="std std-ref">Hardware Implementation</span></a> describes the hardware implementation.</p></li>
<li><p><a class="reference internal" href="#performance-guidelines"><span class="std std-ref">Performance Guidelines</span></a> gives some guidance on how to achieve maximum performance.</p></li>
<li><p><a class="reference internal" href="#cuda-enabled-gpus"><span class="std std-ref">CUDA-Enabled GPUs</span></a> lists all CUDA-enabled devices.</p></li>
<li><p><a class="reference internal" href="#c-language-extensions"><span class="std std-ref">C++ Language Extensions</span></a> is a detailed description of all extensions to the C++ language.</p></li>
<li><p><a class="reference internal" href="#cooperative-groups"><span class="std std-ref">Cooperative Groups</span></a> describes synchronization primitives for various groups of CUDA threads.</p></li>
<li><p><a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a> describes how to launch and synchronize one kernel from another.</p></li>
<li><p><a class="reference internal" href="#virtual-memory-management"><span class="std std-ref">Virtual Memory Management</span></a> describes how to manage the unified virtual address space.</p></li>
<li><p><a class="reference internal" href="#stream-ordered-memory-allocator"><span class="std std-ref">Stream Ordered Memory Allocator</span></a> describes how applications can order memory allocation and deallocation.</p></li>
<li><p><a class="reference internal" href="#graph-memory-nodes"><span class="std std-ref">Graph Memory Nodes</span></a> describes how graphs can create and own memory allocations.</p></li>
<li><p><a class="reference internal" href="#mathematical-functions-appendix"><span class="std std-ref">Mathematical Functions</span></a> lists the mathematical functions supported in CUDA.</p></li>
<li><p><a class="reference internal" href="#c-cplusplus-language-support"><span class="std std-ref">C++ Language Support</span></a> lists the C++ features supported in device code.</p></li>
<li><p><a class="reference internal" href="#texture-fetching"><span class="std std-ref">Texture Fetching</span></a> gives more details on texture fetching.</p></li>
<li><p><a class="reference internal" href="#compute-capabilities"><span class="std std-ref">Compute Capabilities</span></a> gives the technical specifications of various devices, as well as more architectural details.</p></li>
<li><p><a class="reference internal" href="#driver-api"><span class="std std-ref">Driver API</span></a> introduces the low-level driver API.</p></li>
<li><p><a class="reference internal" href="#env-vars"><span class="std std-ref">CUDA Environment Variables</span></a> lists all the CUDA environment variables.</p></li>
<li><p><a class="reference internal" href="#um-unified-memory-programming-hd"><span class="std std-ref">Unified Memory Programming</span></a> introduces the Unified Memory programming model.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="fn1"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>The <em>graphics</em> qualifier comes from the fact that when the GPU was originally created, two decades ago, it was designed as a specialized processor to accelerate graphics rendering. Driven by the insatiable market demand for real-time, high-definition, 3D graphics, it has evolved into a general processor used for many more workloads than just graphics rendering.</p>
</dd>
</dl>
</section>
</section>
<section id="programming-model">
<span id="id4"></span><h1><span class="section-number">2. </span>Programming Model<a class="headerlink" href="#programming-model" title="Permalink to this headline">ï</a></h1>
<p>This chapter introduces the main concepts behind the CUDA programming model by outlining how they are exposed in C++.</p>
<p>An extensive description of CUDA C++ is given in <a class="reference internal" href="#programming-interface"><span class="std std-ref">Programming Interface</span></a>.</p>
<p>Full code for the vector addition example used in this chapter and the next can be found in the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-samples/index.html#vector-addition">vectorAdd CUDA sample</a>.</p>
<section id="kernels">
<span id="id5"></span><h2><span class="section-number">2.1. </span>Kernels<a class="headerlink" href="#kernels" title="Permalink to this headline">ï</a></h2>
<p>CUDA C++ extends C++ by allowing the programmer to define C++ functions, called <em>kernels</em>, that, when called, are executed N times in parallel by N different <em>CUDA threads</em>, as opposed to only once like regular C++ functions.</p>
<p>A kernel is defined using the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> declaration specifier and the number of CUDA threads that execute that kernel for a given kernel call is specified using a new <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code><em>execution configuration</em> syntax (see <a class="reference external" href="index.html#execution-configuration">Execution Configuration</a>). Each thread that executes the kernel is given a unique <em>thread ID</em> that is accessible within the kernel through built-in variables.</p>
<p>As an illustration, the following sample code, using the built-in variable <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code>, adds two vectors <em>A</em> and <em>B</em> of size <em>N</em> and stores the result into vector <em>C</em>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel definition</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Kernel invocation with N threads</span>
<span class="w">    </span><span class="n">VecAdd</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here, each of the <em>N</em> threads that execute <code class="docutils literal notranslate"><span class="pre">VecAdd()</span></code> performs one pair-wise addition.</p>
</section>
<section id="thread-hierarchy">
<span id="id6"></span><h2><span class="section-number">2.2. </span>Thread Hierarchy<a class="headerlink" href="#thread-hierarchy" title="Permalink to this headline">ï</a></h2>
<p>For convenience, <code class="docutils literal notranslate"><span class="pre">threadIdx</span></code> is a 3-component vector, so that threads can be identified using a one-dimensional, two-dimensional, or three-dimensional <em>thread index</em>, forming a one-dimensional, two-dimensional, or three-dimensional block of threads, called a <em>thread block</em>. This provides a natural way to invoke computation across the elements in a domain such as a vector, matrix, or volume.</p>
<p>The index of a thread and its thread ID relate to each other in a straightforward way: For a one-dimensional block, they are the same; for a two-dimensional block of size <em>(Dx, Dy)</em>, the thread ID of a thread of index <em>(x, y)</em> is <em>(x + y Dx)</em>; for a three-dimensional block of size <em>(Dx, Dy, Dz)</em>, the thread ID of a thread of index <em>(x, y, z)</em> is <em>(x + y Dx + z Dx Dy)</em>.</p>
<p>As an example, the following code adds two matrices <em>A</em> and <em>B</em> of size <em>NxN</em> and stores the result into matrix <em>C</em>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel definition</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatAdd</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span><span class="w"></span>
<span class="w">                       </span><span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Kernel invocation with one block of N * N * 1 threads</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numBlocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">threadsPerBlock</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MatAdd</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>There is a limit to the number of threads per block, since all threads of a block are expected to reside on the same streaming multiprocessor core and must share the limited memory resources of that core. On current GPUs, a thread block may contain up to 1024 threads.</p>
<p>However, a kernel can be executed by multiple equally-shaped thread blocks, so that the total number of threads is equal to the number of threads per block times the number of blocks.</p>
<p>Blocks are organized into a one-dimensional, two-dimensional, or three-dimensional <em>grid</em> of thread blocks as illustrated by <a class="reference internal" href="#thread-hierarchy-grid-of-thread-blocks"><span class="std std-ref">Figure 4</span></a>. The number of thread blocks in a grid is usually dictated by the size of the data being processed, which typically exceeds the number of processors in the system.</p>
<figure class="align-center" id="thread-hierarchy-grid-of-thread-blocks">
<a class="reference internal image-reference" href="_images/grid-of-thread-blocks.png"><img alt="Grid of Thread Blocks" src="_images/grid-of-thread-blocks.png" style="width: 454px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 4 </span><span class="caption-text">Grid of Thread Blocks</span><a class="headerlink" href="#thread-hierarchy-grid-of-thread-blocks" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The number of threads per block and the number of blocks per grid specified in the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code> syntax can be of type <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">dim3</span></code>. Two-dimensional blocks or grids can be specified as in the example above.</p>
<p>Each block within the grid can be identified by a one-dimensional, two-dimensional, or three-dimensional unique index accessible within the kernel through the built-in <code class="docutils literal notranslate"><span class="pre">blockIdx</span></code> variable. The dimension of the thread block is accessible within the kernel through the built-in <code class="docutils literal notranslate"><span class="pre">blockDim</span></code> variable.</p>
<p>Extending the previous <code class="docutils literal notranslate"><span class="pre">MatAdd()</span></code> example to handle multiple blocks, the code becomes as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel definition</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatAdd</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">],</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Kernel invocation</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">numBlocks</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MatAdd</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A thread block size of 16x16 (256 threads), although arbitrary in this case, is a common choice. The grid is created with enough blocks to have one thread per matrix element as before. For simplicity, this example assumes that the number of threads per grid in each dimension is evenly divisible by the number of threads per block in that dimension, although that need not be the case.</p>
<p>Thread blocks are required to execute independently. It must be possible to execute blocks in any order, in parallel or in series. This independence requirement allows thread blocks to be scheduled in any order and across any number of cores as illustrated by <a class="reference external" href="index.html#scalable-programming-model-automatic-scalability">Figure 3</a>, enabling programmers to write code that scales with the number of cores.</p>
<p>Threads within a block can cooperate by sharing data through some <em>shared memory</em> and by synchronizing their execution to coordinate memory accesses. More precisely, one can specify synchronization points in the kernel by calling the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> intrinsic function; <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> acts as a barrier at which all threads in the block must wait before any is allowed to proceed. <a class="reference internal" href="#shared-memory"><span class="std std-ref">Shared Memory</span></a> gives an example of using shared memory. In addition to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>, the <a class="reference internal" href="#cooperative-groups"><span class="std std-ref">Cooperative Groups API</span></a> provides a rich set of thread-synchronization primitives.</p>
<p>For efficient cooperation, shared memory is expected to be a low-latency memory near each processor core (much like an L1 cache) and <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> is expected to be lightweight.</p>
<section id="thread-block-clusters">
<span id="id7"></span><h3><span class="section-number">2.2.1. </span>Thread Block Clusters<a class="headerlink" href="#thread-block-clusters" title="Permalink to this headline">ï</a></h3>
<p>With the introduction of NVIDIA <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, the CUDA programming model introduces an optional level of hierarchy called Thread Block Clusters that are made up of thread blocks. Similar to how threads in a thread block are guaranteed to be co-scheduled on a streaming multiprocessor, thread blocks in a cluster are also guaranteed to be co-scheduled on a GPU Processing Cluster (GPC) in the GPU.</p>
<p>Similar to thread blocks, clusters are also organized into a one-dimension, two-dimension, or three-dimension grid of thread block clusters as illustrated by <a class="reference external" href="index.html#thread-block-clusters-grid-of-clusters">Figure 5</a>. The number of thread blocks in a cluster can be user-defined, and a maximum of 8 thread blocks in a cluster is supported as a portable cluster size in CUDA.
Note that on GPU hardware or MIG configurations which are too small to support 8 multiprocessors the maximum cluster size will be reduced accordingly. Identification of these smaller configurations, as well as of larger configurations supporting a thread block cluster size beyond 8, is architecture-specific and can be queried using the <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialClusterSize</span></code> API.</p>
<figure class="align-center" id="thread-block-clusters-grid-of-clusters">
<a class="reference internal image-reference" href="_images/grid-of-clusters.png"><img alt="Grid of Thread Block Clusters" src="_images/grid-of-clusters.png" style="width: 454px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 5 </span><span class="caption-text">Grid of Thread Block Clusters</span><a class="headerlink" href="#thread-block-clusters-grid-of-clusters" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In a kernel launched using cluster support, the gridDim variable still denotes the size in terms of number of thread blocks, for compatibility purposes. The rank of a block in a cluster can be found using the <a class="reference internal" href="#cluster-group-cg"><span class="std std-ref">Cluster Group</span></a> API.</p>
</div>
<p>A thread block cluster can be enabled in a kernel either using a compile-time kernel attribute using <code class="docutils literal notranslate"><span class="pre">__cluster_dims__(X,Y,Z)</span></code> or using the CUDA kernel launch API <code class="docutils literal notranslate"><span class="pre">cudaLaunchKernelEx</span></code>. The example below shows how to launch a cluster using a compile-time kernel attribute. The cluster size using kernel attribute is fixed at compile time and then the kernel can be launched using the classical <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;</span> <span class="pre">,</span> <span class="pre">&gt;&gt;&gt;</span></code>. If a kernel uses compile-time cluster size, the cluster size cannot be modified when launching the kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel definition</span>
<span class="c1">// Compile time cluster size 2 in X-dimension and 1 in Y and Z dimension</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cluster_dims__</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cluster_kernel</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Kernel invocation with compile time cluster size</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">threadsPerBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">numBlocks</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The grid dimension is not affected by cluster launch, and is still enumerated</span>
<span class="w">    </span><span class="c1">// using number of blocks.</span>
<span class="w">    </span><span class="c1">// The grid dimension must be a multiple of cluster size.</span>
<span class="w">    </span><span class="n">cluster_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A thread block cluster size can also be set at runtime and the kernel can be launched using the CUDA kernel launch API <code class="docutils literal notranslate"><span class="pre">cudaLaunchKernelEx</span></code>. The code example below shows how to launch a cluster kernel using the extensible API.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel definition</span>
<span class="c1">// No compile time attribute attached to the kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">cluster_kernel</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">threadsPerBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">numBlocks</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Kernel invocation with runtime cluster size</span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaLaunchConfig_t</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">        </span><span class="c1">// The grid dimension is not affected by cluster launch, and is still enumerated</span>
<span class="w">        </span><span class="c1">// using number of blocks.</span>
<span class="w">        </span><span class="c1">// The grid dimension should be a multiple of cluster size.</span>
<span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">gridDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numBlocks</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">blockDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeClusterDimension</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cluster size in X-dimension</span>
<span class="w">        </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">config</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">cudaLaunchKernelEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">cluster_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In GPUs with compute capability 9.0, all the thread blocks in the cluster are guaranteed to be co-scheduled on a single GPU Processing Cluster (GPC) and allow thread blocks in the cluster to perform hardware-supported synchronization using the <a class="reference internal" href="#cluster-group-cg"><span class="std std-ref">Cluster Group</span></a> API <code class="docutils literal notranslate"><span class="pre">cluster.sync()</span></code>. Cluster group also provides member functions to query cluster group size in terms of number of threads or number of blocks using <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code> and <code class="docutils literal notranslate"><span class="pre">num_blocks()</span></code> API respectively. The rank of a thread or block in the cluster group can be queried using <code class="docutils literal notranslate"><span class="pre">dim_threads()</span></code> and <code class="docutils literal notranslate"><span class="pre">dim_blocks()</span></code> API respectively.</p>
<p>Thread blocks that belong to a cluster have access to the Distributed Shared Memory. Thread blocks in a cluster have the ability to read, write, and perform atomics to any address in the distributed shared memory. <a class="reference internal" href="#distributed-shared-memory"><span class="std std-ref">Distributed Shared Memory</span></a> gives an example of performing histograms in distributed shared memory.</p>
</section>
</section>
<section id="memory-hierarchy">
<span id="id8"></span><h2><span class="section-number">2.3. </span>Memory Hierarchy<a class="headerlink" href="#memory-hierarchy" title="Permalink to this headline">ï</a></h2>
<p>CUDA threads may access data from multiple memory spaces during their execution as illustrated by <a class="reference internal" href="#memory-hierarchy-memory-hierarchy-figure"><span class="std std-ref">Figure 6</span></a>. Each thread has private local memory. Each thread block has shared memory visible to all threads of the block and with the same lifetime as the block. Thread blocks in a thread block cluster can perform read, write, and atomics operations on each otherâs shared memory. All threads have access to the same global memory.</p>
<p>There are also two additional read-only memory spaces accessible by all threads: the constant and texture memory spaces. The global, constant, and texture memory spaces are optimized for different memory usages (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>). Texture memory also offers different addressing modes, as well as data filtering, for some specific data formats (see <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>).</p>
<p>The global, constant, and texture memory spaces are persistent across kernel launches by the same application.</p>
<figure class="align-center" id="memory-hierarchy-memory-hierarchy-figure">
<img alt="Memory Hierarchy" src="_images/memory-hierarchy.png" />
<figcaption>
<p><span class="caption-number">Figure 6 </span><span class="caption-text">Memory Hierarchy</span><a class="headerlink" href="#memory-hierarchy-memory-hierarchy-figure" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="heterogeneous-programming">
<span id="id9"></span><h2><span class="section-number">2.4. </span>Heterogeneous Programming<a class="headerlink" href="#heterogeneous-programming" title="Permalink to this headline">ï</a></h2>
<p>As illustrated by <a class="reference internal" href="#heterogeneous-programming-heterogeneous-programming"><span class="std std-ref">Figure 7</span></a>, the CUDA programming model assumes that the CUDA threads execute on a physically separate <em>device</em> that operates as a coprocessor to the <em>host</em> running the C++ program. This is the case, for example, when the kernels execute on a GPU and the rest of the C++ program executes on a CPU.</p>
<p>The CUDA programming model also assumes that both the host and the device maintain their own separate memory spaces in DRAM, referred to as <em>host memory</em> and <em>device memory</em>, respectively. Therefore, a program manages the global, constant, and texture memory spaces visible to kernels through calls to the CUDA runtime (described in <a class="reference internal" href="#programming-interface"><span class="std std-ref">Programming Interface</span></a>). This includes device memory allocation and deallocation as well as data transfer between host and device memory.</p>
<p>Unified Memory provides <em>managed memory</em> to bridge the host and device memory spaces. Managed memory is accessible from all CPUs and GPUs in the system as a single, coherent memory image with a common address space. This capability enables oversubscription of device memory and can greatly simplify the task of porting applications by eliminating the need to explicitly mirror data on host and device. See <a class="reference internal" href="#um-unified-memory-programming-hd"><span class="std std-ref">Unified Memory Programming</span></a> for an introduction to Unified Memory.</p>
<figure class="align-center" id="heterogeneous-programming-heterogeneous-programming">
<img alt="Heterogeneous Programming" src="_images/heterogeneous-programming.png" />
<figcaption>
<p><span class="caption-number">Figure 7 </span><span class="caption-text">Heterogeneous Programming</span><a class="headerlink" href="#heterogeneous-programming-heterogeneous-programming" title="Permalink to this image">ï</a></p>
<div class="legend">
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Serial code executes on the host while parallel code executes on the device.</p>
</div>
</div>
</figcaption>
</figure>
</section>
<section id="asynchronous-simt-programming-model">
<span id="id10"></span><h2><span class="section-number">2.5. </span>Asynchronous SIMT Programming Model<a class="headerlink" href="#asynchronous-simt-programming-model" title="Permalink to this headline">ï</a></h2>
<p>In the CUDA programming model a thread is the lowest level of abstraction for doing a computation or a memory operation. Starting with devices based on the <strong>NVIDIA Ampere GPU Architecture</strong>, the CUDA programming model provides acceleration to memory operations via the asynchronous programming model. The asynchronous programming model defines the behavior of asynchronous operations with respect to CUDA threads.</p>
<p>The asynchronous programming model defines the behavior of <a class="reference internal" href="#aw-barrier"><span class="std std-ref">Asynchronous Barrier</span></a> for synchronization between CUDA threads. The model also explains and defines how <a class="reference internal" href="#asynchronous-data-copies"><span class="std std-ref">cuda::memcpy_async</span></a> can be used to move data asynchronously from global memory while computing in the GPU.</p>
<section id="asynchronous-operations">
<span id="id11"></span><h3><span class="section-number">2.5.1. </span>Asynchronous Operations<a class="headerlink" href="#asynchronous-operations" title="Permalink to this headline">ï</a></h3>
<p>An asynchronous operation is defined as an operation that is initiated by a CUDA thread and is executed asynchronously as-if by another thread. In a well formed program one or more CUDA threads synchronize with the asynchronous operation. The CUDA thread that initiated the asynchronous operation is not required to be among the synchronizing threads.</p>
<p>Such an asynchronous thread (an as-if thread) is always associated with the CUDA thread that initiated the asynchronous operation. An asynchronous operation uses a synchronization object to synchronize the completion of the operation. Such a synchronization object can be explicitly managed by a user (e.g., <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code>) or implicitly managed within a library (e.g., <code class="docutils literal notranslate"><span class="pre">cooperative_groups::memcpy_async</span></code>).</p>
<p>A synchronization object could be a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> or a <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code>. These objects are explained in detail in <a class="reference internal" href="#aw-barrier"><span class="std std-ref">Asynchronous Barrier</span></a> and <a class="reference internal" href="#asynchronous-data-copies"><span class="std std-ref">Asynchronous Data Copies using cuda::pipeline</span></a>. These synchronization objects can be used at different thread scopes. A scope defines the set of threads that may use the synchronization object to synchronize with the asynchronous operation. The following table defines the thread scopes available in CUDA C++ and the threads that can be synchronized with each.</p>
<table class="table-no-stripes colwidths-given docutils align-default">
<colgroup>
<col style="width: 70%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Thread Scope</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cuda::thread_scope::thread_scope_thread</span></code></p></td>
<td><p>Only the CUDA thread which initiated asynchronous operations synchronizes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cuda::thread_scope::thread_scope_block</span></code></p></td>
<td><p>All or any CUDA threads within the same thread block as the initiating thread synchronizes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cuda::thread_scope::thread_scope_device</span></code></p></td>
<td><p>All or any CUDA threads in the same GPU device as the initiating thread synchronizes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cuda::thread_scope::thread_scope_system</span></code></p></td>
<td><p>All or any CUDA or CPU threads in the same system as the initiating thread synchronizes.</p></td>
</tr>
</tbody>
</table>
<p>These thread scopes are implemented as extensions to standard C++ in the <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#thread-scopes">CUDA Standard C++</a> library.</p>
</section>
</section>
<section id="compute-capability">
<span id="id12"></span><h2><span class="section-number">2.6. </span>Compute Capability<a class="headerlink" href="#compute-capability" title="Permalink to this headline">ï</a></h2>
<p>The <em>compute capability</em> of a device is represented by a version number, also sometimes called its âSM versionâ. This version number identifies the features supported by the GPU hardware and is used by applications at runtime to determine which hardware features and/or instructions are available on the present GPU.</p>
<p>The compute capability comprises a major revision number <em>X</em> and a minor revision number <em>Y</em> and is denoted by <em>X.Y</em>.</p>
<p>The major revision number indicates the core GPU architecture of a device. Devices with the same major revision number share the same fundamental architecture. The table below lists the major revision numbers corresponding to each NVIDIA GPU architecture.</p>
<table class="colwidths-auto docutils align-default" id="id452">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">GPU Architecture and Major Revision Numbers</span><a class="headerlink" href="#id452" title="Permalink to this table">ï</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Major Revision Number</p></th>
<th class="head"><p>NVIDIA GPU Architecture</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>9</p></td>
<td><p>NVIDIA Hopper GPU Architecture</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>NVIDIA Ampere GPU Architecture</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>NVIDIA Volta GPU Architecture</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>NVIDIA Pascal GPU Architecture</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>NVIDIA Maxwell GPU Architecture</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>NVIDIA Kepler GPU Architecture</p></td>
</tr>
</tbody>
</table>
<p>The minor revision number corresponds to an incremental improvement to the core architecture, possibly including new features.</p>
<table class="colwidths-auto docutils align-default" id="id453">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">Incremental Updates in GPU Architectures</span><a class="headerlink" href="#id453" title="Permalink to this table">ï</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Compute Capability</p></th>
<th class="head"><p>NVIDIA GPU Architecture</p></th>
<th class="head"><p>Based On</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>7.5</p></td>
<td><p>NVIDIA Turing GPU Architecture</p></td>
<td><p>NVIDIA Volta GPU Architecture</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#cuda-enabled-gpus"><span class="std std-ref">CUDA-Enabled GPUs</span></a> lists of all CUDA-enabled devices along with their compute capability. <a class="reference internal" href="#compute-capabilities"><span class="std std-ref">Compute Capabilities</span></a> gives the technical specifications of each compute capability.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The compute capability version of a particular GPU should not be confused with the CUDA version (for example, CUDA 7.5, CUDA 8, CUDA 9), which is the version of the CUDA <em>software platform</em>. The CUDA platform is used by application developers to create applications that run on many generations of GPU architectures, including future GPU architectures yet to be invented. While new versions of the CUDA platform often add native support for a new GPU architecture by supporting the compute capability version of that architecture, new versions of the CUDA platform typically also include software features that are independent of hardware generation.</p>
</div>
<p>The <em>Tesla</em> and <em>Fermi</em> architectures are no longer supported starting with CUDA 7.0 and CUDA 9.0, respectively.</p>
</section>
</section>
<section id="programming-interface">
<span id="id13"></span><h1><span class="section-number">3. </span>Programming Interface<a class="headerlink" href="#programming-interface" title="Permalink to this headline">ï</a></h1>
<p>CUDA C++ provides a simple path for users familiar with the C++ programming language to easily write programs for execution by the device.</p>
<p>It consists of a minimal set of extensions to the C++ language and a runtime library.</p>
<p>The core language extensions have been introduced in <a class="reference internal" href="#programming-model"><span class="std std-ref">Programming Model</span></a>. They allow programmers to define a kernel as a C++ function and use some new syntax to specify the grid and block dimension each time the function is called. A complete description of all extensions can be found in <a class="reference internal" href="#c-language-extensions"><span class="std std-ref">C++ Language Extensions</span></a>. Any source file that contains some of these extensions must be compiled with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> as outlined in <a class="reference internal" href="#compilation-with-nvcc"><span class="std std-ref">Compilation with NVCC</span></a>.</p>
<p>The runtime is introduced in <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a>. It provides C and C++ functions that execute on the host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc. A complete description of the runtime can be found in the CUDA reference manual.</p>
<p>The runtime is built on top of a lower-level C API, the CUDA driver API, which is also accessible by the application. The driver API provides an additional level of control by exposing lower-level concepts such as CUDA contexts - the analogue of host processes for the device - and CUDA modules - the analogue of dynamically loaded libraries for the device. Most applications do not use the driver API as they do not need this additional level of control and when using the runtime, context and module management are implicit, resulting in more concise code. As the runtime is interoperable with the driver API, most applications that need some driver API features can default to use the runtime API and only use the driver API where needed. The driver API is introduced in <a class="reference internal" href="#driver-api"><span class="std std-ref">Driver API</span></a> and fully described in the reference manual.</p>
<section id="compilation-with-nvcc">
<span id="id14"></span><h2><span class="section-number">3.1. </span>Compilation with NVCC<a class="headerlink" href="#compilation-with-nvcc" title="Permalink to this headline">ï</a></h2>
<p>Kernels can be written using the CUDA instruction set architecture, called <em>PTX</em>, which is described in the PTX reference manual. It is however usually more effective to use a high-level programming language such as C++. In both cases, kernels must be compiled into binary code by <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> to execute on the device.</p>
<p><code class="docutils literal notranslate"><span class="pre">nvcc</span></code> is a compiler driver that simplifies the process of compiling <em>C++</em> or <em>PTX</em> code: It provides simple and familiar command line options and executes them by invoking the collection of tools that implement the different compilation stages. This section gives an overview of <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> workflow and command options. A complete description can be found in the <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> user manual.</p>
<section id="compilation-workflow">
<span id="id15"></span><h3><span class="section-number">3.1.1. </span>Compilation Workflow<a class="headerlink" href="#compilation-workflow" title="Permalink to this headline">ï</a></h3>
<section id="offline-compilation">
<span id="id16"></span><h4><span class="section-number">3.1.1.1. </span>Offline Compilation<a class="headerlink" href="#offline-compilation" title="Permalink to this headline">ï</a></h4>
<p>Source files compiled with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> can include a mix of host code (i.e., code that executes on the host) and device code (i.e., code that executes on the device). <code class="docutils literal notranslate"><span class="pre">nvcc</span></code>âs basic workflow consists in separating device code from host code and then:</p>
<ul class="simple">
<li><p>compiling the device code into an assembly form (<em>PTX</em> code) and/or binary form (<em>cubin</em> object),</p></li>
<li><p>and modifying the host code by replacing the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code> syntax introduced in <a class="reference internal" href="#kernels"><span class="std std-ref">Kernels</span></a> (and described in more details in <a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a>) by the necessary CUDA runtime function calls to load and launch each compiled kernel from the <em>PTX</em> code and/or <em>cubin</em> object.</p></li>
</ul>
<p>The modified host code is output either as C++ code that is left to be compiled using another tool or as object code directly by letting <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> invoke the host compiler during the last compilation stage.</p>
<p>Applications can then:</p>
<ul class="simple">
<li><p>Either link to the compiled host code (this is the most common case),</p></li>
<li><p>Or ignore the modified host code (if any) and use the CUDA driver API (see <a class="reference internal" href="#driver-api"><span class="std std-ref">Driver API</span></a>) to load and execute the <em>PTX</em> code or <em>cubin</em> object.</p></li>
</ul>
</section>
<section id="just-in-time-compilation">
<span id="id17"></span><h4><span class="section-number">3.1.1.2. </span>Just-in-Time Compilation<a class="headerlink" href="#just-in-time-compilation" title="Permalink to this headline">ï</a></h4>
<p>Any <em>PTX</em> code loaded by an application at runtime is compiled further to binary code by the device driver. This is called <em>just-in-time compilation</em>. Just-in-time compilation increases application load time, but allows the application to benefit from any new compiler improvements coming with each new device driver. It is also the only way for applications to run on devices that did not exist at the time the application was compiled, as detailed in <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>.</p>
<p>When the device driver just-in-time compiles some <em>PTX</em> code for some application, it automatically caches a copy of the generated binary code in order to avoid repeating the compilation in subsequent invocations of the application. The cache - referred to as <em>compute cache</em> - is automatically invalidated when the device driver is upgraded, so that applications can benefit from the improvements in the new just-in-time compiler built into the device driver.</p>
<p>Environment variables are available to control just-in-time compilation as described in <a class="reference internal" href="#env-vars"><span class="std std-ref">CUDA Environment Variables</span></a></p>
<p>As an alternative to using <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> to compile CUDA C++ device code, NVRTC can be used to compile CUDA C++ device code to PTX at runtime. NVRTC is a runtime compilation library for CUDA C++; more information can be found in the NVRTC User guide.</p>
</section>
</section>
<section id="binary-compatibility">
<span id="id18"></span><h3><span class="section-number">3.1.2. </span>Binary Compatibility<a class="headerlink" href="#binary-compatibility" title="Permalink to this headline">ï</a></h3>
<p>Binary code is architecture-specific. A <em>cubin</em> object is generated using the compiler option <code class="docutils literal notranslate"><span class="pre">-code</span></code> that specifies the targeted architecture: For example, compiling with <code class="docutils literal notranslate"><span class="pre">-code=sm_80</span></code> produces binary code for devices of <a class="reference internal" href="#compute-capability"><span class="std std-ref">compute capability</span></a> 8.0. Binary compatibility is guaranteed from one minor revision to the next one, but not from one minor revision to the previous one or across major revisions. In other words, a <em>cubin</em> object generated for compute capability <em>X.y</em> will only execute on devices of compute capability <em>X.z</em> where <em>zâ¥y</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Binary compatibility is supported only for the desktop. It is not supported for Tegra. Also, the binary compatibility between desktop and Tegra is not supported.</p>
</div>
</section>
<section id="ptx-compatibility">
<span id="id19"></span><h3><span class="section-number">3.1.3. </span>PTX Compatibility<a class="headerlink" href="#ptx-compatibility" title="Permalink to this headline">ï</a></h3>
<p>Some <em>PTX</em> instructions are only supported on devices of higher compute capabilities. For example, <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a> are only supported on devices of compute capability 5.0 and above. The <code class="docutils literal notranslate"><span class="pre">-arch</span></code> compiler option specifies the compute capability that is assumed when compiling C++ to <em>PTX</em> code. So, code that contains warp shuffle, for example, must be compiled with <code class="docutils literal notranslate"><span class="pre">-arch=compute_50</span></code> (or higher).</p>
<p><em>PTX</em> code produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability. Note that a binary compiled from an earlier PTX version may not make use of some hardware features. For example, a binary targeting devices of compute capability 7.0 (Volta) compiled from PTX generated for compute capability 6.0 (Pascal) will not make use of Tensor Core instructions, since these were not available on Pascal. As a result, the final binary may perform worse than would be possible if the binary were generated using the latest version of PTX.</p>
<p><em>PTX</em> code compiled to target <a class="reference internal" href="#architecture-specific-features"><span class="std std-ref">Architecture-Specific Features</span></a> only runs on the exact same physical architecture and nowhere else. Architecture-specific <em>PTX</em> code is not forward and backward compatible.
Example code compiled with <code class="docutils literal notranslate"><span class="pre">sm_90a</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_90a</span></code> only runs on devices with compute capability 9.0 and is not backward or forward compatible.</p>
<p><em>PTX</em> code compiled to target <a class="reference internal" href="#family-specific-features"><span class="std std-ref">Family-Specific Features</span></a> only runs on the exact same physical architecture and other architectures in the same family. Family-specific <em>PTX</em> code is forward compatible with other devices in the same family, and is not backward compatible.
Example code compiled with <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code> only runs on devices with compute capability 10.0 and 10.3.  <a class="reference internal" href="#family-specific-compatibility"><span class="std std-numref">Table 26</span></a> shows the compatibility of family-specific targets with compute capability.</p>
</section>
<section id="application-compatibility">
<span id="id20"></span><h3><span class="section-number">3.1.4. </span>Application Compatibility<a class="headerlink" href="#application-compatibility" title="Permalink to this headline">ï</a></h3>
<p>To execute code on devices of specific compute capability, an application must load binary or <em>PTX</em> code that is compatible with this compute capability as described in <a class="reference internal" href="#binary-compatibility"><span class="std std-ref">Binary Compatibility</span></a> and <a class="reference internal" href="#ptx-compatibility"><span class="std std-ref">PTX Compatibility</span></a>. In particular, to be able to execute code on future architectures with higher compute capability (for which no binary code can be generated yet), an application must load <em>PTX</em> code that will be just-in-time compiled for these devices (see <a class="reference internal" href="#just-in-time-compilation"><span class="std std-ref">Just-in-Time Compilation</span></a>).</p>
<p>Which <em>PTX</em> and binary code gets embedded in a CUDA C++ application is controlled by the <code class="docutils literal notranslate"><span class="pre">-arch</span></code> and <code class="docutils literal notranslate"><span class="pre">-code</span></code> compiler options or the <code class="docutils literal notranslate"><span class="pre">-gencode</span></code> compiler option as detailed in the <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> user manual. For example,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nvcc x.cu
        -gencode arch=compute_50,code=sm_50
        -gencode arch=compute_60,code=sm_60
        -gencode arch=compute_70,code=\&quot;compute_70,sm_70\&quot;
</pre></div>
</div>
<p>embeds binary code compatible with compute capability 5.0 and 6.0 (first and second <code class="docutils literal notranslate"><span class="pre">-gencode</span></code> options) and <em>PTX</em> and binary code compatible with compute capability 7.0 (third <code class="docutils literal notranslate"><span class="pre">-gencode</span></code> option).</p>
<p>Host code is generated to automatically select at runtime the most appropriate code to load and execute, which, in the above example, will be:</p>
<ul class="simple">
<li><p>5.0 binary code for devices with compute capability 5.0 and 5.2,</p></li>
<li><p>6.0 binary code for devices with compute capability 6.0 and 6.1,</p></li>
<li><p>7.0 binary code for devices with compute capability 7.0 and 7.5,</p></li>
<li><p><em>PTX</em> code which is compiled to binary code at runtime for devices with compute capability later than 7.5</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">x.cu</span></code> can have an optimized code path that uses warp reduction operations, for example, which are only supported in devices of compute capability 8.0 and higher. The <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro can be used to differentiate various code paths based on compute capability. It is only defined for device code. When compiling with <code class="docutils literal notranslate"><span class="pre">-arch=compute_80</span></code> for example, <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">800</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x.cu</span></code> is compiled for <a class="reference internal" href="#family-specific-features"><span class="std std-ref">Family-Specific Features</span></a> with <code class="docutils literal notranslate"><span class="pre">sm_100f</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code>, the code can only run on devices in that specific family, which are devices with compute capability 10.0 and 10.3.  For family-specific code targets an additional macro <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_FAMILY_SPECIFIC__</span></code> is defined.  In this example, <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_FAMILY_SPECIFIC__</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">1000</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">x.cu</span></code> is compiled for <a class="reference internal" href="#architecture-specific-features"><span class="std std-ref">Architecture-Specific Features</span></a> with <code class="docutils literal notranslate"><span class="pre">sm_100a</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_100a</span></code>, the code can only run on devices with compute capability 10.0.  For architecture-specific code targets an additional macro <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_SPECIFIC__</span></code> is defined.  In this example, <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_SPECIFIC__</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">1000</span></code>.  Because architecture-specific features are a superset of family-specific features, the family-specific macro <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH_FAMILY_SPECIFIC__</span></code> is also defined and is equal to <code class="docutils literal notranslate"><span class="pre">1000</span></code>.</p>
<p>Applications using the driver API must compile code to separate files and explicitly load and execute the most appropriate file at runtime.</p>
<p>The Volta architecture introduces <em>Independent Thread Scheduling</em> which changes the way threads are scheduled on the GPU. For code relying on specific behavior of <a class="reference internal" href="#simt-architecture"><span class="std std-ref">SIMT scheduling</span></a> in previous architectures, Independent Thread Scheduling may alter the set of participating threads, leading to incorrect results. To aid migration while implementing the corrective actions detailed in <a class="reference internal" href="#independent-thread-scheduling-7-x"><span class="std std-ref">Independent Thread Scheduling</span></a>, Volta developers can opt-in to Pascalâs thread scheduling with the compiler option combination <code class="docutils literal notranslate"><span class="pre">-arch=compute_60</span> <span class="pre">-code=sm_70</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> user manual lists various shorthands for the <code class="docutils literal notranslate"><span class="pre">-arch</span></code>, <code class="docutils literal notranslate"><span class="pre">-code</span></code>, and <code class="docutils literal notranslate"><span class="pre">-gencode</span></code> compiler options. For example, <code class="docutils literal notranslate"><span class="pre">-arch=sm_70</span></code> is a shorthand for <code class="docutils literal notranslate"><span class="pre">-arch=compute_70</span> <span class="pre">-code=compute_70,sm_70</span></code> (which is the same as <code class="docutils literal notranslate"><span class="pre">-gencode</span> <span class="pre">arch=compute_70,code=\&quot;compute_70,sm_70\&quot;</span></code>).</p>
</section>
<section id="c-compatibility">
<span id="c-cplusplus-compatibility"></span><h3><span class="section-number">3.1.5. </span>C++ Compatibility<a class="headerlink" href="#c-compatibility" title="Permalink to this headline">ï</a></h3>
<p>The front end of the compiler processes CUDA source files according to C++ syntax rules. Full C++ is supported for the host code. However, only a subset of C++ is fully supported for the device code as described in <a class="reference internal" href="#c-cplusplus-language-support"><span class="std std-ref">C++ Language Support</span></a>.</p>
</section>
<section id="bit-compatibility">
<span id="sixtyfour-bit-compatibility"></span><h3><span class="section-number">3.1.6. </span>64-Bit Compatibility<a class="headerlink" href="#bit-compatibility" title="Permalink to this headline">ï</a></h3>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compiles device code in 64-bit mode (i.e., pointers are 64-bit). Device code compiled in 64-bit mode is only supported with host code compiled in 64-bit mode.</p>
</section>
</section>
<section id="cuda-runtime">
<span id="cuda-c-runtime"></span><h2><span class="section-number">3.2. </span>CUDA Runtime<a class="headerlink" href="#cuda-runtime" title="Permalink to this headline">ï</a></h2>
<p>The runtime is implemented in the <code class="docutils literal notranslate"><span class="pre">cudart</span></code> library, which is linked to the application, either statically via <code class="docutils literal notranslate"><span class="pre">cudart.lib</span></code> or <code class="docutils literal notranslate"><span class="pre">libcudart.a</span></code>, or dynamically via <code class="docutils literal notranslate"><span class="pre">cudart.dll</span></code> or <code class="docutils literal notranslate"><span class="pre">libcudart.so</span></code>. Applications that require <code class="docutils literal notranslate"><span class="pre">cudart.dll</span></code> and/or <code class="docutils literal notranslate"><span class="pre">cudart.so</span></code> for dynamic linking typically include them as part of the application installation package. It is only safe to pass the address of CUDA runtime symbols between components that link to the same instance of the CUDA runtime.</p>
<p>All its entry points are prefixed with <code class="docutils literal notranslate"><span class="pre">cuda</span></code>.</p>
<p>As mentioned in <a class="reference internal" href="#heterogeneous-programming"><span class="std std-ref">Heterogeneous Programming</span></a>, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. <a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a> gives an overview of the runtime functions used to manage device memory.</p>
<p><a class="reference internal" href="#shared-memory"><span class="std std-ref">Shared Memory</span></a> illustrates the use of shared memory, introduced in <a class="reference internal" href="#thread-hierarchy"><span class="std std-ref">Thread Hierarchy</span></a>, to maximize performance.</p>
<p><a class="reference internal" href="#page-locked-host-memory"><span class="std std-ref">Page-Locked Host Memory</span></a> introduces page-locked host memory that is required to overlap kernel execution with data transfers between host and device memory.</p>
<p><a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a> describes the concepts and API used to enable asynchronous concurrent execution at various levels in the system.</p>
<p><a class="reference internal" href="#multi-device-system"><span class="std std-ref">Multi-Device System</span></a> shows how the programming model extends to a system with multiple devices attached to the same host.</p>
<p><a class="reference internal" href="#error-checking"><span class="std std-ref">Error Checking</span></a> describes how to properly check the errors generated by the runtime.</p>
<p><a class="reference internal" href="#call-stack"><span class="std std-ref">Call Stack</span></a> mentions the runtime functions used to manage the CUDA C++ call stack.</p>
<p><a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a> presents the texture and surface memory spaces that provide another way to access device memory; they also expose a subset of the GPU texturing hardware.</p>
<p><a class="reference internal" href="#graphics-interoperability"><span class="std std-ref">Graphics Interoperability</span></a> introduces the various functions the runtime provides to interoperate with the two main graphics APIs, OpenGL and Direct3D.</p>
<section id="initialization">
<span id="id21"></span><h3><span class="section-number">3.2.1. </span>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">ï</a></h3>
<p>As of CUDA 12.0, the <code class="docutils literal notranslate"><span class="pre">cudaInitDevice()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> calls initialize the runtime and the primary context
associated with the specified device. Absent these calls, the runtime will implicitly use device 0 and self-initialize
as needed to process other runtime API requests. One needs to keep this in mind when timing runtime function calls and
when interpreting the error code from the first call into the runtime. Before 12.0, <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> would not
initialize the runtime and applications would often use the no-op runtime call <code class="docutils literal notranslate"><span class="pre">cudaFree(0)</span></code> to isolate the runtime
initialization from other api activity (both for the sake of timing and error handling).</p>
<p>The runtime creates a CUDA context for each device in the system (see <a class="reference internal" href="#context"><span class="std std-ref">Context</span></a> for more details on CUDA contexts). This
context is the <em>primary context</em> for this device and is initialized at the first runtime function which requires an active
context on this device. It is shared among all the host threads of the application. As part of this context creation, the
device code is just-in-time compiled if necessary (see <a class="reference internal" href="#just-in-time-compilation"><span class="std std-ref">Just-in-Time Compilation</span></a>) and loaded into device memory. This
all happens transparently. If needed, for example, for driver API interoperability, the primary context of a device can be
accessed from the driver API as described in <a class="reference internal" href="#interoperability-between-runtime-and-driver-apis"><span class="std std-ref">Interoperability between Runtime and Driver APIs</span></a>.</p>
<p>When a host thread calls <code class="docutils literal notranslate"><span class="pre">cudaDeviceReset()</span></code>, this destroys the primary context of the device the host thread currently
operates on (that is, the current device as defined in <a class="reference internal" href="#device-selection"><span class="std std-ref">Device Selection</span></a>). The next runtime function call made by any
host thread that has this device as current will create a new primary context for this device.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The CUDA interfaces use global state that is initialized during host program initiation and destroyed during host program termination. The CUDA runtime and driver cannot detect if this state is invalid, so using any of these interfaces (implicitly or explicitly) during program initiation or termination after main) will result in undefined behavior.</p>
<p>As of CUDA 12.0, <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> will now explicitly initialize the runtime after changing the current device for the host thread. Previous versions of CUDA delayed runtime initialization on the new device until the first runtime call was made after <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code>. This change means that it is now very important to check the return value of <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> for initialization errors.</p>
<p>The runtime functions from the error handling and version management sections of the reference manual do not initialize the runtime.</p>
</div>
</section>
<section id="device-memory">
<span id="id22"></span><h3><span class="section-number">3.2.2. </span>Device Memory<a class="headerlink" href="#device-memory" title="Permalink to this headline">ï</a></h3>
<p>As mentioned in <a class="reference internal" href="#heterogeneous-programming"><span class="std std-ref">Heterogeneous Programming</span></a>, the CUDA programming model assumes a system composed of a host and a device, each with their own separate memory. Kernels operate out of device memory, so the runtime provides functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory.</p>
<p>Device memory can be allocated either as <em>linear memory</em> or as <em>CUDA arrays</em>.</p>
<p>CUDA arrays are opaque memory layouts optimized for texture fetching. They are described in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
<p>Linear memory is allocated in a single unified address space, which means that separately allocated entities can reference one another via pointers, for example, in a binary tree or linked list. The size of the address space depends on the host system (CPU) and the compute capability of the used GPU:</p>
<table class="table-no-stripes docutils align-default" id="id454">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">Linear Memory Address Space</span><a class="headerlink" href="#id454" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 48%" />
<col style="width: 18%" />
<col style="width: 19%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>x86_64 (AMD64)</p></th>
<th class="head"><p>POWER (ppc64le)</p></th>
<th class="head"><p>ARM64</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>up to compute capability 5.3 (Maxwell)</p></td>
<td><p>40bit</p></td>
<td><p>40bit</p></td>
<td><p>40bit</p></td>
</tr>
<tr class="row-odd"><td><p>compute capability 6.0 (Pascal) or newer</p></td>
<td><p>up to 47bit</p></td>
<td><p>up to 49bit</p></td>
<td><p>up to 48bit</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On devices of compute capability 5.3 (Maxwell) and earlier, the CUDA driver creates an uncommitted 40bit virtual address reservation to ensure that memory allocations (pointers) fall into the supported range. This reservation appears as reserved virtual memory, but does not occupy any physical memory until the program actually allocates memory.</p>
</div>
<p>Linear memory is typically allocated using <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> and freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> and data transfer between host memory and device memory are typically done using <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code>. In the vector addition code sample of <a class="reference internal" href="#kernels"><span class="std std-ref">Kernels</span></a>, the vectors need to be copied from host memory to device memory:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">VecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate input vectors h_A and h_B in host memory</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">h_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">h_B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">h_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize input vectors</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate vectors in device memory</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">d_A</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">d_B</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">d_C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy vectors from host memory to device memory</span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">h_A</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">h_B</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocksPerGrid</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">VecAdd</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy result from device memory to host memory</span>
<span class="w">    </span><span class="c1">// h_C contains the result in host memory</span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">h_C</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free device memory</span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_A</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_B</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_C</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free host memory</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Linear memory can also be allocated through <code class="docutils literal notranslate"><span class="pre">cudaMallocPitch()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMalloc3D()</span></code>. These functions are recommended for allocations of 2D or 3D arrays as it makes sure that the allocation is appropriately padded to meet the alignment requirements described in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>, therefore ensuring best performance when accessing the row addresses or performing copies between 2D arrays and other regions of device memory (using the <code class="docutils literal notranslate"><span class="pre">cudaMemcpy2D()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemcpy3D()</span></code> functions). The returned pitch (or stride) must be used to access array elements. The following code sample allocates a <code class="docutils literal notranslate"><span class="pre">width</span></code> x <code class="docutils literal notranslate"><span class="pre">height</span></code> 2D array of floating-point values and shows how to loop over the array elements in device code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">devPtr</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMallocPitch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pitch</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">devPtr</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">devPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following code sample allocates a <code class="docutils literal notranslate"><span class="pre">width</span></code> x <code class="docutils literal notranslate"><span class="pre">height</span></code> x <code class="docutils literal notranslate"><span class="pre">depth</span></code> 3D array of floating-point values and shows how to loop over the array elements in device code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaExtent</span><span class="w"> </span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_cudaExtent</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"></span>
<span class="w">                                    </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaPitchedPtr</span><span class="w"> </span><span class="n">devPitchedPtr</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMalloc3D</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devPitchedPtr</span><span class="p">,</span><span class="w"> </span><span class="n">extent</span><span class="p">);</span><span class="w"></span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">devPitchedPtr</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(</span><span class="n">cudaPitchedPtr</span><span class="w"> </span><span class="n">devPitchedPtr</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">devPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devPitchedPtr</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devPitchedPtr</span><span class="p">.</span><span class="n">pitch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">slicePitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pitch</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">slicePitch</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)(</span><span class="n">slice</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="kt">float</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">row</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid allocating too much memory and thus impacting system-wide performance, request the allocation parameters from the user based on the problem size. If the allocation fails, you can fallback to other slower memory types (<code class="docutils literal notranslate"><span class="pre">cudaMallocHost()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code>, etc.), or return an error telling the user how much memory was needed that was denied. If your application cannot request the allocation parameters for some reason, we recommend using <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> for platforms that support it.</p>
</div>
<p>The reference manual lists all the various functions used to copy memory between linear memory allocated with <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>, linear memory allocated with <code class="docutils literal notranslate"><span class="pre">cudaMallocPitch()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMalloc3D()</span></code>, CUDA arrays, and memory allocated for variables declared in global or constant memory space.</p>
<p>The following code sample illustrates various ways of accessing global variables via the runtime API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__constant__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">constData</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
<span class="n">cudaMemcpyToSymbol</span><span class="p">(</span><span class="n">constData</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"></span>
<span class="n">cudaMemcpyFromSymbol</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">constData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">devData</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14f</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemcpyToSymbol</span><span class="p">(</span><span class="n">devData</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">devPointer</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>
<span class="n">cudaMemcpyToSymbol</span><span class="p">(</span><span class="n">devPointer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cudaGetSymbolAddress()</span></code> is used to retrieve the address pointing to the memory allocated for a variable declared in global memory space. The size of the allocated memory is obtained through <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolSize()</span></code>.</p>
</section>
<section id="device-memory-l2-access-management">
<span id="l2-access-intro"></span><h3><span class="section-number">3.2.3. </span>Device Memory L2 Access Management<a class="headerlink" href="#device-memory-l2-access-management" title="Permalink to this headline">ï</a></h3>
<p>When a CUDA kernel accesses a data region in the global memory repeatedly, such data accesses can be considered to be <em>persisting</em>. On the other hand, if the data is only accessed once, such data accesses can be considered to be <em>streaming</em>.</p>
<p>Starting with CUDA 11.0, devices of compute capability 8.0 and above have the capability to influence persistence of data in the L2 cache, potentially providing higher bandwidth and lower latency accesses to global memory.</p>
<section id="l2-cache-set-aside-for-persisting-accesses">
<span id="l2-set-aside"></span><h4><span class="section-number">3.2.3.1. </span>L2 Cache Set-Aside for Persisting Accesses<a class="headerlink" href="#l2-cache-set-aside-for-persisting-accesses" title="Permalink to this headline">ï</a></h4>
<p>A portion of the L2 cache can be set aside to be used for persisting data accesses to global memory. Persisting accesses have prioritized use of this set-aside portion of L2 cache, whereas normal or streaming, accesses to global memory can only utilize this portion of L2 when it is unused by persisting accesses.</p>
<p>The L2 cache set-aside size for persisting accesses may be adjusted, within limits:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">device_id</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">prop</span><span class="p">.</span><span class="n">l2CacheSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.75</span><span class="p">),</span><span class="w"> </span><span class="n">prop</span><span class="p">.</span><span class="n">persistingL2CacheMaxSize</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaDeviceSetLimit</span><span class="p">(</span><span class="n">cudaLimitPersistingL2CacheSize</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="cm">/* set-aside 3/4 of L2 cache for persisting accesses or the max allowed*/</span><span class="w"></span>
</pre></div>
</div>
<p>When the GPU is configured in Multi-Instance GPU (MIG) mode, the L2 cache set-aside functionality is disabled.</p>
<p>When using the Multi-Process Service (MPS), the L2 cache set-aside size cannot be changed by <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit</span></code>. Instead, the set-aside size can only be specified at start up of MPS server through the environment variable <code class="docutils literal notranslate"><span class="pre">CUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT</span></code>.</p>
</section>
<section id="l2-policy-for-persisting-accesses">
<span id="l2-access-policy"></span><h4><span class="section-number">3.2.3.2. </span>L2 Policy for Persisting Accesses<a class="headerlink" href="#l2-policy-for-persisting-accesses" title="Permalink to this headline">ï</a></h4>
<p>An access policy window specifies a contiguous region of global memory and a persistence property in the L2 cache for accesses within that region.</p>
<p>The code example below shows how to set an L2 persisting access window using a CUDA Stream.</p>
<p><strong>CUDA Stream Example</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaStreamAttrValue</span><span class="w"> </span><span class="n">stream_attribute</span><span class="p">;</span><span class="w">                                         </span><span class="c1">// Stream level attributes data structure</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">base_ptr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// Global Memory data pointer</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">num_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w">                    </span><span class="c1">// Number of bytes for persistence access.</span>
<span class="w">                                                                              </span><span class="c1">// (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitRatio</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">0.6</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Hint for cache hit ratio</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitProp</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyPersisting</span><span class="p">;</span><span class="w"> </span><span class="c1">// Type of access property on cache hit</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">missProp</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyStreaming</span><span class="p">;</span><span class="w">  </span><span class="c1">// Type of access property on cache miss.</span>

<span class="c1">//Set the attributes to a CUDA stream of type cudaStream_t</span>
<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamAttributeAccessPolicyWindow</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream_attribute</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When a kernel subsequently executes in CUDA <code class="docutils literal notranslate"><span class="pre">stream</span></code>, memory accesses within the global memory extent <code class="docutils literal notranslate"><span class="pre">[ptr..ptr+num_bytes)</span></code> are more likely to persist in the L2 cache than accesses to other global memory locations.</p>
<p>L2 persistence can also be set for a CUDA Graph Kernel Node as shown in the example below:</p>
<p><strong>CUDA GraphKernelNode Example</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaKernelNodeAttrValue</span><span class="w"> </span><span class="n">node_attribute</span><span class="p">;</span><span class="w">                                     </span><span class="c1">// Kernel level attributes data structure</span>
<span class="n">node_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">base_ptr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="c1">// Global Memory data pointer</span>
<span class="n">node_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">num_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w">                    </span><span class="c1">// Number of bytes for persistence access.</span>
<span class="w">                                                                            </span><span class="c1">// (Must be less than cudaDeviceProp::accessPolicyMaxWindowSize)</span>
<span class="n">node_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitRatio</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">0.6</span><span class="p">;</span><span class="w">                          </span><span class="c1">// Hint for cache hit ratio</span>
<span class="n">node_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitProp</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyPersisting</span><span class="p">;</span><span class="w"> </span><span class="c1">// Type of access property on cache hit</span>
<span class="n">node_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">missProp</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyStreaming</span><span class="p">;</span><span class="w">  </span><span class="c1">// Type of access property on cache miss.</span>

<span class="c1">//Set the attributes to a CUDA Graph Kernel node of type cudaGraphNode_t</span>
<span class="n">cudaGraphKernelNodeSetAttribute</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">cudaKernelNodeAttributeAccessPolicyWindow</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node_attribute</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> parameter can be used to specify the fraction of accesses that receive the <code class="docutils literal notranslate"><span class="pre">hitProp</span></code> property. In both of the examples above, 60% of the memory accesses in the global memory region <code class="docutils literal notranslate"><span class="pre">[ptr..ptr+num_bytes)</span></code> have the persisting property and 40% of the memory accesses have the streaming property. Which specific memory accesses are classified as persisting (the <code class="docutils literal notranslate"><span class="pre">hitProp</span></code>) is random with a probability of approximately <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code>; the probability distribution depends upon the hardware architecture and the memory extent.</p>
<p>For example, if the L2 set-aside cache size is 16KB and the <code class="docutils literal notranslate"><span class="pre">num_bytes</span></code> in the <code class="docutils literal notranslate"><span class="pre">accessPolicyWindow</span></code> is 32KB:</p>
<ul class="simple">
<li><p>With a <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> of 0.5, the hardware will select, at random, 16KB of the 32KB window to be designated as persisting and cached in the set-aside L2 cache area.</p></li>
<li><p>With a <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> of 1.0, the hardware will attempt to cache the whole 32KB window in the set-aside L2 cache area. Since the set-aside area is smaller than the window, cache lines will be evicted to keep the most recently used 16KB of the 32KB data in the set-aside portion of the L2 cache.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> can therefore be used to avoid thrashing of cache lines and overall reduce the amount of data moved into and out of the L2 cache.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> value below 1.0 can be used to manually control the amount of data different <code class="docutils literal notranslate"><span class="pre">accessPolicyWindow</span></code>s from concurrent CUDA streams can cache in L2. For example, let the L2 set-aside cache size be 16KB; two concurrent kernels in two different CUDA streams, each with a 16KB <code class="docutils literal notranslate"><span class="pre">accessPolicyWindow</span></code>, and both with <code class="docutils literal notranslate"><span class="pre">hitRatio</span></code> value 1.0, might evict each othersâ cache lines when competing for the shared L2 resource. However, if both <code class="docutils literal notranslate"><span class="pre">accessPolicyWindows</span></code> have a hitRatio value of 0.5, they will be less likely to evict their own or each othersâ persisting cache lines.</p>
</section>
<section id="l2-access-properties">
<span id="l2-access-prop"></span><h4><span class="section-number">3.2.3.3. </span>L2 Access Properties<a class="headerlink" href="#l2-access-properties" title="Permalink to this headline">ï</a></h4>
<p>Three types of access properties are defined for different global memory data accesses:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaAccessPropertyStreaming</span></code>: Memory accesses that occur with the streaming property are less likely to persist in the L2 cache because these accesses are preferentially evicted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaAccessPropertyPersisting</span></code>: Memory accesses that occur with the persisting property are more likely to persist in the L2 cache because these accesses are preferentially retained in the set-aside portion of L2 cache.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaAccessPropertyNormal</span></code>: This access property forcibly resets previously applied persisting access property to a normal status. Memory accesses with the persisting property from previous CUDA kernels may be retained in L2 cache long after their intended use. This persistence-after-use reduces the amount of L2 cache available to subsequent kernels that do not use the persisting property. Resetting an access property window with the <code class="docutils literal notranslate"><span class="pre">cudaAccessPropertyNormal</span></code> property removes the persisting (preferential retention) status of the prior access, as if the prior access had been without an access property.</p></li>
</ol>
</section>
<section id="l2-persistence-example">
<span id="l2-simple-example"></span><h4><span class="section-number">3.2.3.4. </span>L2 Persistence Example<a class="headerlink" href="#l2-persistence-example" title="Permalink to this headline">ï</a></h4>
<p>The following example shows how to set-aside L2 cache for persistent accesses, use the set-aside L2 cache in CUDA kernels via CUDA Stream and then reset the L2 cache.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span><span class="w">                                                                  </span><span class="c1">// Create CUDA stream</span>

<span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">prop</span><span class="p">;</span><span class="w">                                                                        </span><span class="c1">// CUDA device properties variable</span>
<span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">device_id</span><span class="p">);</span><span class="w">                                                 </span><span class="c1">// Query GPU properties</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="n">prop</span><span class="p">.</span><span class="n">l2CacheSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.75</span><span class="p">)</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">prop</span><span class="p">.</span><span class="n">persistingL2CacheMaxSize</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="n">cudaDeviceSetLimit</span><span class="p">(</span><span class="w"> </span><span class="n">cudaLimitPersistingL2CacheSize</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">                                  </span><span class="c1">// set-aside 3/4 of L2 cache for persisting accesses or the max allowed</span>

<span class="kt">size_t</span><span class="w"> </span><span class="n">window_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">prop</span><span class="p">.</span><span class="n">accessPolicyMaxWindowSize</span><span class="p">,</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">);</span><span class="w">                        </span><span class="c1">// Select minimum of user defined num_bytes and max window size.</span>

<span class="n">cudaStreamAttrValue</span><span class="w"> </span><span class="n">stream_attribute</span><span class="p">;</span><span class="w">                                                       </span><span class="c1">// Stream level attributes data structure</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">base_ptr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data1</span><span class="p">);</span><span class="w">               </span><span class="c1">// Global Memory data pointer</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">num_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">window_size</span><span class="p">;</span><span class="w">                                </span><span class="c1">// Number of bytes for persistence access</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitRatio</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mf">0.6</span><span class="p">;</span><span class="w">                                        </span><span class="c1">// Hint for cache hit ratio</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">hitProp</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyPersisting</span><span class="p">;</span><span class="w">               </span><span class="c1">// Persistence Property</span>
<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">missProp</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAccessPropertyStreaming</span><span class="p">;</span><span class="w">                </span><span class="c1">// Type of access property on cache miss</span>

<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamAttributeAccessPolicyWindow</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream_attribute</span><span class="p">);</span><span class="w">   </span><span class="c1">// Set the attributes to a CUDA Stream</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cuda_kernelA</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="n">block_size</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data1</span><span class="p">);</span><span class="w">                                 </span><span class="c1">// This data1 is used by a kernel multiple times</span>
<span class="p">}</span><span class="w">                                                                                           </span><span class="c1">// [data1 + num_bytes) benefits from L2 persistence</span>
<span class="n">cuda_kernelB</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="n">block_size</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data1</span><span class="p">);</span><span class="w">                                     </span><span class="c1">// A different kernel in the same stream can also benefit</span>
<span class="w">                                                                                            </span><span class="c1">// from the persistence of data1</span>

<span class="n">stream_attribute</span><span class="p">.</span><span class="n">accessPolicyWindow</span><span class="p">.</span><span class="n">num_bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                                          </span><span class="c1">// Setting the window size to 0 disable it</span>
<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamAttributeAccessPolicyWindow</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream_attribute</span><span class="p">);</span><span class="w">   </span><span class="c1">// Overwrite the access policy attribute to a CUDA Stream</span>
<span class="n">cudaCtxResetPersistingL2Cache</span><span class="p">();</span><span class="w">                                                            </span><span class="c1">// Remove any persistent lines in L2</span>

<span class="n">cuda_kernelC</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_size</span><span class="p">,</span><span class="n">block_size</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span><span class="w">                                     </span><span class="c1">// data2 can now benefit from full L2 in normal mode</span>
</pre></div>
</div>
</section>
<section id="reset-l2-access-to-normal">
<span id="l2-reset-to-normal"></span><h4><span class="section-number">3.2.3.5. </span>Reset L2 Access to Normal<a class="headerlink" href="#reset-l2-access-to-normal" title="Permalink to this headline">ï</a></h4>
<p>A persisting L2 cache line from a previous CUDA kernel may persist in L2 long after it has been used. Hence, a reset to normal for L2 cache is important for streaming or normal memory accesses to utilize the L2 cache with normal priority. There are three ways a persisting access can be reset to normal status.</p>
<ol class="arabic simple">
<li><p>Reset a previous persisting memory region with the access property, <code class="docutils literal notranslate"><span class="pre">cudaAccessPropertyNormal</span></code>.</p></li>
<li><p>Reset all persisting L2 cache lines to normal by calling <code class="docutils literal notranslate"><span class="pre">cudaCtxResetPersistingL2Cache()</span></code>.</p></li>
<li><p><strong>Eventually</strong> untouched lines are automatically reset to normal. Reliance on automatic reset is strongly discouraged because of the undetermined length of time required for automatic reset to occur.</p></li>
</ol>
</section>
<section id="manage-utilization-of-l2-set-aside-cache">
<span id="l2-managing-utilization"></span><h4><span class="section-number">3.2.3.6. </span>Manage Utilization of L2 set-aside cache<a class="headerlink" href="#manage-utilization-of-l2-set-aside-cache" title="Permalink to this headline">ï</a></h4>
<p>Multiple CUDA kernels executing concurrently in different CUDA streams may have a different access policy window assigned to their streams. However, the L2 set-aside cache portion is shared among all these concurrent CUDA kernels. As a result, the net utilization of this set-aside cache portion is the sum of all the concurrent kernelsâ individual use. The benefits of designating memory accesses as persisting diminish as the volume of persisting accesses exceeds the set-aside L2 cache capacity.</p>
<p>To manage utilization of the set-aside L2 cache portion, an application must consider the following:</p>
<ul class="simple">
<li><p>Size of L2 set-aside cache.</p></li>
<li><p>CUDA kernels that may concurrently execute.</p></li>
<li><p>The access policy window for all the CUDA kernels that may concurrently execute.</p></li>
<li><p>When and how L2 reset is required to allow normal or streaming accesses to utilize the previously set-aside L2 cache with equal priority.</p></li>
</ul>
</section>
<section id="query-l2-cache-properties">
<span id="l2-cache-query"></span><h4><span class="section-number">3.2.3.7. </span>Query L2 cache Properties<a class="headerlink" href="#query-l2-cache-properties" title="Permalink to this headline">ï</a></h4>
<p>Properties related to L2 cache are a part of <code class="docutils literal notranslate"><span class="pre">cudaDeviceProp</span></code> struct and can be queried using CUDA runtime API <code class="docutils literal notranslate"><span class="pre">cudaGetDeviceProperties</span></code></p>
<p>CUDA Device Properties include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l2CacheSize</span></code>: The amount of available L2 cache on the GPU.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">persistingL2CacheMaxSize</span></code>: The maximum amount of L2 cache that can be set-aside for persisting memory accesses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">accessPolicyMaxWindowSize</span></code>: The maximum size of the access policy window.</p></li>
</ul>
</section>
<section id="control-l2-cache-set-aside-size-for-persisting-memory-access">
<span id="l2-cache-getset-size"></span><h4><span class="section-number">3.2.3.8. </span>Control L2 Cache Set-Aside Size for Persisting Memory Access<a class="headerlink" href="#control-l2-cache-set-aside-size-for-persisting-memory-access" title="Permalink to this headline">ï</a></h4>
<p>The L2 set-aside cache size for persisting memory accesses is queried using CUDA runtime API <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit</span></code> and set using CUDA runtime API <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit</span></code> as a <code class="docutils literal notranslate"><span class="pre">cudaLimit</span></code>. The maximum value for setting this limit is <code class="docutils literal notranslate"><span class="pre">cudaDeviceProp::persistingL2CacheMaxSize</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaLimit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* other fields not shown */</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaLimitPersistingL2CacheSize</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="shared-memory">
<span id="id23"></span><h3><span class="section-number">3.2.4. </span>Shared Memory<a class="headerlink" href="#shared-memory" title="Permalink to this headline">ï</a></h3>
<p>As detailed in <a class="reference internal" href="#variable-memory-space-specifiers"><span class="std std-ref">Variable Memory Space Specifiers</span></a> shared memory is allocated using the <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> memory space specifier.</p>
<p>Shared memory is expected to be much faster than global memory as mentioned in <a class="reference internal" href="#thread-hierarchy"><span class="std std-ref">Thread Hierarchy</span></a> and detailed in <a class="reference internal" href="#shared-memory"><span class="std std-ref">Shared Memory</span></a>. It can be used as scratchpad memory (or software managed cache) to minimize global memory accesses from a CUDA block as illustrated by the following matrix multiplication example.</p>
<p>The following code sample is a straightforward implementation of matrix multiplication that does not take advantage of shared memory. Each thread reads one row of <em>A</em> and one column of <em>B</em> and computes the corresponding element of <em>C</em> as illustrated in <a class="reference internal" href="#shared-memory-matrix-multiplication-no-shared-memory"><span class="std std-ref">Figure 8</span></a>. <em>A</em> is therefore read <em>B.width</em> times from global memory and <em>B</em> is read <em>A.height</em> times.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Matrices are stored in row-major order:</span>
<span class="c1">// M(row, col) = *(M.elements + row * M.width + col)</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Matrix</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Thread block size</span>
<span class="cp">#define BLOCK_SIZE 16</span>

<span class="c1">// Forward declaration of the matrix multiplication kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatMulKernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Matrix multiplication - Host code</span>
<span class="c1">// Matrix dimensions are assumed to be multiples of BLOCK_SIZE</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MatMul</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Load A and B to device memory</span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_A</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_B</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_B</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate C in device memory</span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_C</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_C</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MatMulKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Read C from device memory</span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free device memory</span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Matrix multiplication kernel called by MatMul()</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatMulKernel</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Each thread computes one element of C</span>
<span class="w">    </span><span class="c1">// by accumulating results into Cvalue</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Cvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">Cvalue</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"></span>
<span class="w">                </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cvalue</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<figure class="align-default" id="shared-memory-matrix-multiplication-no-shared-memory">
<img alt="_images/matrix-multiplication-without-shared-memory.png" src="_images/matrix-multiplication-without-shared-memory.png" />
<figcaption>
<p><span class="caption-number">Figure 8 </span><span class="caption-text">Matrix Multiplication without Shared Memory</span><a class="headerlink" href="#shared-memory-matrix-multiplication-no-shared-memory" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The following code sample is an implementation of matrix multiplication that does take advantage of shared memory. In this implementation, each thread block is responsible for computing one square sub-matrix <em>Csub</em> of <em>C</em> and each thread within the block is responsible for computing one element of <em>Csub</em>. As illustrated in <a class="reference internal" href="#shared-memory-matrix-multiplication-shared-memory"><span class="std std-ref">Figure 9</span></a>, <em>Csub</em> is equal to the product of two rectangular matrices: the sub-matrix of <em>A</em> of dimension (<em>A.width, block_size</em>) that has the same row indices as <em>Csub</em>, and the sub-matrix of <em>B</em> of dimension (<em>block_size, A.width</em> )that has the same column indices as <em>Csub</em>. In order to fit into the deviceâs resources, these two rectangular matrices are divided into as many square matrices of dimension <em>block_size</em> as necessary and <em>Csub</em> is computed as the sum of the products of these square matrices. Each of these products is performed by first loading the two corresponding square matrices from global memory to shared memory with one thread loading one element of each matrix, and then by having each thread compute one element of the product. Each thread accumulates the result of each of these products into a register and once done writes the result to global memory.</p>
<p>By blocking the computation this way, we take advantage of fast shared memory and save a lot of global memory bandwidth since <em>A</em> is only read (<em>B.width / block_size</em>) times from global memory and <em>B</em> is read (<em>A.height / block_size</em>) times.</p>
<p>The <em>Matrix</em> type from the previous code sample is augmented with a <em>stride</em> field, so that sub-matrices can be efficiently represented with the same type. <a class="reference internal" href="#device-function-specifier"><span class="std std-ref">__device__</span></a> functions are used to get and set elements and build any sub-matrix from a matrix.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Matrices are stored in row-major order:</span>
<span class="c1">// M(row, col) = *(M.elements + row * M.stride + col)</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">Matrix</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Get a matrix element</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">GetElement</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Set a matrix element</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">SetElement</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">row</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Get the BLOCK_SIZExBLOCK_SIZE sub-matrix Asub of A that is</span>
<span class="c1">// located col sub-matrices to the right and row sub-matrices down</span>
<span class="c1">// from the upper-left corner of A</span>
<span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">GetSubMatrix</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">Asub</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Asub</span><span class="p">.</span><span class="n">width</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Asub</span><span class="p">.</span><span class="n">height</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Asub</span><span class="p">.</span><span class="n">stride</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">stride</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Asub</span><span class="p">.</span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">A</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">row</span><span class="w"></span>
<span class="w">                                         </span><span class="o">+</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Asub</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Thread block size</span>
<span class="cp">#define BLOCK_SIZE 16</span>
<span class="c1">// Forward declaration of the matrix multiplication kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatMulKernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Matrix multiplication - Host code</span>
<span class="c1">// Matrix dimensions are assumed to be multiples of BLOCK_SIZE</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MatMul</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Load A and B to device memory</span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_A</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_A</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_B</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_B</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_B</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Allocate C in device memory</span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">d_C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d_C</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_C</span><span class="p">.</span><span class="n">stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">d_C</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">MatMulKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Read C from device memory</span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Free device memory</span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_A</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_B</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_C</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Matrix multiplication kernel called by MatMul()</span>
<span class="w"> </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MatMulKernel</span><span class="p">(</span><span class="n">Matrix</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Block row and column</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blockRow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blockCol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Each thread block computes one sub-matrix Csub of C</span>
<span class="w">    </span><span class="n">Matrix</span><span class="w"> </span><span class="n">Csub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSubMatrix</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">blockRow</span><span class="p">,</span><span class="w"> </span><span class="n">blockCol</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Each thread computes one element of Csub</span>
<span class="w">    </span><span class="c1">// by accumulating results into Cvalue</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Cvalue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Thread row and column within Csub</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Loop over all the sub-matrices of A and B that are</span>
<span class="w">    </span><span class="c1">// required to compute Csub</span>
<span class="w">    </span><span class="c1">// Multiply each pair of sub-matrices together</span>
<span class="w">    </span><span class="c1">// and accumulate the results</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Get sub-matrix Asub of A</span>
<span class="w">        </span><span class="n">Matrix</span><span class="w"> </span><span class="n">Asub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSubMatrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">blockRow</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Get sub-matrix Bsub of B</span>
<span class="w">        </span><span class="n">Matrix</span><span class="w"> </span><span class="n">Bsub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSubMatrix</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">blockCol</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Shared memory used to store Asub and Bsub respectively</span>
<span class="w">        </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">As</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="p">][</span><span class="n">BLOCK_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Bs</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="p">][</span><span class="n">BLOCK_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Load Asub and Bsub from device memory to shared memory</span>
<span class="w">        </span><span class="c1">// Each thread loads one element of each sub-matrix</span>
<span class="w">        </span><span class="n">As</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElement</span><span class="p">(</span><span class="n">Asub</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Bs</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetElement</span><span class="p">(</span><span class="n">Bsub</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Synchronize to make sure the sub-matrices are loaded</span>
<span class="w">        </span><span class="c1">// before starting the computation</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Multiply Asub and Bsub together</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">Cvalue</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">As</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Bs</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">col</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Synchronize to make sure that the preceding</span>
<span class="w">        </span><span class="c1">// computation is done before loading two new</span>
<span class="w">        </span><span class="c1">// sub-matrices of A and B in the next iteration</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Write Csub to device memory</span>
<span class="w">    </span><span class="c1">// Each thread writes one element</span>
<span class="w">    </span><span class="n">SetElement</span><span class="p">(</span><span class="n">Csub</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">Cvalue</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<figure class="align-default" id="shared-memory-matrix-multiplication-shared-memory">
<img alt="_images/matrix-multiplication-with-shared-memory.png" src="_images/matrix-multiplication-with-shared-memory.png" />
<figcaption>
<p><span class="caption-number">Figure 9 </span><span class="caption-text">Matrix Multiplication with Shared Memory</span><a class="headerlink" href="#shared-memory-matrix-multiplication-shared-memory" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="distributed-shared-memory">
<span id="id24"></span><h3><span class="section-number">3.2.5. </span>Distributed Shared Memory<a class="headerlink" href="#distributed-shared-memory" title="Permalink to this headline">ï</a></h3>
<p>Thread block clusters introduced in compute capability 9.0 provide the ability for threads in a thread block cluster to access shared memory of all the participating thread blocks in a cluster. This partitioned shared memory is called <em>Distributed Shared Memory</em>, and the corresponding address space is called Distributed shared memory address space. Threads that belong to a thread block cluster, can read, write or perform atomics in the distributed address space, regardless whether the address belongs to the local thread block or a remote thread block. Whether a kernel uses distributed shared memory or not, the shared memory size specifications, static or dynamic is still per thread block. The size of distributed shared memory is just the number of thread blocks per cluster multiplied by the size of shared memory per thread block.</p>
<p>Accessing data in distributed shared memory requires all the thread blocks to exist. A user can guarantee that all thread blocks have started executing using <code class="docutils literal notranslate"><span class="pre">cluster.sync()</span></code> from <a class="reference internal" href="#cluster-group-cg"><span class="std std-ref">Cluster Group</span></a> API.
The user also needs to ensure that all distributed shared memory operations happen before the exit of a thread block, e.g., if a remote thread block is trying to read a given thread blockâs shared memory, user needs to ensure that the shared memory read by remote thread block is completed before it can exit.</p>
<p>CUDA provides a mechanism to access to distributed shared memory, and applications can benefit from leveraging its capabilities. Lets look at a simple histogram computation and how to optimize it on the GPU using thread block cluster. A standard way of computing histograms is do the computation in the shared memory of each thread block and then perform global memory atomics. A limitation of this approach is the shared memory capacity. Once the histogram bins no longer fit in the shared memory, a user needs to directly compute histograms and hence the atomics in the global memory. With distributed shared memory, CUDA provides an intermediate step, where a depending on the histogram bins size, histogram can be computed in shared memory, distributed shared memory or global memory directly.</p>
<p>The CUDA kernel example below shows how to compute histograms in shared memory or distributed shared memory, depending on the number of histogram bins.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="c1">// Distributed Shared memory histogram kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">clusterHist_kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">bins</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nbins</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">__restrict__</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"></span>
<span class="w">                                   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">array_size</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem</span><span class="p">[];</span><span class="w"></span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_grid</span><span class="p">().</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Cluster initialization, size and calculating local bin offsets.</span>
<span class="w">  </span><span class="n">cg</span><span class="o">::</span><span class="n">cluster_group</span><span class="w"> </span><span class="n">cluster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_cluster</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">clusterBlockRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">block_rank</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cluster_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">dim_blocks</span><span class="p">().</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">smem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//Initialize shared memory histogram to zeros</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// cluster synchronization ensures that shared memory is initialized to zero in</span>
<span class="w">  </span><span class="c1">// all thread blocks in the cluster. It also ensures that all thread blocks</span>
<span class="w">  </span><span class="c1">// have started executing and they exist concurrently.</span>
<span class="w">  </span><span class="n">cluster</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">array_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ldata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Find the right histogram bin.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">binid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ldata</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ldata</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">binid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ldata</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">nbins</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">binid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbins</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Find destination block rank and offset for computing</span>
<span class="w">    </span><span class="c1">//distributed shared memory histogram</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dst_block_rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">binid</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dst_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">binid</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Pointer to target block shared memory</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">dst_smem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">map_shared_rank</span><span class="p">(</span><span class="n">smem</span><span class="p">,</span><span class="w"> </span><span class="n">dst_block_rank</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Perform atomic update of the histogram bin</span>
<span class="w">    </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">dst_smem</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dst_offset</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// cluster synchronization is required to ensure all distributed shared</span>
<span class="w">  </span><span class="c1">// memory operations are completed and no thread block exits while</span>
<span class="w">  </span><span class="c1">// other thread blocks are still accessing distributed shared memory</span>
<span class="w">  </span><span class="n">cluster</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Perform global memory histogram, using the local distributed memory histogram</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">lbins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bins</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">block_rank</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bins_per_block</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lbins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">smem</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The above kernel can be launched at runtime with a cluster size depending on the amount of distributed shared memory required. If histogram is small enough to fit in shared memory of just one block, user can launch kernel with cluster size 1. The code snippet below shows how to launch a cluster kernel dynamically based depending on shared memory requirements.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Launch via extensible launch</span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaLaunchConfig_t</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">gridDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threads_per_block</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">blockDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threads_per_block</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// cluster_size depends on the histogram size.</span>
<span class="w">  </span><span class="c1">// ( cluster_size == 1 ) implies no distributed shared memory, just thread block local shared memory</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cluster_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// size 2 is an example here</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nbins_per_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbins</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cluster_size</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">//dynamic shared memory size is per block.</span>
<span class="w">  </span><span class="c1">//Distributed shared memory size =  cluster_size * nbins_per_block * sizeof(int)</span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">dynamicSmemBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nbins_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="o">::</span><span class="n">cudaFuncSetAttribute</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">clusterHist_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p">.</span><span class="n">dynamicSmemBytes</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeClusterDimension</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster_size</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaLaunchKernelEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">clusterHist_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">bins</span><span class="p">,</span><span class="w"> </span><span class="n">nbins</span><span class="p">,</span><span class="w"> </span><span class="n">nbins_per_block</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">array_size</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="page-locked-host-memory">
<span id="id25"></span><h3><span class="section-number">3.2.6. </span>Page-Locked Host Memory<a class="headerlink" href="#page-locked-host-memory" title="Permalink to this headline">ï</a></h3>
<p>The runtime provides functions to allow the use of <em>page-locked</em> (also known as <em>pinned</em>) host memory (as opposed to regular pageable host memory allocated by <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFreeHost()</span></code> allocate and free page-locked host memory;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code> page-locks a range of memory allocated by <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> (see reference manual for limitations).</p></li>
</ul>
<p>Using page-locked host memory has several benefits:</p>
<ul class="simple">
<li><p>Copies between page-locked host memory and device memory can be performed concurrently with kernel execution for some devices as mentioned in <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>.</p></li>
<li><p>On some devices, page-locked host memory can be mapped into the address space of the device, eliminating the need to copy it to or from device memory as detailed in <a class="reference internal" href="#mapped-memory"><span class="std std-ref">Mapped Memory</span></a>.</p></li>
<li><p>On systems with a front-side bus, bandwidth between host memory and device memory is higher if host memory is allocated as page-locked and even higher if in addition it is allocated as write-combining as described in <a class="reference internal" href="#write-combining-memory"><span class="std std-ref">Write-Combining Memory</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Page-locked host memory is not cached on non I/O coherent Tegra devices. Also, <code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code> is not supported on non I/O coherent Tegra devices.</p>
</div>
<p>The simple zero-copy CUDA sample comes with a detailed document on the page-locked memory APIs.</p>
<section id="portable-memory">
<span id="id26"></span><h4><span class="section-number">3.2.6.1. </span>Portable Memory<a class="headerlink" href="#portable-memory" title="Permalink to this headline">ï</a></h4>
<p>A block of page-locked memory can be used in conjunction with any device in the system (see <a class="reference internal" href="#multi-device-system"><span class="std std-ref">Multi-Device System</span></a> for more details on multi-device systems), but by default, the benefits of using page-locked memory described above are only available in conjunction with the device that was current when the block was allocated (and with all devices sharing the same unified address space, if any, as described in <a class="reference internal" href="#unified-virtual-address-space"><span class="std std-ref">Unified Virtual Address Space</span></a>). To make these advantages available to all devices, the block needs to be allocated by passing the flag <code class="docutils literal notranslate"><span class="pre">cudaHostAllocPortable</span></code> to <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> or page-locked by passing the flag <code class="docutils literal notranslate"><span class="pre">cudaHostRegisterPortable</span></code> to <code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code>.</p>
</section>
<section id="write-combining-memory">
<span id="id27"></span><h4><span class="section-number">3.2.6.2. </span>Write-Combining Memory<a class="headerlink" href="#write-combining-memory" title="Permalink to this headline">ï</a></h4>
<p>By default page-locked host memory is allocated as cacheable. It can optionally be allocated as <em>write-combining</em> instead by passing flag <code class="docutils literal notranslate"><span class="pre">cudaHostAllocWriteCombined</span></code> to <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code>. Write-combining memory frees up the hostâs L1 and L2 cache resources, making more cache available to the rest of the application. In addition, write-combining memory is not snooped during transfers across the PCI Express bus, which can improve transfer performance by up to 40%.</p>
<p>Reading from write-combining memory from the host is prohibitively slow, so write-combining memory should in general be used for memory that the host only writes to.</p>
<p>Using CPU atomic instructions on WC memory should be avoided because not all CPU implementations guarantee that functionality.</p>
</section>
<section id="mapped-memory">
<span id="id28"></span><h4><span class="section-number">3.2.6.3. </span>Mapped Memory<a class="headerlink" href="#mapped-memory" title="Permalink to this headline">ï</a></h4>
<p>A block of page-locked host memory can also be mapped into the address space of the device by passing flag <code class="docutils literal notranslate"><span class="pre">cudaHostAllocMapped</span></code> to <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> or by passing flag <code class="docutils literal notranslate"><span class="pre">cudaHostRegisterMapped</span></code> to <code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code>. Such a block has therefore in general two addresses: one in host memory that is returned by <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, and one in device memory that can be retrieved using <code class="docutils literal notranslate"><span class="pre">cudaHostGetDevicePointer()</span></code> and then used to access the block from within a kernel. The only exception is for pointers allocated with <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> and when a unified address space is used for the host and the device as mentioned in <a class="reference internal" href="#unified-virtual-address-space"><span class="std std-ref">Unified Virtual Address Space</span></a>.</p>
<p>Accessing host memory directly from within a kernel does not provide the same bandwidth as device memory, but does have some advantages:</p>
<ul class="simple">
<li><p>There is no need to allocate a block in device memory and copy data between this block and the block in host memory; data transfers are implicitly performed as needed by the kernel;</p></li>
<li><p>There is no need to use streams (see <a class="reference internal" href="#concurrent-data-transfers"><span class="std std-ref">Concurrent Data Transfers</span></a>) to overlap data transfers with kernel execution; the kernel-originated data transfers automatically overlap with kernel execution.</p></li>
</ul>
<p>Since mapped page-locked memory is shared between host and device however, the application must synchronize memory accesses using streams or events (see <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>) to avoid any potential read-after-write, write-after-read, or write-after-write hazards.</p>
<p>To be able to retrieve the device pointer to any mapped page-locked memory, page-locked memory mapping must be enabled by calling <code class="docutils literal notranslate"><span class="pre">cudaSetDeviceFlags()</span></code> with the <code class="docutils literal notranslate"><span class="pre">cudaDeviceMapHost</span></code> flag before any other CUDA call is performed. Otherwise, <code class="docutils literal notranslate"><span class="pre">cudaHostGetDevicePointer()</span></code> will return an error.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaHostGetDevicePointer()</span></code> also returns an error if the device does not support mapped page-locked host memory. Applications may query this capability by checking the <code class="docutils literal notranslate"><span class="pre">canMapHostMemory</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>), which is equal to 1 for devices that support mapped page-locked host memory.</p>
<p>Note that atomic functions (see <a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>) operating on mapped page-locked memory are not atomic from the point of view of the host or other devices.</p>
<p>Also note that CUDA runtime requires that 1-byte, 2-byte, 4-byte, 8-byte, and 16-byte naturally aligned
loads and stores to host memory initiated from the device are preserved as single accesses
from the point of view of the host and other devices.
On some platforms, atomics to memory may be broken by the hardware into separate
load and store operations.
These component load and store operations have the same requirements on preservation of naturally aligned accesses.
The CUDA runtime does not support a PCI Express bus topology where a PCI Express bridge splits
8-byte naturally aligned operations and NVIDIA is not aware of any topology that splits
16-byte naturally aligned operations.</p>
</section>
</section>
<section id="memory-synchronization-domains">
<span id="id29"></span><h3><span class="section-number">3.2.7. </span>Memory Synchronization Domains<a class="headerlink" href="#memory-synchronization-domains" title="Permalink to this headline">ï</a></h3>
<section id="memory-fence-interference">
<span id="id30"></span><h4><span class="section-number">3.2.7.1. </span>Memory Fence Interference<a class="headerlink" href="#memory-fence-interference" title="Permalink to this headline">ï</a></h4>
<p>Some CUDA applications may see degraded performance due to memory fence/flush operations waiting on more transactions than those necessitated by the CUDA memory consistency model.</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 59%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">__device__</span><span class="w">  </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_device</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">__managed__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_system</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Thread 1 (SM)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><p>Thread 2 (SM)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><p>Thread 3 (CPU)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Consider the example above. The CUDA memory consistency model guarantees that the asserted condition will be true, so the write to <code class="docutils literal notranslate"><span class="pre">x</span></code> from thread 1 must be visible to thread 3, before the write to <code class="docutils literal notranslate"><span class="pre">b</span></code> from thread 2.</p>
<p>The memory ordering provided by the release and acquire of <code class="docutils literal notranslate"><span class="pre">a</span></code> is only sufficient to make <code class="docutils literal notranslate"><span class="pre">x</span></code> visible to thread 2, not thread 3, as it is a device-scope operation. The system-scope ordering provided by release and acquire of <code class="docutils literal notranslate"><span class="pre">b</span></code>, therefore, needs to ensure not only writes issued from thread 2 itself are visible to thread 3, but also writes from other threads that are visible to thread 2. This is known as cumulativity. As the GPU cannot know at the time of execution which writes have been guaranteed at the source level to be visible and which are visible only by chance timing, it must cast a conservatively wide net for in-flight memory operations.</p>
<p>This sometimes leads to interference: because the GPU is waiting on memory operations it is not required to at the source level, the fence/flush may take longer than necessary.</p>
<p>Note that fences may occur explicitly as intrinsics or atomics in code, like in the example, or implicitly to implement <em>synchronizes-with</em> relationships at task boundaries.</p>
<p>A common example is when a kernel is performing computation in local GPU memory, and a parallel kernel (e.g. from NCCL) is performing communications with a peer. Upon completion, the local kernel will implicitly flush its writes to satisfy any <em>synchronizes-with</em> relationships to downstream work. This may unnecessarily wait, fully or partially, on slower nvlink or PCIe writes from the communication kernel.</p>
</section>
<section id="isolating-traffic-with-domains">
<span id="id31"></span><h4><span class="section-number">3.2.7.2. </span>Isolating Traffic with Domains<a class="headerlink" href="#isolating-traffic-with-domains" title="Permalink to this headline">ï</a></h4>
<p>Beginning with Hopper architecture GPUs and CUDA 12.0, the memory synchronization domains feature provides a way to alleviate such interference. In exchange for explicit assistance from code, the GPU can reduce the net cast by a fence operation. Each kernel launch is given a domain ID. Writes and fences are tagged with the ID, and a fence will only order writes matching the fenceâs domain. In the concurrent compute vs communication example, the communication kernels can be placed in a different domain.</p>
<p>When using domains, code must abide by the rule that <strong>ordering or synchronization between distinct domains on the same GPU requires system-scope fencing</strong>. Within a domain, device-scope fencing remains sufficient. This is necessary for cumulativity as one kernelâs writes will not be encompassed by a fence issued from a kernel in another domain. In essence, cumulativity is satisfied by ensuring that cross-domain traffic is flushed to the system scope ahead of time.</p>
<p>Note that this modifies the definition of <code class="docutils literal notranslate"><span class="pre">thread_scope_device</span></code>. However, because kernels will default to domain 0 as described below, backward compatibility is maintained.</p>
</section>
<section id="using-domains-in-cuda">
<span id="id32"></span><h4><span class="section-number">3.2.7.3. </span>Using Domains in CUDA<a class="headerlink" href="#using-domains-in-cuda" title="Permalink to this headline">ï</a></h4>
<p>Domains are accessible via the new launch attributes <code class="docutils literal notranslate"><span class="pre">cudaLaunchAttributeMemSyncDomain</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaLaunchAttributeMemSyncDomainMap</span></code>. The former selects between logical domains <code class="docutils literal notranslate"><span class="pre">cudaLaunchMemSyncDomainDefault</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaLaunchMemSyncDomainRemote</span></code>, and the latter provides a mapping from logical to physical domains. The remote domain is intended for kernels performing remote memory access in order to isolate their memory traffic from local kernels. Note, however, the selection of a particular domain does not affect what memory access a kernel may legally perform.</p>
<p>The domain count can be queried via device attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrMemSyncDomainCount</span></code>. Hopper has 4 domains. To facilitate portable code, domains functionality can be used on all devices and CUDA will report a count of 1 prior to Hopper.</p>
<p>Having logical domains eases application composition. An individual kernel launch at a low level in the stack, such as from NCCL, can select a semantic logical domain without concern for the surrounding application architecture. Higher levels can steer logical domains using the mapping. The default value for the logical domain if it is not set is the default domain, and the default mapping is to map the default domain to 0 and the remote domain to 1 (on GPUs with more than 1 domain). Specific libraries may tag launches with the remote domain in CUDA 12.0 and later; for example, NCCL 2.16 will do so. Together, this provides a beneficial use pattern for common applications out of the box, with no code changes needed in other components, frameworks, or at application level. An alternative use pattern, for example in an application using nvshmem or with no clear separation of kernel types, could be to partition parallel streams. Stream A may map both logical domains to physical domain 0, stream B to 1, and so on.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of launching a kernel with the remote logical domain</span>
<span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">domainAttr</span><span class="p">;</span><span class="w"></span>
<span class="n">domainAttr</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttrMemSyncDomain</span><span class="p">;</span><span class="w"></span>
<span class="n">domainAttr</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchMemSyncDomainRemote</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaLaunchConfig_t</span><span class="w"> </span><span class="n">config</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Fill out other config fields</span>
<span class="n">config</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">domainAttr</span><span class="p">;</span><span class="w"></span>
<span class="n">config</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaLaunchKernelEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">myKernel</span><span class="p">,</span><span class="w"> </span><span class="n">kernelArg1</span><span class="p">,</span><span class="w"> </span><span class="n">kernelArg2</span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of setting a mapping for a stream</span>
<span class="c1">// (This mapping is the default for streams starting on Hopper if not</span>
<span class="c1">// explicitly set, and provided for illustration)</span>
<span class="n">cudaLaunchAttributeValue</span><span class="w"> </span><span class="n">mapAttr</span><span class="p">;</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">default_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">remote</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLaunchAttributeMemSyncDomainMap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mapAttr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example of mapping different streams to different physical domains, ignoring</span>
<span class="c1">// logical domain settings</span>
<span class="n">cudaLaunchAttributeValue</span><span class="w"> </span><span class="n">mapAttr</span><span class="p">;</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">default_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">remote</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">streamA</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLaunchAttributeMemSyncDomainMap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mapAttr</span><span class="p">);</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">default_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">mapAttr</span><span class="p">.</span><span class="n">memSyncDomainMap</span><span class="p">.</span><span class="n">remote</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamSetAttribute</span><span class="p">(</span><span class="n">streamB</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLaunchAttributeMemSyncDomainMap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mapAttr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As with other launch attributes, these are exposed uniformly on CUDA streams, individual launches using <code class="docutils literal notranslate"><span class="pre">cudaLaunchKernelEx</span></code>, and kernel nodes in CUDA graphs. A typical use would set the mapping at stream level and the logical domain at launch level (or bracketing a section of stream use) as described above.</p>
<p>Both attributes are copied to graph nodes during stream capture. Graphs take both attributes from the node itself, essentially an indirect way of specifying a physical domain. Domain-related attributes set on the stream a graph is launched into are not used in execution of the graph.</p>
</section>
</section>
<section id="asynchronous-concurrent-execution">
<span id="id33"></span><h3><span class="section-number">3.2.8. </span>Asynchronous Concurrent Execution<a class="headerlink" href="#asynchronous-concurrent-execution" title="Permalink to this headline">ï</a></h3>
<p>CUDA exposes the following operations as independent tasks that can operate concurrently with one another:</p>
<ul class="simple">
<li><p>Computation on the host;</p></li>
<li><p>Computation on the device;</p></li>
<li><p>Memory transfers from the host to the device;</p></li>
<li><p>Memory transfers from the device to the host;</p></li>
<li><p>Memory transfers within the memory of a given device;</p></li>
<li><p>Memory transfers among devices.</p></li>
</ul>
<p>The level of concurrency achieved between these operations will depend on the feature set and compute capability of the device as described below.</p>
<section id="concurrent-execution-between-host-and-device">
<span id="concurrent-execution-host-device"></span><h4><span class="section-number">3.2.8.1. </span>Concurrent Execution between Host and Device<a class="headerlink" href="#concurrent-execution-between-host-and-device" title="Permalink to this headline">ï</a></h4>
<p>Concurrent host execution is facilitated through asynchronous library functions that return control to the host thread before the device completes the requested task. Using asynchronous calls, many device operations can be queued up together to be executed by the CUDA driver when appropriate device resources are available. This relieves the host thread of much of the responsibility to manage the device, leaving it free for other tasks. The following device operations are asynchronous with respect to the host:</p>
<ul class="simple">
<li><p>Kernel launches;</p></li>
<li><p>Memory copies within a single deviceâs memory;</p></li>
<li><p>Memory copies from host to device of a memory block of 64 KB or less;</p></li>
<li><p>Memory copies performed by functions that are suffixed with <code class="docutils literal notranslate"><span class="pre">Async</span></code>;</p></li>
<li><p>Memory set function calls.</p></li>
</ul>
<p>Programmers can globally disable asynchronicity of kernel launches for all CUDA applications running on a system by setting the <code class="docutils literal notranslate"><span class="pre">CUDA_LAUNCH_BLOCKING</span></code> environment variable to 1. This feature is provided for debugging purposes only and should not be used as a way to make production software run reliably.</p>
<p>Kernel launches are synchronous if hardware counters are collected via a profiler (Nsight, Visual Profiler) unless concurrent kernel profiling is enabled. <code class="docutils literal notranslate"><span class="pre">Async</span></code> memory copies might also be synchronous if they involve host memory that is not page-locked.</p>
</section>
<section id="concurrent-kernel-execution">
<span id="id34"></span><h4><span class="section-number">3.2.8.2. </span>Concurrent Kernel Execution<a class="headerlink" href="#concurrent-kernel-execution" title="Permalink to this headline">ï</a></h4>
<p>Some devices of compute capability 2.x and higher can execute multiple kernels concurrently. Applications may query this capability by checking the <code class="docutils literal notranslate"><span class="pre">concurrentKernels</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>), which is equal to 1 for devices that support it.</p>
<p>The maximum number of kernel launches that a device can execute concurrently depends on its compute capability and is listed in <a class="reference internal" href="#features-and-technical-specifications-technical-specifications-per-compute-capability"><span class="std std-ref">Table 21</span></a>.</p>
<p>A kernel from one CUDA context cannot execute concurrently with a kernel from another CUDA context. The GPU may time slice to provide forward progress to each context. If a user wants to run kernels from multiple process simultaneously on the SM, one must enable MPS.</p>
<p>Kernels that use many textures or a large amount of local memory are less likely to execute concurrently with other kernels.</p>
</section>
<section id="overlap-of-data-transfer-and-kernel-execution">
<span id="id35"></span><h4><span class="section-number">3.2.8.3. </span>Overlap of Data Transfer and Kernel Execution<a class="headerlink" href="#overlap-of-data-transfer-and-kernel-execution" title="Permalink to this headline">ï</a></h4>
<p>Some devices can perform an asynchronous memory copy to or from the GPU concurrently with kernel execution. Applications may query this capability by checking the <code class="docutils literal notranslate"><span class="pre">asyncEngineCount</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>), which is greater than zero for devices that support it. If host memory is involved in the copy, it must be page-locked.</p>
<p>It is also possible to perform an intra-device copy simultaneously with kernel execution (on devices that support the <code class="docutils literal notranslate"><span class="pre">concurrentKernels</span></code> device property) and/or with copies to or from the device (for devices that support the <code class="docutils literal notranslate"><span class="pre">asyncEngineCount</span></code> property). Intra-device copies are initiated using the standard memory copy functions with destination and source addresses residing on the same device.</p>
</section>
<section id="concurrent-data-transfers">
<span id="id36"></span><h4><span class="section-number">3.2.8.4. </span>Concurrent Data Transfers<a class="headerlink" href="#concurrent-data-transfers" title="Permalink to this headline">ï</a></h4>
<p>Some devices of compute capability 2.x and higher can overlap copies to and from the device. Applications may query this capability by checking the <code class="docutils literal notranslate"><span class="pre">asyncEngineCount</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>), which is equal to 2 for devices that support it. In order to be overlapped, any host memory involved in the transfers must be page-locked.</p>
</section>
<section id="streams">
<span id="id37"></span><h4><span class="section-number">3.2.8.5. </span>Streams<a class="headerlink" href="#streams" title="Permalink to this headline">ï</a></h4>
<p>Applications manage the concurrent operations described above through <em>streams</em>. A stream is a sequence of commands (possibly issued by different host threads) that execute in order. Different streams, on the other hand, may execute their commands out of order with respect to one another or concurrently; this behavior is not guaranteed and should therefore not be relied upon for correctness (for example, inter-kernel communication is undefined). The commands issued on a stream may execute when all the dependencies of the command are met. The dependencies could be previously launched commands on same stream or dependencies from other streams. The successful completion of synchronize call guarantees that all the commands launched are completed.</p>
<section id="creation-and-destruction-of-streams">
<span id="creation-and-destruction-streams"></span><h5><span class="section-number">3.2.8.5.1. </span>Creation and Destruction of Streams<a class="headerlink" href="#creation-and-destruction-of-streams" title="Permalink to this headline">ï</a></h5>
<p>A stream is defined by creating a stream object and specifying it as the stream parameter to a sequence of kernel launches and host <code class="docutils literal notranslate"><span class="pre">&lt;-&gt;</span></code> device memory copies. The following code sample creates two streams and allocates an array <code class="docutils literal notranslate"><span class="pre">hostPtr</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> in page-locked memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">hostPtr</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMallocHost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hostPtr</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Each of these streams is defined by the following code sample as a sequence of one memory copy from host to device, one kernel launch, and one memory copy from device to host:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">inputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">hostPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MyKernel</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">outputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">inputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">hostPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">outputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Each stream copies its portion of input array <code class="docutils literal notranslate"><span class="pre">hostPtr</span></code> to array <code class="docutils literal notranslate"><span class="pre">inputDevPtr</span></code> in device memory, processes <code class="docutils literal notranslate"><span class="pre">inputDevPtr</span></code> on the device by calling <code class="docutils literal notranslate"><span class="pre">MyKernel()</span></code>, and copies the result <code class="docutils literal notranslate"><span class="pre">outputDevPtr</span></code> back to the same portion of <code class="docutils literal notranslate"><span class="pre">hostPtr</span></code>. <a class="reference internal" href="#overlapping-behavior"><span class="std std-ref">Overlapping Behavior</span></a> describes how the streams overlap in this example depending on the capability of the device. Note that <code class="docutils literal notranslate"><span class="pre">hostPtr</span></code> must point to page-locked host memory for any overlap to occur.</p>
<p>Streams are released by calling <code class="docutils literal notranslate"><span class="pre">cudaStreamDestroy()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamDestroy</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<p>In case the device is still doing work in the stream when <code class="docutils literal notranslate"><span class="pre">cudaStreamDestroy()</span></code> is called, the function will return immediately and the resources associated with the stream will be released automatically once the device has completed all work in the stream.</p>
</section>
<section id="default-stream">
<span id="id38"></span><h5><span class="section-number">3.2.8.5.2. </span>Default Stream<a class="headerlink" href="#default-stream" title="Permalink to this headline">ï</a></h5>
<p>Kernel launches and host <code class="docutils literal notranslate"><span class="pre">&lt;-&gt;</span></code> device memory copies that do not specify any stream parameter, or equivalently that set the stream parameter to zero, are issued to the default stream. They are therefore executed in order.</p>
<p>For code that is compiled using the <code class="docutils literal notranslate"><span class="pre">--default-stream</span> <span class="pre">per-thread</span></code> compilation flag (or that defines the <code class="docutils literal notranslate"><span class="pre">CUDA_API_PER_THREAD_DEFAULT_STREAM</span></code> macro before including CUDA headers (<code class="docutils literal notranslate"><span class="pre">cuda.h</span></code> and <code class="docutils literal notranslate"><span class="pre">cuda_runtime.h</span></code>)), the default stream is a regular stream and each host thread has its own default stream.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">#define</span> <span class="pre">CUDA_API_PER_THREAD_DEFAULT_STREAM</span> <span class="pre">1</span></code> cannot be used to enable this behavior when the code is compiled by <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> as <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> implicitly includes <code class="docutils literal notranslate"><span class="pre">cuda_runtime.h</span></code> at the top of the translation unit. In this case the <code class="docutils literal notranslate"><span class="pre">--default-stream</span> <span class="pre">per-thread</span></code> compilation flag needs to be used or the <code class="docutils literal notranslate"><span class="pre">CUDA_API_PER_THREAD_DEFAULT_STREAM</span></code> macro needs to be defined with the <code class="docutils literal notranslate"><span class="pre">-DCUDA_API_PER_THREAD_DEFAULT_STREAM=1</span></code> compiler flag.</p>
</div>
<p>For code that is compiled using the <code class="docutils literal notranslate"><span class="pre">--default-stream</span> <span class="pre">legacy</span></code> compilation flag, the default stream is a special stream called the <em>NULL stream</em> and each device has a single NULL stream used for all host threads. The NULL stream is special as it causes implicit synchronization as described in <a class="reference internal" href="#implicit-synchronization"><span class="std std-ref">Implicit Synchronization</span></a>.</p>
<p>For code that is compiled without specifying a <code class="docutils literal notranslate"><span class="pre">--default-stream</span></code> compilation flag, <code class="docutils literal notranslate"><span class="pre">--default-stream</span> <span class="pre">legacy</span></code> is assumed as the default.</p>
</section>
<section id="explicit-synchronization">
<span id="id39"></span><h5><span class="section-number">3.2.8.5.3. </span>Explicit Synchronization<a class="headerlink" href="#explicit-synchronization" title="Permalink to this headline">ï</a></h5>
<p>There are various ways to explicitly synchronize streams with each other.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> waits until all preceding commands in all streams of all host threads have completed.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code>takes a stream as a parameter and waits until all preceding commands in the given stream have completed. It can be used to synchronize the host with a specific stream, allowing other streams to continue executing on the device.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code>takes a stream and an event as parameters (see <a class="reference internal" href="#events"><span class="std std-ref">Events</span></a> for a description of events)and makes all the commands added to the given stream after the call to <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code>delay their execution until the given event has completed.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaStreamQuery()</span></code>provides applications with a way to know if all preceding commands in a stream have completed.</p>
</section>
<section id="implicit-synchronization">
<span id="id40"></span><h5><span class="section-number">3.2.8.5.4. </span>Implicit Synchronization<a class="headerlink" href="#implicit-synchronization" title="Permalink to this headline">ï</a></h5>
<p>Two operations from different streams cannot run concurrently if any CUDA operation on the NULL stream is submitted
in-between them, unless the streams are non-blocking streams (created with the <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag).</p>
<p>Applications should follow these guidelines to improve
their potential for concurrent kernel execution:</p>
<ul class="simple">
<li><p>All independent operations should be issued before dependent operations,</p></li>
<li><p>Synchronization of any kind should be delayed as long as possible.</p></li>
</ul>
</section>
<section id="overlapping-behavior">
<span id="id41"></span><h5><span class="section-number">3.2.8.5.5. </span>Overlapping Behavior<a class="headerlink" href="#overlapping-behavior" title="Permalink to this headline">ï</a></h5>
<p>The amount of execution overlap between two streams depends on the order in which the commands are issued to each stream
and whether or not the device supports overlap of data transfer and kernel execution (see <a class="reference internal" href="#overlap-of-data-transfer-and-kernel-execution"><span class="std std-ref">Overlap of Data Transfer and Kernel Execution</span></a>),
concurrent kernel execution (see <a class="reference internal" href="#concurrent-kernel-execution"><span class="std std-ref">Concurrent Kernel Execution</span></a>), and/or concurrent data transfers (see <a class="reference internal" href="#concurrent-data-transfers"><span class="std std-ref">Concurrent Data Transfers</span></a>).</p>
<p>For example, on devices that do not support concurrent data transfers, the two streams of the code sample of <a class="reference internal" href="#creation-and-destruction-streams"><span class="std std-ref">Creation and Destruction of Streams</span></a>
do not overlap at all because the memory copy from host to device is issued to stream[1] after the memory copy from device to host
is issued to stream[0], so it can only start once the memory copy from device to host issued to stream[0] has completed. If the
code is rewritten the following way (and assuming the device supports overlap of data transfer and kernel execution)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">inputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">hostPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">outputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">inputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">hostPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">outputDevPtr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<p>then the memory copy from host to device issued to stream[1] overlaps with the kernel launch issued to stream[0].</p>
<p>On devices that do support concurrent data transfers, the two streams of the code sample of <a class="reference internal" href="#creation-and-destruction-streams"><span class="std std-ref">Creation and Destruction of Streams</span></a>
do overlap: The memory copy from host to device issued to stream[1] overlaps with the memory copy from device to host issued to
stream[0] and even with the kernel launch issued to stream[0] (assuming the device supports overlap of data transfer and kernel execution).</p>
</section>
<section id="host-functions-callbacks">
<span id="stream-callbacks"></span><h5><span class="section-number">3.2.8.5.6. </span>Host Functions (Callbacks)<a class="headerlink" href="#host-functions-callbacks" title="Permalink to this headline">ï</a></h5>
<p>The runtime provides a way to insert a CPU function call at any point into a stream via <code class="docutils literal notranslate"><span class="pre">cudaLaunchHostFunc()</span></code>. The provided function is executed on the host once all commands issued to the stream before the callback have completed.</p>
<p>The following code sample adds the host function <code class="docutils literal notranslate"><span class="pre">MyCallback</span></code> to each of two streams after issuing a host-to-device memory copy, a kernel launch and a device-to-host memory copy into each stream. The function will begin execution on the host after each of the device-to-host memory copies completes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">CUDART_CB</span><span class="w"> </span><span class="nf">MyCallback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Inside callback %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">devPtrIn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">hostPtr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">devPtrOut</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">devPtrIn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">hostPtr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">devPtrOut</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaLaunchHostFunc</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">MyCallback</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The commands that are issued in a stream after a host function do not start executing before the function has completed.</p>
<p>A host function enqueued into a stream must not make CUDA API calls (directly or indirectly), as it might end up waiting on itself if it makes such a call leading to a deadlock.</p>
</section>
<section id="stream-priorities">
<span id="id42"></span><h5><span class="section-number">3.2.8.5.7. </span>Stream Priorities<a class="headerlink" href="#stream-priorities" title="Permalink to this headline">ï</a></h5>
<p>The relative priorities of streams can be specified at creation using <code class="docutils literal notranslate"><span class="pre">cudaStreamCreateWithPriority()</span></code>. The range of allowable priorities, ordered as [ greatest priority, least priority ] can be obtained using the <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetStreamPriorityRange()</span></code> function. At runtime, the GPU scheduler utilizes stream priorities to determine task execution order, but these priorities serve as hints rather than guarantees. When selecting work to launch, pending tasks in higher-priority streams take precedence over those in lower-priority streams. Higher-priority tasks do not preempt already running lower-priority tasks. The GPU does not reassess work queues during task execution, and increasing a streamâs priority will not interrupt ongoing work. Stream priorities influence task execution without enforcing strict ordering, so users can leverage stream priorities to influence task execution without relying on strict ordering guarantees.</p>
<p>The following code sample obtains the allowable range of priorities for the current device, and creates streams with the highest and lowest available priorities.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// get the range of stream priorities for this device</span>
<span class="kt">int</span><span class="w"> </span><span class="n">leastPriority</span><span class="p">,</span><span class="w"> </span><span class="n">greatestPriority</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDeviceGetStreamPriorityRange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leastPriority</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">greatestPriority</span><span class="p">);</span><span class="w"></span>
<span class="c1">// create streams with highest and lowest available priorities</span>
<span class="n">cudaStream_t</span><span class="w"> </span><span class="n">st_high</span><span class="p">,</span><span class="w"> </span><span class="n">st_low</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamCreateWithPriority</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st_high</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamNonBlocking</span><span class="p">,</span><span class="w"> </span><span class="n">greatestPriority</span><span class="p">));</span><span class="w"></span>
<span class="n">cudaStreamCreateWithPriority</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st_low</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamNonBlocking</span><span class="p">,</span><span class="w"> </span><span class="n">leastPriority</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="programmatic-dependent-launch-and-synchronization">
<span id="programmatic-dependent-launch"></span><span id="id43"></span><h4><span class="section-number">3.2.8.6. </span>Programmatic Dependent Launch and Synchronization<a class="headerlink" href="#programmatic-dependent-launch-and-synchronization" title="Permalink to this headline">ï</a></h4>
<p>The <em>Programmatic Dependent Launch</em> mechanism allows for a dependent <em>secondary</em> kernel
to launch before the <em>primary</em> kernel it depends on in the same CUDA stream has finished executing.
Available starting with devices of compute capability 9.0, this technique can provide performance
benefits when the <em>secondary</em> kernel can complete significant work that does not depend on the results of the <em>primary</em> kernel.</p>
<section id="background">
<h5><span class="section-number">3.2.8.6.1. </span>Background<a class="headerlink" href="#background" title="Permalink to this headline">ï</a></h5>
<p>A CUDA application utilizes the GPU by launching and executing multiple kernels on it.
A typical GPU activity timeline is shown in <a class="reference internal" href="#gpu-activity"><span class="std std-ref">Figure 10</span></a>.</p>
<figure class="align-default" id="gpu-activity">
<a class="reference internal image-reference" href="_images/gpu-activity.png"><img alt="GPU activity timeline" src="_images/gpu-activity.png" style="width: 723.36px; height: 121.44000000000001px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 10 </span><span class="caption-text">GPU activity timeline</span><a class="headerlink" href="#gpu-activity" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>Here, <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> is launched after <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code> finishes its execution.
Serialized execution is usually necessary because <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> depends on result data
produced by <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code>. If <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> has no dependency on <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code>,
both of them can be launched concurrently by using <a class="reference internal" href="#streams"><span class="std std-ref">Streams</span></a>.
Even if <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> is dependent on <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code>, there is some potential for
concurrent execution. For example, almost all the kernels have
some sort of <em>preamble</em> section during which tasks such as zeroing buffers or loading
constant values are performed.</p>
<figure class="align-default" id="secondary-kernel-preamble">
<a class="reference internal image-reference" href="_images/secondary-kernel-preamble.png"><img alt="Preamble section of ``secondary_kernel``" src="_images/secondary-kernel-preamble.png" style="width: 723.36px; height: 156.42000000000002px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 11 </span><span class="caption-text">Preamble section of <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code></span><a class="headerlink" href="#secondary-kernel-preamble" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#secondary-kernel-preamble"><span class="std std-ref">Figure 11</span></a> demonstrates the portion of <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> that could
be executed concurrently without impacting the application.
Note that concurrent launch also allows us to hide the launch latency of <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> behind
the execution of <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code>.</p>
<figure class="align-default" id="preamble-overlap">
<a class="reference internal image-reference" href="_images/preamble-overlap.png"><img alt="Concurrent execution of ``primary_kernel`` and ``secondary_kernel``" src="_images/preamble-overlap.png" style="width: 723.36px; height: 192.06px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 12 </span><span class="caption-text">Concurrent execution of <code class="docutils literal notranslate"><span class="pre">primary_kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code></span><a class="headerlink" href="#preamble-overlap" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The concurrent launch and execution of <code class="docutils literal notranslate"><span class="pre">secondary_kernel</span></code> shown in <a class="reference internal" href="#preamble-overlap"><span class="std std-ref">Figure 12</span></a> is
achievable using <em>Programmatic Dependent Launch</em>.</p>
<p><em>Programmatic Dependent Launch</em> introduces changes to the CUDA kernel launch APIs as explained in following section.
These APIs require at least compute capability 9.0 to provide overlapping execution.</p>
</section>
<section id="api-description">
<h5><span class="section-number">3.2.8.6.2. </span>API Description<a class="headerlink" href="#api-description" title="Permalink to this headline">ï</a></h5>
<p>In Programmatic Dependent Launch, a primary and a secondary kernel are launched in the same CUDA stream.
The primary kernel should execute <code class="docutils literal notranslate"><span class="pre">cudaTriggerProgrammaticLaunchCompletion</span></code> with all thread blocks when
itâs ready for the secondary kernel to launch. The secondary kernel must be launched using the extensible launch API as shown.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">primary_kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Initial work that should finish before starting secondary kernel</span>

<span class="w">   </span><span class="c1">// Trigger the secondary kernel</span>
<span class="w">   </span><span class="n">cudaTriggerProgrammaticLaunchCompletion</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Work that can coincide with the secondary kernel</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">secondary_kernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Independent work</span>

<span class="w">   </span><span class="c1">// Will block until all primary kernels the secondary kernel is dependent on have completed and flushed results to global memory</span>
<span class="w">   </span><span class="n">cudaGridDependencySynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Dependent work</span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeProgrammaticStreamSerialization</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">programmaticStreamSerializationAllowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">configSecondary</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="n">configSecondary</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="n">primary_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">grid_dim</span><span class="p">,</span><span class="w"> </span><span class="n">block_dim</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="n">cudaLaunchKernelEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">configSecondary</span><span class="p">,</span><span class="w"> </span><span class="n">secondary_kernel</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When the secondary kernel is launched using the <code class="docutils literal notranslate"><span class="pre">cudaLaunchAttributeProgrammaticStreamSerialization</span></code> attribute,
the CUDA driver is safe to launch the secondary kernel early and not wait on the
completion and memory flush of the primary before launching the secondary.</p>
<p>The CUDA driver can launch the secondary kernel when all primary thread blocks have launched and executed
<code class="docutils literal notranslate"><span class="pre">cudaTriggerProgrammaticLaunchCompletion</span></code>.
If the primary kernel doesnât execute the trigger, it implicitly occurs after
all thread blocks in the primary kernel exit.</p>
<p>In either case, the secondary thread blocks might launch
before data written by the primary kernel is visible. As such, when the secondary kernel is configured with <em>Programmatic Dependent Launch</em>,
it must always use <code class="docutils literal notranslate"><span class="pre">cudaGridDependencySynchronize</span></code>
or other means to verify that the result data from the primary is available.</p>
<p>Please note that these methods provide the opportunity for the primary and secondary kernels to execute concurrently, however
this behavior is opportunistic and not guaranteed to lead to concurrent kernel execution.
Reliance on concurrent execution in this manner is unsafe and can lead to deadlock.</p>
</section>
<section id="use-in-cuda-graphs">
<h5><span class="section-number">3.2.8.6.3. </span>Use in CUDA Graphs<a class="headerlink" href="#use-in-cuda-graphs" title="Permalink to this headline">ï</a></h5>
<p>Programmatic Dependent Launch can be used in <a class="reference internal" href="#cuda-graphs"><span class="std std-ref">CUDA Graphs</span></a> via <a class="reference internal" href="#creating-a-graph-using-stream-capture"><span class="std std-ref">stream capture</span></a> or
directly via <a class="reference internal" href="#edge-data"><span class="std std-ref">edge data</span></a>. To program this feature in a CUDA Graph with edge data, use a <code class="docutils literal notranslate"><span class="pre">cudaGraphDependencyType</span></code>
value of <code class="docutils literal notranslate"><span class="pre">cudaGraphDependencyTypeProgrammatic</span></code> on an edge connecting two kernel nodes. This edge type makes the upstream kernel
visible to a <code class="docutils literal notranslate"><span class="pre">cudaGridDependencySynchronize()</span></code> in the downstream kernel. This type must be used with an outgoing port of
either <code class="docutils literal notranslate"><span class="pre">cudaGraphKernelNodePortLaunchCompletion</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGraphKernelNodePortProgrammatic</span></code>.</p>
<p>The resulting graph equivalents for stream capture are as follows:</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 52%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Stream code (abbreviated)</p></th>
<th class="head"><p>Resulting graph edge</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeProgrammaticStreamSerialization</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">programmaticStreamSerializationAllowed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraphEdgeData</span><span class="w"> </span><span class="n">edgeData</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphDependencyTypeProgrammatic</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">from_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphKernelNodePortProgrammatic</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeProgrammaticEvent</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">programmaticEvent</span><span class="p">.</span><span class="n">triggerAtBlockStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraphEdgeData</span><span class="w"> </span><span class="n">edgeData</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphDependencyTypeProgrammatic</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">from_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphKernelNodePortProgrammatic</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeProgrammaticEvent</span><span class="p">;</span><span class="w"></span>
<span class="n">attribute</span><span class="p">.</span><span class="n">val</span><span class="p">.</span><span class="n">programmaticEvent</span><span class="p">.</span><span class="n">triggerAtBlockStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraphEdgeData</span><span class="w"> </span><span class="n">edgeData</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphDependencyTypeProgrammatic</span><span class="p">;</span><span class="w"></span>
<span class="n">edgeData</span><span class="p">.</span><span class="n">from_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphKernelNodePortLaunchCompletion</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="cuda-graphs">
<span id="id44"></span><h4><span class="section-number">3.2.8.7. </span>CUDA Graphs<a class="headerlink" href="#cuda-graphs" title="Permalink to this headline">ï</a></h4>
<p>CUDA Graphs present a new model for work submission in CUDA. A graph is a series of operations, such as kernel launches, connected by dependencies, which is defined separately from its execution. This allows a graph to be defined once and then launched repeatedly. Separating out the definition of a graph from its execution enables a number of optimizations: first, CPU launch costs are reduced compared to streams, because much of the setup is done in advance; second, presenting the whole workflow to CUDA enables optimizations which might not be possible with the piecewise work submission mechanism of streams.</p>
<p>To see the optimizations possible with graphs, consider what happens in a stream: when you place a kernel into a stream, the host driver performs a sequence of operations in preparation for the execution of the kernel on the GPU. These operations, necessary for setting up and launching the kernel, are an overhead cost which must be paid for each kernel that is issued. For a GPU kernel with a short execution time, this overhead cost can be a significant fraction of the overall end-to-end execution time.</p>
<p>Work submission using graphs is separated into three distinct stages: definition, instantiation, and execution.</p>
<ul class="simple">
<li><p>During the definition phase, a program creates a description of the operations in the graph along with the dependencies between them.</p></li>
<li><p>Instantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The resulting instance is known as an <em>executable graph.</em></p></li>
<li><p>An executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation.</p></li>
</ul>
<section id="graph-structure">
<span id="id45"></span><h5><span class="section-number">3.2.8.7.1. </span>Graph Structure<a class="headerlink" href="#graph-structure" title="Permalink to this headline">ï</a></h5>
<p>An operation forms a node in a graph. The dependencies between the operations are the edges. These dependencies constrain the execution sequence of the operations.</p>
<p>An operation may be scheduled at any time once the nodes on which it depends are complete. Scheduling is left up to the CUDA system.</p>
<section id="node-types">
<span id="id46"></span><h6><span class="section-number">3.2.8.7.1.1. </span>Node Types<a class="headerlink" href="#node-types" title="Permalink to this headline">ï</a></h6>
<p>A graph node can be one of:</p>
<ul class="simple">
<li><p>kernel</p></li>
<li><p>CPU function call</p></li>
<li><p>memory copy</p></li>
<li><p>memset</p></li>
<li><p>empty node</p></li>
<li><p>waiting on an <a class="reference internal" href="#events"><span class="std std-ref">event</span></a></p></li>
<li><p>recording an <a class="reference internal" href="#events"><span class="std std-ref">event</span></a></p></li>
<li><p>signalling an <a class="reference internal" href="#external-resource-interoperability"><span class="std std-ref">external semaphore</span></a></p></li>
<li><p>waiting on an <a class="reference internal" href="#external-resource-interoperability"><span class="std std-ref">external semaphore</span></a></p></li>
<li><p><a class="reference internal" href="#conditional-graph-nodes"><span class="std std-ref">conditional node</span></a></p></li>
<li><p>child graph: To execute a separate nested graph, as shown in the following figure.</p></li>
</ul>
<figure class="align-center" id="node-types-fig-child-graph">
<a class="reference internal image-reference" href="_images/child-graph.png"><img alt="Child Graph Example" src="_images/child-graph.png" style="width: 200px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 13 </span><span class="caption-text">Child Graph Example</span><a class="headerlink" href="#node-types-fig-child-graph" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="edge-data">
<span id="id47"></span><h6><span class="section-number">3.2.8.7.1.2. </span>Edge Data<a class="headerlink" href="#edge-data" title="Permalink to this headline">ï</a></h6>
<p>CUDA 12.3 introduced edge data on CUDA Graphs. Edge data modifies a dependency specified by an edge and consists of three parts:
an outgoing port, an incoming port, and a type. An outgoing port specifies when an associated edge is triggered. An incoming port
specifies what portion of a node is dependent on an associated edge. A type modifies the relation between the endpoints.</p>
<p>Port values are specific to node type and direction, and edge types may be restricted to specific node types. In all cases,
zero-initialized edge data represents default behavior. Outgoing port 0 waits on an entire task, incoming port 0 blocks an
entire task, and edge type 0 is associated with a full dependency with memory synchronizing behavior.</p>
<p>Edge data is optionally specified in various graph APIs via a parallel array to the associated nodes. If it is omitted as an
input parameter, zero-initialized data is used. If it is omitted as an output (query) parameter, the API accepts this if the
edge data being ignored is all zero-initialized, and returns <code class="docutils literal notranslate"><span class="pre">cudaErrorLossyQuery</span></code> if the call would discard information.</p>
<p>Edge data is also available in some stream capture APIs: <code class="docutils literal notranslate"><span class="pre">cudaStreamBeginCaptureToGraph()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaStreamGetCaptureInfo()</span></code>,
and <code class="docutils literal notranslate"><span class="pre">cudaStreamUpdateCaptureDependencies()</span></code>. In these cases, there is not yet a downstream node. The data is associated with
a dangling edge (half edge) which will either be connected to a future captured node or discarded at termination of stream capture.
Note that some edge types do not wait on full completion of the upstream node. These edges are ignored when considering if a
stream capture has been fully rejoined to the origin stream, and cannot be discarded at the end of capture. See <a class="reference internal" href="#creating-a-graph-using-stream-capture"><span class="std std-ref">Creating a Graph Using Stream Capture</span></a>.</p>
<p>Currently, no node types define additional incoming ports, and only kernel nodes define additional outgoing ports. There is
one non-default dependency type, <code class="docutils literal notranslate"><span class="pre">cudaGraphDependencyTypeProgrammatic</span></code>, which enables <a class="reference internal" href="#programmatic-dependent-launch-and-synchronization"><span class="std std-ref">Programmatic Dependent Launch</span></a> between two kernel nodes.</p>
</section>
</section>
<section id="creating-a-graph-using-graph-apis">
<span id="id48"></span><h5><span class="section-number">3.2.8.7.2. </span>Creating a Graph Using Graph APIs<a class="headerlink" href="#creating-a-graph-using-graph-apis" title="Permalink to this headline">ï</a></h5>
<p>Graphs can be created via two mechanisms: explicit API and stream capture. The following is an example of creating and executing the below graph.</p>
<figure class="align-center" id="creating-a-graph-using-api-fig-creating-using-graph-apis">
<a class="reference internal image-reference" href="_images/create-a-graph.png"><img alt="Creating a Graph Using Graph APIs Example" src="_images/create-a-graph.png" style="width: 200px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 14 </span><span class="caption-text">Creating a Graph Using Graph APIs Example</span><a class="headerlink" href="#creating-a-graph-using-api-fig-creating-using-graph-apis" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create the graph - it starts out empty</span>
<span class="n">cudaGraphCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// For the purpose of this example, we&#39;ll create</span>
<span class="c1">// the nodes separately from the dependencies to</span>
<span class="c1">// demonstrate that it can be done in two stages.</span>
<span class="c1">// Note that dependencies can also be specified</span>
<span class="c1">// at node creation.</span>
<span class="n">cudaGraphAddKernelNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nodeParams</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphAddKernelNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nodeParams</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphAddKernelNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nodeParams</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphAddKernelNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nodeParams</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Now set up dependencies on each node</span>
<span class="n">cudaGraphAddDependencies</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// A-&gt;B</span>
<span class="n">cudaGraphAddDependencies</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// A-&gt;C</span>
<span class="n">cudaGraphAddDependencies</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// B-&gt;D</span>
<span class="n">cudaGraphAddDependencies</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// C-&gt;D</span>
</pre></div>
</div>
</section>
<section id="creating-a-graph-using-stream-capture">
<span id="id49"></span><h5><span class="section-number">3.2.8.7.3. </span>Creating a Graph Using Stream Capture<a class="headerlink" href="#creating-a-graph-using-stream-capture" title="Permalink to this headline">ï</a></h5>
<p>Stream capture provides a mechanism to create a graph from existing stream-based APIs. A section of code which launches work into streams, including existing code, can be bracketed with calls to <code class="docutils literal notranslate"><span class="pre">cudaStreamBeginCapture()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code>. See below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"></span>

<span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="n">kernel_A</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
<span class="n">kernel_B</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
<span class="n">libraryCall</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel_C</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>

<span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>A call to <code class="docutils literal notranslate"><span class="pre">cudaStreamBeginCapture()</span></code> places a stream in capture mode. When a stream is being captured, work launched into the stream is not enqueued for execution. It is instead appended to an internal graph that is progressively being built up. This graph is then returned by calling <code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code>, which also ends capture mode for the stream. A graph which is actively being constructed by stream capture is referred to as a <em>capture graph.</em></p>
<p>Stream capture can be used on any CUDA stream except <code class="docutils literal notranslate"><span class="pre">cudaStreamLegacy</span></code> (the âNULL streamâ). Note that it <em>can</em> be used on <code class="docutils literal notranslate"><span class="pre">cudaStreamPerThread</span></code>. If a program is using the legacy stream, it may be possible to redefine stream 0 to be the per-thread stream with no functional change. See <a class="reference internal" href="#default-stream"><span class="std std-ref">Default Stream</span></a>.</p>
<p>Whether a stream is being captured can be queried with <code class="docutils literal notranslate"><span class="pre">cudaStreamIsCapturing()</span></code>.</p>
<p>Work can be captured to an existing graph using <code class="docutils literal notranslate"><span class="pre">cudaStreamBeginCaptureToGraph()</span></code>.  Instead of capturing to an internal graph, work is captured to a graph provided by the user.</p>
<section id="cross-stream-dependencies-and-events">
<span id="cross-stream-dependencies"></span><h6><span class="section-number">3.2.8.7.3.1. </span>Cross-stream Dependencies and Events<a class="headerlink" href="#cross-stream-dependencies-and-events" title="Permalink to this headline">ï</a></h6>
<p>Stream capture can handle cross-stream dependencies expressed with <code class="docutils literal notranslate"><span class="pre">cudaEventRecord()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code>, provided the event being waited upon was recorded into the same capture graph.</p>
<p>When an event is recorded in a stream that is in capture mode, it results in a <em>captured event.</em> A captured event represents a set of nodes in a capture graph.</p>
<p>When a captured event is waited on by a stream, it places the stream in capture mode if it is not already, and the next item in the stream will have additional dependencies on the nodes in the captured event. The two streams are then being captured to the same capture graph.</p>
<p>When cross-stream dependencies are present in stream capture, <code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code> must still be called in the same stream where <code class="docutils literal notranslate"><span class="pre">cudaStreamBeginCapture()</span></code> was called; this is the <em>origin stream</em>. Any other streams which are being captured to the same capture graph, due to event-based dependencies, must also be joined back to the origin stream. This is illustrated below. All streams being captured to the same capture graph are taken out of capture mode upon <code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code>. Failure to rejoin to the origin stream will result in failure of the overall capture operation.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// stream1 is the origin stream</span>
<span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>

<span class="n">kernel_A</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>

<span class="c1">// Fork into stream2</span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event1</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span><span class="n">event1</span><span class="p">);</span><span class="w"></span>

<span class="n">kernel_B</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
<span class="n">kernel_C</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>

<span class="c1">// Join stream2 back to origin stream (stream1)</span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event2</span><span class="p">,</span><span class="w"> </span><span class="n">stream2</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream1</span><span class="p">,</span><span class="w"> </span><span class="n">event2</span><span class="p">);</span><span class="w"></span>

<span class="n">kernel_D</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>

<span class="c1">// End capture in the origin stream</span>
<span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="c1">// stream1 and stream2 no longer in capture mode</span>
</pre></div>
</div>
<p>Graph returned by the above code is shown in <a class="reference internal" href="#creating-a-graph-using-api-fig-creating-using-graph-apis"><span class="std std-ref">Figure 14</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a stream is taken out of capture mode, the next non-captured item in the stream (if any) will still have a dependency on the most recent prior non-captured item, despite intermediate items having been removed.</p>
</div>
</section>
<section id="prohibited-and-unhandled-operations">
<span id="prohibited-unhandled-operations"></span><h6><span class="section-number">3.2.8.7.3.2. </span>Prohibited and Unhandled Operations<a class="headerlink" href="#prohibited-and-unhandled-operations" title="Permalink to this headline">ï</a></h6>
<p>It is invalid to synchronize or query the execution status of a stream which is being captured or a captured event, because they do not represent items scheduled for execution. It is also invalid to query the execution status of or synchronize a broader handle which encompasses an active stream capture, such as a device or context handle when any associated stream is in capture mode.</p>
<p>When any stream in the same context is being captured, and it was not created with <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code>, any attempted use of the legacy stream is invalid. This is because the legacy stream handle at all times encompasses these other streams; enqueueing to the legacy stream would create a dependency on the streams being captured, and querying it or synchronizing it would query or synchronize the streams being captured.</p>
<p>It is therefore also invalid to call synchronous APIs in this case. Synchronous APIs, such as <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code>, enqueue work to the legacy stream and synchronize it before returning.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As a general rule, when a dependency relation would connect something that is captured with something that was not captured and instead enqueued for execution, CUDA prefers to return an error rather than ignore the dependency. An exception is made for placing a stream into or out of capture mode; this severs a dependency relation between items added to the stream immediately before and after the mode transition.</p>
</div>
<p>It is invalid to merge two separate capture graphs by waiting on a captured event from a stream which is being captured and is associated with a different capture graph than the event. It is invalid to wait on a non-captured event from a stream which is being captured without specifying the cudaEventWaitExternal flag.</p>
<p>A small number of APIs that enqueue asynchronous operations into streams are not currently supported in graphs and will return an error if called with a stream which is being captured, such as <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code>.</p>
</section>
<section id="invalidation">
<h6><span class="section-number">3.2.8.7.3.3. </span>Invalidation<a class="headerlink" href="#invalidation" title="Permalink to this headline">ï</a></h6>
<p>When an invalid operation is attempted during stream capture, any associated capture graphs are <em>invalidated</em>. When a capture graph is invalidated, further use of any streams which are being captured or captured events associated with the graph is invalid and will return an error, until stream capture is ended with <code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code>. This call will take the associated streams out of capture mode, but will also return an error value and a NULL graph.</p>
</section>
</section>
<section id="cuda-user-objects">
<span id="id50"></span><h5><span class="section-number">3.2.8.7.4. </span>CUDA User Objects<a class="headerlink" href="#cuda-user-objects" title="Permalink to this headline">ï</a></h5>
<p>CUDA User Objects can be used to help manage the lifetime of resources used by asynchronous work in CUDA. In particular, this feature is useful for <a class="reference internal" href="#cuda-graphs"><span class="std std-ref">CUDA Graphs</span></a> and <a class="reference internal" href="#creating-a-graph-using-stream-capture"><span class="std std-ref">stream capture</span></a>.</p>
<p>Various resource management schemes are not compatible with CUDA graphs. Consider for example an event-based pool or a synchronous-create, asynchronous-destroy scheme.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Library API with pool allocation</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">libraryWork</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pool</span><span class="p">.</span><span class="n">claimTemporaryResource</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">resource</span><span class="p">.</span><span class="n">waitOnReadyEventInStream</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">launchWork</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">resource</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">resource</span><span class="p">.</span><span class="n">recordReadyEvent</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Library API with asynchronous resource deletion</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">libraryWork</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Resource</span><span class="w"> </span><span class="o">*</span><span class="n">resource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Resource</span><span class="p">(...);</span><span class="w"></span>
<span class="w">    </span><span class="n">launchWork</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">resource</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamAddCallback</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">stream</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">[](</span><span class="n">cudaStream_t</span><span class="p">,</span><span class="w"> </span><span class="n">cudaError_t</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">resource</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">delete</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Resource</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="n">resource</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Error handling considerations not shown</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>These schemes are difficult with CUDA graphs because of the non-fixed pointer or handle for the resource which requires indirection or graph update, and the synchronous CPU code needed each time the work is submitted. They also do not work with stream capture if these considerations are hidden from the caller of the library, and because of use of disallowed APIs during capture. Various solutions exist such as exposing the resource to the caller. CUDA user objects present another approach.</p>
<p>A CUDA user object associates a user-specified destructor callback with an internal refcount, similar to C++ <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>. References may be owned by user code on the CPU and by CUDA graphs. Note that for user-owned references, unlike C++ smart pointers, there is no object representing the reference; users must track user-owned references manually. A typical use case would be to immediately move the sole user-owned reference to a CUDA graph after the user object is created.</p>
<p>When a reference is associated to a CUDA graph, CUDA will manage the graph operations automatically. A cloned <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> retains a copy of every reference owned by the source <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code>, with the same multiplicity. An instantiated <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> retains a copy of every reference in the source <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code>. When a <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> is destroyed without being synchronized, the references are retained until the execution is completed.</p>
<p>Here is an example use.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w">  </span><span class="c1">// Preexisting graph</span>

<span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">;</span><span class="w">  </span><span class="c1">// C++ object with possibly nontrivial destructor</span>
<span class="n">cudaUserObject_t</span><span class="w"> </span><span class="n">cuObject</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaUserObjectCreate</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">cuObject</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">object</span><span class="p">,</span><span class="w">  </span><span class="c1">// Here we use a CUDA-provided template wrapper for this API,</span>
<span class="w">             </span><span class="c1">// which supplies a callback to delete the C++ object pointer</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// Initial refcount</span>
<span class="w">    </span><span class="n">cudaUserObjectNoDestructorSync</span><span class="w">  </span><span class="c1">// Acknowledge that the callback cannot be</span>
<span class="w">                                    </span><span class="c1">// waited on via CUDA</span>
<span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphRetainUserObject</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">graph</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">cuObject</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="c1">// Number of references</span>
<span class="w">    </span><span class="n">cudaGraphUserObjectMove</span><span class="w">  </span><span class="c1">// Transfer a reference owned by the caller (do</span>
<span class="w">                             </span><span class="c1">// not modify the total reference count)</span>
<span class="p">);</span><span class="w"></span>
<span class="c1">// No more references owned by this thread; no need to call release API</span>
<span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graphExec</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will retain a</span>
<span class="w">                                                               </span><span class="c1">// new reference</span>
<span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w">  </span><span class="c1">// graphExec still owns a reference</span>
<span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Async launch has access to the user objects</span>
<span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">graphExec</span><span class="p">);</span><span class="w">  </span><span class="c1">// Launch is not synchronized; the release</span>
<span class="w">                                  </span><span class="c1">// will be deferred if needed</span>
<span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// After the launch is synchronized, the remaining</span>
<span class="w">                           </span><span class="c1">// reference is released and the destructor will</span>
<span class="w">                           </span><span class="c1">// execute. Note this happens asynchronously.</span>
<span class="c1">// If the destructor callback had signaled a synchronization object, it would</span>
<span class="c1">// be safe to wait on it at this point.</span>
</pre></div>
</div>
<p>References owned by graphs in child graph nodes are associated to the child graphs, not the parents. If a child graph is updated or deleted, the references change accordingly. If an executable graph or child graph is updated with <code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGraphExecChildGraphNodeSetParams</span></code>, the references in the new source graph are cloned and replace the references in the target graph. In either case, if previous launches are not synchronized, any references which would be released are held until the launches have finished executing.</p>
<p>There is not currently a mechanism to wait on user object destructors via a CUDA API. Users may signal a synchronization object manually from the destructor code. In addition, it is not legal to call CUDA APIs from the destructor, similar to the restriction on <code class="docutils literal notranslate"><span class="pre">cudaLaunchHostFunc</span></code>. This is to avoid blocking a CUDA internal shared thread and preventing forward progress. It is legal to signal another thread to perform an API call, if the dependency is one way and the thread doing the call cannot block forward progress of CUDA work.</p>
<p>User objects are created with <code class="docutils literal notranslate"><span class="pre">cudaUserObjectCreate</span></code>, which is a good starting point to browse related APIs.</p>
</section>
<section id="updating-instantiated-graphs">
<span id="id51"></span><h5><span class="section-number">3.2.8.7.5. </span>Updating Instantiated Graphs<a class="headerlink" href="#updating-instantiated-graphs" title="Permalink to this headline">ï</a></h5>
<p>Work submission using graphs is separated into three distinct stages: definition, instantiation, and execution. In situations where the workflow is not changing, the overhead of definition and instantiation can be amortized over many executions, and graphs provide a clear advantage over streams.</p>
<p>A graph is a snapshot of a workflow, including kernels, parameters, and dependencies, in order to replay it as rapidly and efficiently as possible. In situations where the workflow changes the graph becomes out of date and must be modified. Major changes to graph structure such as topology or types of nodes will require re-instantiation of the source graph because various topology-related optimization techniques must be re-applied.</p>
<p>The cost of repeated instantiation can reduce the overall performance benefit from graph execution, but it is common for only node parameters, such as kernel parameters and <code class="docutils literal notranslate"><span class="pre">cudaMemcpy</span></code> addresses, to change while graph topology remains the same. For this case, CUDA provides a lightweight mechanism known as âGraph Update,â which allows certain node parameters to be modified in-place without having to rebuild the entire graph. This is much more efficient than re-instantiation.</p>
<p>Updates will take effect the next time the graph is launched, so they will not impact previous graph launches, even if they are running at the time of the update. A graph may be updated and relaunched repeatedly, so multiple updates/launches can be queued on a stream.</p>
<p>CUDA provides two mechanisms for updating instantiated graph parameters, whole graph update and individual node update. Whole graph update allows the user to supply a topologically identical <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> object whose nodes contain updated parameters. Individual node update allows the user to explicitly update the parameters of individual nodes. Using an updated <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> is more convenient when a large number of nodes are being updated, or when the graph topology is unknown to the caller (i.e., The graph resulted from stream capture of a library call). Using individual node update is preferred when the number of changes is small and the user has the handles to the nodes requiring updates. Individual node update skips the topology checks and comparisons for unchanged nodes, so it can be more efficient in many cases.</p>
<p>CUDA also provides a mechanism for enabling and disabling individual nodes without affecting their current parameters.</p>
<p>The following sections explain each approach in more detail.</p>
<section id="graph-update-limitations">
<span id="id52"></span><h6><span class="section-number">3.2.8.7.5.1. </span>Graph Update Limitations<a class="headerlink" href="#graph-update-limitations" title="Permalink to this headline">ï</a></h6>
<p>Kernel nodes:</p>
<ul class="simple">
<li><p>The owning context of the function cannot change.</p></li>
<li><p>A node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CUDA dynamic parallelism.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cudaMemset</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemcpy</span></code> nodes:</p>
<ul class="simple">
<li><p>The CUDA device(s) to which the operand(s) was allocated/mapped cannot change.</p></li>
<li><p>The source/destination memory must be allocated from the same context as the original source/destination memory.</p></li>
<li><p>Only 1D <code class="docutils literal notranslate"><span class="pre">cudaMemset</span></code>/<code class="docutils literal notranslate"><span class="pre">cudaMemcpy</span></code> nodes can be changed.</p></li>
</ul>
<p>Additional memcpy node restrictions:</p>
<ul class="simple">
<li><p>Changing either the source or destination memory type (i.e., <code class="docutils literal notranslate"><span class="pre">cudaPitchedPtr</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaArray_t</span></code>, etc.), or the type of transfer (i.e., <code class="docutils literal notranslate"><span class="pre">cudaMemcpyKind</span></code>) is not supported.</p></li>
</ul>
<p>External semaphore wait nodes and record nodes:</p>
<ul class="simple">
<li><p>Changing the number of semaphores is not supported.</p></li>
</ul>
<p>Conditional nodes:</p>
<ul class="simple">
<li><p>The order of handle creation and assignment must match between the graphs.</p></li>
<li><p>Changing node parameters is not supported (i.e. number of graphs in the conditional, node context, etc).</p></li>
<li><p>Changing parameters of nodes within the conditional body graph is subject to the rules above.</p></li>
</ul>
<p>There are no restrictions on updates to host nodes, event record nodes, or event wait nodes.</p>
</section>
<section id="whole-graph-update">
<span id="id53"></span><h6><span class="section-number">3.2.8.7.5.2. </span>Whole Graph Update<a class="headerlink" href="#whole-graph-update" title="Permalink to this headline">ï</a></h6>
<p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate()</span></code> allows an instantiated graph (the âoriginal graphâ) to be updated with the parameters from a topologically identical graph (the âupdatingâ graph). The topology of the updating graph must be identical to the original graph used to instantiate the <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code>. In addition, the order in which the dependencies are specified must match. Finally, CUDA needs to consistently order the sink nodes (nodes with no dependencies). CUDA relies on the order of specific api calls to achieve consistent sink node ordering.</p>
<p>More explicitly, following the following rules will cause <code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate()</span></code> to pair the nodes in the original graph and the updating graph deterministically:</p>
<ol class="arabic simple">
<li><p>For any capturing stream, the API calls operating on that stream must be made in the same order, including event wait and other api calls not directly corresponding to node creation.</p></li>
<li><p>The API calls which directly manipulate a given graph nodeâs incoming edges (including captured stream APIs, node add APIs, and edge addition / removal APIs) must be made in the same order. Moreover, when dependencies are specified in arrays to these APIs, the order in which the dependencies are specified inside those arrays must match.</p></li>
<li><p>Sink nodes must be consistently ordered. Sink nodes are nodes without dependent nodes / outgoing edges in the final graph at the time of the <code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate()</span></code> invocation. The following operations affect sink node ordering (if present) and must (as a combined set) be made in the same order:</p>
<ul class="simple">
<li><p>Node add APIs resulting in a sink node.</p></li>
<li><p>Edge removal resulting in a node becoming a sink node.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaStreamUpdateCaptureDependencies()</span></code>, if it removes a sink node from a capturing streamâs dependency set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaStreamEndCapture()</span></code>.</p></li>
</ul>
</li>
</ol>
<p>The following example shows how the API could be used to update an instantiated graph:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graphExec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExecUpdateResult</span><span class="w"> </span><span class="n">updateResult</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphNode_t</span><span class="w"> </span><span class="n">errorNode</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// In this example we use stream capture to create the graph.</span>
<span class="w">    </span><span class="c1">// You can also use the Graph API to produce a graph.</span>
<span class="w">    </span><span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Call a user-defined, stream based workload, for example</span>
<span class="w">    </span><span class="n">do_cuda_work</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// If we&#39;ve already instantiated the graph, try to update it directly</span>
<span class="w">    </span><span class="c1">// and avoid the instantiation overhead</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">graphExec</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// If the graph fails to update, errorNode will be set to the</span>
<span class="w">        </span><span class="c1">// node causing the failure and updateResult will be set to a</span>
<span class="w">        </span><span class="c1">// reason code.</span>
<span class="w">        </span><span class="n">cudaGraphExecUpdate</span><span class="p">(</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">errorNode</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">updateResult</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Instantiate during the first iteration or whenever the update</span>
<span class="w">    </span><span class="c1">// fails for any reason</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">graphExec</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">updateResult</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaGraphExecUpdateSuccess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// If a previous update failed, destroy the cudaGraphExec_t</span>
<span class="w">        </span><span class="c1">// before re-instantiating it</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">graphExec</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">graphExec</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Instantiate graphExec from graph. The error node and</span>
<span class="w">        </span><span class="c1">// error message parameters are unused here.</span>
<span class="w">        </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A typical workflow is to create the initial <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> using either the stream capture or graph API. The <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> is then instantiated and launched as normal. After the initial launch, a new <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> is created using the same method as the initial graph and <code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate()</span></code> is called. If the graph update is successful, indicated by the <code class="docutils literal notranslate"><span class="pre">updateResult</span></code> parameter in the above example, the updated <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> is launched. If the update fails for any reason, the <code class="docutils literal notranslate"><span class="pre">cudaGraphExecDestroy()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiate()</span></code> are called to destroy the original <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> and instantiate a new one.</p>
<p>It is also possible to update the <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> nodes directly (i.e., Using <code class="docutils literal notranslate"><span class="pre">cudaGraphKernelNodeSetParams()</span></code>) and subsequently update the <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code>, however it is more efficient to use the explicit node update APIs covered in the next section.</p>
<p>Conditional handle flags and default values are updated as part of the graph update.</p>
<p>Please see the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH">Graph API</a> for more information on usage and current limitations.</p>
</section>
<section id="individual-node-update">
<span id="id54"></span><h6><span class="section-number">3.2.8.7.5.3. </span>Individual Node Update<a class="headerlink" href="#individual-node-update" title="Permalink to this headline">ï</a></h6>
<p>Instantiated graph node parameters can be updated directly. This eliminates the overhead of instantiation as well as the overhead of creating a new <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code>. If the number of nodes requiring update is small relative to the total number of nodes in the graph, it is better to update the nodes individually. The following methods are available for updating <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> nodes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecKernelNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecMemcpyNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecMemsetNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecHostNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecChildGraphNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecEventRecordNodeSetEvent()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecEventWaitNodeSetEvent()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecExternalSemaphoresSignalNodeSetParams()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphExecExternalSemaphoresWaitNodeSetParams()</span></code></p></li>
</ul>
<p>Please see the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH">Graph API</a> for more information on usage and current limitations.</p>
</section>
<section id="individual-node-enable">
<span id="id55"></span><h6><span class="section-number">3.2.8.7.5.4. </span>Individual Node Enable<a class="headerlink" href="#individual-node-enable" title="Permalink to this headline">ï</a></h6>
<p>Kernel, memset and memcpy nodes in an instantiated graph can be enabled or disabled using the <code class="docutils literal notranslate"><span class="pre">cudaGraphNodeSetEnabled()</span></code> API. This allows the creation of a graph which contains a superset of the desired functionality which can be customized for each launch. The enable state of a node can be queried using the <code class="docutils literal notranslate"><span class="pre">cudaGraphNodeGetEnabled()</span></code> API.</p>
<p>A disabled node is functionally equivalent to empty node until it is reenabled. Node parameters are not affected by enabling/disabling a node. Enable state is unaffected by individual node update or whole graph update with <code class="docutils literal notranslate"><span class="pre">cudaGraphExecUpdate()</span></code>. Parameter updates while the node is disabled will take effect when the node is reenabled.</p>
<p>The following methods are available for enabling/disabling <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> nodes, as well as querying their status:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphNodeSetEnabled()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaGraphNodeGetEnabled()</span></code></p></li>
</ul>
<p>Refer to the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH">Graph API</a> for more information on usage and current limitations.</p>
</section>
</section>
<section id="using-graph-apis">
<span id="id56"></span><h5><span class="section-number">3.2.8.7.6. </span>Using Graph APIs<a class="headerlink" href="#using-graph-apis" title="Permalink to this headline">ï</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code> objects are not thread-safe. It is the responsibility of the user to ensure that multiple threads do not concurrently access the same <code class="docutils literal notranslate"><span class="pre">cudaGraph_t</span></code>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> cannot run concurrently with itself. A launch of a <code class="docutils literal notranslate"><span class="pre">cudaGraphExec_t</span></code> will be ordered after previous launches of the same executable graph.</p>
<p>Graph execution is done in streams for ordering with other asynchronous work. However, the stream is for ordering only; it does not constrain the internal parallelism of the graph, nor does it affect where graph nodes execute.</p>
<p>See <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH">Graph API.</a></p>
</section>
<section id="device-graph-launch">
<span id="id57"></span><h5><span class="section-number">3.2.8.7.7. </span>Device Graph Launch<a class="headerlink" href="#device-graph-launch" title="Permalink to this headline">ï</a></h5>
<p>There are many workflows which need to make data-dependent decisions during runtime and execute different operations depending on those decisions. Rather than offloading this decision-making process to the host, which may require a round-trip from the device, users may prefer to perform it on the device. To that end, CUDA provides a mechanism to launch graphs from the device.</p>
<p>Device graph launch provides a convenient way to perform dynamic control flow from the device, be it something as simple as a loop or as complex as a device-side work scheduler. This functionality is only available on systems which support <a class="reference internal" href="#unified-virtual-address-space"><span class="std std-ref">unified addressing</span></a>.</p>
<p>Graphs which can be launched from the device will henceforth be referred to as device graphs, and graphs which cannot be launched from the device will be referred to as host graphs.</p>
<p>Device graphs can be launched from both the host and device, whereas host graphs can only be launched from the host. Unlike host launches, launching a device graph from the device while a previous launch of the graph is running will result in an error, returning <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code>; therefore, a device graph cannot be launched twice from the device at the same time. Launching a device graph from the host and device simultaneously will result in undefined behavior.</p>
<section id="device-graph-creation">
<span id="id58"></span><h6><span class="section-number">3.2.8.7.7.1. </span>Device Graph Creation<a class="headerlink" href="#device-graph-creation" title="Permalink to this headline">ï</a></h6>
<p>In order for a graph to be launched from the device, it must be instantiated explicitly for device launch. This is achieved by passing the <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiateFlagDeviceLaunch</span></code> flag to the <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiate()</span></code> call. As is the case for host graphs, device graph structure is fixed at time of instantiation and cannot be updated without re-instantiation, and instantiation can only be performed on the host. In order for a graph to be able to be instantiated for device launch, it must adhere to various requirements.</p>
<section id="device-graph-requirements">
<span id="id59"></span><h7><span class="section-number">3.2.8.7.7.1.1. </span>Device Graph Requirements<a class="headerlink" href="#device-graph-requirements" title="Permalink to this headline">ï</a></h7>
<p>General requirements:</p>
<ul class="simple">
<li><p>The graphâs nodes must all reside on a single device.</p></li>
<li><p>The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.</p></li>
</ul>
<p>Kernel nodes:</p>
<ul class="simple">
<li><p>Use of CUDA Dynamic Parallelism by kernels in the graph is not permitted.</p></li>
<li><p>Cooperative launches are permitted so long as MPS is not in use.</p></li>
</ul>
<p>Memcpy nodes:</p>
<ul class="simple">
<li><p>Only copies involving device memory and/or pinned device-mapped host memory are permitted.</p></li>
<li><p>Copies involving CUDA arrays are not permitted.</p></li>
<li><p>Both operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.</p></li>
</ul>
</section>
<section id="device-graph-upload">
<span id="id60"></span><h7><span class="section-number">3.2.8.7.7.1.2. </span>Device Graph Upload<a class="headerlink" href="#device-graph-upload" title="Permalink to this headline">ï</a></h7>
<p>In order to launch a graph on the device, it must first be uploaded to the device to populate the necessary device resources. This can be achieved in one of two ways.</p>
<p>Firstly, the graph can be uploaded explicitly, either via <code class="docutils literal notranslate"><span class="pre">cudaGraphUpload()</span></code> or by requesting an upload as part of instantiation via <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiateWithParams()</span></code>.</p>
<p>Alternatively, the graph can first be launched from the host, which will perform this upload step implicitly as part of the launch.</p>
<p>Examples of all three methods can be seen below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Explicit upload after instantiation</span>
<span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceGraphExec1</span><span class="p">,</span><span class="w"> </span><span class="n">deviceGraph1</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphUpload</span><span class="p">(</span><span class="n">deviceGraphExec1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Explicit upload as part of instantiation</span>
<span class="n">cudaGraphInstantiateParams</span><span class="w"> </span><span class="n">instantiateParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="n">instantiateParams</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagUpload</span><span class="p">;</span><span class="w"></span>
<span class="n">instantiateParams</span><span class="p">.</span><span class="n">uploadStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGraphInstantiateWithParams</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceGraphExec2</span><span class="p">,</span><span class="w"> </span><span class="n">deviceGraph2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instantiateParams</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Implicit upload via host launch</span>
<span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceGraphExec3</span><span class="p">,</span><span class="w"> </span><span class="n">deviceGraph3</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">deviceGraphExec3</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="device-graph-update">
<span id="id61"></span><h7><span class="section-number">3.2.8.7.7.1.3. </span>Device Graph Update<a class="headerlink" href="#device-graph-update" title="Permalink to this headline">ï</a></h7>
<p>Device graphs can only be updated from the host, and must be re-uploaded to the device upon executable graph update in order for the changes to take effect. This can be achieved using the same methods outlined in the previous section. Unlike host graphs, launching a device graph from the device while an update is being applied will result in undefined behavior.</p>
</section>
</section>
<section id="device-launch">
<span id="device-graph-device-launch"></span><h6><span class="section-number">3.2.8.7.7.2. </span>Device Launch<a class="headerlink" href="#device-launch" title="Permalink to this headline">ï</a></h6>
<p>Device graphs can be launched from both the host and the device via <code class="docutils literal notranslate"><span class="pre">cudaGraphLaunch()</span></code>, which has the same signature on the device as on the host. Device graphs are launched via the same handle on the host and the device. Device graphs must be launched from another graph when launched from the device.</p>
<p>Device-side graph launch is per-thread and multiple launches may occur from different threads at the same time, so the user will need to select a single thread from which to launch a given graph.</p>
<section id="device-launch-modes">
<span id="device-graph-launch-modes"></span><h7><span class="section-number">3.2.8.7.7.2.1. </span>Device Launch Modes<a class="headerlink" href="#device-launch-modes" title="Permalink to this headline">ï</a></h7>
<p>Unlike host launch, device graphs cannot be launched into regular CUDA streams, and can only be launched into distinct named streams, which each denote a specific launch mode:</p>
<table class="table-no-stripes docutils align-default" id="id455">
<caption><span class="caption-number">Table 5 </span><span class="caption-text">Device-only Graph Launch Streams</span><a class="headerlink" href="#id455" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 65%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Stream</p></th>
<th class="head"><p>Launch Mode</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamGraphFireAndForget</span></code></p></td>
<td><p>Fire and forget launch</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamGraphTailLaunch</span></code></p></td>
<td><p>Tail launch</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamGraphFireAndForgetAsSibling</span></code></p></td>
<td><p>Sibling launch</p></td>
</tr>
</tbody>
</table>
<section id="fire-and-forget-launch">
<span id="device-graph-fire-and-forget-launch"></span><h8><span class="section-number">3.2.8.7.7.2.1.1. </span>Fire and Forget Launch<a class="headerlink" href="#fire-and-forget-launch" title="Permalink to this headline">ï</a></h8>
<p>As the name suggests, a fire and forget launch is submitted to the GPU immediately, and it runs independently of the launching graph. In a fire-and-forget scenario, the launching graph is the parent, and the launched graph is the child.</p>
<figure class="align-default" id="id456">
<a class="image reference internal image-reference" href="_images/fire-and-forget-simple.png"><img alt="_images/fire-and-forget-simple.png" class="image" src="_images/fire-and-forget-simple.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 15 </span><span class="caption-text">Fire and forget launch</span><a class="headerlink" href="#id456" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The above diagram can be generated by the sample code below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launchFireAndForgetGraph</span><span class="p">(</span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamGraphFireAndForget</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">graphSetup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">gExec2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">g1</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create, instantiate, and upload the device graph.</span>
<span class="w">    </span><span class="n">create_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphUpload</span><span class="p">(</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create and instantiate the launching graph.</span>
<span class="w">    </span><span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">launchFireAndForgetGraph</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">gExec2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">g1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch the host graph, which will in turn launch the device graph.</span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A graph can have up to 120 total fire-and-forget graphs during the course of its execution. This total resets between launches of the same parent graph.</p>
</section>
<section id="graph-execution-environments">
<span id="device-graph-execution-environments"></span><h8><span class="section-number">3.2.8.7.7.2.1.2. </span>Graph Execution Environments<a class="headerlink" href="#graph-execution-environments" title="Permalink to this headline">ï</a></h8>
<p>In order to fully understand the device-side synchronization model, it is first necessary to understand the concept of an execution environment.</p>
<p>When a graph is launched from the device, it is launched into its own execution environment. The execution environment of a given graph encapsulates all work in the graph as well as all generated fire and forget work. The graph can be considered complete when it has completed execution and when all generated child work is complete.</p>
<p>The below diagram shows the environment encapsulation that would be generated by the fire-and-forget sample code in the previous section.</p>
<figure class="align-default" id="id457">
<a class="image reference internal image-reference" href="_images/fire-and-forget-environments.png"><img alt="_images/fire-and-forget-environments.png" class="image" src="_images/fire-and-forget-environments.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 16 </span><span class="caption-text">Fire and forget launch, with execution environments</span><a class="headerlink" href="#id457" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>These environments are also hierarchical, so a graph environment can include multiple levels of child-environments from fire and forget launches.</p>
<figure class="align-default" id="id458">
<a class="image reference internal image-reference" href="_images/fire-and-forget-nested-environments.png"><img alt="_images/fire-and-forget-nested-environments.png" class="image" src="_images/fire-and-forget-nested-environments.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 17 </span><span class="caption-text">Nested fire and forget environments</span><a class="headerlink" href="#id458" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>When a graph is launched from the host, there exists a stream environment that parents the execution environment of the launched graph. The stream environment encapsulates all work generated as part of the overall launch. The stream launch is complete (i.e. downstream dependent work may now run) when the overall stream environment is marked as complete.</p>
<figure class="align-default" id="id459">
<a class="image reference internal image-reference" href="_images/device-graph-stream-environment.png"><img alt="_images/device-graph-stream-environment.png" class="image" src="_images/device-graph-stream-environment.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 18 </span><span class="caption-text">The stream environment, visualized</span><a class="headerlink" href="#id459" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="tail-launch">
<span id="device-graph-tail-launch"></span><h8><span class="section-number">3.2.8.7.7.2.1.3. </span>Tail Launch<a class="headerlink" href="#tail-launch" title="Permalink to this headline">ï</a></h8>
<p>Unlike on the host, it is not possible to synchronize with device graphs from the GPU via traditional methods such as <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code>. Rather, in order to enable serial work dependencies, a different launch mode - tail launch - is offered, to provide similar functionality.</p>
<p>A tail launch executes when a graphâs environment is considered complete - ie, when the graph and all its children are complete. When a graph completes, the environment of the next graph in the tail launch list will replace the completed environment as a child of the parent environment. Like fire-and-forget launches, a graph can have multiple graphs enqueued for tail launch.</p>
<figure class="align-default" id="id460">
<a class="image reference internal image-reference" href="_images/tail-launch-simple.png"><img alt="_images/tail-launch-simple.png" class="image" src="_images/tail-launch-simple.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 19 </span><span class="caption-text">A simple tail launch</span><a class="headerlink" href="#id460" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The above execution flow can be generated by the code below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launchTailGraph</span><span class="p">(</span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamGraphTailLaunch</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">graphSetup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">gExec2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">g1</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create, instantiate, and upload the device graph.</span>
<span class="w">    </span><span class="n">create_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphUpload</span><span class="p">(</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create and instantiate the launching graph.</span>
<span class="w">    </span><span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">launchTailGraph</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">gExec2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">g1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch the host graph, which will in turn launch the device graph.</span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Tail launches enqueued by a given graph will execute one at a time, in order of when they were enqueued. So the first enqueued graph will run first, and then the second, and so on.</p>
<figure class="align-default" id="id461">
<img alt="_images/tail-launch-ordering-simple.png" class="image" src="_images/tail-launch-ordering-simple.png" />
<figcaption>
<p><span class="caption-number">Figure 20 </span><span class="caption-text">Tail launch ordering</span><a class="headerlink" href="#id461" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>Tail launches enqueued by a tail graph will execute before tail launches enqueued by previous graphs in the tail launch list. These new tail launches will execute in the order they are enqueued.</p>
<figure class="align-default" id="id462">
<img alt="_images/tail-launch-ordering-complex.png" class="image" src="_images/tail-launch-ordering-complex.png" />
<figcaption>
<p><span class="caption-number">Figure 21 </span><span class="caption-text">Tail launch ordering when enqueued from multiple graphs</span><a class="headerlink" href="#id462" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>A graph can have up to 255 pending tail launches.</p>
<section id="tail-self-launch">
<span id="device-graph-tail-self-launch"></span><h9><span class="section-number">3.2.8.7.7.2.1.3.1. </span>Tail Self-launch<a class="headerlink" href="#tail-self-launch" title="Permalink to this headline">ï</a></h9>
<p>It is possible for a device graph to enqueue itself for a tail launch, although a given graph can only have one self-launch enqueued at a time. In order to query the currently running device graph so that it can be relaunched, a new device-side function is added:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="nf">cudaGetCurrentGraphExec</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>This function returns the handle of the currently running graph if it is a device graph. If the currently executing kernel is not a node within a device graph, this function will return NULL.</p>
<p>Below is sample code showing usage of this function for a relaunch loop:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">relaunchCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">relaunchSelf</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">relaunchMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">relaunchCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">relaunchMax</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">cudaGetCurrentGraphExec</span><span class="p">(),</span><span class="w"> </span><span class="n">cudaStreamGraphTailLaunch</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">relaunchCount</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="sibling-launch">
<span id="id62"></span><h8><span class="section-number">3.2.8.7.7.2.1.4. </span>Sibling Launch<a class="headerlink" href="#sibling-launch" title="Permalink to this headline">ï</a></h8>
<p>Sibling launch is a variation of fire-and-forget launch in which the graph is launched not as a child of the launching graphâs execution environment, but rather as a child of the launching graphâs parent environment. Sibling launch is equivalent to a fire-and-forget launch from the launching graphâs parent environment.</p>
<figure class="align-default" id="id463">
<img alt="_images/sibling-launch-simple.png" class="image" src="_images/sibling-launch-simple.png" />
<figcaption>
<p><span class="caption-number">Figure 22 </span><span class="caption-text">A simple sibling launch</span><a class="headerlink" href="#id463" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The above diagram can be generated by the sample code below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launchSiblingGraph</span><span class="p">(</span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamGraphFireAndForgetAsSibling</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">graphSetup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">gExec2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">g1</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create, instantiate, and upload the device graph.</span>
<span class="w">    </span><span class="n">create_graph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">g2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">g2</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphInstantiateFlagDeviceLaunch</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphUpload</span><span class="p">(</span><span class="n">gExec2</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create and instantiate the launching graph.</span>
<span class="w">    </span><span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">launchSiblingGraph</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">gExec2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">g1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch the host graph, which will in turn launch the device graph.</span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">gExec1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Since sibling launches are not launched into the launching graphâs execution environment, they will not gate tail launches enqueued by the launching graph.</p>
</section>
</section>
</section>
</section>
<section id="conditional-graph-nodes">
<span id="id63"></span><h5><span class="section-number">3.2.8.7.8. </span>Conditional Graph Nodes<a class="headerlink" href="#conditional-graph-nodes" title="Permalink to this headline">ï</a></h5>
<p>Conditional nodes allow conditional execution and looping of a graph contained within the conditional node. This allows dynamic and iterative workflows to be represented completely within a graph and frees up the host CPU to perform other work in parallel.</p>
<p>Evaluation of the condition value is performed on the device when the dependencies of the conditional node have been met. Conditional nodes can be one of the following types:</p>
<ul class="simple">
<li><p>Conditional <a class="reference internal" href="#conditional-if-nodes"><span class="std std-ref">IF nodes</span></a> execute their body graph once if the condition value is non-zero when the node is executed.</p></li>
<li><p>Conditional <a class="reference internal" href="#conditional-while-nodes"><span class="std std-ref">WHILE nodes</span></a> execute their body graph if the condition value is non-zero when the node is executed and will continue to execute their body graph until the condition value is zero.</p></li>
</ul>
<p>A condition value is accessed by a <a class="reference internal" href="#conditional-handles"><span class="std std-ref">conditional handle</span></a> , which must be created before the node. The condition value can be set by device code using <code class="docutils literal notranslate"><span class="pre">cudaGraphSetConditional()</span></code>. A default value, applied on each graph launch, can also be specified when the handle is created.</p>
<p>When the conditional node is created, an empty graph is created and the handle is returned to the user so that the graph can be populated.  This conditional body graph can be populated using either the <a class="reference internal" href="#creating-a-graph-using-graph-apis"><span class="std std-ref">graph APIs</span></a> or <a class="reference internal" href="#creating-a-graph-using-stream-capture"><span class="std std-ref">cudaStreamBeginCaptureToGraph()</span></a>.</p>
<p>Conditional nodes can be nested.</p>
<section id="conditional-handles">
<span id="id64"></span><h6><span class="section-number">3.2.8.7.8.1. </span>Conditional Handles<a class="headerlink" href="#conditional-handles" title="Permalink to this headline">ï</a></h6>
<p>A condition value is represented by <code class="docutils literal notranslate"><span class="pre">cudaGraphConditionalHandle</span></code> and is created by <code class="docutils literal notranslate"><span class="pre">cudaGraphConditionalHandleCreate()</span></code>.</p>
<p>The handle must be associated with a single conditional node. Handles cannot be destroyed.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">cudaGraphCondAssignDefault</span></code> is specified when the handle is created, the condition value will be initialized to the specified default at the beginning of each graph execution. If this flag is not provided, the condition value is undefined at the start of each graph execution and code should not assume that the condition value persists across executions.</p>
<p>The default value and flags associated with a handle will be updated during <a class="reference internal" href="#whole-graph-update"><span class="std std-ref">whole graph update</span></a>.</p>
</section>
<section id="condtional-node-body-graph-requirements">
<span id="conditional-node-body-graph-requirements"></span><h6><span class="section-number">3.2.8.7.8.2. </span>Condtional Node Body Graph Requirements<a class="headerlink" href="#condtional-node-body-graph-requirements" title="Permalink to this headline">ï</a></h6>
<p>General requirements:</p>
<ul class="simple">
<li><p>The graphâs nodes must all reside on a single device.</p></li>
<li><p>The graph can only contain kernel nodes, empty nodes, memcpy nodes, memset nodes, child graph nodes, and conditional nodes.</p></li>
</ul>
<p>Kernel nodes:</p>
<ul class="simple">
<li><p>Use of CUDA Dynamic Parallelism by kernels in the graph is not permitted.</p></li>
<li><p>Cooperative launches are permitted so long as MPS is not in use.</p></li>
</ul>
<p>Memcpy/Memset nodes:</p>
<ul class="simple">
<li><p>Only copies/memsets involving device memory and/or pinned device-mapped host memory are permitted.</p></li>
<li><p>Copies/memsets involving CUDA arrays are not permitted.</p></li>
<li><p>Both operands must be accessible from the current device at time of instantiation. Note that the copy operation will be performed from the device on which the graph resides, even if it is targeting memory on another device.</p></li>
</ul>
</section>
<section id="conditional-if-nodes">
<span id="id65"></span><h6><span class="section-number">3.2.8.7.8.3. </span>Conditional IF Nodes<a class="headerlink" href="#conditional-if-nodes" title="Permalink to this headline">ï</a></h6>
<p>The body graph of an IF node will be executed once if the condition is non-zero when the node is executed.  The following diagram depicts a 3 node graph where the middle node, B, is a conditional node:</p>
<figure class="align-default" id="id464">
<img alt="_images/conditional-if-node.png" class="image" src="_images/conditional-if-node.png" />
<figcaption>
<p><span class="caption-number">Figure 23 </span><span class="caption-text">Conditional IF Node</span><a class="headerlink" href="#id464" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The following code illustrates the creation of a graph containing an IF conditional node. The default value of the condition is set using an upstream kernel. The body of the conditional is populated using the <a class="reference internal" href="#creating-a-graph-using-graph-apis"><span class="std std-ref">graph API</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">setHandle</span><span class="p">(</span><span class="n">cudaGraphConditionalHandle</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphSetConditional</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">graphSetup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graphExec</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphNode_t</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernelArgs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphConditionalHandle</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphConditionalHandleCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use a kernel upstream of the conditional to set the handle value</span>
<span class="w">    </span><span class="n">cudaGraphNodeParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaGraphNodeTypeKernel</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">setHandle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">kernelParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernelArgs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">kernelArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphAddNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphNodeParams</span><span class="w"> </span><span class="n">cParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaGraphNodeTypeConditional</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">type</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphCondTypeIf</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphAddNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cParams</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">bodyGraph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">phGraph_out</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Populate the body of the conditional node</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphAddNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">bodyGraph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">graphExec</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="conditional-while-nodes">
<span id="id66"></span><h6><span class="section-number">3.2.8.7.8.4. </span>Conditional WHILE Nodes<a class="headerlink" href="#conditional-while-nodes" title="Permalink to this headline">ï</a></h6>
<p>The body graph of a WHILE node will be executed until the condition is non-zero. The condition will be
evaluated when the node is executed and after completion of the body graph. The following diagram depicts
a 3 node graph where the middle node, B, is a conditional node:</p>
<figure class="align-default" id="id465">
<img alt="_images/conditional-while-node.png" class="image" src="_images/conditional-while-node.png" />
<figcaption>
<p><span class="caption-number">Figure 24 </span><span class="caption-text">Conditional WHILE Node</span><a class="headerlink" href="#id465" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The following code illustrates the creation of a graph containing a WHILE conditional node. The handle
is created using <em>cudaGraphCondAssignDefault</em> to avoid the need for an upstream kernel. The body of the
conditional is populated using the <a class="reference internal" href="#creating-a-graph-using-graph-apis"><span class="std std-ref">graph API</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">loopKernel</span><span class="p">(</span><span class="n">cudaGraphConditionalHandle</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphSetConditional</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">--</span><span class="n">count</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">graphSetup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphExec_t</span><span class="w"> </span><span class="n">graphExec</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphNode_t</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernelArgs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">cuGraphCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphConditionalHandle</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphConditionalHandleCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGraphCondAssignDefault</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphNodeParams</span><span class="w"> </span><span class="n">cParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaGraphNodeTypeConditional</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">type</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGraphCondTypeWhile</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphAddNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cParams</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraph_t</span><span class="w"> </span><span class="n">bodyGraph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cParams</span><span class="p">.</span><span class="n">conditional</span><span class="p">.</span><span class="n">phGraph_out</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphNodeParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaGraphNodeTypeKernel</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">loopKernel</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">gridDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">blockDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">kernel</span><span class="p">.</span><span class="n">kernelParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernelArgs</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">kernelArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphAddNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">bodyGraph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphInstantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">graphExec</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">graphExec</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="events">
<span id="id67"></span><h4><span class="section-number">3.2.8.8. </span>Events<a class="headerlink" href="#events" title="Permalink to this headline">ï</a></h4>
<p>The runtime also provides a way to closely monitor the deviceâs progress, as well as perform accurate timing, by letting the application asynchronously record <em>events</em> at any point in the program, and query when these events are completed. An event has completed when all tasks - or optionally, all commands in a given stream - preceding the event have completed. Events in stream zero are completed after all preceding tasks and commands in all streams are completed.</p>
<section id="creation-and-destruction-of-events">
<span id="creation-and-destruction-events"></span><h5><span class="section-number">3.2.8.8.1. </span>Creation and Destruction of Events<a class="headerlink" href="#creation-and-destruction-of-events" title="Permalink to this headline">ï</a></h5>
<p>The following code sample creates two events:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaEvent_t</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">stop</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaEventCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaEventCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>They are destroyed this way:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaEventDestroy</span><span class="p">(</span><span class="n">start</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaEventDestroy</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="elapsed-time">
<span id="id68"></span><h5><span class="section-number">3.2.8.8.2. </span>Elapsed Time<a class="headerlink" href="#elapsed-time" title="Permalink to this headline">ï</a></h5>
<p>The events created in <a class="reference internal" href="#creation-and-destruction-events"><span class="std std-ref">Creation and Destruction of Events</span></a> can be used to time the code sample of <a class="reference internal" href="#creation-and-destruction-streams"><span class="std std-ref">Creation and Destruction of Streams</span></a> the following way:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">inputDev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">inputHost</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="w">               </span><span class="p">(</span><span class="n">outputDev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">inputDev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">outputHost</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">outputDev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaEventSynchronize</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">elapsedTime</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaEventElapsedTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elapsedTime</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">stop</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="synchronous-calls">
<span id="id69"></span><h4><span class="section-number">3.2.8.9. </span>Synchronous Calls<a class="headerlink" href="#synchronous-calls" title="Permalink to this headline">ï</a></h4>
<p>When a synchronous function is called, control is not returned to the host thread before the device has completed the requested task. Whether the host thread will then yield, block, or spin can be specified by calling <code class="docutils literal notranslate"><span class="pre">cudaSetDeviceFlags()</span></code>with some specific flags (see reference manual for details) before any other CUDA call is performed by the host thread.</p>
</section>
</section>
<section id="multi-device-system">
<span id="id70"></span><h3><span class="section-number">3.2.9. </span>Multi-Device System<a class="headerlink" href="#multi-device-system" title="Permalink to this headline">ï</a></h3>
<section id="device-enumeration">
<span id="id71"></span><h4><span class="section-number">3.2.9.1. </span>Device Enumeration<a class="headerlink" href="#device-enumeration" title="Permalink to this headline">ï</a></h4>
<p>A host system can have multiple devices. The following code sample shows how to enumerate these devices, query their properties, and determine the number of CUDA-enabled devices.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">deviceCount</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceCount</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">deviceCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Device %d has compute capability %d.%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">.</span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">.</span><span class="n">minor</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="device-selection">
<span id="id72"></span><h4><span class="section-number">3.2.9.2. </span>Device Selection<a class="headerlink" href="#device-selection" title="Permalink to this headline">ï</a></h4>
<p>A host thread can set the device it operates on at any time by calling <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code>. Device memory allocations and kernel launches are made on the currently set device; streams and events are created in association with the currently set device. If no call to <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> is made, the current device is device 0.</p>
<p>The following code sample illustrates how setting the current device affects memory allocation and kernel execution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">            </span><span class="c1">// Set device 0 as current</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">       </span><span class="c1">// Allocate memory on device 0</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Launch kernel on device 0</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">            </span><span class="c1">// Set device 1 as current</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">       </span><span class="c1">// Allocate memory on device 1</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Launch kernel on device 1</span>
</pre></div>
</div>
</section>
<section id="stream-and-event-behavior">
<span id="id73"></span><h4><span class="section-number">3.2.9.3. </span>Stream and Event Behavior<a class="headerlink" href="#stream-and-event-behavior" title="Permalink to this headline">ï</a></h4>
<p>A kernel launch will fail if it is issued to a stream that is not associated to the current device as illustrated in the following code sample.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">               </span><span class="c1">// Set device 0 as current</span>
<span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s0</span><span class="p">);</span><span class="w">          </span><span class="c1">// Create stream s0 on device 0</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Launch kernel on device 0 in s0</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">               </span><span class="c1">// Set device 1 as current</span>
<span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span><span class="w">          </span><span class="c1">// Create stream s1 on device 1</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Launch kernel on device 1 in s1</span>

<span class="c1">// This kernel launch will fail:</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Launch kernel on device 1 in s0</span>
</pre></div>
</div>
<p>A memory copy will succeed even if it is issued to a stream that is not associated to the current device.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaEventRecord()</span></code> will fail if the input event and input stream are associated to different devices.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaEventElapsedTime()</span></code> will fail if the two input events are associated to different devices.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaEventQuery()</span></code> will succeed even if the input event is associated to a device that is different from the current device.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code> will succeed even if the input stream and input event are associated to different devices. <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code> can therefore be used to synchronize multiple devices with each other.</p>
<p>Each device has its own default stream (see <a class="reference internal" href="#default-stream"><span class="std std-ref">Default Stream</span></a>), so commands issued to the default stream of a device may execute out of order or concurrently with respect to commands issued to the default stream of any other device.</p>
</section>
<section id="peer-to-peer-memory-access">
<span id="id74"></span><h4><span class="section-number">3.2.9.4. </span>Peer-to-Peer Memory Access<a class="headerlink" href="#peer-to-peer-memory-access" title="Permalink to this headline">ï</a></h4>
<p>Depending on the system properties, specifically the PCIe and/or NVLINK topology, devices are able to address each otherâs memory (i.e., a kernel executing on one device can dereference a pointer to the memory of the other device). This peer-to-peer memory access feature is supported between two devices if <code class="docutils literal notranslate"><span class="pre">cudaDeviceCanAccessPeer()</span></code> returns true for these two devices.</p>
<p>Peer-to-peer memory access is only supported in 64-bit applications and must be enabled between two devices by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceEnablePeerAccess()</span></code> as illustrated in the following code sample. On non-NVSwitch enabled systems, each device can support a system-wide maximum of eight peer connections.</p>
<p>A unified address space is used for both devices (see <a class="reference internal" href="#unified-virtual-address-space"><span class="std std-ref">Unified Virtual Address Space</span></a>), so the same pointer can be used to address memory from both devices as shown in the code sample below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 0 as current</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">              </span><span class="c1">// Allocate memory on device 0</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span><span class="w">        </span><span class="c1">// Launch kernel on device 0</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 1 as current</span>
<span class="n">cudaDeviceEnablePeerAccess</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">   </span><span class="c1">// Enable peer-to-peer access</span>
<span class="w">                                    </span><span class="c1">// with device 0</span>

<span class="c1">// Launch kernel on device 1</span>
<span class="c1">// This kernel launch can access memory on device 0 at address p0</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<section id="iommu-on-linux">
<span id="id75"></span><h5><span class="section-number">3.2.9.4.1. </span>IOMMU on Linux<a class="headerlink" href="#iommu-on-linux" title="Permalink to this headline">ï</a></h5>
<p>On Linux only, CUDA and the display driver does not support IOMMU-enabled bare-metal PCIe peer to peer memory copy. However, CUDA and the display driver does support IOMMU via VM pass through. As a consequence, users on Linux, when running on a native bare metal system, should disable the IOMMU. The IOMMU should be enabled and the VFIO driver be used as a PCIe pass through for virtual machines.</p>
<p>On Windows the above limitation does not exist.</p>
<p>See also <a class="reference external" href="https://download.nvidia.com/XFree86/Linux-x86_64/396.51/README/dma_issues.html">Allocating DMA Buffers on 64-bit Platforms</a>.</p>
</section>
</section>
<section id="peer-to-peer-memory-copy">
<span id="id76"></span><h4><span class="section-number">3.2.9.5. </span>Peer-to-Peer Memory Copy<a class="headerlink" href="#peer-to-peer-memory-copy" title="Permalink to this headline">ï</a></h4>
<p>Memory copies can be performed between the memories of two different devices.</p>
<p>When a unified address space is used for both devices (see <a class="reference internal" href="#unified-virtual-address-space"><span class="std std-ref">Unified Virtual Address Space</span></a>), this is done using the regular memory copy functions mentioned in <a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a>.</p>
<p>Otherwise, this is done using <code class="docutils literal notranslate"><span class="pre">cudaMemcpyPeer()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemcpyPeerAsync()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemcpy3DPeer()</span></code>, or <code class="docutils literal notranslate"><span class="pre">cudaMemcpy3DPeerAsync()</span></code> as illustrated in the following code sample.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 0 as current</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">              </span><span class="c1">// Allocate memory on device 0</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 1 as current</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w">              </span><span class="c1">// Allocate memory on device 1</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 0 as current</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span><span class="w">        </span><span class="c1">// Launch kernel on device 0</span>
<span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">                   </span><span class="c1">// Set device 1 as current</span>
<span class="n">cudaMemcpyPeer</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// Copy p0 to p1</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1000</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span><span class="w">        </span><span class="c1">// Launch kernel on device 1</span>
</pre></div>
</div>
<p>A copy (in the implicit <em>NULL</em> stream) between the memories of two different devices:</p>
<ul class="simple">
<li><p>does not start until all commands previously issued to either device have completed and</p></li>
<li><p>runs to completion before any commands (see <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>) issued after the copy to either device can start.</p></li>
</ul>
<p>Consistent with the normal behavior of streams, an asynchronous copy between the memories of two devices may overlap with copies or kernels in another stream.</p>
<p>Note that if peer-to-peer access is enabled between two devices via <code class="docutils literal notranslate"><span class="pre">cudaDeviceEnablePeerAccess()</span></code> as described in <a class="reference internal" href="#peer-to-peer-memory-access"><span class="std std-ref">Peer-to-Peer Memory Access</span></a>, peer-to-peer memory copy between these two devices no longer needs to be staged through the host and is therefore faster.</p>
</section>
</section>
<section id="unified-virtual-address-space">
<span id="id77"></span><h3><span class="section-number">3.2.10. </span>Unified Virtual Address Space<a class="headerlink" href="#unified-virtual-address-space" title="Permalink to this headline">ï</a></h3>
<p>When the application is run as a 64-bit process, a single address space is used for the host and all the devices of compute capability 2.0 and higher. All host memory allocations made via CUDA API calls and all device memory allocations on supported devices are within this virtual address range. As a consequence:</p>
<ul class="simple">
<li><p>The location of any memory on the host allocated through CUDA, or on any of the devices which use the unified address space, can be determined from the value of the pointer using <code class="docutils literal notranslate"><span class="pre">cudaPointerGetAttributes()</span></code>.</p></li>
<li><p>When copying to or from the memory of any device which uses the unified address space, the <code class="docutils literal notranslate"><span class="pre">cudaMemcpyKind</span></code> parameter of <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">cudaMemcpyDefault</span></code> to determine locations from the pointers. This also works for host pointers not allocated through CUDA, as long as the current device uses unified addressing.</p></li>
<li><p>Allocations via <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> are automatically portable (see <a class="reference internal" href="#portable-memory"><span class="std std-ref">Portable Memory</span></a>) across all the devices for which the unified address space is used, and pointers returned by <code class="docutils literal notranslate"><span class="pre">cudaHostAlloc()</span></code> can be used directly from within kernels running on these devices (i.e., there is no need to obtain a device pointer via <code class="docutils literal notranslate"><span class="pre">cudaHostGetDevicePointer()</span></code> as described in <a class="reference internal" href="#mapped-memory"><span class="std std-ref">Mapped Memory</span></a>.</p></li>
</ul>
<p>Applications may query if the unified address space is used for a particular device by checking that the <code class="docutils literal notranslate"><span class="pre">unifiedAddressing</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>) is equal to 1.</p>
</section>
<section id="interprocess-communication">
<span id="id78"></span><h3><span class="section-number">3.2.11. </span>Interprocess Communication<a class="headerlink" href="#interprocess-communication" title="Permalink to this headline">ï</a></h3>
<p>Any device memory pointer or event handle created by a host thread can be directly referenced by any other thread within the same process. It is not valid outside this process however, and therefore cannot be directly referenced by threads belonging to a different process.</p>
<p>To share device memory pointers and events across processes, an application must use the Inter Process Communication API, which is described in detail in the reference manual. The IPC API is only supported for 64-bit processes on Linux and for devices of compute capability 2.0 and higher. Note that the IPC API is not supported for <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> allocations.</p>
<p>Using this API, an application can get the IPC handle for a given device memory pointer using <code class="docutils literal notranslate"><span class="pre">cudaIpcGetMemHandle()</span></code>, pass it to another process using standard IPC mechanisms (for example, interprocess shared memory or files), and use <code class="docutils literal notranslate"><span class="pre">cudaIpcOpenMemHandle()</span></code> to retrieve a device pointer from the IPC handle that is a valid pointer within this other process. Event handles can be shared using similar entry points.</p>
<p>Note that allocations made by <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> may be sub-allocated from a larger block of memory for performance reasons. In such case, CUDA IPC APIs will share the entire underlying memory block which may cause other sub-allocations to be shared, which can potentially lead to information disclosure between processes. To prevent this behavior, it is recommended to only share allocations with a 2MiB aligned size.</p>
<p>An example of using the IPC API is where a single primary process generates a batch of input data, making the data available to multiple secondary processes without requiring regeneration or copying.</p>
<p>Applications using CUDA IPC to communicate with each other should be compiled, linked, and run with the same CUDA driver and runtime.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since CUDA 11.5, only events-sharing IPC APIs are supported on L4T and embedded Linux Tegra devices with compute capability 7.x and higher. The memory-sharing IPC APIs are still not supported on Tegra platforms.</p>
</div>
</section>
<section id="error-checking">
<span id="id79"></span><h3><span class="section-number">3.2.12. </span>Error Checking<a class="headerlink" href="#error-checking" title="Permalink to this headline">ï</a></h3>
<p>All runtime functions return an error code, but for an asynchronous function (see <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>), this error code cannot possibly report any of the asynchronous errors that could occur on the device since the function returns before the device has completed the task; the error code only reports errors that occur on the host prior to executing the task, typically related to parameter validation; if an asynchronous error occurs, it will be reported by some subsequent unrelated runtime function call.</p>
<p>The only way to check for asynchronous errors just after some asynchronous function call is therefore to synchronize just after the call by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> (or by using any other synchronization mechanisms described in <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>) and checking the error code returned by <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>.</p>
<p>The runtime maintains an error variable for each host thread that is initialized to <code class="docutils literal notranslate"><span class="pre">cudaSuccess</span></code> and is overwritten by the error code every time an error occurs (be it a parameter validation error or an asynchronous error). <code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError()</span></code> returns this variable. <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> returns this variable and resets it to <code class="docutils literal notranslate"><span class="pre">cudaSuccess</span></code>.</p>
<p>Kernel launches do not return any error code, so <code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> must be called just after the kernel launch to retrieve any pre-launch errors. To ensure that any error returned by <code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> does not originate from calls prior to the kernel launch, one has to make sure that the runtime error variable is set to <code class="docutils literal notranslate"><span class="pre">cudaSuccess</span></code> just before the kernel launch, for example, by calling <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> just before the kernel launch. Kernel launches are asynchronous, so to check for asynchronous errors, the application must synchronize in-between the kernel launch and the call to <code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">cudaErrorNotReady</span></code> that may be returned by <code class="docutils literal notranslate"><span class="pre">cudaStreamQuery()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaEventQuery()</span></code> is not considered an error and is therefore not reported by <code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code>.</p>
</section>
<section id="call-stack">
<span id="id80"></span><h3><span class="section-number">3.2.13. </span>Call Stack<a class="headerlink" href="#call-stack" title="Permalink to this headline">ï</a></h3>
<p>On devices of compute capability 2.x and higher, the size of the call stack can be queried using<code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code> and set using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code>.</p>
<p>When the call stack overflows, the kernel call fails with a stack overflow error if the application is run via a CUDA debugger (CUDA-GDB, Nsight) or an unspecified launch error, otherwise.
When the compiler cannot determine the stack size, it issues a warning saying Stack size cannot be statically determined. This is usually the case with recursive functions.
Once this warning is issued, user will need to set stack size manually if default stack size is not sufficient.</p>
</section>
<section id="texture-and-surface-memory">
<span id="id81"></span><h3><span class="section-number">3.2.14. </span>Texture and Surface Memory<a class="headerlink" href="#texture-and-surface-memory" title="Permalink to this headline">ï</a></h3>
<p>CUDA supports a subset of the texturing hardware that the GPU uses for graphics to access texture and surface memory. Reading data from texture or surface memory instead of global memory can have several performance benefits as described in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>.</p>
<section id="texture-memory">
<span id="id82"></span><h4><span class="section-number">3.2.14.1. </span>Texture Memory<a class="headerlink" href="#texture-memory" title="Permalink to this headline">ï</a></h4>
<p>Texture memory is read from kernels using the device functions described in <a class="reference internal" href="#texture-functions"><span class="std std-ref">Texture Functions</span></a>. The process of reading a texture calling one of these functions is called a <em>texture fetch</em>. Each texture fetch specifies a parameter called a <em>texture object</em> for the texture object API.</p>
<p>The texture object specifies:</p>
<ul class="simple">
<li><p>The <em>texture</em>, which is the piece of texture memory that is fetched. Texture objects are created at runtime and the texture is specified when creating the texture object as described in <a class="reference internal" href="#texture-object-api"><span class="std std-ref">Texture Object API</span></a>.</p></li>
<li><p>Its <em>dimensionality</em> that specifies whether the texture is addressed as a one dimensional array using one texture coordinate, a two-dimensional array using two texture coordinates, or a three-dimensional array using three texture coordinates. Elements of the array are called <em>texels</em>, short for <em>texture elements</em>. The <em>texture width</em>, <em>height</em>, and <em>depth</em> refer to the size of the array in each dimension. <cite>Table 21 &lt;features-and-technical-specifications-technical-specifications-per-compute-capability&gt;</cite> lists the maximum texture width, height, and depth depending on the compute capability of the device.</p></li>
<li><p>The type of a texel, which is restricted to the basic integer and single-precision floating-point types and any of the 1-, 2-, and 4-component vector types defined in <a class="reference internal" href="#built-in-vector-types"><span class="std std-ref">Built-in Vector Types</span></a> that are derived from the basic integer and single-precision floating-point types.</p></li>
<li><p>The <em>read mode</em>, which is equal to <code class="docutils literal notranslate"><span class="pre">cudaReadModeNormalizedFloat</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaReadModeElementType</span></code>. If it is <code class="docutils literal notranslate"><span class="pre">cudaReadModeNormalizedFloat</span></code> and the type of the texel is a 16-bit or 8-bit integer type, the value returned by the texture fetch is actually returned as floating-point type and the full range of the integer type is mapped to [0.0, 1.0] for unsigned integer type and [-1.0, 1.0] for signed integer type; for example, an unsigned 8-bit texture element with the value 0xff reads as 1. If it is <code class="docutils literal notranslate"><span class="pre">cudaReadModeElementType</span></code>, no conversion is performed.</p></li>
<li><p>Whether texture coordinates are normalized or not. By default, textures are referenced (by the functions of <a class="reference internal" href="#texture-functions"><span class="std std-ref">Texture Functions</span></a>) using floating-point coordinates in the range [0, N-1] where N is the size of the texture in the dimension corresponding to the coordinate. For example, a texture that is 64x32 in size will be referenced with coordinates in the range [0, 63] and [0, 31] for the x and y dimensions, respectively. Normalized texture coordinates cause the coordinates to be specified in the range [0.0, 1.0-1/N] instead of [0, N-1], so the same 64x32 texture would be addressed by normalized coordinates in the range [0, 1-1/N] in both the x and y dimensions. Normalized texture coordinates are a natural fit to some applicationsâ requirements, if it is preferable for the texture coordinates to be independent of the texture size.</p></li>
<li><p>The <em>addressing mode</em>. It is valid to call the device functions of Section B.8 with coordinates that are out of range. The addressing mode defines what happens in that case. The default addressing mode is to clamp the coordinates to the valid range: [0, N) for non-normalized coordinates and [0.0, 1.0) for normalized coordinates. If the border mode is specified instead, texture fetches with out-of-range texture coordinates return zero. For normalized coordinates, the wrap mode and the mirror mode are also available. When using the wrap mode, each coordinate x is converted to <em>frac(x)=x - floor(x)</em> where <em>floor(x)</em> is the largest integer not greater than <em>x</em>. When using the mirror mode, each coordinate <em>x</em> is converted to <em>frac(x)</em> if <em>floor(x)</em> is even and <em>1-frac(x)</em> if <em>floor(x)</em> is odd. The addressing mode is specified as an array of size three whose first, second, and third elements specify the addressing mode for the first, second, and third texture coordinates, respectively; the addressing mode are <code class="docutils literal notranslate"><span class="pre">cudaAddressModeBorder</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaAddressModeClamp</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaAddressModeWrap</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaAddressModeMirror</span></code>; <code class="docutils literal notranslate"><span class="pre">cudaAddressModeWrap</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaAddressModeMirror</span></code> are only supported for normalized texture coordinates</p></li>
<li><p>The <em>filtering</em> mode which specifies how the value returned when fetching the texture is computed based on the input texture coordinates. Linear texture filtering may be done only for textures that are configured to return floating-point data. It performs low-precision interpolation between neighboring texels. When enabled, the texels surrounding a texture fetch location are read and the return value of the texture fetch is interpolated based on where the texture coordinates fell between the texels. Simple linear interpolation is performed for one-dimensional textures, bilinear interpolation for two-dimensional textures, and trilinear interpolation for three-dimensional textures. <a class="reference internal" href="#texture-fetching"><span class="std std-ref">Texture Fetching</span></a> gives more details on texture fetching. The filtering mode is equal to <code class="docutils literal notranslate"><span class="pre">cudaFilterModePoint</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaFilterModeLinear</span></code>. If it is <code class="docutils literal notranslate"><span class="pre">cudaFilterModePoint</span></code>, the returned value is the texel whose texture coordinates are the closest to the input texture coordinates. If it is <code class="docutils literal notranslate"><span class="pre">cudaFilterModeLinear</span></code>, the returned value is the linear interpolation of the two (for a one-dimensional texture), four (for a two dimensional texture), or eight (for a three dimensional texture) texels whose texture coordinates are the closest to the input texture coordinates. <code class="docutils literal notranslate"><span class="pre">cudaFilterModeLinear</span></code> is only valid for returned values of floating-point type.</p></li>
</ul>
<p><a class="reference internal" href="#texture-object-api"><span class="std std-ref">Texture Object API</span></a> introduces the texture object API.</p>
<p><a class="reference internal" href="#sixteen-bit-floating-point-textures"><span class="std std-ref">16-Bit Floating-Point Textures</span></a> explains how to deal with 16-bit floating-point textures.</p>
<p>Textures can also be layered as described in <a class="reference internal" href="#layered-textures"><span class="std std-ref">Layered Textures</span></a>.</p>
<p><a class="reference internal" href="#cubemap-textures"><span class="std std-ref">Cubemap Textures</span></a> and <a class="reference internal" href="#cubemap-layered-textures"><span class="std std-ref">Cubemap Layered Textures</span></a> describe a special type of texture, the cubemap texture.</p>
<p><a class="reference internal" href="#texture-gather"><span class="std std-ref">Texture Gather</span></a> describes a special texture fetch, texture gather.</p>
<section id="texture-object-api">
<span id="id83"></span><h5><span class="section-number">3.2.14.1.1. </span>Texture Object API<a class="headerlink" href="#texture-object-api" title="Permalink to this headline">ï</a></h5>
<p>A texture object is created using <code class="docutils literal notranslate"><span class="pre">cudaCreateTextureObject()</span></code> from a resource description of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cudaResourceDesc</span></code>, which specifies the texture, and from a texture description defined as such:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">cudaTextureDesc</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaTextureAddressMode</span><span class="w"> </span><span class="n">addressMode</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaTextureFilterMode</span><span class="w">  </span><span class="n">filterMode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaTextureReadMode</span><span class="w">    </span><span class="n">readMode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">                         </span><span class="n">sRGB</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w">                         </span><span class="n">normalizedCoords</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">                </span><span class="n">maxAnisotropy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaTextureFilterMode</span><span class="w">  </span><span class="n">mipmapFilterMode</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w">                       </span><span class="n">mipmapLevelBias</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w">                       </span><span class="n">minMipmapLevelClamp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w">                       </span><span class="n">maxMipmapLevelClamp</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">addressMode</span></code> specifies the addressing mode;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">filterMode</span></code> specifies the filter mode;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">readMode</span></code> specifies the read mode;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">normalizedCoords</span></code> specifies whether texture coordinates are normalized or not;</p></li>
<li><p>See reference manual for <code class="docutils literal notranslate"><span class="pre">sRGB</span></code>, <code class="docutils literal notranslate"><span class="pre">maxAnisotropy</span></code>, <code class="docutils literal notranslate"><span class="pre">mipmapFilterMode</span></code>, <code class="docutils literal notranslate"><span class="pre">mipmapLevelBias</span></code>, <code class="docutils literal notranslate"><span class="pre">minMipmapLevelClamp</span></code>, and <code class="docutils literal notranslate"><span class="pre">maxMipmapLevelClamp</span></code>.</p></li>
</ul>
<p>The following code sample applies some simple transformation kernel to a texture.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple transformation kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">transformKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">float</span><span class="w"> </span><span class="n">theta</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Calculate normalized texture coordinates</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Transform coordinates</span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">tu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">tv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Read from texture and write to global memory</span>
<span class="w">    </span><span class="n">output</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tex2D</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="n">tu</span><span class="p">,</span><span class="w"> </span><span class="n">tv</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate and set some host data</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">h_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate CUDA array in device memory</span>
<span class="w">    </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="n">channelDesc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaCreateChannelDesc</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaArray_t</span><span class="w"> </span><span class="n">cuArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuArray</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channelDesc</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Set pitch of the source (the width in memory in bytes of the 2D array pointed</span>
<span class="w">    </span><span class="c1">// to by src, including padding), we dont have any padding</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">spitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Copy data located at address h_data in host memory to device memory</span>
<span class="w">    </span><span class="n">cudaMemcpy2DToArray</span><span class="p">(</span><span class="n">cuArray</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">h_data</span><span class="p">,</span><span class="w"> </span><span class="n">spitch</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Specify texture</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cudaResourceDesc</span><span class="w"> </span><span class="n">resDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">resDesc</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">resDesc</span><span class="p">.</span><span class="n">resType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaResourceTypeArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">resDesc</span><span class="p">.</span><span class="n">res</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuArray</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Specify texture object parameters</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cudaTextureDesc</span><span class="w"> </span><span class="n">texDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">texDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">texDesc</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">texDesc</span><span class="p">.</span><span class="n">addressMode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAddressModeWrap</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">texDesc</span><span class="p">.</span><span class="n">addressMode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaAddressModeWrap</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">texDesc</span><span class="p">.</span><span class="n">filterMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaFilterModeLinear</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">texDesc</span><span class="p">.</span><span class="n">readMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaReadModeElementType</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">texDesc</span><span class="p">.</span><span class="n">normalizedCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create texture object</span>
<span class="w">    </span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaCreateTextureObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resDesc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texDesc</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate result of transformation in device memory</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">numBlocks</span><span class="p">((</span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="n">height</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">transformKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                    </span><span class="n">angle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Copy data from device back to host</span>
<span class="w">    </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">h_data</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"></span>
<span class="w">                </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Destroy texture object</span>
<span class="w">    </span><span class="n">cudaDestroyTextureObject</span><span class="p">(</span><span class="n">texObj</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free device memory</span>
<span class="w">    </span><span class="n">cudaFreeArray</span><span class="p">(</span><span class="n">cuArray</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">output</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free host memory</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">h_data</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="bit-floating-point-textures">
<span id="sixteen-bit-floating-point-textures"></span><h5><span class="section-number">3.2.14.1.2. </span>16-Bit Floating-Point Textures<a class="headerlink" href="#bit-floating-point-textures" title="Permalink to this headline">ï</a></h5>
<p>The 16-bit floating-point or <em>half</em> format supported by CUDA arrays is the same as the IEEE 754-2008 binary2 format.</p>
<p>CUDA C++ does not support a matching data type, but provides intrinsic functions to convert to and from the 32-bit floating-point format via the <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code> type: <code class="docutils literal notranslate"><span class="pre">__float2half_rn(float)</span></code> and <code class="docutils literal notranslate"><span class="pre">__half2float(unsigned</span> <span class="pre">short)</span></code>. These functions are only supported in device code. Equivalent functions for the host code can be found in the OpenEXR library, for example.</p>
<p>16-bit floating-point components are promoted to 32 bit float during texture fetching before any filtering is performed.</p>
<p>A channel description for the 16-bit floating-point format can be created by calling one of the <code class="docutils literal notranslate"><span class="pre">cudaCreateChannelDescHalf*()</span></code> functions.</p>
</section>
<section id="layered-textures">
<span id="id84"></span><h5><span class="section-number">3.2.14.1.3. </span>Layered Textures<a class="headerlink" href="#layered-textures" title="Permalink to this headline">ï</a></h5>
<p>A one-dimensional or two-dimensional layered texture (also known as <em>texture array</em> in Direct3D and <em>array texture</em> in OpenGL) is a texture made up of a sequence of layers, all of which are regular textures of same dimensionality, size, and data type.</p>
<p>A one-dimensional layered texture is addressed using an integer index and a floating-point texture coordinate; the index denotes a layer within the sequence and the coordinate addresses a texel within that layer. A two-dimensional layered texture is addressed using an integer index and two floating-point texture coordinates; the index denotes a layer within the sequence and the coordinates address a texel within that layer.</p>
<p>A layered texture can only be a CUDA array by calling <code class="docutils literal notranslate"><span class="pre">cudaMalloc3DArray()</span></code> with the <code class="docutils literal notranslate"><span class="pre">cudaArrayLayered</span></code> flag (and a height of zero for one-dimensional layered texture).</p>
<p>Layered textures are fetched using the device functions described in <a class="reference internal" href="#tex1dlayered-object"><span class="std std-ref">tex1DLayered()</span></a> and <a class="reference internal" href="#tex2dlayered-object"><span class="std std-ref">tex2DLayered()</span></a>. Texture filtering (see <a class="reference internal" href="#texture-fetching"><span class="std std-ref">Texture Fetching</span></a>) is done only within a layer, not across layers.</p>
<p>Layered textures are only supported on devices of compute capability 2.0 and higher.</p>
</section>
<section id="cubemap-textures">
<span id="id85"></span><h5><span class="section-number">3.2.14.1.4. </span>Cubemap Textures<a class="headerlink" href="#cubemap-textures" title="Permalink to this headline">ï</a></h5>
<p>A <em>cubemap</em> texture is a special type of two-dimensional layered texture that has six layers representing the faces of a cube:</p>
<ul class="simple">
<li><p>The width of a layer is equal to its height.</p></li>
<li><p>The cubemap is addressed using three texture coordinates <em>x</em>, <em>y</em>, and <em>z</em> that are interpreted as a direction vector emanating from the center of the cube and pointing to one face of the cube and a texel within the layer corresponding to that face. More specifically, the face is selected by the coordinate with largest magnitude <em>m</em> and the corresponding layer is addressed using coordinates <em>(s/m+1)/2</em> and <em>(t/m+1)/2</em> where <em>s</em> and <em>t</em> are defined in <a class="reference internal" href="#cubemap-textures-cubemap-fetch"><span class="std std-ref">Table 3</span></a>.</p></li>
</ul>
<table class="table-no-stripes docutils align-default" id="cubemap-textures-cubemap-fetch">
<caption><span class="caption-number">Table 6 </span><span class="caption-text">Cubemap Fetch</span><a class="headerlink" href="#cubemap-textures-cubemap-fetch" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 58%" />
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"></th>
<th class="head"><p>face</p></th>
<th class="head"><p>m</p></th>
<th class="head"><p>s</p></th>
<th class="head"><p>t</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p><code class="docutils literal notranslate"><span class="pre">|x|</span> <span class="pre">&gt;</span> <span class="pre">|y|</span></code> and <code class="docutils literal notranslate"><span class="pre">|x|</span> <span class="pre">&gt;</span> <span class="pre">|z|</span></code></p></td>
<td><p>x â¥ 0</p></td>
<td><p>0</p></td>
<td><p>x</p></td>
<td><p>-z</p></td>
<td><p>-y</p></td>
</tr>
<tr class="row-odd"><td><p>x &lt; 0</p></td>
<td><p>1</p></td>
<td><p>-x</p></td>
<td><p>z</p></td>
<td><p>-y</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><code class="docutils literal notranslate"><span class="pre">|y|</span> <span class="pre">&gt;</span> <span class="pre">|x|</span></code> and <code class="docutils literal notranslate"><span class="pre">|y|</span> <span class="pre">&gt;</span> <span class="pre">|z|</span></code></p></td>
<td><p>y â¥ 0</p></td>
<td><p>2</p></td>
<td><p>y</p></td>
<td><p>x</p></td>
<td><p>z</p></td>
</tr>
<tr class="row-odd"><td><p>y &lt; 0</p></td>
<td><p>3</p></td>
<td><p>-y</p></td>
<td><p>x</p></td>
<td><p>-z</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><code class="docutils literal notranslate"><span class="pre">|z|</span> <span class="pre">&gt;</span> <span class="pre">|x|</span></code> and <code class="docutils literal notranslate"><span class="pre">|z|</span> <span class="pre">&gt;</span> <span class="pre">|y|</span></code></p></td>
<td><p>z â¥ 0</p></td>
<td><p>4</p></td>
<td><p>z</p></td>
<td><p>x</p></td>
<td><p>-y</p></td>
</tr>
<tr class="row-odd"><td><p>z &lt; 0</p></td>
<td><p>5</p></td>
<td><p>-z</p></td>
<td><p>-x</p></td>
<td><p>-y</p></td>
</tr>
</tbody>
</table>
<p>A cubemap texture can only be a CUDA array by calling <code class="docutils literal notranslate"><span class="pre">cudaMalloc3DArray()</span></code> with the <code class="docutils literal notranslate"><span class="pre">cudaArrayCubemap</span></code> flag.</p>
<p>Cubemap textures are fetched using the device function described in <a class="reference internal" href="#texcubemap-object"><span class="std std-ref">texCubemap()</span></a>.</p>
<p>Cubemap textures are only supported on devices of compute capability 2.0 and higher.</p>
</section>
<section id="cubemap-layered-textures">
<span id="id86"></span><h5><span class="section-number">3.2.14.1.5. </span>Cubemap Layered Textures<a class="headerlink" href="#cubemap-layered-textures" title="Permalink to this headline">ï</a></h5>
<p>A <em>cubemap layered</em> texture is a layered texture whose layers are cubemaps of same dimension.</p>
<p>A cubemap layered texture is addressed using an integer index and three floating-point texture coordinates; the index denotes a cubemap within the sequence and the coordinates address a texel within that cubemap.</p>
<p>A cubemap layered texture can only be a CUDA array by calling <code class="docutils literal notranslate"><span class="pre">cudaMalloc3DArray()</span></code> with the <code class="docutils literal notranslate"><span class="pre">cudaArrayLayered</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaArrayCubemap</span></code> flags.</p>
<p>Cubemap layered textures are fetched using the device function described in <a class="reference internal" href="#texcubemaplayered-object"><span class="std std-ref">texCubemapLayered()</span></a>. Texture filtering (see <a class="reference internal" href="#texture-fetching"><span class="std std-ref">Texture Fetching</span></a>) is done only within a layer, not across layers.</p>
<p>Cubemap layered textures are only supported on devices of compute capability 2.0 and higher.</p>
</section>
<section id="texture-gather">
<span id="id87"></span><h5><span class="section-number">3.2.14.1.6. </span>Texture Gather<a class="headerlink" href="#texture-gather" title="Permalink to this headline">ï</a></h5>
<p>Texture gather is a special texture fetch that is available for two-dimensional textures only. It is performed by the <code class="docutils literal notranslate"><span class="pre">tex2Dgather()</span></code> function, which has the same parameters as <code class="docutils literal notranslate"><span class="pre">tex2D()</span></code>, plus an additional <code class="docutils literal notranslate"><span class="pre">comp</span></code> parameter equal to 0, 1, 2, or 3 (see <a class="reference internal" href="#tex2dgather-object"><span class="std std-ref">tex2Dgather()</span></a>). It returns four 32-bit numbers that correspond to the value of the component <code class="docutils literal notranslate"><span class="pre">comp</span></code> of each of the four texels that would have been used for bilinear filtering during a regular texture fetch. For example, if these texels are of values (253, 20, 31, 255), (250, 25, 29, 254), (249, 16, 37, 253), (251, 22, 30, 250), and <code class="docutils literal notranslate"><span class="pre">comp</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">tex2Dgather()</span></code> returns (31, 29, 37, 30).</p>
<p>Note that texture coordinates are computed with only 8 bits of fractional precision. <code class="docutils literal notranslate"><span class="pre">tex2Dgather()</span></code> may therefore return unexpected results for cases where <code class="docutils literal notranslate"><span class="pre">tex2D()</span></code> would use 1.0 for one of its weights (Î± or Î², see <a class="reference internal" href="#linear-filtering"><span class="std std-ref">Linear Filtering</span></a>). For example, with an <em>x</em> texture coordinate of 2.49805: <em>xB=x-0.5=1.99805</em>, however the fractional part of <em>xB</em> is stored in an 8-bit fixed-point format. Since 0.99805 is closer to 256.f/256.f than it is to 255.f/256.f, <em>xB</em> has the value 2. A <code class="docutils literal notranslate"><span class="pre">tex2Dgather()</span></code> in this case would therefore return indices 2 and 3 in <em>x</em>, instead of indices 1 and 2.</p>
<p>Texture gather is only supported for CUDA arrays created with the <code class="docutils literal notranslate"><span class="pre">cudaArrayTextureGather</span></code> flag and of width and height less than the maximum specified in <a class="reference internal" href="#features-and-technical-specifications-technical-specifications-per-compute-capability"><span class="std std-ref">Table 21</span></a> for texture gather, which is smaller than for regular texture fetch.</p>
<p>Texture gather is only supported on devices of compute capability 2.0 and higher.</p>
</section>
</section>
<section id="surface-memory">
<span id="id88"></span><h4><span class="section-number">3.2.14.2. </span>Surface Memory<a class="headerlink" href="#surface-memory" title="Permalink to this headline">ï</a></h4>
<p>For devices of compute capability 2.0 and higher, a CUDA array (described in <a class="reference internal" href="#cubemap-surfaces"><span class="std std-ref">Cubemap Surfaces</span></a>), created with the <code class="docutils literal notranslate"><span class="pre">cudaArraySurfaceLoadStore</span></code> flag, can be read and written via a <em>surface object</em> using the functions described in <a class="reference internal" href="#surface-functions"><span class="std std-ref">Surface Functions</span></a>.</p>
<p><a class="reference internal" href="#features-and-technical-specifications-technical-specifications-per-compute-capability"><span class="std std-ref">Table 21</span></a> lists the maximum surface width, height, and depth depending on the compute capability of the device.</p>
<section id="surface-object-api">
<span id="id89"></span><h5><span class="section-number">3.2.14.2.1. </span>Surface Object API<a class="headerlink" href="#surface-object-api" title="Permalink to this headline">ï</a></h5>
<p>A surface object is created using <code class="docutils literal notranslate"><span class="pre">cudaCreateSurfaceObject()</span></code> from a resource description of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cudaResourceDesc</span></code>. Unlike
texture memory, surface memory uses byte addressing. This means that the x-coordinate used to access a texture element via texture functions
needs to be multiplied by the byte size of the element to access the same element via a surface function. For example, the element at
texture coordinate x of a one-dimensional floating-point CUDA array bound to a texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> and a surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code>
is read using <code class="docutils literal notranslate"><span class="pre">tex1d(texObj,</span> <span class="pre">x)</span></code> via <code class="docutils literal notranslate"><span class="pre">texObj</span></code>, but <code class="docutils literal notranslate"><span class="pre">surf1Dread(surfObj,</span> <span class="pre">4*x)</span></code> via <code class="docutils literal notranslate"><span class="pre">surfObj</span></code>. Similarly, the element at texture
coordinate x and y of a two-dimensional floating-point CUDA array bound to a texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> and a surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code>
is accessed using <code class="docutils literal notranslate"><span class="pre">tex2d(texObj,</span> <span class="pre">x,</span> <span class="pre">y)</span></code> via <code class="docutils literal notranslate"><span class="pre">texObj</span></code>, but <code class="docutils literal notranslate"><span class="pre">surf2Dread(surfObj,</span> <span class="pre">4*x,</span> <span class="pre">y)</span></code> via <code class="docutils literal notranslate"><span class="pre">surObj</span></code> (the byte offset of the
y-coordinate is internally calculated from the underlying line pitch of the CUDA array).</p>
<p>The following code sample applies some simple transformation kernel to a surface.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple copy kernel</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">copyKernel</span><span class="p">(</span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">inputSurfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">outputSurfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Calculate surface coordinates</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">uchar4</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Read from input surface</span>
<span class="w">        </span><span class="n">surf2Dread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w">  </span><span class="n">inputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Write to output surface</span>
<span class="w">        </span><span class="n">surf2Dwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">outputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate and set some host data</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">h_data</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">h_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate CUDA arrays in device memory</span>
<span class="w">    </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="n">channelDesc</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaCreateChannelDesc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaArray_t</span><span class="w"> </span><span class="n">cuInputArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuInputArray</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channelDesc</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">cudaArraySurfaceLoadStore</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaArray_t</span><span class="w"> </span><span class="n">cuOutputArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuOutputArray</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channelDesc</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="n">cudaArraySurfaceLoadStore</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Set pitch of the source (the width in memory in bytes of the 2D array</span>
<span class="w">    </span><span class="c1">// pointed to by src, including padding), we dont have any padding</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">spitch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Copy data located at address h_data in host memory to device memory</span>
<span class="w">    </span><span class="n">cudaMemcpy2DToArray</span><span class="p">(</span><span class="n">cuInputArray</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">h_data</span><span class="p">,</span><span class="w"> </span><span class="n">spitch</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">),</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Specify surface</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cudaResourceDesc</span><span class="w"> </span><span class="n">resDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">resDesc</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">resDesc</span><span class="p">.</span><span class="n">resType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaResourceTypeArray</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create the surface objects</span>
<span class="w">    </span><span class="n">resDesc</span><span class="p">.</span><span class="n">res</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuInputArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">inputSurfObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaCreateSurfaceObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resDesc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">resDesc</span><span class="p">.</span><span class="n">res</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuOutputArray</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">outputSurfObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaCreateSurfaceObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resDesc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">threadsperBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="nf">numBlocks</span><span class="p">((</span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="n">height</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">copyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"> </span><span class="n">threadsperBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">inputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="n">outputSurfObj</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy data from device back to host</span>
<span class="w">    </span><span class="n">cudaMemcpy2DFromArray</span><span class="p">(</span><span class="n">h_data</span><span class="p">,</span><span class="w"> </span><span class="n">spitch</span><span class="p">,</span><span class="w"> </span><span class="n">cuOutputArray</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">),</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Destroy surface objects</span>
<span class="w">    </span><span class="n">cudaDestroySurfaceObject</span><span class="p">(</span><span class="n">inputSurfObj</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDestroySurfaceObject</span><span class="p">(</span><span class="n">outputSurfObj</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free device memory</span>
<span class="w">    </span><span class="n">cudaFreeArray</span><span class="p">(</span><span class="n">cuInputArray</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFreeArray</span><span class="p">(</span><span class="n">cuOutputArray</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free host memory</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">h_data</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="cubemap-surfaces">
<span id="id90"></span><h5><span class="section-number">3.2.14.2.2. </span>Cubemap Surfaces<a class="headerlink" href="#cubemap-surfaces" title="Permalink to this headline">ï</a></h5>
<p>Cubemap surfaces are accessed using<code class="docutils literal notranslate"><span class="pre">surfCubemapread()</span></code> and <code class="docutils literal notranslate"><span class="pre">surfCubemapwrite()</span></code> (<a class="reference internal" href="#surfcubemapread-object"><span class="std std-ref">surfCubemapread()</span></a> and <a class="reference internal" href="#surfcubemapwrite-object"><span class="std std-ref">surfCubemapwrite()</span></a>) as a two-dimensional layered surface, i.e., using an integer index denoting a face and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in <a class="reference internal" href="#cubemap-textures-cubemap-fetch"><span class="std std-ref">Table 3</span></a>.</p>
</section>
<section id="cubemap-layered-surfaces">
<span id="cubemap-layered-sufaces"></span><h5><span class="section-number">3.2.14.2.3. </span>Cubemap Layered Surfaces<a class="headerlink" href="#cubemap-layered-surfaces" title="Permalink to this headline">ï</a></h5>
<p>Cubemap layered surfaces are accessed using <code class="docutils literal notranslate"><span class="pre">surfCubemapLayeredread()</span></code> and <code class="docutils literal notranslate"><span class="pre">surfCubemapLayeredwrite()</span></code> (<a class="reference internal" href="#surfcubemaplayeredread-object"><span class="std std-ref">surfCubemapLayeredread()</span></a> and <a class="reference internal" href="#surfcubemaplayeredwrite-object"><span class="std std-ref">surfCubemapLayeredwrite()</span></a>) as a two-dimensional layered surface, i.e., using an integer index denoting a face of one of the cubemaps and two floating-point texture coordinates addressing a texel within the layer corresponding to this face. Faces are ordered as indicated in <a class="reference internal" href="#cubemap-textures-cubemap-fetch"><span class="std std-ref">Table 3</span></a>, so index ((2 * 6) + 3), for example, accesses the fourth face of the third cubemap.</p>
</section>
</section>
<section id="cuda-arrays">
<h4><span class="section-number">3.2.14.3. </span>CUDA Arrays<a class="headerlink" href="#cuda-arrays" title="Permalink to this headline">ï</a></h4>
<p>CUDA arrays are opaque memory layouts optimized for texture fetching. They are one dimensional, two dimensional, or three-dimensional and composed of elements, each of which has 1, 2 or 4 components that may be signed or unsigned 8-, 16-, or 32-bit integers, 16-bit floats, or 32-bit floats. CUDA arrays are only accessible by kernels through texture fetching as described in <a class="reference internal" href="#texture-memory"><span class="std std-ref">Texture Memory</span></a> or surface reading and writing as described in <a class="reference internal" href="#surface-memory"><span class="std std-ref">Surface Memory</span></a>.</p>
</section>
<section id="read-write-coherency">
<span id="id91"></span><h4><span class="section-number">3.2.14.4. </span>Read/Write Coherency<a class="headerlink" href="#read-write-coherency" title="Permalink to this headline">ï</a></h4>
<p>The texture and surface memory is cached (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>) and within the same kernel call, the cache is not kept coherent with respect to global memory writes and surface memory writes, so any texture fetch or surface read to an address that has been written to via a global write or a surface write in the same kernel call returns undefined data. In other words, a thread can safely read some texture or surface memory location only if this memory location has been updated by a previous kernel call or memory copy, but not if it has been previously updated by the same thread or another thread from the same kernel call.</p>
</section>
</section>
<section id="graphics-interoperability">
<span id="id92"></span><h3><span class="section-number">3.2.15. </span>Graphics Interoperability<a class="headerlink" href="#graphics-interoperability" title="Permalink to this headline">ï</a></h3>
<p>Some resources from OpenGL and Direct3D may be mapped into the address space of CUDA, either to enable CUDA to read data written by OpenGL or Direct3D, or to enable CUDA to write data for consumption by OpenGL or Direct3D.</p>
<p>A resource must be registered to CUDA before it can be mapped using the functions mentioned in <a class="reference internal" href="#opengl-interoperability"><span class="std std-ref">OpenGL Interoperability</span></a> and <a class="reference internal" href="#direct3d-interoperability"><span class="std std-ref">Direct3D Interoperability</span></a>. These functions return a pointer to a CUDA graphics resource of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cudaGraphicsResource</span></code>. Registering a resource is potentially high-overhead and therefore typically called only once per resource. A CUDA graphics resource is unregistered using <code class="docutils literal notranslate"><span class="pre">cudaGraphicsUnregisterResource()</span></code>. Each CUDA context which intends to use the resource is required to register it separately.</p>
<p>Once a resource is registered to CUDA, it can be mapped and unmapped as many times as necessary using <code class="docutils literal notranslate"><span class="pre">cudaGraphicsMapResources()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGraphicsUnmapResources()</span></code>. <code class="docutils literal notranslate"><span class="pre">cudaGraphicsResourceSetMapFlags()</span></code> can be called to specify usage hints (write-only, read-only) that the CUDA driver can use to optimize resource management.</p>
<p>A mapped resource can be read from or written to by kernels using the device memory address returned by <code class="docutils literal notranslate"><span class="pre">cudaGraphicsResourceGetMappedPointer()</span></code> for buffers and<code class="docutils literal notranslate"><span class="pre">cudaGraphicsSubResourceGetMappedArray()</span></code> for CUDA arrays.</p>
<p>Accessing a resource through OpenGL, Direct3D, or another CUDA context while it is mapped produces undefined results. <a class="reference internal" href="#opengl-interoperability"><span class="std std-ref">OpenGL Interoperability</span></a> and <a class="reference internal" href="#direct3d-interoperability"><span class="std std-ref">Direct3D Interoperability</span></a> give specifics for each graphics API and some code samples. <a class="reference internal" href="#sli-interoperability"><span class="std std-ref">SLI Interoperability</span></a> gives specifics for when the system is in SLI mode.</p>
<section id="opengl-interoperability">
<span id="id93"></span><h4><span class="section-number">3.2.15.1. </span>OpenGL Interoperability<a class="headerlink" href="#opengl-interoperability" title="Permalink to this headline">ï</a></h4>
<p>The OpenGL resources that may be mapped into the address space of CUDA are OpenGL buffer, texture, and renderbuffer objects.</p>
<p>A buffer object is registered using <code class="docutils literal notranslate"><span class="pre">cudaGraphicsGLRegisterBuffer()</span></code>. In CUDA, it appears as a device pointer and can therefore be read and written by kernels or via <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code> calls.</p>
<p>A texture or renderbuffer object is registered using <code class="docutils literal notranslate"><span class="pre">cudaGraphicsGLRegisterImage()</span></code>. In CUDA, it appears as a CUDA array. Kernels can read from the array by binding it to a texture or surface reference. They can also write to it via the surface write functions if the resource has been registered with the <code class="docutils literal notranslate"><span class="pre">cudaGraphicsRegisterFlagsSurfaceLoadStore</span></code> flag. The array can also be read and written via <code class="docutils literal notranslate"><span class="pre">cudaMemcpy2D()</span></code> calls. <code class="docutils literal notranslate"><span class="pre">cudaGraphicsGLRegisterImage()</span></code> supports all texture formats with 1, 2, or 4 components and an internal type of float (for example, <code class="docutils literal notranslate"><span class="pre">GL_RGBA_FLOAT32</span></code>), normalized integer (for example, <code class="docutils literal notranslate"><span class="pre">GL_RGBA8,</span> <span class="pre">GL_INTENSITY16</span></code>), and unnormalized integer (for example, <code class="docutils literal notranslate"><span class="pre">GL_RGBA8UI</span></code>) (please note that since unnormalized integer formats require OpenGL 3.0, they can only be written by shaders, not the fixed function pipeline).</p>
<p>The OpenGL context whose resources are being shared has to be current to the host thread making any OpenGL interoperability API calls.</p>
<p>Please note: When an OpenGL texture is made bindless (say for example by requesting an image or texture handle using the <code class="docutils literal notranslate"><span class="pre">glGetTextureHandle</span></code>*/<code class="docutils literal notranslate"><span class="pre">glGetImageHandle</span></code>* APIs) it cannot be registered with CUDA. The application needs to register the texture for interop before requesting an image or texture handle.</p>
<p>The following code sample uses a kernel to dynamically modify a 2D <code class="docutils literal notranslate"><span class="pre">width</span></code> x <code class="docutils literal notranslate"><span class="pre">height</span></code> grid of vertices stored in a vertex buffer object:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">positionsVBO</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cudaGraphicsResource</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVBO_CUDA</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialize OpenGL and GLUT for device 0</span>
<span class="w">    </span><span class="c1">// and make the OpenGL context current</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">glutDisplayFunc</span><span class="p">(</span><span class="n">display</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Explicitly set device 0</span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create buffer object and register it with CUDA</span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVBO</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">positionsVBO</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_DYNAMIC_DRAW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsGLRegisterBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">positionsVBO_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">positionsVBO</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">cudaGraphicsMapFlagsWriteDiscard</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch rendering loop</span>
<span class="w">    </span><span class="n">glutMainLoop</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">display</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Map buffer object for writing from CUDA</span>
<span class="w">    </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsMapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVBO_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceGetMappedPointer</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">positions</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">positionsVBO_CUDA</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Execute kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">createVertices</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Unmap buffer object</span>
<span class="w">    </span><span class="n">cudaGraphicsUnmapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVBO_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Render from buffer object</span>
<span class="w">    </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">positionsVBO</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glVertexPointer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Swap buffers</span>
<span class="w">    </span><span class="n">glutSwapBuffers</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">glutPostRedisplay</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">deleteVBO</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsUnregisterResource</span><span class="p">(</span><span class="n">positionsVBO_CUDA</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVBO</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">createVertices</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate uv coordinates</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// calculate simple sine wave pattern</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Write positions</span>
<span class="w">    </span><span class="n">positions</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_float4</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>On Windows and for Quadro GPUs, <code class="docutils literal notranslate"><span class="pre">cudaWGLGetDevice()</span></code> can be used to retrieve the CUDA device associated to the handle returned by <code class="docutils literal notranslate"><span class="pre">wglEnumGpusNV()</span></code>. Quadro GPUs offer higher performance OpenGL interoperability than GeForce and Tesla GPUs in a multi-GPU configuration where OpenGL rendering is performed on the Quadro GPU and CUDA computations are performed on other GPUs in the system.</p>
</section>
<section id="direct3d-interoperability">
<span id="id94"></span><h4><span class="section-number">3.2.15.2. </span>Direct3D Interoperability<a class="headerlink" href="#direct3d-interoperability" title="Permalink to this headline">ï</a></h4>
<p>Direct3D interoperability is supported for Direct3D 9Ex, Direct3D 10, and Direct3D 11.</p>
<p>A CUDA context may interoperate only with Direct3D devices that fulfill the following criteria: Direct3D 9Ex devices must be created with <code class="docutils literal notranslate"><span class="pre">DeviceType</span></code> set to <code class="docutils literal notranslate"><span class="pre">D3DDEVTYPE_HAL</span></code> and <code class="docutils literal notranslate"><span class="pre">BehaviorFlags</span></code> with the <code class="docutils literal notranslate"><span class="pre">D3DCREATE_HARDWARE_VERTEXPROCESSING</span></code> flag; Direct3D 10 and Direct3D 11 devices must be created with <code class="docutils literal notranslate"><span class="pre">DriverType</span></code> set to <code class="docutils literal notranslate"><span class="pre">D3D_DRIVER_TYPE_HARDWARE</span></code>.</p>
<p>The Direct3D resources that may be mapped into the address space of CUDA are Direct3D buffers, textures, and surfaces. These resources are registered using <code class="docutils literal notranslate"><span class="pre">cudaGraphicsD3D9RegisterResource()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaGraphicsD3D10RegisterResource()</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaGraphicsD3D11RegisterResource()</span></code>.</p>
<p>The following code sample uses a kernel to dynamically modify a 2D <code class="docutils literal notranslate"><span class="pre">width</span></code> x <code class="docutils literal notranslate"><span class="pre">height</span></code> grid of vertices stored in a vertex buffer object.</p>
<section id="direct3d-9-version">
<span id="id95"></span><h5><span class="section-number">3.2.15.2.1. </span>Direct3D 9 Version<a class="headerlink" href="#direct3d-9-version" title="Permalink to this headline">ï</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">IDirect3D9</span><span class="o">*</span><span class="w"> </span><span class="n">D3D</span><span class="p">;</span><span class="w"></span>
<span class="n">IDirect3DDevice9</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CUSTOMVERTEX</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FLOAT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">DWORD</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">IDirect3DVertexBuffer9</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cudaGraphicsResource</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB_CUDA</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialize Direct3D</span>
<span class="w">    </span><span class="n">D3D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Direct3DCreate9Ex</span><span class="p">(</span><span class="n">D3D_SDK_VERSION</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get a CUDA-enabled adapter</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">adapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">adapter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_pD3D</span><span class="o">-&gt;</span><span class="n">GetAdapterCount</span><span class="p">();</span><span class="w"> </span><span class="n">adapter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">D3DADAPTER_IDENTIFIER9</span><span class="w"> </span><span class="n">adapterId</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">g_pD3D</span><span class="o">-&gt;</span><span class="n">GetAdapterIdentifier</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">adapterId</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaD3D9GetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">adapterId</span><span class="p">.</span><span class="n">DeviceName</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">     </span><span class="c1">// Create device</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">D3D</span><span class="o">-&gt;</span><span class="n">CreateDeviceEx</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span><span class="w"> </span><span class="n">D3DDEVTYPE_HAL</span><span class="p">,</span><span class="w"> </span><span class="n">hWnd</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">D3DCREATE_HARDWARE_VERTEXPROCESSING</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use the same device</span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create vertex buffer and register it with CUDA</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUSTOMVERTEX</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateVertexBuffer</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">D3DFVF_CUSTOMVERTEX</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">D3DPOOL_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsD3D9RegisterResource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="n">positionsVB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="n">cudaGraphicsRegisterFlagsNone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceSetMapFlags</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">cudaGraphicsMapFlagsWriteDiscard</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch rendering loop</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">Render</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Render</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Map vertex buffer for writing from CUDA</span>
<span class="w">    </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsMapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceGetMappedPointer</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">positions</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">positionsVB_CUDA</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Execute kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">createVertices</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Unmap vertex buffer</span>
<span class="w">    </span><span class="n">cudaGraphicsUnmapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Draw and present</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">releaseVB</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsUnregisterResource</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">positionsVB</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">createVertices</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate uv coordinates</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate simple sine wave pattern</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Write positions</span>
<span class="w">    </span><span class="n">positions</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                </span><span class="n">make_float4</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">__int_as_float</span><span class="p">(</span><span class="mh">0xff00ff00</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="direct3d-10-version">
<span id="id96"></span><h5><span class="section-number">3.2.15.2.2. </span>Direct3D 10 Version<a class="headerlink" href="#direct3d-10-version" title="Permalink to this headline">ï</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ID3D10Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CUSTOMVERTEX</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FLOAT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">DWORD</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">ID3D10Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cudaGraphicsResource</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB_CUDA</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Get a CUDA-enabled adapter</span>
<span class="w">    </span><span class="n">IDXGIFactory</span><span class="o">*</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CreateDXGIFactory</span><span class="p">(</span><span class="n">__uuidof</span><span class="p">(</span><span class="n">IDXGIFactory</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">factory</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">IDXGIAdapter</span><span class="o">*</span><span class="w"> </span><span class="n">adapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">!</span><span class="n">adapter</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">EnumAdapters</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">adapter</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaD3D10GetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">adapter</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create swap chain and device</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">D3D10CreateDeviceAndSwapChain</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">D3D10_DRIVER_TYPE_HARDWARE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">D3D10_CREATE_DEVICE_DEBUG</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">D3D10_SDK_VERSION</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="o">&amp;</span><span class="n">swapChainDesc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapChain</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use the same device</span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create vertex buffer and register it with CUDA</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUSTOMVERTEX</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">D3D10_BUFFER_DESC</span><span class="w"> </span><span class="n">bufferDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">Usage</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">D3D10_USAGE_DEFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">ByteWidth</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">BindFlags</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">D3D10_BIND_VERTEX_BUFFER</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">CPUAccessFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">MiscFlags</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsD3D10RegisterResource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">positionsVB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">cudaGraphicsRegisterFlagsNone</span><span class="p">);</span><span class="w"></span>
<span class="w">                                      </span><span class="n">cudaGraphicsResourceSetMapFlags</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">cudaGraphicsMapFlagsWriteDiscard</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch rendering loop</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">Render</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Render</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Map vertex buffer for writing from CUDA</span>
<span class="w">    </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsMapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceGetMappedPointer</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">positions</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">positionsVB_CUDA</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Execute kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">createVertices</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Unmap vertex buffer</span>
<span class="w">    </span><span class="n">cudaGraphicsUnmapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Draw and present</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">releaseVB</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsUnregisterResource</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">positionsVB</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">createVertices</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate uv coordinates</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate simple sine wave pattern</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Write positions</span>
<span class="w">    </span><span class="n">positions</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                </span><span class="n">make_float4</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">__int_as_float</span><span class="p">(</span><span class="mh">0xff00ff00</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="direct3d-11-version">
<span id="id97"></span><h5><span class="section-number">3.2.15.2.3. </span>Direct3D 11 Version<a class="headerlink" href="#direct3d-11-version" title="Permalink to this headline">ï</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ID3D11Device</span><span class="o">*</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">CUSTOMVERTEX</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FLOAT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">DWORD</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">ID3D11Buffer</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cudaGraphicsResource</span><span class="o">*</span><span class="w"> </span><span class="n">positionsVB_CUDA</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Get a CUDA-enabled adapter</span>
<span class="w">    </span><span class="n">IDXGIFactory</span><span class="o">*</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CreateDXGIFactory</span><span class="p">(</span><span class="n">__uuidof</span><span class="p">(</span><span class="n">IDXGIFactory</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">factory</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">IDXGIAdapter</span><span class="o">*</span><span class="w"> </span><span class="n">adapter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="o">!</span><span class="n">adapter</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">EnumAdapters</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">adapter</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaD3D11GetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">adapter</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">factory</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create swap chain and device</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">sFnPtr_D3D11CreateDeviceAndSwapChain</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">D3D11_DRIVER_TYPE_HARDWARE</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">D3D11_CREATE_DEVICE_DEBUG</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">featureLevels</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">D3D11_SDK_VERSION</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">swapChainDesc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">swapChain</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">featureLevel</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">deviceContext</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use the same device</span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create vertex buffer and register it with CUDA</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUSTOMVERTEX</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">D3D11_BUFFER_DESC</span><span class="w"> </span><span class="n">bufferDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">Usage</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="n">D3D11_USAGE_DEFAULT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">ByteWidth</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">BindFlags</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">D3D11_BIND_VERTEX_BUFFER</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">CPUAccessFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bufferDesc</span><span class="p">.</span><span class="n">MiscFlags</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsD3D11RegisterResource</span><span class="p">(</span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">positionsVB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">cudaGraphicsRegisterFlagsNone</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceSetMapFlags</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">cudaGraphicsMapFlagsWriteDiscard</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Launch rendering loop</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">Render</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Render</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Map vertex buffer for writing from CUDA</span>
<span class="w">    </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsMapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsResourceGetMappedPointer</span><span class="p">((</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">positions</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"></span>
<span class="w">                                         </span><span class="n">positionsVB_CUDA</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Execute kernel</span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">dim3</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">createVertices</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                                          </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Unmap vertex buffer</span>
<span class="w">    </span><span class="n">cudaGraphicsUnmapResources</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">positionsVB_CUDA</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Draw and present</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">releaseVB</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphicsUnregisterResource</span><span class="p">(</span><span class="n">positionsVB_CUDA</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">positionsVB</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">createVertices</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Calculate uv coordinates</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">height</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Calculate simple sine wave pattern</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">freq</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">time</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Write positions</span>
<span class="w">    </span><span class="n">positions</span><span class="p">[</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                </span><span class="n">make_float4</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">__int_as_float</span><span class="p">(</span><span class="mh">0xff00ff00</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="sli-interoperability">
<span id="id98"></span><h4><span class="section-number">3.2.15.3. </span>SLI Interoperability<a class="headerlink" href="#sli-interoperability" title="Permalink to this headline">ï</a></h4>
<p>In a system with multiple GPUs, all CUDA-enabled GPUs are accessible via the CUDA driver and runtime as separate devices. There are however special considerations as described below when the system is in SLI mode.</p>
<p>First, an allocation in one CUDA device on one GPU will consume memory on other GPUs that are part of the SLI configuration of the Direct3D or OpenGL device. Because of this, allocations may fail earlier than otherwise expected.</p>
<p>Second, applications should create multiple CUDA contexts, one for each GPU in the SLI configuration. While this is not a strict requirement, it avoids unnecessary data transfers between devices. The application can use the <code class="docutils literal notranslate"><span class="pre">cudaD3D[9|10|11]GetDevices()</span></code> for Direct3D and <code class="docutils literal notranslate"><span class="pre">cudaGLGetDevices()</span></code> for OpenGL set of calls to identify the CUDA device handle(s) for the device(s) that are performing the rendering in the current and next frame. Given this information the application will typically choose the appropriate device and map Direct3D or OpenGL resources to the CUDA device returned by <code class="docutils literal notranslate"><span class="pre">cudaD3D[9|10|11]GetDevices()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGLGetDevices()</span></code> when the <code class="docutils literal notranslate"><span class="pre">deviceList</span></code> parameter is set to <code class="docutils literal notranslate"><span class="pre">cudaD3D[9|10|11]DeviceListCurrentFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGLDeviceListCurrentFrame</span></code>.</p>
<p>Please note that resource returned from <code class="docutils literal notranslate"><span class="pre">cudaGraphicsD9D[9|10|11]RegisterResource</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGraphicsGLRegister[Buffer|Image]</span></code> must be only used on device the registration happened. Therefore on SLI configurations when data for different frames is computed on different CUDA devices it is necessary to register the resources for each separately.</p>
<p>See <a class="reference internal" href="#direct3d-interoperability"><span class="std std-ref">Direct3D Interoperability</span></a> and <a class="reference internal" href="#opengl-interoperability"><span class="std std-ref">OpenGL Interoperability</span></a> for details on how the CUDA runtime interoperate with Direct3D and OpenGL, respectively.</p>
</section>
</section>
<section id="external-resource-interoperability">
<span id="id99"></span><h3><span class="section-number">3.2.16. </span>External Resource Interoperability<a class="headerlink" href="#external-resource-interoperability" title="Permalink to this headline">ï</a></h3>
<p>External resource interoperability allows CUDA to import certain resources that are explicitly exported by other APIs. These objects are typically exported by other APIs using handles native to the Operating System, like file descriptors on Linux or NT handles on Windows. They could also be exported using other unified interfaces such as the NVIDIA Software Communication Interface. There are two types of resources that can be imported: memory objects and synchronization objects.</p>
<p>Memory objects can be imported into CUDA using <code class="docutils literal notranslate"><span class="pre">cudaImportExternalMemory()</span></code>. An imported memory object can be accessed from within kernels using device pointers mapped onto the memory object via <code class="docutils literal notranslate"><span class="pre">cudaExternalMemoryGetMappedBuffer()</span></code>or CUDA mipmapped arrays mapped via <code class="docutils literal notranslate"><span class="pre">cudaExternalMemoryGetMappedMipmappedArray()</span></code>. Depending on the type of memory object, it may be possible for more than one mapping to be setup on a single memory object. The mappings must match the mappings setup in the exporting API. Any mismatched mappings result in undefined behavior. Imported memory objects must be freed using <code class="docutils literal notranslate"><span class="pre">cudaDestroyExternalMemory()</span></code>. Freeing a memory object does not free any mappings to that object. Therefore, any device pointers mapped onto that object must be explicitly freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> and any CUDA mipmapped arrays mapped onto that object must be explicitly freed using <code class="docutils literal notranslate"><span class="pre">cudaFreeMipmappedArray()</span></code>. It is illegal to access mappings to an object after it has been destroyed.</p>
<p>Synchronization objects can be imported into CUDA using <code class="docutils literal notranslate"><span class="pre">cudaImportExternalSemaphore()</span></code>. An imported synchronization object can then be signaled using <code class="docutils literal notranslate"><span class="pre">cudaSignalExternalSemaphoresAsync()</span></code> and waited on using <code class="docutils literal notranslate"><span class="pre">cudaWaitExternalSemaphoresAsync()</span></code>. It is illegal to issue a wait before the corresponding signal has been issued. Also, depending on the type of the imported synchronization object, there may be additional constraints imposed on how they can be signaled and waited on, as described in subsequent sections. Imported semaphore objects must be freed using <code class="docutils literal notranslate"><span class="pre">cudaDestroyExternalSemaphore()</span></code>. All outstanding signals and waits must have completed before the semaphore object is destroyed.</p>
<section id="vulkan-interoperability">
<span id="id100"></span><h4><span class="section-number">3.2.16.1. </span>Vulkan Interoperability<a class="headerlink" href="#vulkan-interoperability" title="Permalink to this headline">ï</a></h4>
<section id="matching-device-uuids">
<span id="matching-device-uuids-vul-int"></span><h5><span class="section-number">3.2.16.1.1. </span>Matching device UUIDs<a class="headerlink" href="#matching-device-uuids" title="Permalink to this headline">ï</a></h5>
<p>When importing memory and synchronization objects exported by Vulkan, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Vulkan physical device on which the objects were created can be determined by comparing the UUID of a CUDA device with that of the Vulkan physical device, as shown in the following code sample. Note that the Vulkan physical device should not be part of a device group that contains more than one Vulkan physical device. The device group as returned by <code class="docutils literal notranslate"><span class="pre">vkEnumeratePhysicalDeviceGroups</span></code> that contains the given Vulkan physical device must have a physical device count of 1.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">getCudaDeviceForVulkanPhysicalDevice</span><span class="p">(</span><span class="n">VkPhysicalDevice</span><span class="w"> </span><span class="n">vkPhysicalDevice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">VkPhysicalDeviceIDProperties</span><span class="w"> </span><span class="n">vkPhysicalDeviceIDProperties</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">vkPhysicalDeviceIDProperties</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vkPhysicalDeviceIDProperties</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">VkPhysicalDeviceProperties2</span><span class="w"> </span><span class="n">vkPhysicalDeviceProperties2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">vkPhysicalDeviceProperties2</span><span class="p">.</span><span class="n">sType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">vkPhysicalDeviceProperties2</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vkPhysicalDeviceIDProperties</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">vkGetPhysicalDeviceProperties2</span><span class="p">(</span><span class="n">vkPhysicalDevice</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vkPhysicalDeviceProperties2</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaDeviceCount</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">.</span><span class="n">uuid</span><span class="p">,</span><span class="w"> </span><span class="n">vkPhysicalDeviceIDProperties</span><span class="p">.</span><span class="n">deviceUUID</span><span class="p">,</span><span class="w"> </span><span class="n">VK_UUID_SIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cudaInvalidDeviceId</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-memory-objects">
<span id="importing-memory-objects-vul-int"></span><h5><span class="section-number">3.2.16.1.2. </span>Importing Memory Objects<a class="headerlink" href="#importing-memory-objects" title="Permalink to this headline">ï</a></h5>
<p>On Linux and Windows 10, both dedicated and non-dedicated memory objects exported by Vulkan can be imported into CUDA. On Windows 7, only dedicated memory objects can be imported. When importing a Vulkan dedicated memory object, the flag <code class="docutils literal notranslate"><span class="pre">cudaExternalMemoryDedicated</span></code> must be set.</p>
<p>A Vulkan memory object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT</span></code> can be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importVulkanMemoryObjectFromFileDescriptor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeOpaqueFd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;fd&#39; should not be used beyond this point as CUDA has assumed ownership of it</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan memory object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT</span></code> can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importVulkanMemoryObjectFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeOpaqueWin32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan memory object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT</span></code> can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importVulkanMemoryObjectFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeOpaqueWin32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan memory object exported using VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importVulkanMemoryObjectFromKMTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeOpaqueWin32Kmt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isDedicated</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-buffers-onto-imported-memory-objects">
<span id="mapping-buffers-onto-imported-memory-objects-vul-int"></span><h5><span class="section-number">3.2.16.1.3. </span>Mapping Buffers onto Imported Memory Objects<a class="headerlink" href="#mapping-buffers-onto-imported-memory-objects" title="Permalink to this headline">ï</a></h5>
<p>A device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Vulkan API. All mapped device pointers must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">mapBufferOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaExternalMemoryBufferDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>



<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>



<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>



<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>



<span class="w">    </span><span class="c1">// Note: âptrâ must eventually be freed using cudaFree()</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-mipmapped-arrays-onto-imported-memory-objects">
<span id="mapping-mipmapped-arrays-onto-imported-memory-objects-vul-int"></span><h5><span class="section-number">3.2.16.1.4. </span>Mapping Mipmapped Arrays onto Imported Memory Objects<a class="headerlink" href="#mapping-mipmapped-arrays-onto-imported-memory-objects" title="Permalink to this headline">ï</a></h5>
<p>A CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Vulkan API. Additionally, if the mipmapped array is bound as a color target in Vulkan, the flag<code class="docutils literal notranslate"><span class="pre">cudaArrayColorAttachment</span></code> must be set. All mapped mipmapped arrays must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFreeMipmappedArray()</span></code>. The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="nf">mapMipmappedArrayOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">,</span><span class="w"> </span><span class="n">cudaExtent</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLevels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="n">mipmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryMipmappedArrayDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">formatDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">numLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numLevels</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;mipmap&#39; must eventually be freed using cudaFreeMipmappedArray()</span>
<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedMipmappedArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mipmap</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mipmap</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="nf">getCudaChannelFormatDescForVulkanFormat</span><span class="p">(</span><span class="n">VkFormat</span><span class="w"> </span><span class="n">format</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8_UINT</span><span class="p">:</span><span class="w">             </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8_SINT</span><span class="p">:</span><span class="w">             </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8G8_UINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8G8_SINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8G8B8A8_UINT</span><span class="p">:</span><span class="w">       </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R8G8B8A8_SINT</span><span class="p">:</span><span class="w">       </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16_UINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16_SINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16G16_UINT</span><span class="p">:</span><span class="w">         </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16G16_SINT</span><span class="p">:</span><span class="w">         </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16G16B16A16_UINT</span><span class="p">:</span><span class="w">   </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R16G16B16A16_SINT</span><span class="p">:</span><span class="w">   </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32_UINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32_SINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32_SFLOAT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32_UINT</span><span class="p">:</span><span class="w">         </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32_SINT</span><span class="p">:</span><span class="w">         </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32_SFLOAT</span><span class="p">:</span><span class="w">       </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32B32A32_UINT</span><span class="p">:</span><span class="w">   </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32B32A32_SINT</span><span class="p">:</span><span class="w">   </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_FORMAT_R32G32B32A32_SFLOAT</span><span class="p">:</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaExtent</span><span class="w"> </span><span class="n">getCudaExtentForVulkanExtent</span><span class="p">(</span><span class="n">VkExtent3D</span><span class="w"> </span><span class="n">vkExt</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arrayLayers</span><span class="p">,</span><span class="w"> </span><span class="n">VkImageViewType</span><span class="w"> </span><span class="n">vkImageViewType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExtent</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">vkImageViewType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_1D</span><span class="p">:</span><span class="w">         </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">           </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_2D</span><span class="p">:</span><span class="w">         </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">           </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_3D</span><span class="p">:</span><span class="w">         </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">depth</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_CUBE</span><span class="p">:</span><span class="w">       </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayLayers</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_1D_ARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayLayers</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_2D_ARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayLayers</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vkExt</span><span class="p">.</span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayLayers</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">getCudaMipmappedArrayFlagsForVulkanImage</span><span class="p">(</span><span class="n">VkImageViewType</span><span class="w"> </span><span class="n">vkImageViewType</span><span class="p">,</span><span class="w"> </span><span class="n">VkImageUsageFlags</span><span class="w"> </span><span class="n">vkImageUsageFlags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">vkImageViewType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_CUBE</span><span class="p">:</span><span class="w">       </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_1D_ARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">VK_IMAGE_VIEW_TYPE_2D_ARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vkImageUsageFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayColorAttachment</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArraySurfaceLoadStore</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-synchronization-objects">
<span id="importing-synchronization-objects-vul-int"></span><h5><span class="section-number">3.2.16.1.5. </span>Importing Synchronization Objects<a class="headerlink" href="#importing-synchronization-objects" title="Permalink to this headline">ï</a></h5>
<p>A Vulkan semaphore object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT</span></code>can be imported into CUDA using the file descriptor associated with that object as shown below. Note that CUDA assumes ownership of the file descriptor once it is imported. Using the file descriptor after a successful import results in undefined behavior.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importVulkanSemaphoreObjectFromFileDescriptor</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeOpaqueFd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;fd&#39; should not be used beyond this point as CUDA has assumed ownership of it</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan semaphore object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT</span></code> can be imported into CUDA using the NT handle associated with that object as shown below. Note that CUDA does not assume ownership of the NT handle and it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importVulkanSemaphoreObjectFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeOpaqueWin32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan semaphore object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT</span></code> can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importVulkanSemaphoreObjectFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeOpaqueWin32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A Vulkan semaphore object exported using <code class="docutils literal notranslate"><span class="pre">VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT</span></code> can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying semaphore it is automatically destroyed when all other references to the resource are destroyed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importVulkanSemaphoreObjectFromKMTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="signaling-waiting-on-imported-synchronization-objects">
<span id="signaling-waiting-on-imported-synchronization-objects-vul-int"></span><h5><span class="section-number">3.2.16.1.6. </span>Signaling/Waiting on Imported Synchronization Objects<a class="headerlink" href="#signaling-waiting-on-imported-synchronization-objects" title="Permalink to this headline">ï</a></h5>
<p>An imported Vulkan semaphore object can be signaled as shown below. Signaling such a semaphore object sets it to the signaled state. The corresponding wait that waits on this signal must be issued in Vulkan. Additionally, the wait that waits on this signal must be issued after this signal has been issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">signalExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreSignalParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaSignalExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported Vulkan semaphore object can be waited on as shown below. Waiting on such a semaphore object waits until it reaches the signaled state and then resets it back to the unsignaled state. The corresponding signal that this wait is waiting on must be issued in Vulkan. Additionally, the signal must be issued before this wait can be issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">waitExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreWaitParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaWaitExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="opengl-interoperability-ext-res-int">
<span id="id101"></span><h4><span class="section-number">3.2.16.2. </span>OpenGL Interoperability<a class="headerlink" href="#opengl-interoperability-ext-res-int" title="Permalink to this headline">ï</a></h4>
<p>Traditional OpenGL-CUDA interop as outlined in <a class="reference internal" href="#opengl-interoperability"><span class="std std-ref">OpenGL Interoperability</span></a> works by CUDA directly consuming handles created in OpenGL. However, since OpenGL can also consume memory and synchronization objects created in Vulkan, there exists an alternative approach to doing OpenGL-CUDA interop. Essentially, memory and synchronization objects exported by Vulkan could be imported into both, OpenGL and CUDA, and then used to coordinate memory accesses between OpenGL and CUDA. Please refer to the following OpenGL extensions for further details on how to import memory and synchronization objects exported by Vulkan:</p>
<ul class="simple">
<li><p>GL_EXT_memory_object</p></li>
<li><p>GL_EXT_memory_object_fd</p></li>
<li><p>GL_EXT_memory_object_win32</p></li>
<li><p>GL_EXT_semaphore</p></li>
<li><p>GL_EXT_semaphore_fd</p></li>
<li><p>GL_EXT_semaphore_win32</p></li>
</ul>
</section>
<section id="direct3d-12-interoperability">
<span id="id102"></span><h4><span class="section-number">3.2.16.3. </span>Direct3D 12 Interoperability<a class="headerlink" href="#direct3d-12-interoperability" title="Permalink to this headline">ï</a></h4>
<section id="matching-device-luids">
<span id="matching-device-luids-dir3d-12-int"></span><h5><span class="section-number">3.2.16.3.1. </span>Matching Device LUIDs<a class="headerlink" href="#matching-device-luids" title="Permalink to this headline">ï</a></h5>
<p>When importing memory and synchronization objects exported by Direct3D 12, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 12 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 12 device, as shown in the following code sample. Note that the Direct3D 12 device must not be created on a linked node adapter. I.e. the node count as returned by <code class="docutils literal notranslate"><span class="pre">ID3D12Device::GetNodeCount</span></code> must be 1.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">getCudaDeviceForD3D12Device</span><span class="p">(</span><span class="n">ID3D12Device</span><span class="w"> </span><span class="o">*</span><span class="n">d3d12Device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">LUID</span><span class="w"> </span><span class="n">d3d12Luid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d3d12Device</span><span class="o">-&gt;</span><span class="n">GetAdapterLuid</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaDeviceCount</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cudaLuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">.</span><span class="n">luid</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d3d12Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLuid</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d12Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d3d12Luid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLuid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d12Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d12Luid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cudaInvalidDeviceId</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-memory-objects-dir3d-12-int">
<span id="id103"></span><h5><span class="section-number">3.2.16.3.2. </span>Importing Memory Objects<a class="headerlink" href="#importing-memory-objects-dir3d-12-int" title="Permalink to this headline">ï</a></h5>
<p>A shareable Direct3D 12 heap memory object, created by setting the flag <code class="docutils literal notranslate"><span class="pre">D3D12_HEAP_FLAG_SHARED</span></code> in the call to <code class="docutils literal notranslate"><span class="pre">ID3D12Device::CreateHeap</span></code>, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D12HeapFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D12Heap</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 12 heap memory object can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D12HeapFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D12Heap</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 12 committed resource, created by setting the flag <code class="docutils literal notranslate"><span class="pre">D3D12_HEAP_FLAG_SHARED</span></code> in the call to <code class="docutils literal notranslate"><span class="pre">D3D12Device::CreateCommittedResource</span></code>, can be imported into CUDA using the NT handle associated with that object as shown below. When importing a Direct3D 12 committed resource, the flag <code class="docutils literal notranslate"><span class="pre">cudaExternalMemoryDedicated</span></code> must be set. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D12CommittedResourceFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D12Resource</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 12 committed resource can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D12CommittedResourceFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D12Resource</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-buffers-onto-imported-memory-objects-dir3d-12-int">
<span id="id104"></span><h5><span class="section-number">3.2.16.3.3. </span>Mapping Buffers onto Imported Memory Objects<a class="headerlink" href="#mapping-buffers-onto-imported-memory-objects-dir3d-12-int" title="Permalink to this headline">ï</a></h5>
<p>A device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 12 API. All mapped device pointers must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">mapBufferOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryBufferDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;ptr&#39; must eventually be freed using cudaFree()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-12-int">
<span id="id105"></span><h5><span class="section-number">3.2.16.3.4. </span>Mapping Mipmapped Arrays onto Imported Memory Objects<a class="headerlink" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-12-int" title="Permalink to this headline">ï</a></h5>
<p>A CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 12 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag <code class="docutils literal notranslate"><span class="pre">cudaArrayColorAttachment</span></code> must be set. All mapped mipmapped arrays must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFreeMipmappedArray()</span></code>. The following code sample shows how to convert Vulkan parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="nf">mapMipmappedArrayOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">,</span><span class="w"> </span><span class="n">cudaExtent</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLevels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="n">mipmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryMipmappedArrayDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">formatDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">numLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numLevels</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;mipmap&#39; must eventually be freed using cudaFreeMipmappedArray()</span>
<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedMipmappedArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mipmap</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mipmap</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="nf">getCudaChannelFormatDescForDxgiFormat</span><span class="p">(</span><span class="n">DXGI_FORMAT</span><span class="w"> </span><span class="n">dxgiFormat</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">dxgiFormat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8_UINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8_SINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8_UINT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8_SINT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8B8A8_UINT</span><span class="p">:</span><span class="w">      </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8B8A8_SINT</span><span class="p">:</span><span class="w">      </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16_UINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16_SINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16_UINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16_SINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16B16A16_UINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16B16A16_SINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_UINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_SINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_FLOAT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_UINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_SINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_FLOAT</span><span class="p">:</span><span class="w">       </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_UINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_SINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_FLOAT</span><span class="p">:</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaExtent</span><span class="w"> </span><span class="n">getCudaExtentForD3D12Extent</span><span class="p">(</span><span class="n">UINT64</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">UINT</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">UINT16</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">D3D12_SRV_DIMENSION</span><span class="w"> </span><span class="n">d3d12SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExtent</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">d3d12SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE1D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE2D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE3D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURECUBE</span><span class="p">:</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE1DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE2DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURECUBEARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">getCudaMipmappedArrayFlagsForD3D12Resource</span><span class="p">(</span><span class="n">D3D12_SRV_DIMENSION</span><span class="w"> </span><span class="n">d3d12SRVDimension</span><span class="p">,</span><span class="w"> </span><span class="n">D3D12_RESOURCE_FLAGS</span><span class="w"> </span><span class="n">d3d12ResourceFlags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">d3d12SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURECUBE</span><span class="p">:</span><span class="w">      </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURECUBEARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE1DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D12_SRV_DIMENSION_TEXTURE2DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d3d12ResourceFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayColorAttachment</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArraySurfaceLoadStore</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-synchronization-objects-dir3d-12-int">
<span id="id106"></span><h5><span class="section-number">3.2.16.3.5. </span>Importing Synchronization Objects<a class="headerlink" href="#importing-synchronization-objects-dir3d-12-int" title="Permalink to this headline">ï</a></h5>
<p>A shareable Direct3D 12 fence object, created by setting the flag <code class="docutils literal notranslate"><span class="pre">D3D12_FENCE_FLAG_SHARED</span></code> in the call to <code class="docutils literal notranslate"><span class="pre">ID3D12Device::CreateFence</span></code>, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D12FenceFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeD3D12Fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 12 fence object can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D12FenceFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeD3D12Fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="signaling-waiting-on-imported-synchronization-objects-dir3d-12-int">
<span id="id107"></span><h5><span class="section-number">3.2.16.3.6. </span>Signaling/Waiting on Imported Synchronization Objects<a class="headerlink" href="#signaling-waiting-on-imported-synchronization-objects-dir3d-12-int" title="Permalink to this headline">ï</a></h5>
<p>An imported Direct3D 12 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 12. Additionally, the wait that waits on this signal must be issued after this signal has been issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">signalExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreSignalParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">fence</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaSignalExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported Direct3D 12 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 12. Additionally, the signal must be issued before this wait can be issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">waitExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreWaitParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">fence</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaWaitExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="direct3d-11-interoperability">
<span id="direct3d11-interoperability"></span><h4><span class="section-number">3.2.16.4. </span>Direct3D 11 Interoperability<a class="headerlink" href="#direct3d-11-interoperability" title="Permalink to this headline">ï</a></h4>
<section id="matching-device-luids-dir3d-11-int">
<span id="id108"></span><h5><span class="section-number">3.2.16.4.1. </span>Matching Device LUIDs<a class="headerlink" href="#matching-device-luids-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>When importing memory and synchronization objects exported by Direct3D 11, they must be imported and mapped on the same device as they were created on. The CUDA device that corresponds to the Direct3D 11 device on which the objects were created can be determined by comparing the LUID of a CUDA device with that of the Direct3D 11 device, as shown in the following code sample.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">getCudaDeviceForD3D11Device</span><span class="p">(</span><span class="n">ID3D11Device</span><span class="w"> </span><span class="o">*</span><span class="n">d3d11Device</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">IDXGIDevice</span><span class="w"> </span><span class="o">*</span><span class="n">dxgiDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d3d11Device</span><span class="o">-&gt;</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">__uuidof</span><span class="p">(</span><span class="n">IDXGIDevice</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dxgiDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">IDXGIAdapter</span><span class="w"> </span><span class="o">*</span><span class="n">dxgiAdapter</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">dxgiDevice</span><span class="o">-&gt;</span><span class="n">GetAdapter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dxgiAdapter</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">DXGI_ADAPTER_DESC</span><span class="w"> </span><span class="n">dxgiAdapterDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">dxgiAdapter</span><span class="o">-&gt;</span><span class="n">GetDesc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dxgiAdapterDesc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">LUID</span><span class="w"> </span><span class="n">d3d11Luid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dxgiAdapterDesc</span><span class="p">.</span><span class="n">AdapterLuid</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaDeviceCount</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cudaDeviceCount</span><span class="p">;</span><span class="w"> </span><span class="n">cudaDevice</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cudaLuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">.</span><span class="n">luid</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d3d11Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLuid</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d11Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">            </span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d3d11Luid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">,</span><span class="w"> </span><span class="n">cudaLuid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d11Luid</span><span class="p">.</span><span class="n">LowPart</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d3d11Luid</span><span class="p">.</span><span class="n">HighPart</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">cudaDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cudaInvalidDeviceId</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-memory-objects-dir3d-11-int">
<span id="id109"></span><h5><span class="section-number">3.2.16.4.2. </span>Importing Memory Objects<a class="headerlink" href="#importing-memory-objects-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>A shareable Direct3D 11 texture resource, viz, <code class="docutils literal notranslate"><span class="pre">ID3D11Texture1D</span></code>, <code class="docutils literal notranslate"><span class="pre">ID3D11Texture2D</span></code> or <code class="docutils literal notranslate"><span class="pre">ID3D11Texture3D</span></code>, can be created by setting either the <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED</span></code> or <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</span></code> (on Windows 7) or <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED_NTHANDLE</span></code> (on Windows 10) when calling <code class="docutils literal notranslate"><span class="pre">ID3D11Device:CreateTexture1D</span></code>, <code class="docutils literal notranslate"><span class="pre">ID3D11Device:CreateTexture2D</span></code> or <code class="docutils literal notranslate"><span class="pre">ID3D11Device:CreateTexture3D</span></code> respectively. A shareable Direct3D 11 buffer resource, <code class="docutils literal notranslate"><span class="pre">ID3D11Buffer</span></code>, can be created by specifying either of the above flags when calling <code class="docutils literal notranslate"><span class="pre">ID3D11Device::CreateBuffer</span></code>. A shareable resource created by specifying the <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED_NTHANDLE</span></code> can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the NT handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying memory can be freed. When importing a Direct3D 11 resource, the flag <code class="docutils literal notranslate"><span class="pre">cudaExternalMemoryDedicated</span></code> must be set.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D11ResourceFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D11Resource</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 resource can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D11ResourceFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D11Resource</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 resource, created by specifying the <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED</span></code> or <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</span></code>, can be imported into CUDA using the globally shared <code class="docutils literal notranslate"><span class="pre">D3DKMT</span></code> handle associated with that object as shown below. Since a globally shared <code class="docutils literal notranslate"><span class="pre">D3DKMT</span></code> handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importD3D11ResourceFromKMTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeD3D11ResourceKmt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">handle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaExternalMemoryDedicated</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-buffers-onto-imported-memory-objects-dir3d-11-int">
<span id="id110"></span><h5><span class="section-number">3.2.16.4.3. </span>Mapping Buffers onto Imported Memory Objects<a class="headerlink" href="#mapping-buffers-onto-imported-memory-objects-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>A device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping must match that specified when creating the mapping using the corresponding Direct3D 11 API. All mapped device pointers must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">mapBufferOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryBufferDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: âptrâ must eventually be freed using cudaFree()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-11-int">
<span id="id111"></span><h5><span class="section-number">3.2.16.4.4. </span>Mapping Mipmapped Arrays onto Imported Memory Objects<a class="headerlink" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>A CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions, format and number of mip levels must match that specified when creating the mapping using the corresponding Direct3D 11 API. Additionally, if the mipmapped array can be bound as a render target in Direct3D 12, the flag <code class="docutils literal notranslate"><span class="pre">cudaArrayColorAttachment</span></code> must be set. All mapped mipmapped arrays must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFreeMipmappedArray()</span></code>. The following code sample shows how to convert Direct3D 11 parameters into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="nf">mapMipmappedArrayOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">,</span><span class="w"> </span><span class="n">cudaExtent</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLevels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="n">mipmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryMipmappedArrayDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">formatDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">numLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numLevels</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;mipmap&#39; must eventually be freed using cudaFreeMipmappedArray()</span>
<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedMipmappedArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mipmap</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mipmap</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="nf">getCudaChannelFormatDescForDxgiFormat</span><span class="p">(</span><span class="n">DXGI_FORMAT</span><span class="w"> </span><span class="n">dxgiFormat</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">dxgiFormat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8_UINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8_SINT</span><span class="p">:</span><span class="w">            </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8_UINT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8_SINT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8B8A8_UINT</span><span class="p">:</span><span class="w">      </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R8G8B8A8_SINT</span><span class="p">:</span><span class="w">      </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16_UINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16_SINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16_UINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16_SINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16B16A16_UINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R16G16B16A16_SINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_UINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_SINT</span><span class="p">:</span><span class="w">           </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32_FLOAT</span><span class="p">:</span><span class="w">          </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_UINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_SINT</span><span class="p">:</span><span class="w">        </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32_FLOAT</span><span class="p">:</span><span class="w">       </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_UINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindUnsigned</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_SINT</span><span class="p">:</span><span class="w">  </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindSigned</span><span class="p">;</span><span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">DXGI_FORMAT_R32G32B32A32_FLOAT</span><span class="p">:</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaChannelFormatKindFloat</span><span class="p">;</span><span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaExtent</span><span class="w"> </span><span class="n">getCudaExtentForD3D11Extent</span><span class="p">(</span><span class="n">UINT64</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">UINT</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">UINT16</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">,</span><span class="w"> </span><span class="n">D3D12_SRV_DIMENSION</span><span class="w"> </span><span class="n">d3d11SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExtent</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">d3d11SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE1D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE2D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE3D</span><span class="p">:</span><span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURECUBE</span><span class="p">:</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE1DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">      </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE2DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURECUBEARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depthOrArraySize</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">getCudaMipmappedArrayFlagsForD3D12Resource</span><span class="p">(</span><span class="n">D3D11_SRV_DIMENSION</span><span class="w"> </span><span class="n">d3d11SRVDimension</span><span class="p">,</span><span class="w"> </span><span class="n">D3D11_BIND_FLAG</span><span class="w"> </span><span class="n">d3d11BindFlags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">d3d11SRVDimension</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURECUBE</span><span class="p">:</span><span class="w">      </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURECUBEARRAY</span><span class="p">:</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayCubemap</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE1DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">D3D11_SRV_DIMENSION_TEXTURE2DARRAY</span><span class="p">:</span><span class="w">   </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayLayered</span><span class="p">;</span><span class="w">                    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d3d11BindFlags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">D3D11_BIND_RENDER_TARGET</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArrayColorAttachment</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allowSurfaceLoadStore</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">cudaArraySurfaceLoadStore</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-synchronization-objects-dir3d-11-int">
<span id="id112"></span><h5><span class="section-number">3.2.16.4.5. </span>Importing Synchronization Objects<a class="headerlink" href="#importing-synchronization-objects-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>A shareable Direct3D 11 fence object, created by setting the flag <code class="docutils literal notranslate"><span class="pre">D3D11_FENCE_FLAG_SHARED</span></code> in the call to <code class="docutils literal notranslate"><span class="pre">ID3D11Device5::CreateFence</span></code>, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D11FenceFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeD3D11Fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 fence object can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D11FenceFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeD3D11Fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 keyed mutex object associated with a shareable Direct3D 11 resource, viz, <code class="docutils literal notranslate"><span class="pre">IDXGIKeyedMutex</span></code>, created by setting the flag <code class="docutils literal notranslate"><span class="pre">D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX</span></code>, can be imported into CUDA using the NT handle associated with that object as shown below. Note that it is the applicationâs responsibility to close the handle when it is not required anymore. The NT handle holds a reference to the resource, so it must be explicitly freed before the underlying semaphore can be freed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D11KeyedMutexFromNTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeKeyedMutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 keyed mutex object can also be imported using a named handle if one exists as shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D11KeyedMutexFromNamedNTHandle</span><span class="p">(</span><span class="n">LPCWSTR</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeKeyedMutex</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A shareable Direct3D 11 keyed mutex object can be imported into CUDA using the globally shared D3DKMT handle associated with that object as shown below. Since a globally shared D3DKMT handle does not hold a reference to the underlying memory it is automatically destroyed when all other references to the resource are destroyed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importD3D11FenceFromKMTHandle</span><span class="p">(</span><span class="n">HANDLE</span><span class="w"> </span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeKeyedMutexKmt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">win32</span><span class="p">.</span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Input parameter &#39;handle&#39; should be closed if it&#39;s not needed anymore</span>
<span class="w">    </span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="signaling-waiting-on-imported-synchronization-objects-dir3d-11-int">
<span id="id113"></span><h5><span class="section-number">3.2.16.4.6. </span>Signaling/Waiting on Imported Synchronization Objects<a class="headerlink" href="#signaling-waiting-on-imported-synchronization-objects-dir3d-11-int" title="Permalink to this headline">ï</a></h5>
<p>An imported Direct3D 11 fence object can be signaled as shown below. Signaling such a fence object sets its value to the one specified. The corresponding wait that waits on this signal must be issued in Direct3D 11. Additionally, the wait that waits on this signal must be issued after this signal has been issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">signalExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreSignalParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">fence</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaSignalExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported Direct3D 11 fence object can be waited on as shown below. Waiting on such a fence object waits until its value becomes greater than or equal to the specified value. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the signal must be issued before this wait can be issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">waitExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreWaitParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">fence</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaWaitExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported Direct3D 11 keyed mutex object can be signaled as shown below. Signaling such a keyed mutex object by specifying a key value releases the keyed mutex for that value. The corresponding wait that waits on this signal must be issued in Direct3D 11 with the same key value. Additionally, the Direct3D 11 wait must be issued after this signal has been issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">signalExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreSignalParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">keyedmutex</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaSignalExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported Direct3D 11 keyed mutex object can be waited on as shown below. A timeout value in milliseconds is needed when waiting on such a keyed mutex. The wait operation waits until the keyed mutex value is equal to the specified key value or until the timeout has elapsed. The timeout interval can also be an infinite value. In case an infinite value is specified the timeout never elapses. The windows INFINITE macro must be used to specify an infinite timeout. The corresponding signal that this wait is waiting on must be issued in Direct3D 11. Additionally, the Direct3D 11 signal must be issued before this wait can be issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">waitExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">timeoutMs</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreWaitParams</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">params</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">keyedmutex</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">params</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">keyedmutex</span><span class="p">.</span><span class="n">timeoutMs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timeoutMs</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaWaitExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="nvidia-software-communication-interface-interoperability-nvsci">
<span id="nvidia-softwarcommunication-interface-interoperability-nvsci"></span><h4><span class="section-number">3.2.16.5. </span>NVIDIA Software Communication Interface Interoperability (NVSCI)<a class="headerlink" href="#nvidia-software-communication-interface-interoperability-nvsci" title="Permalink to this headline">ï</a></h4>
<p>NvSciBuf and NvSciSync are interfaces developed for serving the following purposes:</p>
<ul class="simple">
<li><p>NvSciBuf: Allows applications to allocate and exchange buffers in memory</p></li>
<li><p>NvSciSync: Allows applications to manage synchronization objects at operation boundaries</p></li>
</ul>
<p>More details on these interfaces are available at: <a class="reference external" href="https://docs.nvidia.com/drive">https://docs.nvidia.com/drive</a>.</p>
<section id="importing-memory-objects-nvsci">
<span id="id114"></span><h5><span class="section-number">3.2.16.5.1. </span>Importing Memory Objects<a class="headerlink" href="#importing-memory-objects-nvsci" title="Permalink to this headline">ï</a></h5>
<p>For allocating an NvSciBuf object compatible with a given CUDA device, the corresponding GPU id must be set with <code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_GpuId</span></code> in the NvSciBuf attribute list as shown below. Optionally, applications can specify the following attributes -</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_NeedCpuAccess</span></code>: Specifies if CPU access is required for the buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NvSciBufRawBufferAttrKey_Align</span></code>: Specifies the alignment requirement of <code class="docutils literal notranslate"><span class="pre">NvSciBufType_RawBuffer</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_RequiredPerm</span></code>: Different access permissions can be configured for different UMDs per NvSciBuf memory object instance. For example, to provide the GPU with read-only access permissions to the buffer, create a duplicate NvSciBuf object using <code class="docutils literal notranslate"><span class="pre">NvSciBufObjDupWithReducePerm()</span></code> with <code class="docutils literal notranslate"><span class="pre">NvSciBufAccessPerm_Readonly</span></code> as the input parameter. Then import this newly created duplicate object with reduced permission into CUDA as shown</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_EnableGpuCache</span></code>: To control GPU L2 cacheability</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_EnableGpuCompression</span></code>: To specify GPU compression</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more details on these attributes and their valid input options, refer to NvSciBuf Documentation.</p>
</div>
<p>The following code snippet illustrates their sample usage.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NvSciBufObj</span><span class="w"> </span><span class="nf">createNvSciBufObject</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Raw Buffer Attributes for CUDA</span>
<span class="w">    </span><span class="n">NvSciBufType</span><span class="w"> </span><span class="n">bufType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NvSciBufType_RawBuffer</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">rawsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">cpuaccess_flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrValAccessPerm</span><span class="w"> </span><span class="n">perm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NvSciBufAccessPerm_ReadWrite</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">NvSciRmGpuId</span><span class="w"> </span><span class="n">gpuid</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">CUuuid</span><span class="w"> </span><span class="n">uuid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuDeviceGetUuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uuid</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">bytes</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Disable cache on dev</span>
<span class="w">    </span><span class="n">NvSciBufAttrValGpuCache</span><span class="w"> </span><span class="n">gpuCache</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="n">gpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="nb">false</span><span class="p">}};</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrValGpuCompression</span><span class="w"> </span><span class="n">gpuCompression</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="n">gpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">NvSciBufCompressionType_GenericCompressible</span><span class="p">}};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Fill in values</span>
<span class="w">    </span><span class="n">NvSciBufAttrKeyValuePair</span><span class="w"> </span><span class="n">rawbuffattrs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_Types</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufType</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">bufType</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufRawBufferAttrKey_Size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rawsize</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rawsize</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufRawBufferAttrKey_Align</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">align</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_NeedCpuAccess</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpuaccess_flag</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cpuaccess_flag</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_RequiredPerm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">perm</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_GpuId</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpuid</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">gpuid</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_EnableGpuCache</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpuCache</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">gpuCache</span><span class="p">)</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_EnableGpuCompression</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpuCompression</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">gpuCompression</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create list by setting attributes</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NvSciBufAttrListSetAttrs</span><span class="p">(</span><span class="n">attrListBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">rawbuffattrs</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="k">sizeof</span><span class="p">(</span><span class="n">rawbuffattrs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NvSciBufAttrKeyValuePair</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">NvSciBufAttrListCreate</span><span class="p">(</span><span class="n">NvSciBufModule</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attrListBuffer</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Reconcile And Allocate</span>
<span class="w">    </span><span class="n">NvSciBufAttrListReconcile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrListBuffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attrListReconciledBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="o">&amp;</span><span class="n">attrListConflictBuffer</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufObjAlloc</span><span class="p">(</span><span class="n">attrListReconciledBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferObjRaw</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">bufferObjRaw</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NvSciBufObj</span><span class="w"> </span><span class="n">bufferObjRo</span><span class="p">;</span><span class="w"> </span><span class="c1">// Readonly NvSciBuf memory obj</span>
<span class="c1">// Create a duplicate handle to the same memory buffer with reduced permissions</span>
<span class="n">NvSciBufObjDupWithReducePerm</span><span class="p">(</span><span class="n">bufferObjRaw</span><span class="p">,</span><span class="w"> </span><span class="n">NvSciBufAccessPerm_Readonly</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferObjRo</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">bufferObjRo</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The allocated NvSciBuf memory object can be imported in CUDA using the NvSciBufObj handle as shown below. Application should query the allocated NvSciBufObj for attributes required for filling CUDA External Memory Descriptor. Note that the attribute list and NvSciBuf objects should be maintained by the application. If the NvSciBuf object imported into CUDA is also mapped by other drivers, then based on <code class="docutils literal notranslate"><span class="pre">NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency</span></code> output attribute value the application must use NvSciSync objects (refer to <a class="reference internal" href="#importing-synchronization-objects-nvsci"><span class="std std-ref">Importing Synchronization Objects</span></a>) as appropriate barriers to maintain coherence between CUDA and the other drivers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more details on how to allocate and maintain NvSciBuf objects refer to NvSciBuf API Documentation.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="nf">importNvSciBufObject</span><span class="w"> </span><span class="p">(</span><span class="n">NvSciBufObj</span><span class="w"> </span><span class="n">bufferObjRaw</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*************** Query NvSciBuf Object **************/</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrKeyValuePair</span><span class="w"> </span><span class="n">bufattrs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufRawBufferAttrKey_Size</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_GpuSwNeedCacheCoherency</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"> </span><span class="n">NvSciBufGeneralAttrKey_EnableGpuCompression</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrListGetAttrs</span><span class="p">(</span><span class="n">retList</span><span class="p">,</span><span class="w"> </span><span class="n">bufattrs</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="k">sizeof</span><span class="p">(</span><span class="n">bufattrs</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NvSciBufAttrKeyValuePair</span><span class="p">)));</span><span class="w"></span>
<span class="w">                </span><span class="n">ret_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">uint64_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">bufattrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note cache and compression are per GPU attributes, so read values for specific gpu by comparing UUID</span>
<span class="w">    </span><span class="c1">// Read cacheability granted by NvSciBuf</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numGpus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufattrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">NvSciBufAttrValGpuCache</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrValGpuCache</span><span class="p">[]</span><span class="w"> </span><span class="n">cacheVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">NvSciBufAttrValGpuCache</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">bufattrs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ret_cacheVal</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGpus</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">gpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">cacheVal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpuId</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUuuid</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret_cacheVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cacheVal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cacheability</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Read compression granted by NvSciBuf</span>
<span class="w">    </span><span class="n">numGpus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufattrs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">len</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">NvSciBufAttrValGpuCompression</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufAttrValGpuCompression</span><span class="p">[]</span><span class="w"> </span><span class="n">compVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">NvSciBufAttrValGpuCompression</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">bufattrs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciBufCompressionType</span><span class="w"> </span><span class="n">ret_compVal</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGpus</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">gpuid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">compVal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpuId</span><span class="p">.</span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUuuid</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ret_compVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compVal</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">compressionType</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*************** NvSciBuf Registration With CUDA **************/</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Fill up CUDA_EXTERNAL_MEMORY_HANDLE_DESC</span>
<span class="w">    </span><span class="n">cudaExternalMemoryHandleDesc</span><span class="w"> </span><span class="n">memHandleDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memHandleDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">memHandleDesc</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">memHandleDesc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalMemoryHandleTypeNvSciBuf</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memHandleDesc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">nvSciBufObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufferObjRaw</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Set the NvSciBuf object with required access permissions in this step</span>
<span class="w">    </span><span class="n">memHandleDesc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">nvSciBufObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufferObjRo</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">memHandleDesc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret_size</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaImportExternalMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extMemBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">memHandleDesc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extMemBuffer</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-buffers-onto-imported-memory-objects-nvsci">
<span id="id115"></span><h5><span class="section-number">3.2.16.5.2. </span>Mapping Buffers onto Imported Memory Objects<a class="headerlink" href="#mapping-buffers-onto-imported-memory-objects-nvsci" title="Permalink to this headline">ï</a></h5>
<p>A device pointer can be mapped onto an imported memory object as shown below. The offset and size of the mapping can be filled as per the attributes of the allocated <code class="docutils literal notranslate"><span class="pre">NvSciBufObj</span></code>. All mapped device pointers must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">mapBufferOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryBufferDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedBuffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;ptr&#39; must eventually be freed using cudaFree()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-mipmapped-arrays-onto-imported-memory-objects-nvsci">
<span id="id116"></span><h5><span class="section-number">3.2.16.5.3. </span>Mapping Mipmapped Arrays onto Imported Memory Objects<a class="headerlink" href="#mapping-mipmapped-arrays-onto-imported-memory-objects-nvsci" title="Permalink to this headline">ï</a></h5>
<p>A CUDA mipmapped array can be mapped onto an imported memory object as shown below. The offset, dimensions and format can be filled as per the attributes of the allocated <code class="docutils literal notranslate"><span class="pre">NvSciBufObj</span></code>. All mapped mipmapped arrays must be freed using <code class="docutils literal notranslate"><span class="pre">cudaFreeMipmappedArray()</span></code>. The following code sample shows how to convert NvSciBuf attributes into the corresponding CUDA parameters when mapping mipmapped arrays onto imported memory objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The number of mip levels must be 1.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="nf">mapMipmappedArrayOntoExternalMemory</span><span class="p">(</span><span class="n">cudaExternalMemory_t</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">cudaChannelFormatDesc</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">,</span><span class="w"> </span><span class="n">cudaExtent</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numLevels</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMipmappedArray_t</span><span class="w"> </span><span class="n">mipmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalMemoryMipmappedArrayDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">formatDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">formatDesc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">extent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">extent</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">numLevels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numLevels</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: &#39;mipmap&#39; must eventually be freed using cudaFreeMipmappedArray()</span>
<span class="w">    </span><span class="n">cudaExternalMemoryGetMappedMipmappedArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mipmap</span><span class="p">,</span><span class="w"> </span><span class="n">extMem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mipmap</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="importing-synchronization-objects-nvsci">
<span id="id117"></span><h5><span class="section-number">3.2.16.5.4. </span>Importing Synchronization Objects<a class="headerlink" href="#importing-synchronization-objects-nvsci" title="Permalink to this headline">ï</a></h5>
<p>NvSciSync attributes that are compatible with a given CUDA device can be generated using <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetNvSciSyncAttributes()</span></code>. The returned attribute list can be used to create a <code class="docutils literal notranslate"><span class="pre">NvSciSyncObj</span></code> that is guaranteed compatibility with a given CUDA device.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">NvSciSyncObj</span><span class="w"> </span><span class="nf">createNvSciSyncObject</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncObj</span><span class="w"> </span><span class="n">nvSciSyncObj</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDev0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">cudaDev1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrList</span><span class="w"> </span><span class="n">signalerAttrList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrList</span><span class="w"> </span><span class="n">waiterAttrList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrList</span><span class="w"> </span><span class="n">reconciledList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrList</span><span class="w"> </span><span class="n">newConflictList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">NvSciSyncAttrListCreate</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">signalerAttrList</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrListCreate</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waiterAttrList</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">NvSciSyncAttrList</span><span class="w"> </span><span class="n">unreconciledList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">unreconciledList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signalerAttrList</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">unreconciledList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">waiterAttrList</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaDeviceGetNvSciSyncAttributes</span><span class="p">(</span><span class="n">signalerAttrList</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDev0</span><span class="p">,</span><span class="w"> </span><span class="n">CUDA_NVSCISYNC_ATTR_SIGNAL</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceGetNvSciSyncAttributes</span><span class="p">(</span><span class="n">waiterAttrList</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDev1</span><span class="p">,</span><span class="w"> </span><span class="n">CUDA_NVSCISYNC_ATTR_WAIT</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">NvSciSyncAttrListReconcile</span><span class="p">(</span><span class="n">unreconciledList</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reconciledList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">newConflictList</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">NvSciSyncObjAlloc</span><span class="p">(</span><span class="n">reconciledList</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nvSciSyncObj</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">nvSciSyncObj</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An NvSciSync object (created as above) can be imported into CUDA using the NvSciSyncObj handle as shown below. Note that ownership of the NvSciSyncObj handle continues to lie with the application even after it is imported.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="nf">importNvSciSyncObject</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">nvSciSyncObj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreHandleDesc</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">desc</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaExternalSemaphoreHandleTypeNvSciSync</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">desc</span><span class="p">.</span><span class="n">handle</span><span class="p">.</span><span class="n">nvSciSyncObj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nvSciSyncObj</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaImportExternalSemaphore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Deleting/Freeing the nvSciSyncObj beyond this point will lead to undefined behavior in CUDA</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">extSem</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="signaling-waiting-on-imported-synchronization-objects-nvsci">
<span id="id118"></span><h5><span class="section-number">3.2.16.5.5. </span>Signaling/Waiting on Imported Synchronization Objects<a class="headerlink" href="#signaling-waiting-on-imported-synchronization-objects-nvsci" title="Permalink to this headline">ï</a></h5>
<p>An imported <code class="docutils literal notranslate"><span class="pre">NvSciSyncObj</span></code> object can be signaled as outlined below. Signaling NvSciSync backed semaphore object initializes the <em>fence</em> parameter passed as input. This fence parameter is waited upon by a wait operation that corresponds to the aforementioned signal. Additionally, the wait that waits on this signal must be issued after this signal has been issued. If the flags are set to <code class="docutils literal notranslate"><span class="pre">cudaExternalSemaphoreSignalSkipNvSciBufMemSync</span></code> then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When <code class="docutils literal notranslate"><span class="pre">NvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency</span></code> is FALSE, this flag should be set.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">signalExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaExternalSemaphoreSignalParams</span><span class="w"> </span><span class="n">signalParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">signalParams</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">signalParams</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">signalParams</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">nvSciSync</span><span class="p">.</span><span class="n">fence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">signalParams</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//OR cudaExternalSemaphoreSignalSkipNvSciBufMemSync</span>

<span class="w">    </span><span class="n">cudaSignalExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">signalParams</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>An imported <code class="docutils literal notranslate"><span class="pre">NvSciSyncObj</span></code> object can be waited upon as outlined below. Waiting on NvSciSync backed semaphore object waits until the input <em>fence</em> parameter is signaled by the corresponding signaler. Additionally, the signal must be issued before the wait can be issued. If the flags are set to <code class="docutils literal notranslate"><span class="pre">cudaExternalSemaphoreWaitSkipNvSciBufMemSync</span></code> then memory synchronization operations (over all the imported NvSciBuf in this process) that are executed as a part of the signal operation by default are skipped. When <code class="docutils literal notranslate"><span class="pre">NvsciBufGeneralAttrKey_GpuSwNeedCacheCoherency</span></code> is FALSE, this flag should be set.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">waitExternalSemaphore</span><span class="p">(</span><span class="n">cudaExternalSemaphore_t</span><span class="w"> </span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">cudaExternalSemaphoreWaitParams</span><span class="w"> </span><span class="n">waitParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waitParams</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">waitParams</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">waitParams</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">nvSciSync</span><span class="p">.</span><span class="n">fence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fence</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">waitParams</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">//OR cudaExternalSemaphoreWaitSkipNvSciBufMemSync</span>

<span class="w">    </span><span class="n">cudaWaitExternalSemaphoresAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extSem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">waitParams</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="versioning-and-compatibility">
<span id="id119"></span><h2><span class="section-number">3.3. </span>Versioning and Compatibility<a class="headerlink" href="#versioning-and-compatibility" title="Permalink to this headline">ï</a></h2>
<p>There are two version numbers that developers should care about when developing a CUDA application: The compute capability that describes the general specifications and features of the compute device (see <a class="reference internal" href="#compute-capability"><span class="std std-ref">Compute Capability</span></a>) and the version of the CUDA driver API that describes the features supported by the driver API and runtime.</p>
<p>The version of the driver API is defined in the driver header file as <code class="docutils literal notranslate"><span class="pre">CUDA_VERSION</span></code>. It allows developers to check whether their application requires a newer device driver than the one currently installed. This is important, because the driver API is <em>backward compatible</em>, meaning that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will continue to work on subsequent device driver releases as illustrated in <a class="reference internal" href="#versioning-and-compatibility-driver-api-is-backward-but-not-forward-compatible"><span class="std std-ref">Figure 12</span></a>. The driver API is not <em>forward compatible</em>, which means that applications, plug-ins, and libraries (including the CUDA runtime) compiled against a particular version of the driver API will not work on previous versions of the device driver.</p>
<p>It is important to note that there are limitations on the mixing and matching of versions that is supported:</p>
<ul class="simple">
<li><p>Since only one version of the CUDA Driver can be installed at a time on a system, the installed driver must be of the same or higher version than the maximum Driver API version against which any application, plug-ins, or libraries that must run on that system were built.</p></li>
<li><p>All plug-ins and libraries used by an application must use the same version of the CUDA Runtime unless they statically link to the Runtime, in which case multiple versions of the runtime can coexist in the same process space. Note that if <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> is used to link the application, the static version of the CUDA Runtime library will be used by default, and all CUDA Toolkit libraries are statically linked against the CUDA Runtime.</p></li>
<li><p>All plug-ins and libraries used by an application must use the same version of any libraries that use the runtime (such as cuFFT, cuBLAS, â¦) unless statically linking to those libraries.</p></li>
</ul>
<figure class="align-center" id="versioning-and-compatibility-driver-api-is-backward-but-not-forward-compatible">
<img alt="The Driver API Is Backward but Not Forward Compatible" src="_images/compatibility-of-cuda-versions.png" />
<figcaption>
<p><span class="caption-number">Figure 25 </span><span class="caption-text">The Driver API Is Backward but Not Forward Compatible</span><a class="headerlink" href="#versioning-and-compatibility-driver-api-is-backward-but-not-forward-compatible" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>For Tesla GPU products, CUDA 10 introduced a new forward-compatible upgrade path for the user-mode components of the CUDA Driver. This feature is described in <a class="reference external" href="https://docs.nvidia.com/deploy/cuda-compatibility/index.html">CUDA Compatibility</a>. The requirements on the CUDA Driver version described here apply to the version of the user-mode components.</p>
</section>
<section id="compute-modes">
<span id="id120"></span><h2><span class="section-number">3.4. </span>Compute Modes<a class="headerlink" href="#compute-modes" title="Permalink to this headline">ï</a></h2>
<p>On Tesla solutions running Windows Server 2008 and later or Linux, one can set any device in a system in one of the three following modes using NVIDIAâs System Management Interface (nvidia-smi), which is a tool distributed as part of the driver:</p>
<ul class="simple">
<li><p><em>Default</em> compute mode: Multiple host threads can use the device (by calling <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> on this device, when using the runtime API, or by making current a context associated to the device, when using the driver API) at the same time.</p></li>
<li><p><em>Exclusive-process</em> compute mode: Only one CUDA context may be created on the device across all processes in the system. The context may be current to as many threads as desired within the process that created that context.</p></li>
<li><p><em>Prohibited</em> compute mode: No CUDA context can be created on the device.</p></li>
</ul>
<p>This means, in particular, that a host thread using the runtime API without explicitly calling <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> might be associated with a device other than device 0 if device 0 turns out to be in prohibited mode or in exclusive-process mode and used by another process. <code class="docutils literal notranslate"><span class="pre">cudaSetValidDevices()</span></code> can be used to set a device from a prioritized list of devices.</p>
<p>Note also that, for devices featuring the Pascal architecture onwards (compute capability with major revision number 6 and higher), there exists support for Compute Preemption. This allows compute tasks to be preempted at instruction-level granularity, rather than thread block granularity as in prior Maxwell and Kepler GPU architecture, with the benefit that applications with long-running kernels can be prevented from either monopolizing the system or timing out. However, there will be context switch overheads associated with Compute Preemption, which is automatically enabled on those devices for which support exists. The individual attribute query function <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute()</span></code> with the attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrComputePreemptionSupported</span></code> can be used to determine if the device in use supports Compute Preemption. Users wishing to avoid context switch overheads associated with different processes can ensure that only one process is active on the GPU by selecting exclusive-process mode.</p>
<p>Applications may query the compute mode of a device by checking the <code class="docutils literal notranslate"><span class="pre">computeMode</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>).</p>
</section>
<section id="mode-switches">
<span id="id121"></span><h2><span class="section-number">3.5. </span>Mode Switches<a class="headerlink" href="#mode-switches" title="Permalink to this headline">ï</a></h2>
<p>GPUs that have a display output dedicate some DRAM memory to the so-called <em>primary surface</em>, which is used to refresh the display device whose output is viewed by the user. When users initiate a <em>mode switch</em> of the display by changing the resolution or bit depth of the display (using NVIDIA control panel or the Display control panel on Windows), the amount of memory needed for the primary surface changes. For example, if the user changes the display resolution from 1280x1024x32-bit to 1600x1200x32-bit, the system must dedicate 7.68 MB to the primary surface rather than 5.24 MB. (Full-screen graphics applications running with anti-aliasing enabled may require much more display memory for the primary surface.) On Windows, other events that may initiate display mode switches include launching a full-screen DirectX application, hitting Alt+Tab to task switch away from a full-screen DirectX application, or hitting Ctrl+Alt+Del to lock the computer.</p>
<p>If a mode switch increases the amount of memory needed for the primary surface, the system may have to cannibalize memory allocations dedicated to CUDA applications. Therefore, a mode switch results in any call to the CUDA runtime to fail and return an invalid context error.</p>
</section>
<section id="tesla-compute-cluster-mode-for-windows">
<h2><span class="section-number">3.6. </span>Tesla Compute Cluster Mode for Windows<a class="headerlink" href="#tesla-compute-cluster-mode-for-windows" title="Permalink to this headline">ï</a></h2>
<p>Using NVIDIAâs System Management Interface (<em>nvidia-smi</em>), the Windows device driver can be put in TCC (Tesla Compute Cluster) mode for devices of the Tesla and Quadro Series.</p>
<p>TCC mode removes support for any graphics functionality.</p>
</section>
</section>
<section id="hardware-implementation">
<span id="id122"></span><h1><span class="section-number">4. </span>Hardware Implementation<a class="headerlink" href="#hardware-implementation" title="Permalink to this headline">ï</a></h1>
<p>The NVIDIA GPU architecture is built around a scalable array of multithreaded <em>Streaming Multiprocessors</em> (<em>SMs</em>). When a CUDA program on the host CPU invokes a kernel grid, the blocks of the grid are enumerated and distributed to multiprocessors with available execution capacity. The threads of a thread block execute concurrently on one multiprocessor, and multiple thread blocks can execute concurrently on one multiprocessor. As thread blocks terminate, new blocks are launched on the vacated multiprocessors.</p>
<p>A multiprocessor is designed to execute hundreds of threads concurrently. To manage such a large number of threads, it employs a unique architecture called <em>SIMT</em> (<em>Single-Instruction, Multiple-Thread</em>) that is described in <a class="reference internal" href="#simt-architecture"><span class="std std-ref">SIMT Architecture</span></a>. The instructions are pipelined, leveraging instruction-level parallelism within a single thread, as well as extensive thread-level parallelism through simultaneous hardware multithreading as detailed in <a class="reference internal" href="#hardware-multithreading"><span class="std std-ref">Hardware Multithreading</span></a>. Unlike CPU cores, they are issued in order and there is no branch prediction or speculative execution.</p>
<p><a class="reference internal" href="#simt-architecture"><span class="std std-ref">SIMT Architecture</span></a> and <a class="reference internal" href="#hardware-multithreading"><span class="std std-ref">Hardware Multithreading</span></a> describe the architecture features of the streaming multiprocessor that are common to all devices. <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, and <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a> provide the specifics for devices of compute capabilities 5.x, 6.x, and 7.x respectively.</p>
<p>The NVIDIA GPU architecture uses a little-endian representation.</p>
<section id="simt-architecture">
<span id="id123"></span><h2><span class="section-number">4.1. </span>SIMT Architecture<a class="headerlink" href="#simt-architecture" title="Permalink to this headline">ï</a></h2>
<p>The multiprocessor creates, manages, schedules, and executes threads in groups of 32 parallel threads called <em>warps</em>. Individual threads composing a warp start together at the same program address, but they have their own instruction address counter and register state and are therefore free to branch and execute independently. The term <em>warp</em> originates from weaving, the first parallel thread technology. A <em>half-warp</em> is either the first or second half of a warp. A <em>quarter-warp</em> is either the first, second, third, or fourth quarter of a warp.</p>
<p>When a multiprocessor is given one or more thread blocks to execute, it partitions them into warps and each warp gets scheduled by a <em>warp scheduler</em> for execution. The way a block is partitioned into warps is always the same; each warp contains threads of consecutive, increasing thread IDs with the first warp containing thread 0. <a class="reference internal" href="#thread-hierarchy"><span class="std std-ref">Thread Hierarchy</span></a> describes how thread IDs relate to thread indices in the block.</p>
<p>A warp executes one common instruction at a time, so full efficiency is realized when all 32 threads of a warp agree on their execution path. If threads of a warp diverge via a data-dependent conditional branch, the warp executes each branch path taken, disabling threads that are not on that path. Branch divergence occurs only within a warp; different warps execute independently regardless of whether they are executing common or disjoint code paths.</p>
<p>The SIMT architecture is akin to SIMD (Single Instruction, Multiple Data) vector organizations in that a single instruction controls multiple processing elements. A key difference is that SIMD vector organizations expose the SIMD width to the software, whereas SIMT instructions specify the execution and branching behavior of a single thread. In contrast with SIMD vector machines, SIMT enables programmers to write thread-level parallel code for independent, scalar threads, as well as data-parallel code for coordinated threads. For the purposes of correctness, the programmer can essentially ignore the SIMT behavior; however, substantial performance improvements can be realized by taking care that the code seldom requires threads in a warp to diverge. In practice, this is analogous to the role of cache lines in traditional code: Cache line size can be safely ignored when designing for correctness but must be considered in the code structure when designing for peak performance. Vector architectures, on the other hand, require the software to coalesce loads into vectors and manage divergence manually.</p>
<p>Prior to NVIDIA Volta, warps used a single program counter shared amongst all 32 threads in the warp together with an active mask specifying the active threads of the warp. As a result, threads from the same warp in divergent regions or different states of execution cannot signal each other or exchange data, and algorithms requiring fine-grained sharing of data guarded by locks or mutexes can easily lead to deadlock, depending on which warp the contending threads come from.</p>
<p>Starting with the NVIDIA Volta architecture, <em>Independent Thread Scheduling</em> allows full concurrency between threads, regardless of warp. With Independent Thread Scheduling, the GPU maintains execution state per thread, including a program counter and call stack, and can yield execution at a per-thread granularity, either to make better use of execution resources or to allow one thread to wait for data to be produced by another. A schedule optimizer determines how to group active threads from the same warp together into SIMT units. This retains the high throughput of SIMT execution as in prior NVIDIA GPUs, but with much more flexibility: threads can now diverge and reconverge at sub-warp granularity.</p>
<p>Independent Thread Scheduling can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp-synchronicity<a class="footnote-reference brackets" href="#fn2" id="id124">2</a> of previous hardware architectures. In particular, any warp-synchronous code (such as synchronization-free, intra-warp reductions) should be revisited to ensure compatibility with NVIDIA Volta and beyond. See <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a> for further details.</p>
<div class="admonition note" id="simt-architecture-notes">
<p class="admonition-title">Note</p>
<p>The threads of a warp that are participating in the current instruction are called the <em>active</em> threads, whereas threads not on the current instruction are <em>inactive</em> (disabled). Threads can be inactive for a variety of reasons including having exited earlier than other threads of their warp, having taken a different branch path than the branch path currently executed by the warp, or being the last threads of a block whose number of threads is not a multiple of the warp size.</p>
<p>If a non-atomic instruction executed by a warp writes to the same location in global or shared memory for more than one of the threads of the warp, the number of serialized writes that occur to that location varies depending on the compute capability of the device (see <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, and <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>), and which thread performs the final write is undefined.</p>
<p>If an <a class="reference internal" href="#atomic-functions"><span class="std std-ref">atomic</span></a> instruction executed by a warp reads, modifies, and writes to the same location in global memory for more than one of the threads of the warp, each read/modify/write to that location occurs and they are all serialized, but the order in which they occur is undefined.</p>
</div>
</section>
<section id="hardware-multithreading">
<span id="id125"></span><h2><span class="section-number">4.2. </span>Hardware Multithreading<a class="headerlink" href="#hardware-multithreading" title="Permalink to this headline">ï</a></h2>
<p>The execution context (program counters, registers, and so on) for each warp processed by a multiprocessor is maintained on-chip during the entire lifetime of the warp. Therefore, switching from one execution context to another has no cost, and at every instruction issue time, a warp scheduler selects a warp that has threads ready to execute its next instruction (the <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">active threads</span></a> of the warp) and issues the instruction to those threads.</p>
<p>In particular, each multiprocessor has a set of 32-bit registers that are partitioned among the warps, and a <em>parallel data cache</em> or <em>shared memory</em> that is partitioned among the thread blocks.</p>
<p>The number of blocks and warps that can reside and be processed together on the multiprocessor for a given kernel depends on the amount of registers and shared memory used by the kernel and the amount of registers and shared memory available on the multiprocessor. There are also a maximum number of resident blocks and a maximum number of resident warps per multiprocessor. These limits as well the amount of registers and shared memory available on the multiprocessor are a function of the compute capability of the device and are given in <a class="reference internal" href="#compute-capabilities"><span class="std std-ref">Compute Capabilities</span></a>. If there are not enough registers or shared memory available per multiprocessor to process at least one block, the kernel will fail to launch.</p>
<p>The total number of warps in a block is as follows:</p>
<p><span class="math notranslate nohighlight">\(\text{ceil}\left( \frac{T}{W_{size}},1 \right)\)</span></p>
<ul class="simple">
<li><p><em>T</em> is the number of threads per block,</p></li>
<li><p><em>Wsize</em> is the warp size, which is equal to 32,</p></li>
<li><p>ceil(x, y) is equal to x rounded up to the nearest multiple of y.</p></li>
</ul>
<p>The total number of registers and total amount of shared memory allocated for a block are documented in the CUDA Occupancy Calculator provided in the CUDA Toolkit.</p>
<dl class="footnote brackets">
<dt class="label" id="fn2"><span class="brackets"><a class="fn-backref" href="#id124">2</a></span></dt>
<dd><p>The term <em>warp-synchronous</em> refers to code that implicitly assumes threads in the same warp are synchronized at every instruction.</p>
</dd>
</dl>
</section>
</section>
<section id="performance-guidelines">
<span id="id126"></span><h1><span class="section-number">5. </span>Performance Guidelines<a class="headerlink" href="#performance-guidelines" title="Permalink to this headline">ï</a></h1>
<section id="overall-performance-optimization-strategies">
<span id="id127"></span><h2><span class="section-number">5.1. </span>Overall Performance Optimization Strategies<a class="headerlink" href="#overall-performance-optimization-strategies" title="Permalink to this headline">ï</a></h2>
<p>Performance optimization revolves around four basic strategies:</p>
<ul class="simple">
<li><p>Maximize parallel execution to achieve maximum utilization;</p></li>
<li><p>Optimize memory usage to achieve maximum memory throughput;</p></li>
<li><p>Optimize instruction usage to achieve maximum instruction throughput;</p></li>
<li><p>Minimize memory thrashing.</p></li>
</ul>
<p>Which strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example. Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler. Also, comparing the floating-point operation throughput or memory throughputâwhichever makes more senseâof a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel.</p>
</section>
<section id="maximize-utilization">
<span id="id128"></span><h2><span class="section-number">5.2. </span>Maximize Utilization<a class="headerlink" href="#maximize-utilization" title="Permalink to this headline">ï</a></h2>
<p>To maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time.</p>
<section id="application-level">
<span id="id129"></span><h3><span class="section-number">5.2.1. </span>Application Level<a class="headerlink" href="#application-level" title="Permalink to this headline">ï</a></h3>
<p>At a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by using asynchronous functions calls and streams as described in <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>. It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices.</p>
<p>For the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> and share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory. The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic. Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter-thread communication are performed within a single thread block as much as possible.</p>
</section>
<section id="device-level">
<span id="id130"></span><h3><span class="section-number">5.2.2. </span>Device Level<a class="headerlink" href="#device-level" title="Permalink to this headline">ï</a></h3>
<p>At a lower level, the application should maximize parallel execution between the multiprocessors of a device.</p>
<p>Multiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in <a class="reference internal" href="#asynchronous-concurrent-execution"><span class="std std-ref">Asynchronous Concurrent Execution</span></a>.</p>
</section>
<section id="multiprocessor-level">
<span id="id131"></span><h3><span class="section-number">5.2.3. </span>Multiprocessor Level<a class="headerlink" href="#multiprocessor-level" title="Permalink to this headline">ï</a></h3>
<p>At an even lower level, the application should maximize parallel execution between the various functional units within a multiprocessor.</p>
<p>As described in <a class="reference internal" href="#hardware-multithreading"><span class="std std-ref">Hardware Multithreading</span></a>, a GPU multiprocessor primarily relies on thread-level parallelism to maximize utilization of its functional units. Utilization is therefore directly linked to the number of resident warps. At every instruction issue time, a warp scheduler selects an instruction that is ready to execute. This instruction can be another independent instruction of the same warp, exploiting instruction-level parallelism, or more commonly an instruction of another warp, exploiting thread-level parallelism. If a ready to execute instruction is selected it is issued to the <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">active</span></a> threads of the warp. The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the <em>latency</em>, and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely âhiddenâ. The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see <a class="reference internal" href="#arithmetic-instructions"><span class="std std-ref">Arithmetic Instructions</span></a> for the throughputs of various arithmetic instructions). If we assume instructions with maximum throughput, it is equal to:</p>
<ul class="simple">
<li><p><em>4L</em> for devices of compute capability 5.x, 6.1, 6.2, 7.x and 8.x since for these devices, a multiprocessor issues one instruction per warp over one clock cycle for four warps at a time, as mentioned in <a class="reference internal" href="#compute-capabilities"><span class="std std-ref">Compute Capabilities</span></a>.</p></li>
<li><p><em>2L</em> for devices of compute capability 6.0 since for these devices, the two instructions issued every cycle are one instruction for two different warps.</p></li>
</ul>
<p>The most common reason a warp is not ready to execute its next instruction is that the instructionâs input operands are not available yet.</p>
<p>If all input operands are registers, latency is caused by register dependencies, i.e., some of the input operands are written by some previous instruction(s) whose execution has not completed yet. In this case, the latency is equal to the execution time of the previous instruction and the warp schedulers must schedule instructions of other warps during that time. Execution time varies depending on the instruction. On devices of compute capability 7.x, for most arithmetic instructions, it is typically 4 clock cycles. This means that 16 active warps per multiprocessor (4 cycles, 4 warp schedulers) are required to hide arithmetic instruction latencies (assuming that warps execute instructions with maximum throughput, otherwise fewer warps are needed). If the individual warps exhibit instruction-level parallelism, i.e. have multiple independent instructions in their instruction stream, fewer warps are needed because multiple independent instructions from a single warp can be issued back to back.</p>
<p>If some input operand resides in off-chip memory, the latency is much higher: typically hundreds of clock cycles. The number of warps required to keep the warp schedulers busy during such high latency periods depends on the kernel code and its degree of instruction-level parallelism. In general, more warps are required if the ratio of the number of instructions with no off-chip memory operands (i.e., arithmetic instructions most of the time) to the number of instructions with off-chip memory operands is low (this ratio is commonly called the arithmetic intensity of the program).</p>
<p>Another reason a warp is not ready to execute its next instruction is that it is waiting at some memory fence (<a class="reference internal" href="#memory-fence-functions"><span class="std std-ref">Memory Fence Functions</span></a>) or synchronization point (<a class="reference internal" href="#synchronization-functions"><span class="std std-ref">Synchronization Functions</span></a>). A synchronization point can force the multiprocessor to idle as more and more warps wait for other warps in the same block to complete execution of instructions prior to the synchronization point. Having multiple resident blocks per multiprocessor can help reduce idling in this case, as warps from different blocks do not need to wait for each other at synchronization points.</p>
<p>The number of blocks and warps residing on each multiprocessor for a given kernel call depends on the execution configuration of the call (<a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a>), the memory resources of the multiprocessor, and the resource requirements of the kernel as described in <a class="reference internal" href="#hardware-multithreading"><span class="std std-ref">Hardware Multithreading</span></a>. Register and shared memory usage are reported by the compiler when compiling with the <code class="docutils literal notranslate"><span class="pre">--ptxas-options=-v</span></code> option.</p>
<p>The total amount of shared memory required for a block is equal to the sum of the amount of statically allocated shared memory and the amount of dynamically allocated shared memory.</p>
<p>The number of registers used by a kernel can have a significant impact on the number of resident warps. For example, for devices of compute capability 6.x, if a kernel uses 64
registers and each block has 512 threads and requires very little shared memory, then two blocks (i.e., 32 warps) can reside on the multiprocessor since they require 2x512x64
registers, which exactly matches the number of registers available on the multiprocessor. But as soon as the kernel uses one more register, only one block (i.e., 16 warps) can be
resident since two blocks would require 2x512x65 registers, which are more registers than are available on the multiprocessor. Therefore, the compiler attempts to minimize register
usage while keeping register spilling (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>) and the number of instructions to a minimum. Register usage can be
controlled using the <code class="docutils literal notranslate"><span class="pre">maxrregcount</span></code> compiler option, the <code class="docutils literal notranslate"><span class="pre">__launch_bounds__()</span></code> qualifier as described in <a class="reference internal" href="#launch-bounds"><span class="std std-ref">Launch Bounds</span></a>, or the <code class="docutils literal notranslate"><span class="pre">__maxnreg__()</span></code>
qualifier as described in <a class="reference internal" href="#maximum-number-of-registers-per-thread"><span class="std std-ref">Maximum Number of Registers per Thread</span></a>.</p>
<p>The register file is organized as 32-bit registers. So, each variable stored in a register needs at least one 32-bit register, for example, a <code class="docutils literal notranslate"><span class="pre">double</span></code> variable uses two 32-bit registers.</p>
<p>The effect of execution configuration on performance for a given kernel call generally depends on the kernel code. Experimentation is therefore recommended. Applications can also parametrize execution configurations based on register file size and shared memory size, which depends on the compute capability of the device, as well as on the number of multiprocessors and memory bandwidth of the device, all of which can be queried using the runtime (see reference manual).</p>
<p>The number of threads per block should be chosen as a multiple of the warp size to avoid wasting computing resources with under-populated warps as much as possible.</p>
<section id="occupancy-calculator">
<span id="id132"></span><h4><span class="section-number">5.2.3.1. </span>Occupancy Calculator<a class="headerlink" href="#occupancy-calculator" title="Permalink to this headline">ï</a></h4>
<p>Several API functions exist to assist programmers in choosing thread block size and cluster size based on register and shared memory requirements.</p>
<ul class="simple">
<li><p>The occupancy calculator API, <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span></code>, can provide an occupancy prediction based on the block size and shared memory usage of a kernel. This function reports occupancy in terms of the number of concurrent thread blocks per multiprocessor.</p>
<ul>
<li><p>Note that this value can be converted to other metrics. Multiplying by the number of warps per block yields the number of concurrent warps per multiprocessor; further dividing concurrent warps by max warps per multiprocessor gives the occupancy as a percentage.</p></li>
</ul>
</li>
<li><p>The occupancy-based launch configurator APIs, <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSize</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSizeVariableSMem</span></code>, heuristically calculate an execution configuration that achieves the maximum multiprocessor-level occupancy.</p></li>
<li><p>The occupancy calculator API, <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxActiveClusters</span></code>, can provided occupancy prediction based on the cluster size, block size and shared memory usage of a kernel. This function reports occupancy in terms of number of max active clusters of a given size on the GPU present in the system.</p></li>
</ul>
<p>The following code sample calculates the occupancy of MyKernel. It then reports the occupancy level with the ratio between concurrent warps versus maximum warps per multiprocessor.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">d</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numBlocks</span><span class="p">;</span><span class="w">        </span><span class="c1">// Occupancy in terms of active blocks</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blockSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// These variables are used to convert occupancy to warps</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">prop</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">activeWarps</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">maxWarps</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaGetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">numBlocks</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">MyKernel</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">blockSize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">activeWarps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numBlocks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockSize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">prop</span><span class="p">.</span><span class="n">warpSize</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">maxWarps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prop</span><span class="p">.</span><span class="n">maxThreadsPerMultiProcessor</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">prop</span><span class="p">.</span><span class="n">warpSize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Occupancy: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">activeWarps</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">maxWarps</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;%&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following code sample configures an occupancy-based kernel launch of MyKernel according to the user input.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayCount</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arrayCount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">launchMyKernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayCount</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blockSize</span><span class="p">;</span><span class="w">      </span><span class="c1">// The launch configurator returned block size</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">minGridSize</span><span class="p">;</span><span class="w">    </span><span class="c1">// The minimum grid size needed to achieve the</span>
<span class="w">                        </span><span class="c1">// maximum occupancy for a full device</span>
<span class="w">                        </span><span class="c1">// launch</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">gridSize</span><span class="p">;</span><span class="w">       </span><span class="c1">// The actual grid size needed, based on input</span>
<span class="w">                        </span><span class="c1">// size</span>

<span class="w">    </span><span class="n">cudaOccupancyMaxPotentialBlockSize</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">minGridSize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">blockSize</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">MyKernel</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">arrayCount</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Round up according to array size</span>
<span class="w">    </span><span class="n">gridSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">arrayCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">blockSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">blockSize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">gridSize</span><span class="p">,</span><span class="w"> </span><span class="n">blockSize</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">arrayCount</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// If interested, the occupancy can be calculated with</span>
<span class="w">    </span><span class="c1">// cudaOccupancyMaxActiveBlocksPerMultiprocessor</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following code sample shows how to use the cluster occupancy API to find the max number of active clusters of a given size. Example code below calucaltes occupancy for cluster of size 2 and 128 threads per block.</p>
<p>Cluster size of 8 is forward compatible starting compute capability 9.0, except on GPU hardware or MIG configurations which are too small to support 8 multiprocessors in which case the maximum cluster size will be reduced. But it is recommended that the users query the maximum cluster size before launching a cluster kernel. Max cluster size can be queried using <code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialClusterSize</span></code> API.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaLaunchConfig_t</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">gridDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number_of_blocks</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">blockDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="c1">// threads_per_block = 128</span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">dynamicSmemBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynamic_shared_memory_size</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeClusterDimension</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// cluster_size = 2</span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">config</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">max_cluster_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaOccupancyMaxPotentialClusterSize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_cluster_size</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">max_active_clusters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaOccupancyMaxActiveClusters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_active_clusters</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Max Active Clusters of size 2: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">max_active_clusters</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The CUDA Nsight Compute User Interface also provides a standalone occupancy calculator and launch configurator implementation in <code class="docutils literal notranslate"><span class="pre">&lt;CUDA_Toolkit_Path&gt;/include/cuda_occupancy.h</span></code> for any use cases that cannot depend on the CUDA software stack. The Nsight Compute version of the occupancy calculator is particularly useful as a learning tool that visualizes the impact of changes to the parameters that affect occupancy (block size, registers per thread, and shared memory per thread).</p>
</section>
</section>
</section>
<section id="maximize-memory-throughput">
<span id="id133"></span><h2><span class="section-number">5.3. </span>Maximize Memory Throughput<a class="headerlink" href="#maximize-memory-throughput" title="Permalink to this headline">ï</a></h2>
<p>The first step in maximizing overall memory throughput for the application is to minimize data transfers with low bandwidth.</p>
<p>That means minimizing data transfers between the host and the device, as detailed in <a class="reference internal" href="#data-transfer-between-host-and-device"><span class="std std-ref">Data Transfer between Host and Device</span></a>, since these have much lower bandwidth than data transfers between global memory and the device.</p>
<p>That also means minimizing data transfers between global memory and the device by maximizing use of on-chip memory: shared memory and caches (i.e., L1 cache and L2 cache available on devices of compute capability 2.x and higher, texture cache and constant cache available on all devices).</p>
<p>Shared memory is equivalent to a user-managed cache: The application explicitly allocates and accesses it. As illustrated in <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a>, a typical programming pattern is to stage data coming from device memory into shared memory; in other words, to have each thread of a block:</p>
<ul class="simple">
<li><p>Load data from device memory to shared memory,</p></li>
<li><p>Synchronize with all the other threads of the block so that each thread can safely read shared memory locations that were populated by different threads,</p></li>
<li><p>Process the data in shared memory,</p></li>
<li><p>Synchronize again if necessary to make sure that shared memory has been updated with the results,</p></li>
<li><p>Write the results back to device memory.</p></li>
</ul>
<p>For some applications (for example, for which global memory access patterns are data-dependent), a traditional hardware-managed cache is more appropriate to exploit data locality. As mentioned in <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>, <a class="reference internal" href="#compute-capability-8-x"><span class="std std-ref">Compute Capability 8.x</span></a> and <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, for devices of compute capability 7.x, 8.x and 9.0, the same on-chip memory is used for both L1 and shared memory, and how much of it is dedicated to L1 versus shared memory is configurable for each kernel call.</p>
<p>The throughput of memory accesses by a kernel can vary by an order of magnitude depending on access pattern for each type of memory. The next step in maximizing memory throughput is therefore to organize memory accesses as optimally as possible based on the optimal memory access patterns described in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>. This optimization is especially important for global memory accesses as global memory bandwidth is low compared to available on-chip bandwidths and arithmetic instruction throughput, so non-optimal global memory accesses generally have a high impact on performance.</p>
<section id="data-transfer-between-host-and-device">
<span id="id134"></span><h3><span class="section-number">5.3.1. </span>Data Transfer between Host and Device<a class="headerlink" href="#data-transfer-between-host-and-device" title="Permalink to this headline">ï</a></h3>
<p>Applications should strive to minimize data transfer between the host and the device. One way to accomplish this is to move more code from the host to the device, even if that means running kernels that do not expose enough parallelism to execute on the device with full efficiency. Intermediate data structures may be created in device memory, operated on by the device, and destroyed without ever being mapped by the host or copied to host memory.</p>
<p>Also, because of the overhead associated with each transfer, batching many small transfers into a single large transfer always performs better than making each transfer separately.</p>
<p>On systems with a front-side bus, higher performance for data transfers between host and device is achieved by using page-locked host memory as described in <a class="reference internal" href="#page-locked-host-memory"><span class="std std-ref">Page-Locked Host Memory</span></a>.</p>
<p>In addition, when using mapped page-locked memory (<a class="reference internal" href="#mapped-memory"><span class="std std-ref">Mapped Memory</span></a>), there is no need to allocate any device memory and explicitly copy data between device and host memory. Data transfers are implicitly performed each time the kernel accesses the mapped memory. For maximum performance, these memory accesses must be coalesced as with accesses to global memory (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>). Assuming that they are and that the mapped memory is read or written only once, using mapped page-locked memory instead of explicit copies between device and host memory can be a win for performance.</p>
<p>On integrated systems where device memory and host memory are physically the same, any copy between host and device memory is superfluous and mapped page-locked memory should be used instead. Applications may query a device is <code class="docutils literal notranslate"><span class="pre">integrated</span></code> by checking that the integrated device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>) is equal to 1.</p>
</section>
<section id="device-memory-accesses">
<span id="id135"></span><h3><span class="section-number">5.3.2. </span>Device Memory Accesses<a class="headerlink" href="#device-memory-accesses" title="Permalink to this headline">ï</a></h3>
<p>An instruction that accesses addressable memory (i.e., global, local, shared, constant, or texture memory) might need to be re-issued multiple times depending on the distribution of the memory addresses across the threads within the warp. How the distribution affects the instruction throughput this way is specific to each type of memory and described in the following sections. For example, for global memory, as a general rule, the more scattered the addresses are, the more reduced the throughput is.</p>
<p><strong>Global Memory</strong></p>
<p>Global memory resides in device memory and device memory is accessed via 32-, 64-, or 128-byte memory transactions. These memory transactions must be naturally aligned: Only the 32-, 64-, or 128-byte segments of device memory that are aligned to their size (i.e., whose first address is a multiple of their size) can be read or written by memory transactions.</p>
<p>When a warp executes an instruction that accesses global memory, it coalesces the memory accesses of the threads within the warp into one or more of these memory transactions depending on the size of the word accessed by each thread and the distribution of the memory addresses across the threads. In general, the more transactions are necessary, the more unused words are transferred in addition to the words accessed by the threads, reducing the instruction throughput accordingly. For example, if a 32-byte memory transaction is generated for each threadâs 4-byte access, throughput is divided by 8.</p>
<p>How many transactions are necessary and how much throughput is ultimately affected varies with the compute capability of the device. <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>, <a class="reference internal" href="#compute-capability-8-x"><span class="std std-ref">Compute Capability 8.x</span></a>, <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, <a class="reference internal" href="#compute-capability-10-x"><span class="std std-ref">Compute Capability 10.x</span></a>, and <a class="reference internal" href="#compute-capability-12-x"><span class="std std-ref">Compute Capability 12.0</span></a> give more details on how global memory accesses are handled for various compute capabilities.</p>
<p>To maximize global memory throughput, it is therefore important to maximize coalescing by:</p>
<ul class="simple">
<li><p>Following the most optimal access patterns based on <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>, <a class="reference internal" href="#compute-capability-8-x"><span class="std std-ref">Compute Capability 8.x</span></a>,  <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, <a class="reference internal" href="#compute-capability-10-x"><span class="std std-ref">Compute Capability 10.x</span></a>, and <a class="reference internal" href="#compute-capability-12-x"><span class="std std-ref">Compute Capability 12.0</span></a>.</p></li>
<li><p>Using data types that meet the size and alignment requirement detailed in the section Size and Alignment Requirement below,</p></li>
<li><p>Padding data in some cases, for example, when accessing a two-dimensional array as described in the section Two-Dimensional Arrays below.</p></li>
</ul>
<p><strong>Size and Alignment Requirement</strong></p>
<p>Global memory instructions support reading or writing words of size equal to 1, 2, 4, 8, or 16 bytes. Any access (via a variable or a pointer) to data residing in global memory compiles to a single global memory instruction if and only if the size of the data type is 1, 2, 4, 8, or 16 bytes and the data is naturally aligned (i.e., its address is a multiple of that size).</p>
<p>If this size and alignment requirement is not fulfilled, the access compiles to multiple instructions with interleaved access patterns that prevent these instructions from fully coalescing. It is therefore recommended to use types that meet this requirement for data that resides in global memory.</p>
<p>The alignment requirement is automatically fulfilled for the <a class="reference internal" href="#built-in-vector-types"><span class="std std-ref">Built-in Vector Types</span></a>.</p>
<p>For structures, the size and alignment requirements can be enforced by the compiler using the alignment specifiers<code class="docutils literal notranslate"><span class="pre">__align__(8)</span> <span class="pre">or</span> <span class="pre">__align__(16)</span></code>, such as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">__align__</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">__align__</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Any address of a variable residing in global memory or returned by one of the memory allocation routines from the driver or runtime API is always aligned to at least 256 bytes.</p>
<p>Reading non-naturally aligned 8-byte or 16-byte words produces incorrect results (off by a few words), so special care must be taken to maintain alignment of the starting address of any value or array of values of these types. A typical case where this might be easily overlooked is when using some custom global memory allocation scheme, whereby the allocations of multiple arrays (with multiple calls to <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuMemAlloc()</span></code>) is replaced by the allocation of a single large block of memory partitioned into multiple arrays, in which case the starting address of each array is offset from the blockâs starting address.</p>
<p><strong>Two-Dimensional Arrays</strong></p>
<p>A common global memory access pattern is when each thread of index <code class="docutils literal notranslate"><span class="pre">(tx,ty)</span></code> uses the following address to access one element of a 2D array of width <code class="docutils literal notranslate"><span class="pre">width</span></code>, located at address <code class="docutils literal notranslate"><span class="pre">BaseAddress</span></code> of type <code class="docutils literal notranslate"><span class="pre">type*</span></code> (where <code class="docutils literal notranslate"><span class="pre">type</span></code> meets the requirement described in <a class="reference internal" href="#maximize-utilization"><span class="std std-ref">Maximize Utilization</span></a>):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BaseAddress</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tx</span><span class="w"></span>
</pre></div>
</div>
<p>For these accesses to be fully coalesced, both the width of the thread block and the width of the array must be a multiple of the warp size.</p>
<p>In particular, this means that an array whose width is not a multiple of this size will be accessed much more efficiently if it is actually allocated with a width rounded up to the closest multiple of this size and its rows padded accordingly. The <code class="docutils literal notranslate"><span class="pre">cudaMallocPitch()</span></code> and <code class="docutils literal notranslate"><span class="pre">cuMemAllocPitch()</span></code> functions and associated memory copy functions described in the reference manual enable programmers to write non-hardware-dependent code to allocate arrays that conform to these constraints.</p>
<p><strong>Local Memory</strong></p>
<p>Local memory accesses only occur for some automatic variables as mentioned in <a class="reference internal" href="#variable-memory-space-specifiers"><span class="std std-ref">Variable Memory Space Specifiers</span></a>. Automatic variables that the compiler is likely to place in local memory are:</p>
<ul class="simple">
<li><p>Arrays for which it cannot determine that they are indexed with constant quantities,</p></li>
<li><p>Large structures or arrays that would consume too much register space,</p></li>
<li><p>Any variable if the kernel uses more registers than available (this is also known as <em>register spilling</em>).</p></li>
</ul>
<p>Inspection of the <em>PTX</em> assembly code (obtained by compiling with the <code class="docutils literal notranslate"><span class="pre">-ptx</span></code> or<code class="docutils literal notranslate"><span class="pre">-keep</span></code> option) will tell if a variable has been placed in local memory during the first compilation phases as it will be declared using the <code class="docutils literal notranslate"><span class="pre">.local</span></code> mnemonic and accessed using the <code class="docutils literal notranslate"><span class="pre">ld.local</span></code> and <code class="docutils literal notranslate"><span class="pre">st.local</span></code> mnemonics. Even if it has not, subsequent compilation phases might still decide otherwise though if they find it consumes too much register space for the targeted architecture: Inspection of the <em>cubin</em> object using <code class="docutils literal notranslate"><span class="pre">cuobjdump</span></code> will tell if this is the case. Also, the compiler reports total local memory usage per kernel (<code class="docutils literal notranslate"><span class="pre">lmem</span></code>) when compiling with the <code class="docutils literal notranslate"><span class="pre">--ptxas-options=-v</span></code> option. Note that some mathematical functions have implementation paths that might access local memory.</p>
<p>The local memory space resides in device memory, so local memory accesses have the same high latency and low bandwidth as global memory accesses and are subject to the same requirements for memory coalescing as described in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>. Local memory is however organized such that consecutive 32-bit words are accessed by consecutive thread IDs. Accesses are therefore fully coalesced as long as all threads in a warp access the same relative address (for example, same index in an array variable, same member in a structure variable).</p>
<p>On devices of compute capability 5.x onwards, local memory accesses are always cached in L2 in the same way as global memory accesses (see <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a> and <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>).</p>
<p><strong>Shared Memory</strong></p>
<p>Because it is on-chip, shared memory has much higher bandwidth and much lower latency than local or global memory.</p>
<p>To achieve high bandwidth, shared memory is divided into equally-sized memory modules, called banks, which can be accessed simultaneously. Any memory read or write request made of <em>n</em> addresses that fall in <em>n</em> distinct memory banks can therefore be serviced simultaneously, yielding an overall bandwidth that is <em>n</em> times as high as the bandwidth of a single module.</p>
<p>However, if two addresses of a memory request fall in the same memory bank, there is a bank conflict and the access has to be serialized. The hardware splits a memory request with bank conflicts into as many separate conflict-free requests as necessary, decreasing throughput by a factor equal to the number of separate memory requests. If the number of separate memory requests is <em>n</em>, the initial memory request is said to cause <em>n</em>-way bank conflicts.</p>
<p>To get maximum performance, it is therefore important to understand how memory addresses map to memory banks in order to schedule the memory requests so as to minimize bank conflicts. This is described in <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>, <a class="reference internal" href="#compute-capability-8-x"><span class="std std-ref">Compute Capability 8.x</span></a>, <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, <a class="reference internal" href="#compute-capability-10-x"><span class="std std-ref">Compute Capability 10.x</span></a>, and <a class="reference internal" href="#compute-capability-12-x"><span class="std std-ref">Compute Capability 12.0</span></a> for devices of these compute capabilities respectively.</p>
<p><strong>Constant Memory</strong></p>
<p>The constant memory space resides in device memory and is cached in the constant cache.</p>
<p>A request is then split into as many separate requests as there are different memory addresses in the initial request, decreasing throughput by a factor equal to the number of separate requests.</p>
<p>The resulting requests are then serviced at the throughput of the constant cache in case of a cache hit, or at the throughput of device memory otherwise.</p>
<p><strong>Texture and Surface Memory</strong></p>
<p>The texture and surface memory spaces reside in device memory and are cached in texture cache, so a texture fetch or surface read costs one memory read from device memory only on a cache miss, otherwise it just costs one read from texture cache. The texture cache is optimized for 2D spatial locality, so threads of the same warp that read texture or surface addresses that are close together in 2D will achieve best performance. Also, it is designed for streaming fetches with a constant latency; a cache hit reduces DRAM bandwidth demand but not fetch latency.</p>
<p>Reading device memory through texture or surface fetching present some benefits that can make it an advantageous alternative to reading device memory from global or constant memory:</p>
<ul class="simple">
<li><p>If the memory reads do not follow the access patterns that global or constant memory reads must follow to get good performance, higher bandwidth can be achieved providing that there is locality in the texture fetches or surface reads;</p></li>
<li><p>Addressing calculations are performed outside the kernel by dedicated units;</p></li>
<li><p>Packed data may be broadcast to separate variables in a single operation;</p></li>
<li><p>8-bit and 16-bit integer input data may be optionally converted to 32 bit floating-point values in the range [0.0, 1.0] or [-1.0, 1.0] (see <a class="reference internal" href="#texture-memory"><span class="std std-ref">Texture Memory</span></a>).</p></li>
</ul>
</section>
</section>
<section id="maximize-instruction-throughput">
<span id="id136"></span><h2><span class="section-number">5.4. </span>Maximize Instruction Throughput<a class="headerlink" href="#maximize-instruction-throughput" title="Permalink to this headline">ï</a></h2>
<p>To maximize instruction throughput the application should:</p>
<ul class="simple">
<li><p>Minimize the use of arithmetic instructions with low throughput; this includes trading precision for speed when it does not affect the end result, such as using intrinsic instead of regular functions (intrinsic functions are listed in <a class="reference internal" href="#mathematical-functions-appendix-intrinsic-functions"><span class="std std-ref">Intrinsic Functions</span></a>), single-precision instead of double-precision, or flushing denormalized numbers to zero;</p></li>
<li><p>Minimize divergent warps caused by control flow instructions as detailed in <a class="reference internal" href="#control-flow-instructions"><span class="std std-ref">Control Flow Instructions</span></a></p></li>
<li><p>Reduce the number of instructions, for example, by optimizing out synchronization points whenever possible as described in <a class="reference internal" href="#synchronization-instruction"><span class="std std-ref">Synchronization Instruction</span></a> or by using restricted pointers as described in <a class="reference internal" href="#restrict"><span class="std std-ref">__restrict__</span></a>.</p></li>
</ul>
<p>In this section, throughputs are given in number of operations per clock cycle per multiprocessor. For a warp size of 32, one instruction corresponds to 32 operations, so if N is the number of operations per clock cycle, the instruction throughput is N/32 instructions per clock cycle.</p>
<p>All throughputs are for one multiprocessor. They must be multiplied by the number of multiprocessors in the device to get throughput for the whole device.</p>
<section id="arithmetic-instructions">
<span id="id137"></span><h3><span class="section-number">5.4.1. </span>Arithmetic Instructions<a class="headerlink" href="#arithmetic-instructions" title="Permalink to this headline">ï</a></h3>
<p>The following table gives the throughputs of the arithmetic instructions that are natively supported in hardware for devices of various compute capabilities.</p>
<table class="table-no-stripes longtable docutils align-default" id="arithmetic-instructions-throughput-native-arithmetic-instructions">
<caption><span class="caption-number">Table 7 </span><span class="caption-text">Throughput of Native Arithmetic Instructions. (Number of Results per Clock Cycle per Multiprocessor)</span><a class="headerlink" href="#arithmetic-instructions-throughput-native-arithmetic-instructions" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 55%" />
<col style="width: 7%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 9%" />
<col style="width: 8%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Compute Capability</p></th>
<th class="head"><p>5.0, 5.2</p></th>
<th class="head"><p>5.3</p></th>
<th class="head"><p>6.0</p></th>
<th class="head"><p>6.1</p></th>
<th class="head"><p>6.2</p></th>
<th class="head"><p>7.x</p></th>
<th class="head"><p>8.0</p></th>
<th class="head"><p>8.6</p></th>
<th class="head"><p>8.9</p></th>
<th class="head"><p>9.0</p></th>
<th class="head"><p>10.0</p></th>
<th class="head"><p>12.0</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>16-bit floating-point add, multiply, multiply-add</p></td>
<td><p>N/A</p></td>
<td><p>256</p></td>
<td><p>128</p></td>
<td><p>2</p></td>
<td><p>256</p></td>
<td><p>128</p></td>
<td colspan="2"><p>256<a class="footnote-reference brackets" href="#fn3" id="id138">3</a></p></td>
<td><p>128</p></td>
<td colspan="3"><p>256</p></td>
</tr>
<tr class="row-odd"><td><p>32-bit floating-point add, multiply, multiply-add</p></td>
<td colspan="2"><p>128</p></td>
<td><p>64</p></td>
<td colspan="2"><p>128</p></td>
<td colspan="2"><p>64</p></td>
<td colspan="5"><p>128</p></td>
</tr>
<tr class="row-even"><td><p>64-bit floating-point add, multiply, multiply-add</p></td>
<td colspan="2"><p>4</p></td>
<td><p>32</p></td>
<td colspan="2"><p>4</p></td>
<td><p>32<a class="footnote-reference brackets" href="#fn5" id="id139">5</a></p></td>
<td><p>32</p></td>
<td colspan="2"><p>2</p></td>
<td><p>64</p></td>
<td><p>64</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>32-bit floating-point reciprocal, reciprocal square root, base-2 logarithm (<code class="docutils literal notranslate"><span class="pre">__log2f</span></code>), base 2 exponential (<code class="docutils literal notranslate"><span class="pre">exp2f</span></code>), sine (<code class="docutils literal notranslate"><span class="pre">__sinf</span></code>), cosine (<code class="docutils literal notranslate"><span class="pre">__cosf</span></code>)</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td colspan="2"><p>32</p></td>
<td colspan="7"><p>16</p></td>
</tr>
<tr class="row-even"><td><p>32-bit integer add, extended-precision add, subtract, extended-precision subtract</p></td>
<td colspan="2"><p>128</p></td>
<td><p>64</p></td>
<td colspan="2"><p>128</p></td>
<td colspan="6"><p>64</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>32-bit integer multiply, multiply-add, extended-precision multiply-add</p></td>
<td colspan="5"><p>Multiple instruct.</p></td>
<td colspan="7"><p>64<a class="footnote-reference brackets" href="#fn6" id="id140">6</a></p></td>
</tr>
<tr class="row-even"><td><p>32-bit integer shift</p></td>
<td colspan="2"><p>64</p></td>
<td><p>32</p></td>
<td colspan="9"><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>64-bit integer add</p></td>
<td colspan="11"><p>Multiple instruct.</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>32-bit integer compare, minimum, maximum</p></td>
<td colspan="2"><p>64</p></td>
<td><p>32</p></td>
<td colspan="8"><p>64</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>32-bit integer bit reverse</p></td>
<td colspan="2"><p>64</p></td>
<td><p>32</p></td>
<td colspan="2"><p>64</p></td>
<td colspan="7"><p>16</p></td>
</tr>
<tr class="row-even"><td><p>32-bit bitwise AND, OR, XOR</p></td>
<td colspan="2"><p>128</p></td>
<td><p>64</p></td>
<td colspan="2"><p>128</p></td>
<td colspan="7"><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>count of leading zeros, most significant non-sign bit</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td colspan="2"><p>32</p></td>
<td colspan="7"><p>16</p></td>
</tr>
<tr class="row-even"><td><p>population count</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td colspan="2"><p>32</p></td>
<td colspan="7"><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>warp shuffle</p></td>
<td colspan="5"><p>32</p></td>
<td><p>32<a class="footnote-reference brackets" href="#fn8" id="id141">8</a></p></td>
<td colspan="6"><p>32</p></td>
</tr>
<tr class="row-even"><td><p>warp reduce</p></td>
<td colspan="6"><p>Multiple instruct.</p></td>
<td colspan="6"><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>warp vote</p></td>
<td colspan="11"><p>64</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>sum of absolute difference</p></td>
<td colspan="2"><p>64</p></td>
<td><p>32</p></td>
<td colspan="9"><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>SIMD video instructions <code class="docutils literal notranslate"><span class="pre">vabsdiff2</span></code></p></td>
<td colspan="12"><p>Multiple instruct.</p></td>
</tr>
<tr class="row-even"><td><p>SIMD video instructions <code class="docutils literal notranslate"><span class="pre">vabsdiff4</span></code></p></td>
<td colspan="5"><p>Multiple instruct.</p></td>
<td colspan="7"><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>All other SIMD video instructions</p></td>
<td colspan="12"><p>Multiple instruct.</p></td>
</tr>
<tr class="row-even"><td><p>Type conversions from 8-bit and 16-bit integer to 32-bit integer types</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td colspan="2"><p>32</p></td>
<td colspan="7"><p>64</p></td>
</tr>
<tr class="row-odd"><td><p>Type conversions from and to 64-bit types</p></td>
<td colspan="2"><p>4</p></td>
<td><p>16</p></td>
<td colspan="2"><p>4</p></td>
<td><p>16<a class="footnote-reference brackets" href="#fn10" id="id142">10</a></p></td>
<td><p>16</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
<td colspan="2"><p>16</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>All other type conversions</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td colspan="2"><p>32</p></td>
<td colspan="7"><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>16-bit DPX</p></td>
<td colspan="9"><p>Multiple instruct.</p></td>
<td colspan="2"><p>128</p></td>
<td><p>Multiple instruct.</p></td>
</tr>
<tr class="row-even"><td><p>32-bit DPX</p></td>
<td colspan="9"><p>Multiple instruct.</p></td>
<td colspan="2"><p>64</p></td>
<td><p>Multiple instruct.</p></td>
</tr>
</tbody>
</table>
<p>Other instructions and functions are implemented on top of the native instructions. The implementation may be different for devices of different compute capabilities, and the number of native instructions after compilation may fluctuate with every compiler version. For complicated functions, there can be multiple code paths depending on input. <code class="docutils literal notranslate"><span class="pre">cuobjdump</span></code> can be used to inspect a particular implementation in a <code class="docutils literal notranslate"><span class="pre">cubin</span></code> object.</p>
<p>The implementation of some functions are readily available on the CUDA header files (<code class="docutils literal notranslate"><span class="pre">math_functions.h</span></code>, <code class="docutils literal notranslate"><span class="pre">device_functions.h</span></code>, â¦).</p>
<p>In general, code compiled with <code class="docutils literal notranslate"><span class="pre">-ftz=true</span></code> (denormalized numbers are flushed to zero) tends to have higher performance than code compiled with <code class="docutils literal notranslate"><span class="pre">-ftz=false</span></code>. Similarly, code compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=false</span></code> (less precise division) tends to have higher performance code than code compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code>, and code compiled with <code class="docutils literal notranslate"><span class="pre">-prec-sqrt=false</span></code> (less precise square root) tends to have higher performance than code compiled with <code class="docutils literal notranslate"><span class="pre">-prec-sqrt=true</span></code>. The nvcc user manual describes these compilation flags in more details.</p>
<p><strong>Single-Precision Floating-Point Division</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__fdividef(x,</span> <span class="pre">y)</span></code> (see <a class="reference internal" href="#mathematical-functions-appendix-intrinsic-functions"><span class="std std-ref">Intrinsic Functions</span></a>) provides faster single-precision floating-point division than the division operator.</p>
<p><strong>Single-Precision Floating-Point Reciprocal Square Root</strong></p>
<p>To preserve IEEE-754 semantics the compiler can optimize <code class="docutils literal notranslate"><span class="pre">1.0/sqrtf()</span></code> into <code class="docutils literal notranslate"><span class="pre">rsqrtf()</span></code> only when both reciprocal and square root are approximate, (i.e., with <code class="docutils literal notranslate"><span class="pre">-prec-div=false</span></code> and <code class="docutils literal notranslate"><span class="pre">-prec-sqrt=false</span></code>). It is therefore recommended to invoke <code class="docutils literal notranslate"><span class="pre">rsqrtf()</span></code> directly where desired.</p>
<p><strong>Single-Precision Floating-Point Square Root</strong></p>
<p>Single-precision floating-point square root is implemented as a reciprocal square root followed by a reciprocal instead of a reciprocal square root followed by a multiplication so that it gives correct results for 0 and infinity.</p>
<p><strong>Sine and Cosine</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">sinf(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">cosf(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">tanf(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">sincosf(x)</span></code>, and corresponding double-precision instructions are much more expensive and even more so if the argument x is large in magnitude.</p>
<p>More precisely, the argument reduction code (see <a class="reference internal" href="#mathematical-functions-appendix"><span class="std std-ref">Mathematical Functions</span></a> for implementation) comprises two code paths referred to as the fast path and the slow path, respectively.</p>
<p>The fast path is used for arguments sufficiently small in magnitude and essentially consists of a few multiply-add operations. The slow path is used for arguments large in magnitude and consists of lengthy computations required to achieve correct results over the entire argument range.</p>
<p>At present, the argument reduction code for the trigonometric functions selects the fast path for arguments whose magnitude is less than <code class="docutils literal notranslate"><span class="pre">105615.0f</span></code> for the single-precision functions, and less than <code class="docutils literal notranslate"><span class="pre">2147483648.0</span></code> for the double-precision functions.</p>
<p>As the slow path requires more registers than the fast path, an attempt has been made to reduce register pressure in the slow path by storing some intermediate variables in local memory, which may affect performance because of local memory high latency and bandwidth (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>). At present, 28 bytes of local memory are used by single-precision functions, and 44 bytes are used by double-precision functions. However, the exact amount is subject to change.</p>
<p>Due to the lengthy computations and use of local memory in the slow path, the throughput of these trigonometric functions is lower by one order of magnitude when the slow path reduction is required as opposed to the fast path reduction.</p>
<p><strong>Integer Arithmetic</strong></p>
<p>Integer division and modulo operation are costly as they compile to up to 20 instructions. They can be replaced with bitwise operations in some cases: If <code class="docutils literal notranslate"><span class="pre">n</span></code> is a power of 2, (<code class="docutils literal notranslate"><span class="pre">i/n</span></code>) is equivalent to <code class="docutils literal notranslate"><span class="pre">(i&gt;&gt;log2(n))</span></code> and <code class="docutils literal notranslate"><span class="pre">(i%n)</span></code> is equivalent to (<code class="docutils literal notranslate"><span class="pre">i&amp;(n-1)</span></code>); the compiler will perform these conversions if <code class="docutils literal notranslate"><span class="pre">n</span></code> is literal.</p>
<p><code class="docutils literal notranslate"><span class="pre">__brev</span></code> and <code class="docutils literal notranslate"><span class="pre">__popc</span></code> map to a single instruction and <code class="docutils literal notranslate"><span class="pre">__brevll</span></code> and <code class="docutils literal notranslate"><span class="pre">__popcll</span></code> to a few instructions.</p>
<p><code class="docutils literal notranslate"><span class="pre">__[u]mul24</span></code> are legacy intrinsic functions that no longer have any reason to be used.</p>
<p><strong>Half Precision Arithmetic</strong></p>
<p>In order to achieve good performance for 16-bit precision floating-point add, multiply or multiply-add, it is recommended that the <code class="docutils literal notranslate"><span class="pre">half2</span></code> datatype is used for <code class="docutils literal notranslate"><span class="pre">half</span></code> precision and <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code> be used for <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> precision. Vector intrinsics (for example, <code class="docutils literal notranslate"><span class="pre">__hadd2</span></code>, <code class="docutils literal notranslate"><span class="pre">__hsub2</span></code>, <code class="docutils literal notranslate"><span class="pre">__hmul2</span></code>, <code class="docutils literal notranslate"><span class="pre">__hfma2</span></code>) can then be used to do two operations in a single instruction. Using <code class="docutils literal notranslate"><span class="pre">half2</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code> in place of two calls using <code class="docutils literal notranslate"><span class="pre">half</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> may also help performance of other intrinsics, such as warp shuffles.</p>
<p>The intrinsic <code class="docutils literal notranslate"><span class="pre">__halves2half2</span></code> is provided to convert two <code class="docutils literal notranslate"><span class="pre">half</span></code> precision values to the <code class="docutils literal notranslate"><span class="pre">half2</span></code> datatype.</p>
<p>The intrinsic <code class="docutils literal notranslate"><span class="pre">__halves2bfloat162</span></code> is provided to convert two <code class="docutils literal notranslate"><span class="pre">__nv_bfloat</span></code> precision values to the <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code> datatype.</p>
<p><strong>Type Conversion</strong></p>
<p>Sometimes, the compiler must insert conversion instructions, introducing additional execution cycles. This is the case for:</p>
<ul class="simple">
<li><p>Functions operating on variables of type <code class="docutils literal notranslate"><span class="pre">char</span></code> or <code class="docutils literal notranslate"><span class="pre">short</span></code> whose operands generally need to be converted to <code class="docutils literal notranslate"><span class="pre">int</span></code>,</p></li>
<li><p>Double-precision floating-point constants (i.e., those constants defined without any type suffix) used as input to single-precision floating-point computations (as mandated by C/C++ standards).</p></li>
</ul>
<p>This last case can be avoided by using single-precision floating-point constants, defined with an <code class="docutils literal notranslate"><span class="pre">f</span></code> suffix such as <code class="docutils literal notranslate"><span class="pre">3.141592653589793f</span></code>, <code class="docutils literal notranslate"><span class="pre">1.0f</span></code>, <code class="docutils literal notranslate"><span class="pre">0.5f</span></code>.</p>
</section>
<section id="control-flow-instructions">
<span id="id143"></span><h3><span class="section-number">5.4.2. </span>Control Flow Instructions<a class="headerlink" href="#control-flow-instructions" title="Permalink to this headline">ï</a></h3>
<p>Any flow control instruction (<code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">switch</span></code>, <code class="docutils literal notranslate"><span class="pre">do</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code>) can significantly impact the effective instruction throughput by causing threads of the same warp to diverge (i.e., to follow different execution paths). If this happens, the different executions paths have to be serialized, increasing the total number of instructions executed for this warp.</p>
<p>To obtain best performance in cases where the control flow depends on the thread ID, the controlling condition should be written so as to minimize the number of divergent warps. This is possible because the distribution of the warps across the block is deterministic as mentioned in <a class="reference internal" href="#simt-architecture"><span class="std std-ref">SIMT Architecture</span></a>. A trivial example is when the controlling condition only depends on (<code class="docutils literal notranslate"><span class="pre">threadIdx</span> <span class="pre">/</span> <span class="pre">warpSize</span></code>) where <code class="docutils literal notranslate"><span class="pre">warpSize</span></code> is the warp size. In this case, no warp diverges since the controlling condition is perfectly aligned with the warps.</p>
<p>Sometimes, the compiler may unroll loops or it may optimize out short <code class="docutils literal notranslate"><span class="pre">if</span></code> or <code class="docutils literal notranslate"><span class="pre">switch</span></code> blocks by using branch predication instead, as detailed below. In these cases, no warp can ever diverge. The programmer can also control loop unrolling using the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">unroll</span></code> directive (see <a class="reference internal" href="#pragma-unroll"><span class="std std-ref">#pragma unroll</span></a>).</p>
<p>When using branch predication none of the instructions whose execution depends on the controlling condition gets skipped. Instead, each of them is associated with a per-thread condition code or predicate that is set to true or false based on the controlling condition and although each of these instructions gets scheduled for execution, only the instructions with a true predicate are actually executed. Instructions with a false predicate do not write results, and also do not evaluate addresses or read operands.</p>
</section>
<section id="synchronization-instruction">
<span id="id144"></span><h3><span class="section-number">5.4.3. </span>Synchronization Instruction<a class="headerlink" href="#synchronization-instruction" title="Permalink to this headline">ï</a></h3>
<p>Throughput for <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> is 32 operations per clock cycle for devices of compute capability 6.0, 16 operations per clock cycle for devices of compute capability 7.x as well as 8.x and 64 operations per clock cycle for devices of compute capability 5.x, 6.1 and 6.2.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> can impact performance by forcing the multiprocessor to idle as detailed in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>.</p>
</section>
</section>
<section id="minimize-memory-thrashing">
<span id="id145"></span><h2><span class="section-number">5.5. </span>Minimize Memory Thrashing<a class="headerlink" href="#minimize-memory-thrashing" title="Permalink to this headline">ï</a></h2>
<p>Applications that constantly allocate and free memory too often may find that the allocation calls tend to get slower over time up to a limit. This is typically expected due to the nature of releasing memory back to the operating system for its own use. For best performance in this regard, we recommend the following:</p>
<ul class="simple">
<li><p>Try to size your allocation to the problem at hand. Donât try to allocate all available memory with <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMallocHost</span></code> / <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>, as this forces memory to be resident immediately and prevents other applications from being able to use that memory. This can put more pressure on operating system schedulers, or just prevent other applications using the same GPU from running entirely.</p></li>
<li><p>Try to allocate memory in appropriately sized allocations early in the application and allocations only when the application does not have any use for it. Reduce the number of <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code>+<code class="docutils literal notranslate"><span class="pre">cudaFree</span></code> calls in the application, especially in performance-critical regions.</p></li>
<li><p>If an application cannot allocate enough device memory, consider falling back on other memory types such as <code class="docutils literal notranslate"><span class="pre">cudaMallocHost</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code>, which may not be as performant, but will enable the application to make progress.</p></li>
<li><p>For platforms that support the feature, <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> allows for oversubscription, and with the correct <code class="docutils literal notranslate"><span class="pre">cudaMemAdvise</span></code> policies enabled, will allow the application to retain most if not all the performance of <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code>. <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> also wonât force an allocation to be resident until it is needed or prefetched, reducing the overall pressure on the operating system schedulers and better enabling multi-tenet use cases.</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="fn3"><span class="brackets"><a class="fn-backref" href="#id138">3</a></span></dt>
<dd><p>128 for __nv_bfloat16</p>
</dd>
<dt class="label" id="fn4"><span class="brackets">4</span></dt>
<dd><p>8 for GeForce GPUs, except for Titan GPUs</p>
</dd>
<dt class="label" id="fn5"><span class="brackets"><a class="fn-backref" href="#id139">5</a></span></dt>
<dd><p>2 for compute capability 7.5 GPUs</p>
</dd>
<dt class="label" id="fn6"><span class="brackets"><a class="fn-backref" href="#id140">6</a></span></dt>
<dd><p>32 for extended-precision</p>
</dd>
<dt class="label" id="fn7"><span class="brackets">7</span></dt>
<dd><p>32 for GeForce GPUs, except for Titan GPUs</p>
</dd>
<dt class="label" id="fn8"><span class="brackets"><a class="fn-backref" href="#id141">8</a></span></dt>
<dd><p>16 for compute capabilities 7.5 GPUs</p>
</dd>
<dt class="label" id="fn9"><span class="brackets"><a class="fn-backref" href="#id150">9</a></span></dt>
<dd><p>8 for GeForce GPUs, except for Titan GPUs</p>
</dd>
<dt class="label" id="fn10"><span class="brackets"><a class="fn-backref" href="#id142">10</a></span></dt>
<dd><p>2 for compute capabilities 7.5 GPUs</p>
</dd>
</dl>
</section>
</section>
<section id="cuda-enabled-gpus">
<span id="id146"></span><h1><span class="section-number">6. </span>CUDA-Enabled GPUs<a class="headerlink" href="#cuda-enabled-gpus" title="Permalink to this headline">ï</a></h1>
<p><a class="reference external" href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a> lists all CUDA-enabled devices with their compute capability.</p>
<p>The compute capability, number of multiprocessors, clock frequency, total amount of device memory, and other properties can be queried using the runtime (see reference manual).</p>
</section>
<section id="c-language-extensions">
<span id="id147"></span><h1><span class="section-number">7. </span>C++ Language Extensions<a class="headerlink" href="#c-language-extensions" title="Permalink to this headline">ï</a></h1>
<section id="function-execution-space-specifiers">
<span id="function-declaration-specifiers"></span><h2><span class="section-number">7.1. </span>Function Execution Space Specifiers<a class="headerlink" href="#function-execution-space-specifiers" title="Permalink to this headline">ï</a></h2>
<p>Function execution space specifiers denote whether a function executes on the host or on the device and whether it is callable from the host or from the device.</p>
<section id="global">
<span id="id148"></span><h3><span class="section-number">7.1.1. </span>__global__<a class="headerlink" href="#global" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__global__</span></code> execution space specifier declares a function as being a kernel. Such a function is:</p>
<ul class="simple">
<li><p>Executed on the device,</p></li>
<li><p>Callable from the host,</p></li>
<li><p>Callable from the device for devices of compute capability 5.0 or higher (see <a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a> for more details).</p></li>
</ul>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function must have void return type, and cannot be a member of a class.</p>
<p>Any call to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function must specify its execution configuration as described in <a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a>.</p>
<p>A call to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function is asynchronous, meaning it returns before the device has completed its execution.</p>
</section>
<section id="device">
<span id="device-function-specifier"></span><h3><span class="section-number">7.1.2. </span>__device__<a class="headerlink" href="#device" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__device__</span></code> execution space specifier declares a function that is:</p>
<ul class="simple">
<li><p>Executed on the device,</p></li>
<li><p>Callable from the device only.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">__global__</span></code> and <code class="docutils literal notranslate"><span class="pre">__device__</span></code> execution space specifiers cannot be used together.</p>
</section>
<section id="host">
<span id="id149"></span><h3><span class="section-number">7.1.3. </span>__host__<a class="headerlink" href="#host" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__host__</span></code> execution space specifier declares a function that is:</p>
<ul class="simple">
<li><p>Executed on the host,</p></li>
<li><p>Callable from the host only.</p></li>
</ul>
<p>It is equivalent to declare a function with only the <code class="docutils literal notranslate"><span class="pre">__host__</span></code> execution space specifier or to declare it without any of the <code class="docutils literal notranslate"><span class="pre">__host__</span></code>, <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> execution space specifier; in either case the function is compiled for the host only.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__global__</span></code> and <code class="docutils literal notranslate"><span class="pre">__host__</span></code> execution space specifiers cannot be used together.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__device__</span></code> and <code class="docutils literal notranslate"><span class="pre">__host__</span></code> execution space specifiers can be used together however, in which case the function is compiled for both the host and the device. The <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro introduced in <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a> can be used to differentiate code paths between host and device:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">func</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#if __CUDA_ARCH__ &gt;= 800</span>
<span class="w">   </span><span class="c1">// Device code path for compute capability 8.x</span>
<span class="cp">#elif __CUDA_ARCH__ &gt;= 700</span>
<span class="w">   </span><span class="c1">// Device code path for compute capability 7.x</span>
<span class="cp">#elif __CUDA_ARCH__ &gt;= 600</span>
<span class="w">   </span><span class="c1">// Device code path for compute capability 6.x</span>
<span class="cp">#elif __CUDA_ARCH__ &gt;= 500</span>
<span class="w">   </span><span class="c1">// Device code path for compute capability 5.x</span>
<span class="cp">#elif !defined(__CUDA_ARCH__)</span>
<span class="w">   </span><span class="c1">// Host code path</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="undefined-behavior">
<span id="cross-execution-undefined-behavior"></span><h3><span class="section-number">7.1.4. </span>Undefined behavior<a class="headerlink" href="#undefined-behavior" title="Permalink to this headline">ï</a></h3>
<p>A âcross-execution spaceâ call has undefined behavior when:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined, a call from within a <code class="docutils literal notranslate"><span class="pre">__global__</span></code>, <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function to a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is undefined, a call from within a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function to a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function. <a class="footnote-reference brackets" href="#fn9" id="id150">9</a></p></li>
</ul>
</section>
<section id="noinline-and-forceinline">
<span id="id151"></span><h3><span class="section-number">7.1.5. </span>__noinline__ and __forceinline__<a class="headerlink" href="#noinline-and-forceinline" title="Permalink to this headline">ï</a></h3>
<p>The compiler inlines any <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function when deemed appropriate.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__noinline__</span></code> function qualifier can be used as a hint for the compiler not to inline the function if possible.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code> function qualifier can be used to force the compiler to inline the function.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">__noinline__</span></code> and <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code> function qualifiers cannot be used together, and neither function qualifier can be applied to an inline function.</p>
</section>
<section id="inline-hint">
<span id="id152"></span><h3><span class="section-number">7.1.6. </span>__inline_hint__<a class="headerlink" href="#inline-hint" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__inline_hint__</span></code> qualifier enables more aggressive inlining in the compiler. Unlike <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code>, it does not imply that the function is inline. It can be used to improve inlining across modules when using LTO.</p>
<p>Neither the <code class="docutils literal notranslate"><span class="pre">__noinline__</span></code> nor the <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code> function qualifier can be used with the <code class="docutils literal notranslate"><span class="pre">__inline_hint__</span></code> function qualifier.</p>
</section>
</section>
<section id="variable-memory-space-specifiers">
<span id="id153"></span><h2><span class="section-number">7.2. </span>Variable Memory Space Specifiers<a class="headerlink" href="#variable-memory-space-specifiers" title="Permalink to this headline">ï</a></h2>
<p>Variable memory space specifiers denote the memory location on the device of a variable.</p>
<p>An automatic variable declared in device code without any of the <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> memory space specifiers described in this section generally resides in a register. However in some cases the compiler might choose to place it in local memory, which can have adverse performance consequences as detailed in <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>.</p>
<section id="device-variable-specifier">
<span id="id154"></span><h3><span class="section-number">7.2.1. </span>__device__<a class="headerlink" href="#device-variable-specifier" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__device__</span></code> memory space specifier declares a variable that resides on the device.</p>
<p>At most one of the other memory space specifiers defined in the next three sections may be used together with <code class="docutils literal notranslate"><span class="pre">__device__</span></code> to further denote which memory space the variable belongs to. If none of them is present, the variable:</p>
<ul class="simple">
<li><p>Resides in global memory space,</p></li>
<li><p>Has the lifetime of the CUDA context in which it is created,</p></li>
<li><p>Has a distinct object per device,</p></li>
<li><p>Is accessible from all the threads within the grid and from the host through the runtime library <code class="docutils literal notranslate"><span class="pre">(cudaGetSymbolAddress()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolSize()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMemcpyFromSymbol()</span></code>).</p></li>
</ul>
</section>
<section id="constant">
<span id="id155"></span><h3><span class="section-number">7.2.2. </span>__constant__<a class="headerlink" href="#constant" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> memory space specifier, optionally used together with <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, declares a variable that:</p>
<ul class="simple">
<li><p>Resides in constant memory space,</p></li>
<li><p>Has the lifetime of the CUDA context in which it is created,</p></li>
<li><p>Has a distinct object per device,</p></li>
<li><p>Is accessible from all the threads within the grid and from the host through the runtime library (<code class="docutils literal notranslate"><span class="pre">cudaGetSymbolAddress()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolSize()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol()</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMemcpyFromSymbol()</span></code>).</p></li>
</ul>
<p>The behavior of modifying a constant from the host while there is a concurrent grid that access that constant at any point of this gridâs lifetime is undefined.</p>
</section>
<section id="shared">
<span id="id156"></span><h3><span class="section-number">7.2.3. </span>__shared__<a class="headerlink" href="#shared" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> memory space specifier, optionally used together with <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, declares a variable that:</p>
<ul class="simple">
<li><p>Resides in the shared memory space of a thread block,</p></li>
<li><p>Has the lifetime of the block,</p></li>
<li><p>Has a distinct object per block,</p></li>
<li><p>Is only accessible from all the threads within the block,</p></li>
<li><p>Does not have a constant address.</p></li>
</ul>
<p>When declaring a variable in shared memory as an external array such as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"></span>
</pre></div>
</div>
<p>the size of the array is determined at launch time (see <a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a>). All variables declared in this fashion, start at the same address in memory, so that the layout of the variables in the array must be explicitly managed through offsets. For example, if one wants the equivalent of</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">short</span><span class="w"> </span><span class="n">array0</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">array1</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w">   </span><span class="n">array2</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>in dynamically allocated shared memory, one could declare and initialize the arrays the following way:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">array</span><span class="p">[];</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">()</span><span class="w">      </span><span class="c1">// __device__ or __global__ function</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">short</span><span class="o">*</span><span class="w"> </span><span class="n">array0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">array0</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w">   </span><span class="n">array2</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">array1</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that pointers need to be aligned to the type they point to, so the following code, for example, does not work since array1 is not aligned to 4 bytes.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">array</span><span class="p">[];</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">()</span><span class="w">      </span><span class="c1">// __device__ or __global__ function</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">short</span><span class="o">*</span><span class="w"> </span><span class="n">array0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">array0</span><span class="p">[</span><span class="mi">127</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Alignment requirements for the built-in vector types are listed in <a class="reference internal" href="#vector-types-alignment-requirements-in-device-code"><span class="std std-ref">Table 8</span></a>.</p>
</section>
<section id="grid-constant">
<span id="id157"></span><h3><span class="section-number">7.2.4. </span>__grid_constant__<a class="headerlink" href="#grid-constant" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> annotation for compute architectures greater or equal to 7.0 annotates a <code class="docutils literal notranslate"><span class="pre">const</span></code>-qualified <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function parameter of non-reference type that:</p>
<ul class="simple">
<li><p>Has the lifetime of the grid,</p></li>
<li><p>Is private to the grid, i.e., the object is not accessible to host threads and threads from other grids, including sub-grids,</p></li>
<li><p>Has a distinct object per grid, i.e., all threads in the grid see the same address,</p></li>
<li><p>Is read-only, i.e., modifying a <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> object or any of its sub-objects is <em>undefined behavior</em>, including <code class="docutils literal notranslate"><span class="pre">mutable</span></code> members.</p></li>
</ul>
<p>Requirements:</p>
<ul class="simple">
<li><p>Kernel parameters annotated with <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> must have <code class="docutils literal notranslate"><span class="pre">const</span></code>-qualified non-reference types.</p></li>
<li><p>All function declarations must match with respect to any <code class="docutils literal notranslate"><span class="pre">__grid_constant_</span></code> parameters.</p></li>
<li><p>A function template specialization must match the primary template declaration with respect to any <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> parameters.</p></li>
<li><p>A function template instantiation directive must match the primary template declaration with respect to any <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> parameters.</p></li>
</ul>
<p>If the address of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function parameter is taken, the compiler will ordinarily make a copy of the kernel parameter in thread local memory and use the address of the copy, to partially support C++ semantics, which allow each thread to modify its own local copy of function parameters. Annotating a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function parameter with <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> ensures that the compiler will not create a copy of the kernel parameter in thread local memory, but will instead use the generic address of the parameter itself. Avoiding the local copy may result in improved performance.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">unknown_function</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__grid_constant__</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">s</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// Undefined Behavior: tried to modify read-only memory</span>

<span class="w">   </span><span class="c1">// Compiler will _not_ create a per-thread thread local copy of &quot;s&quot;:</span>
<span class="w">   </span><span class="n">unknown_function</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="managed">
<span id="id158"></span><h3><span class="section-number">7.2.5. </span>__managed__<a class="headerlink" href="#managed" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> memory space specifier, optionally used together with <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, declares a variable that:</p>
<ul class="simple">
<li><p>Can be referenced from both device and host code, for example, its address can be taken or it can be read or written directly from a device or host function.</p></li>
<li><p>Has the lifetime of an application.</p></li>
</ul>
<p>See <a class="reference internal" href="#managed-specifier"><span class="std std-ref">__managed__ Memory Space Specifier</span></a> for more details.</p>
</section>
<section id="restrict">
<span id="id159"></span><h3><span class="section-number">7.2.6. </span>__restrict__<a class="headerlink" href="#restrict" title="Permalink to this headline">ï</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">nvcc</span></code> supports restricted pointers via the <code class="docutils literal notranslate"><span class="pre">__restrict__</span></code> keyword.</p>
<p>Restricted pointers were introduced in C99 to alleviate the aliasing problem that exists in C-type languages, and which inhibits all kind of optimization from code re-ordering to common sub-expression elimination.</p>
<p>Here is an example subject to the aliasing issue, where use of restricted pointer can help the compiler to reduce the number of instructions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In C-type languages, the pointers <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> may be aliased, so any write through <code class="docutils literal notranslate"><span class="pre">c</span></code> could modify elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>. This means that to guarantee functional correctness, the compiler cannot load <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">b[0]</span></code> into registers, multiply them, and store the result to both <code class="docutils literal notranslate"><span class="pre">c[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">c[1]</span></code>, because the results would differ from the abstract execution model if, say, <code class="docutils literal notranslate"><span class="pre">a[0]</span></code> is really the same location as <code class="docutils literal notranslate"><span class="pre">c[0]</span></code>. So the compiler cannot take advantage of the common sub-expression. Likewise, the compiler cannot just reorder the computation of <code class="docutils literal notranslate"><span class="pre">c[4]</span></code> into the proximity of the computation of <code class="docutils literal notranslate"><span class="pre">c[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">c[1]</span></code> because the preceding write to <code class="docutils literal notranslate"><span class="pre">c[3]</span></code> could change the inputs to the computation of <code class="docutils literal notranslate"><span class="pre">c[4]</span></code>.</p>
<p>By making <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> restricted pointers, the programmer asserts to the compiler that the pointers are in fact not aliased, which in this case means writes through <code class="docutils literal notranslate"><span class="pre">c</span></code> would never overwrite elements of <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>. This changes the function prototype as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Note that all pointer arguments need to be made restricted for the compiler optimizer to derive any benefit. With the <code class="docutils literal notranslate"><span class="pre">__restrict__</span></code> keywords added, the compiler can now reorder and do common sub-expression elimination at will, while retaining functionality identical with the abstract execution model:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The effects here are a reduced number of memory accesses and reduced number of computations. This is balanced by an increase in register pressure due to âcachedâ loads and common sub-expressions.</p>
<p>Since register pressure is a critical issue in many CUDA codes, use of restricted pointers can have negative performance impact on CUDA code, due to reduced occupancy.</p>
</section>
</section>
<section id="built-in-vector-types">
<span id="id160"></span><h2><span class="section-number">7.3. </span>Built-in Vector Types<a class="headerlink" href="#built-in-vector-types" title="Permalink to this headline">ï</a></h2>
<section id="char-short-int-long-longlong-float-double">
<span id="vector-types"></span><h3><span class="section-number">7.3.1. </span>char, short, int, long, longlong, float, double<a class="headerlink" href="#char-short-int-long-longlong-float-double" title="Permalink to this headline">ï</a></h3>
<p>These are vector types derived from the basic integer and floating-point types. They are structures and the 1st, 2nd, 3rd, and 4th components are accessible through the fields <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>, and <code class="docutils literal notranslate"><span class="pre">w</span></code>, respectively. They all come with a constructor function of the form <code class="docutils literal notranslate"><span class="pre">make_&lt;type</span> <span class="pre">name&gt;</span></code>; for example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">int2</span><span class="w"> </span><span class="nf">make_int2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>which creates a vector of type <code class="docutils literal notranslate"><span class="pre">int2</span></code> with value<code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>.</p>
<p>The alignment requirements of the vector types are detailed in the <a class="reference internal" href="#vector-types-alignment-requirements-in-device-code"><span class="std std-ref">following table</span></a>.</p>
<table class="table-no-stripes docutils align-default" id="vector-types-alignment-requirements-in-device-code">
<caption><span class="caption-number">Table 8 </span><span class="caption-text">Alignment Requirements</span><a class="headerlink" href="#vector-types-alignment-requirements-in-device-code" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>Alignment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>char1, uchar1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>char2, uchar2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>char3, uchar3</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>char4, uchar4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>short1, ushort1</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>short2, ushort2</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>short3, ushort3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>short4, ushort4</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>int1, uint1</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>int2, uint2</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>int3, uint3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>int4, uint4</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>long1, ulong1</p></td>
<td><p>4 if sizeof(long) is equal to sizeof(int) 8, otherwise</p></td>
</tr>
<tr class="row-odd"><td><p>long2, ulong2</p></td>
<td><p>8 if sizeof(long) is equal to sizeof(int), 16, otherwise</p></td>
</tr>
<tr class="row-even"><td><p>long3, ulong3</p></td>
<td><p>4 if sizeof(long) is equal to sizeof(int), 8, otherwise</p></td>
</tr>
<tr class="row-odd"><td><p>long4, ulong4</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>longlong1, ulonglong1</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>longlong2, ulonglong2</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>longlong3, ulonglong3</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>longlong4, ulonglong4</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>float1</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>float2</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-even"><td><p>float3</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>float4</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>double1</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>double2</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>double3</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>double4</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>
</section>
<section id="dim3">
<span id="id161"></span><h3><span class="section-number">7.3.2. </span>dim3<a class="headerlink" href="#dim3" title="Permalink to this headline">ï</a></h3>
<p>This type is an integer vector type based on <code class="docutils literal notranslate"><span class="pre">uint3</span></code> that is used to specify dimensions. When defining a variable of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code>, any component left unspecified is initialized to 1.</p>
</section>
</section>
<section id="built-in-variables">
<span id="id162"></span><h2><span class="section-number">7.4. </span>Built-in Variables<a class="headerlink" href="#built-in-variables" title="Permalink to this headline">ï</a></h2>
<p>Built-in variables specify the grid and block dimensions and the block and thread indices. They are only valid within functions that are executed on the device.</p>
<section id="griddim">
<h3><span class="section-number">7.4.1. </span>gridDim<a class="headerlink" href="#griddim" title="Permalink to this headline">ï</a></h3>
<p>This variable is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> (see <a class="reference internal" href="#dim3"><span class="std std-ref">dim3</span></a>) and contains the dimensions of the grid.</p>
</section>
<section id="blockidx">
<h3><span class="section-number">7.4.2. </span>blockIdx<a class="headerlink" href="#blockidx" title="Permalink to this headline">ï</a></h3>
<p>This variable is of type <code class="docutils literal notranslate"><span class="pre">uint3</span></code> (see <a class="reference internal" href="#vector-types"><span class="std std-ref">char, short, int, long, longlong, float, double</span></a>) and contains the block index within the grid.</p>
</section>
<section id="blockdim">
<h3><span class="section-number">7.4.3. </span>blockDim<a class="headerlink" href="#blockdim" title="Permalink to this headline">ï</a></h3>
<p>This variable is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> (see <a class="reference internal" href="#dim3"><span class="std std-ref">dim3</span></a>) and contains the dimensions of the block.</p>
</section>
<section id="threadidx">
<h3><span class="section-number">7.4.4. </span>threadIdx<a class="headerlink" href="#threadidx" title="Permalink to this headline">ï</a></h3>
<p>This variable is of type <code class="docutils literal notranslate"><span class="pre">uint3</span></code> (see <a class="reference internal" href="#vector-types"><span class="std std-ref">char, short, int, long, longlong, float, double</span></a>) and contains the thread index within the block.</p>
</section>
<section id="warpsize">
<h3><span class="section-number">7.4.5. </span>warpSize<a class="headerlink" href="#warpsize" title="Permalink to this headline">ï</a></h3>
<p>This variable is of type <code class="docutils literal notranslate"><span class="pre">int</span></code> and contains the warp size in threads (see <a class="reference internal" href="#simt-architecture"><span class="std std-ref">SIMT Architecture</span></a> for the definition of a warp).</p>
</section>
</section>
<section id="memory-fence-functions">
<span id="id163"></span><h2><span class="section-number">7.5. </span>Memory Fence Functions<a class="headerlink" href="#memory-fence-functions" title="Permalink to this headline">ï</a></h2>
<p>The CUDA programming model assumes a device with a weakly-ordered memory model, that is the order in which a CUDA thread writes data to shared memory, global memory, page-locked host memory, or the memory of a peer device is not necessarily the order in which the data is observed being written by another CUDA or host thread. It is undefined behavior for two threads to read from or write to the same memory location without synchronization.</p>
<p>In the following example, thread 1 executes <code class="docutils literal notranslate"><span class="pre">writeXY()</span></code>, while thread 2 executes <code class="docutils literal notranslate"><span class="pre">readXY()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">writeXY</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">readXY</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The two threads read and write from the same memory locations <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> simultaneously. Any data-race is undefined behavior, and has no defined semantics. The resulting values for <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> can be anything.</p>
<p>Memory fence functions can be used to enforce a <a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">sequentially-consistent</a> ordering on memory accesses. The memory fence functions differ in the <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#thread-scopes">scope</a> in which the orderings are enforced but they are independent of the accessed memory space (shared memory, global memory, page-locked host memory, and the memory of a peer device).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__threadfence_block</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>is equivalent to <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives/atomic/atomic_thread_fence.html">cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_block)</a> and ensures that:</p>
<ul class="simple">
<li><p>All writes to all memory made by the calling thread before the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_block()</span></code> are observed by all threads in the block of the calling thread as occurring before all writes to all memory made by the calling thread after the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_block()</span></code>;</p></li>
<li><p>All reads from all memory made by the calling thread before the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_block()</span></code> are ordered before all reads from all memory made by the calling thread after the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_block()</span></code>.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>is equivalent to <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives/atomic/atomic_thread_fence.html">cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_device)</a> and ensures that no writes to all memory made by the calling thread after the call to <code class="docutils literal notranslate"><span class="pre">__threadfence()</span></code> are observed by any thread in the device as occurring before any write to all memory made by the calling thread before the call to <code class="docutils literal notranslate"><span class="pre">__threadfence()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__threadfence_system</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>is equivalent to <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives/atomic/atomic_thread_fence.html">cuda::atomic_thread_fence(cuda::memory_order_seq_cst, cuda::thread_scope_system)</a> and ensures that all writes to all memory made by the calling thread before the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_system()</span></code> are observed by all threads in the device, host threads, and all threads in peer devices as occurring before all writes to all memory made by the calling thread after the call to <code class="docutils literal notranslate"><span class="pre">__threadfence_system()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">__threadfence_system()</span></code> is only supported by devices of compute capability 2.x and higher.</p>
<p>In the previous code sample, we can insert fences in the codes as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">writeXY</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__threadfence</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">readXY</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__threadfence</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>For this code, the following outcomes can be observed:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> equal to 1 and <code class="docutils literal notranslate"><span class="pre">B</span></code> equal to 2,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> equal to 10 and <code class="docutils literal notranslate"><span class="pre">B</span></code> equal to 2,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code> equal to 10 and <code class="docutils literal notranslate"><span class="pre">B</span></code> equal to 20.</p></li>
</ul>
<p>The fourth outcome is not possible, because the first write must be visible before the second write. If thread 1 and 2 belong to the same block, it is enough to use <code class="docutils literal notranslate"><span class="pre">__threadfence_block()</span></code>. If thread 1 and 2 do not belong to the same block, <code class="docutils literal notranslate"><span class="pre">__threadfence()</span></code> must be used if they are CUDA threads from the same device and <code class="docutils literal notranslate"><span class="pre">__threadfence_system()</span></code> must be used if they are CUDA threads from two different devices.</p>
<p>A common use case is when threads consume some data produced by other threads as illustrated by the following code sample of a kernel that computes the sum of an array of N numbers in one call. Each block first sums a subset of the array and stores the result in global memory. When all blocks are done, the last block done reads each of these partial sums from global memory and sums them to obtain the final result. In order to determine which block is finished last, each block atomically increments a counter to signal that it is done with computing and storing its partial sum (see <a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a> about atomic functions). The last block is the one that receives the counter value equal to <code class="docutils literal notranslate"><span class="pre">gridDim.x-1</span></code>. If no fence is placed between storing the partial sum and incrementing the counter, the counter might increment before the partial sum is stored and therefore, might reach <code class="docutils literal notranslate"><span class="pre">gridDim.x-1</span></code> and let the last block start reading partial sums before they have been actually updated in memory.</p>
<p>Memory fence functions only affect the ordering of memory operations by a thread; they do not, by themselves, ensure that these memory operations are visible to other threads (like <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> does for threads within a block; see <a class="reference internal" href="#synchronization-functions"><span class="std std-ref">Synchronization Functions</span></a>). In the code sample below, the visibility of memory operations on the <code class="docutils literal notranslate"><span class="pre">result</span></code> variable is ensured by declaring it as volatile (see <a class="reference internal" href="#volatile-qualifier"><span class="std std-ref">Volatile Qualifier</span></a>).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">__shared__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isLastBlockDone</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Each block sums a subset of the input array.</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">partialSum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculatePartialSum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Thread 0 of each block stores the partial sum</span>
<span class="w">        </span><span class="c1">// to global memory. The compiler will use</span>
<span class="w">        </span><span class="c1">// a store operation that bypasses the L1 cache</span>
<span class="w">        </span><span class="c1">// since the &quot;result&quot; variable is declared as</span>
<span class="w">        </span><span class="c1">// volatile. This ensures that the threads of</span>
<span class="w">        </span><span class="c1">// the last block will read the correct partial</span>
<span class="w">        </span><span class="c1">// sums computed by all other blocks.</span>
<span class="w">        </span><span class="n">result</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partialSum</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Thread 0 makes sure that the incrementing</span>
<span class="w">        </span><span class="c1">// of the &quot;count&quot; variable is only performed after</span>
<span class="w">        </span><span class="c1">// the partial sum has been written to global memory.</span>
<span class="w">        </span><span class="n">__threadfence</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Thread 0 signals that it is done.</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicInc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Thread 0 determines if its block is the last</span>
<span class="w">        </span><span class="c1">// block to be done.</span>
<span class="w">        </span><span class="n">isLastBlockDone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Synchronize to make sure that each thread reads</span>
<span class="w">    </span><span class="c1">// the correct value of isLastBlockDone.</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLastBlockDone</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="c1">// The last block sums the partial sums</span>
<span class="w">        </span><span class="c1">// stored in result[0 .. gridDim.x-1]</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">totalSum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculateTotalSum</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Thread 0 of last block stores the total sum</span>
<span class="w">            </span><span class="c1">// to global memory and resets the count</span>
<span class="w">            </span><span class="c1">// variable, so that the next kernel call</span>
<span class="w">            </span><span class="c1">// works properly.</span>
<span class="w">            </span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">totalSum</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="synchronization-functions">
<span id="id164"></span><h2><span class="section-number">7.6. </span>Synchronization Functions<a class="headerlink" href="#synchronization-functions" title="Permalink to this headline">ï</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__syncthreads</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>waits until all threads in the thread block have reached this point and all global and shared memory accesses made by these threads prior to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> are visible to all threads in the block.</p>
<p><code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> is used to coordinate communication between the threads of the same block. When some threads within a block access the same addresses in shared or global memory, there are potential read-after-write, write-after-read, or write-after-write hazards for some of these memory accesses. These data hazards can be avoided by synchronizing threads in-between these accesses.</p>
<p><code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> is allowed in conditional code but only if the conditional evaluates identically across the entire thread block, otherwise the code execution is likely to hang or produce unintended side effects.</p>
<p>Devices of compute capability 2.x and higher support three variations of <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> described below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__syncthreads_count</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>is identical to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> with the additional feature that it evaluates predicate for all threads of the block and returns the number of threads for which predicate evaluates to non-zero.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__syncthreads_and</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>is identical to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for all of them.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__syncthreads_or</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>is identical to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> with the additional feature that it evaluates predicate for all threads of the block and returns non-zero if and only if predicate evaluates to non-zero for any of them.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__syncwarp</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="o">=</span><span class="mh">0xffffffff</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>will cause the executing thread to wait until all warp lanes named in mask have executed a <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> (with the same mask) before resuming execution. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute a corresponding <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> with the same mask, or the result is undefined.</p>
<p>Executing <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> guarantees memory ordering among threads participating in the barrier. Thus, threads within a warp that wish to communicate via memory can store to memory, execute <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code>, and then safely read values stored by other threads in the warp.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For .target sm_6x or below, all threads in mask must execute the same <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> in convergence, and the union of all values in mask must be equal to the active mask. Otherwise, the behavior is undefined.</p>
</div>
</section>
<section id="mathematical-functions">
<h2><span class="section-number">7.7. </span>Mathematical Functions<a class="headerlink" href="#mathematical-functions" title="Permalink to this headline">ï</a></h2>
<p>The reference manual lists all C/C++ standard library mathematical functions that are supported in device code and all intrinsic functions that are only supported in device code.</p>
<p><a class="reference internal" href="#mathematical-functions-appendix"><span class="std std-ref">Mathematical Functions</span></a> provides accuracy information for some of these functions when relevant.</p>
</section>
<section id="texture-functions">
<span id="id165"></span><h2><span class="section-number">7.8. </span>Texture Functions<a class="headerlink" href="#texture-functions" title="Permalink to this headline">ï</a></h2>
<p>Texture objects are described in <a class="reference internal" href="#texture-object-api"><span class="std std-ref">Texture Object API</span></a>.</p>
<p>Texture fetching is described in <a class="reference internal" href="#texture-fetching"><span class="std std-ref">Texture Fetching</span></a>.</p>
<section id="texture-object-api-appendix">
<span id="id166"></span><h3><span class="section-number">7.8.1. </span>Texture Object API<a class="headerlink" href="#texture-object-api-appendix" title="Permalink to this headline">ï</a></h3>
<section id="tex1dfetch">
<span id="tex1dfetch-object"></span><h4><span class="section-number">7.8.1.1. </span>tex1Dfetch()<a class="headerlink" href="#tex1dfetch" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1Dfetch</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the region of linear memory specified by the one-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using integer texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code>. <code class="docutils literal notranslate"><span class="pre">tex1Dfetch()</span></code> only works with non-normalized coordinates, so only the border and clamp addressing modes are supported. It does not perform any texture filtering. For integer types, it may optionally promote the integer to single-precision floating point.</p>
</section>
<section id="tex1d">
<span id="tex1d-object"></span><h4><span class="section-number">7.8.1.2. </span>tex1D()<a class="headerlink" href="#tex1d" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1D</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</section>
<section id="tex1dlod">
<span id="tex1dlod-object"></span><h4><span class="section-number">7.8.1.3. </span>tex1DLod()<a class="headerlink" href="#tex1dlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1DLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code> at the level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
<section id="tex1dgrad">
<span id="tex1dgrad-object"></span><h4><span class="section-number">7.8.1.4. </span>tex1DGrad()<a class="headerlink" href="#tex1dgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1DGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code>. The level-of-detail is derived from the X-gradient <code class="docutils literal notranslate"><span class="pre">dx</span></code> and Y-gradient <code class="docutils literal notranslate"><span class="pre">dy</span></code>.</p>
</section>
<section id="tex2d">
<span id="tex2d-object"></span><h4><span class="section-number">7.8.1.5. </span>tex2D()<a class="headerlink" href="#tex2d" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2D</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>.</p>
</section>
<section id="tex2d-for-sparse-cuda-arrays">
<span id="tex2d-object-sparse"></span><h4><span class="section-number">7.8.1.6. </span>tex2D() for sparse CUDA arrays<a class="headerlink" href="#tex2d-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2D</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex2dgather">
<span id="tex2dgather-object"></span><h4><span class="section-number">7.8.1.7. </span>tex2Dgather()<a class="headerlink" href="#tex2dgather" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2Dgather</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the 2D texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinates <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> and the <code class="docutils literal notranslate"><span class="pre">comp</span></code> parameter as described in <a class="reference internal" href="#texture-gather"><span class="std std-ref">Texture Gather</span></a>.</p>
</section>
<section id="tex2dgather-for-sparse-cuda-arrays">
<span id="tex2dgather-object-sparse"></span><h4><span class="section-number">7.8.1.8. </span>tex2Dgather() for sparse CUDA arrays<a class="headerlink" href="#tex2dgather-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2Dgather</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the 2D texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinates <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> and the <code class="docutils literal notranslate"><span class="pre">comp</span></code> parameter as described in <a class="reference internal" href="#texture-gather"><span class="std std-ref">Texture Gather</span></a>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex2dgrad">
<span id="tex2dgrad-object"></span><h4><span class="section-number">7.8.1.9. </span>tex2DGrad()<a class="headerlink" href="#tex2dgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">float2</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>. The level-of-detail is derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients.</p>
</section>
<section id="tex2dgrad-for-sparse-cuda-arrays">
<span id="tex2dgrad-object-sparse"></span><h4><span class="section-number">7.8.1.10. </span>tex2DGrad() for sparse CUDA arrays<a class="headerlink" href="#tex2dgrad-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">float2</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">dy</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>. The level-of-detail is derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex2dlod">
<span id="tex2dlod-object"></span><h4><span class="section-number">7.8.1.11. </span>tex2DLod()<a class="headerlink" href="#tex2dlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">tex2DLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array or the region of linear memory specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> at level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
<section id="tex2dlod-for-sparse-cuda-arrays">
<span id="tex2dlod-object-sparse"></span><h4><span class="section-number">7.8.1.12. </span>tex2DLod() for sparse CUDA arrays<a class="headerlink" href="#tex2dlod-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">tex2DLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> at level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex3d">
<span id="tex3d-object"></span><h4><span class="section-number">7.8.1.13. </span>tex3D()<a class="headerlink" href="#tex3d" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3D</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code>.</p>
</section>
<section id="tex3d-for-sparse-cuda-arrays">
<span id="tex3d-object-sparse"></span><h4><span class="section-number">7.8.1.14. </span>tex3D() for sparse CUDA arrays<a class="headerlink" href="#tex3d-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3D</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex3dlod">
<span id="tex3dlod-object"></span><h4><span class="section-number">7.8.1.15. </span>tex3DLod()<a class="headerlink" href="#tex3dlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3DLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> at level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
<section id="tex3dlod-for-sparse-cuda-arrays">
<span id="tex3dlod-object-sparse"></span><h4><span class="section-number">7.8.1.16. </span>tex3DLod() for sparse CUDA arrays<a class="headerlink" href="#tex3dlod-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3DLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array or the region of linear memory specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> at level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex3dgrad">
<span id="tex3dgrad-object"></span><h4><span class="section-number">7.8.1.17. </span>tex3DGrad()<a class="headerlink" href="#tex3dgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3DGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">float4</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> at a level-of-detail derived from the X and Y gradients <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code>.</p>
</section>
<section id="tex3dgrad-for-sparse-cuda-arrays">
<span id="tex3dgrad-object-sparse"></span><h4><span class="section-number">7.8.1.18. </span>tex3DGrad() for sparse CUDA arrays<a class="headerlink" href="#tex3dgrad-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex3DGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">float4</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">dy</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the three-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> at a level-of-detail derived from the X and Y gradients <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex1dlayered">
<span id="tex1dlayered-object"></span><h4><span class="section-number">7.8.1.19. </span>tex1DLayered()<a class="headerlink" href="#tex1dlayered" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1DLayered</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code> and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#layered-textures"><span class="std std-ref">Layered Textures</span></a>.</p>
</section>
<section id="tex1dlayeredlod">
<span id="tex1dlayeredlod-object"></span><h4><span class="section-number">7.8.1.20. </span>tex1DLayeredLod()<a class="headerlink" href="#tex1dlayeredlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1DLayeredLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">Layered Textures</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code> and level-of-detail <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
<section id="tex1dlayeredgrad">
<span id="tex1dlayeredgrad-object"></span><h4><span class="section-number">7.8.1.21. </span>tex1DLayeredGrad()<a class="headerlink" href="#tex1dlayeredgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex1DLayeredGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="kt">float</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the one-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">layered texture</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code> and a level-of-detail derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients.</p>
</section>
<section id="tex2dlayered">
<span id="tex2dlayered-object"></span><h4><span class="section-number">7.8.1.22. </span>tex2DLayered()<a class="headerlink" href="#tex2dlayered" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayered</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#layered-textures"><span class="std std-ref">Layered Textures</span></a>.</p>
</section>
<section id="tex2dlayered-for-sparse-cuda-arrays">
<span id="tex2dlayered-object-sparse"></span><h4><span class="section-number">7.8.1.23. </span>tex2DLayered() for Sparse CUDA Arrays<a class="headerlink" href="#tex2dlayered-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayered</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#layered-textures"><span class="std std-ref">Layered Textures</span></a>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex2dlayeredlod">
<span id="tex2dlayeredlod-object"></span><h4><span class="section-number">7.8.1.24. </span>tex2DLayeredLod()<a class="headerlink" href="#tex2dlayeredlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayeredLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">layered texture</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>.</p>
</section>
<section id="tex2dlayeredlod-for-sparse-cuda-arrays">
<span id="tex2dlayeredlod-object-sparse"></span><h4><span class="section-number">7.8.1.25. </span>tex2DLayeredLod() for sparse CUDA arrays<a class="headerlink" href="#tex2dlayeredlod-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayeredLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">layered texture</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code>. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="tex2dlayeredgrad">
<span id="tex2dlayeredgrad-object"></span><h4><span class="section-number">7.8.1.26. </span>tex2DLayeredGrad()<a class="headerlink" href="#tex2dlayeredgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayeredGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">float2</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">layered texture</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> and a level-of-detail derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients.</p>
</section>
<section id="tex2dlayeredgrad-for-sparse-cuda-arrays">
<span id="tex2dlayeredgrad-object-sparse"></span><h4><span class="section-number">7.8.1.27. </span>tex2DLayeredGrad() for sparse CUDA arrays<a class="headerlink" href="#tex2dlayeredgrad-for-sparse-cuda-arrays" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">tex2DLayeredGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">float2</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">dy</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">*</span><span class="w"> </span><span class="n">isResident</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the two-dimensional <a class="reference internal" href="#layered-textures"><span class="std std-ref">layered texture</span></a> at layer <code class="docutils literal notranslate"><span class="pre">layer</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> and a level-of-detail derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients. Also returns whether the texel is resident in memory via <code class="docutils literal notranslate"><span class="pre">isResident</span></code> pointer. If not, the values fetched will be zeros.</p>
</section>
<section id="texcubemap">
<span id="texcubemap-object"></span><h4><span class="section-number">7.8.1.28. </span>texCubemap()<a class="headerlink" href="#texcubemap" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemap</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches the CUDA array specified by the cubemap texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code>, as described in <a class="reference internal" href="#cubemap-textures"><span class="std std-ref">Cubemap Textures</span></a>.</p>
</section>
<section id="texcubemapgrad">
<span id="texcubemapgrad-object"></span><h4><span class="section-number">7.8.1.29. </span>texCubemapGrad()<a class="headerlink" href="#texcubemapgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemapGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">float4</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the cubemap texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> as described in <a class="reference internal" href="#cubemap-textures"><span class="std std-ref">Cubemap Textures</span></a>. The level-of-detail used is derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients.</p>
</section>
<section id="texcubemaplod">
<span id="texcubemaplod-object"></span><h4><span class="section-number">7.8.1.30. </span>texCubemapLod()<a class="headerlink" href="#texcubemaplod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemapLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the cubemap texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> as described in <a class="reference internal" href="#cubemap-textures"><span class="std std-ref">Cubemap Textures</span></a>. The level-of-detail used is given by <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
<section id="texcubemaplayered">
<span id="texcubemaplayered-object"></span><h4><span class="section-number">7.8.1.31. </span>texCubemapLayered()<a class="headerlink" href="#texcubemaplayered" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemapLayered</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the cubemap layered texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinates <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code>, and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#cubemap-layered-textures"><span class="std std-ref">Cubemap Layered Textures</span></a>.</p>
</section>
<section id="texcubemaplayeredgrad">
<span id="texcubemaplayeredgrad-object"></span><h4><span class="section-number">7.8.1.32. </span>texCubemapLayeredGrad()<a class="headerlink" href="#texcubemaplayeredgrad" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemapLayeredGrad</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the cubemap layered texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#cubemap-layered-textures"><span class="std std-ref">Cubemap Layered Textures</span></a>, at level-of-detail derived from the <code class="docutils literal notranslate"><span class="pre">dx</span></code> and <code class="docutils literal notranslate"><span class="pre">dy</span></code> gradients.</p>
</section>
<section id="texcubemaplayeredlod">
<span id="texcubemaplayeredlod-object"></span><h4><span class="section-number">7.8.1.33. </span>texCubemapLayeredLod()<a class="headerlink" href="#texcubemaplayeredlod" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">texCubemapLayeredLod</span><span class="p">(</span><span class="n">cudaTextureObject_t</span><span class="w"> </span><span class="n">texObj</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">level</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>fetches from the CUDA array specified by the cubemap layered texture object <code class="docutils literal notranslate"><span class="pre">texObj</span></code> using texture coordinate <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>, as described in <a class="reference internal" href="#cubemap-layered-textures"><span class="std std-ref">Cubemap Layered Textures</span></a>, at level-of-detail level <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p>
</section>
</section>
</section>
<section id="surface-functions">
<span id="id167"></span><h2><span class="section-number">7.9. </span>Surface Functions<a class="headerlink" href="#surface-functions" title="Permalink to this headline">ï</a></h2>
<p>Surface functions are only supported by devices of compute capability 2.0 and higher.</p>
<p>Surface objects are described in described in <a class="reference internal" href="#surface-object-api-appendix"><span class="std std-ref">Surface Object API</span></a>.</p>
<p>In the sections below, <code class="docutils literal notranslate"><span class="pre">boundaryMode</span></code> specifies the boundary mode, that is how out-of-range surface coordinates are handled; it is equal to either <code class="docutils literal notranslate"><span class="pre">cudaBoundaryModeClamp</span></code>, in which case out-of-range coordinates are clamped to the valid range, or <code class="docutils literal notranslate"><span class="pre">cudaBoundaryModeZero</span></code>, in which case out-of-range reads return zero and out-of-range writes are ignored, or <code class="docutils literal notranslate"><span class="pre">cudaBoundaryModeTrap</span></code>, in which case out-of-range accesses cause the kernel execution to fail.</p>
<section id="surface-object-api-appendix">
<span id="id168"></span><h3><span class="section-number">7.9.1. </span>Surface Object API<a class="headerlink" href="#surface-object-api-appendix" title="Permalink to this headline">ï</a></h3>
<section id="surf1dread">
<span id="surf1dread-object"></span><h4><span class="section-number">7.9.1.1. </span>surf1Dread()<a class="headerlink" href="#surf1dread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surf1Dread</span><span class="p">(</span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the one-dimensional surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinate x.</p>
</section>
<section id="surf1dwrite">
<span id="surf1dwrite-object"></span><h4><span class="section-number">7.9.1.2. </span>surf1Dwrite<a class="headerlink" href="#surf1dwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf1Dwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the one-dimensional surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x.</p>
</section>
<section id="surf2dread">
<span id="surf2dread-object"></span><h4><span class="section-number">7.9.1.3. </span>surf2Dread()<a class="headerlink" href="#surf2dread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surf2Dread</span><span class="p">(</span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf2Dread</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the two-dimensional surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinates x and y.</p>
</section>
<section id="surf2dwrite">
<span id="surf2dwrite-object"></span><h4><span class="section-number">7.9.1.4. </span>surf2Dwrite()<a class="headerlink" href="#surf2dwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf2Dwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the two-dimensional surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x and y.</p>
</section>
<section id="surf3dread">
<span id="surf3dread-object"></span><h4><span class="section-number">7.9.1.5. </span>surf3Dread()<a class="headerlink" href="#surf3dread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surf3Dread</span><span class="p">(</span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf3Dread</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the three-dimensional surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinates x, y, and z.</p>
</section>
<section id="surf3dwrite">
<span id="surf3dwrite-object"></span><h4><span class="section-number">7.9.1.6. </span>surf3Dwrite()<a class="headerlink" href="#surf3dwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf3Dwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"></span>
<span class="w">                  </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the three-dimensional object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x, y, and z.</p>
</section>
<section id="surf1dlayeredread">
<span id="surf1dlayeredread-object"></span><h4><span class="section-number">7.9.1.7. </span>surf1DLayeredread()<a class="headerlink" href="#surf1dlayeredread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surf1DLayeredread</span><span class="p">(</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf1DLayeredread</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the one-dimensional layered surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinate x and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>.</p>
</section>
<section id="surf1dlayeredwrite">
<span id="surf1dlayeredwrite-object"></span><h4><span class="section-number">7.9.1.8. </span>surf1DLayeredwrite()<a class="headerlink" href="#surf1dlayeredwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf1DLayeredwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the two-dimensional layered surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>.</p>
</section>
<section id="surf2dlayeredread">
<span id="surf2dlayeredread-object"></span><h4><span class="section-number">7.9.1.9. </span>surf2DLayeredread()<a class="headerlink" href="#surf2dlayeredread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surf2DLayeredread</span><span class="p">(</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf2DLayeredread</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the two-dimensional layered surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinate x and y, and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>.</p>
</section>
<section id="surf2dlayeredwrite">
<span id="surf2dlayeredwrite-object"></span><h4><span class="section-number">7.9.1.10. </span>surf2DLayeredwrite()<a class="headerlink" href="#surf2dlayeredwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surf2DLayeredwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layer</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the one-dimensional layered surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x and y, and index <code class="docutils literal notranslate"><span class="pre">layer</span></code>.</p>
</section>
<section id="surfcubemapread">
<span id="surfcubemapread-object"></span><h4><span class="section-number">7.9.1.11. </span>surfCubemapread()<a class="headerlink" href="#surfcubemapread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surfCubemapread</span><span class="p">(</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">face</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surfCubemapread</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">face</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the cubemap surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinate x and y, and face index face.</p>
</section>
<section id="surfcubemapwrite">
<span id="surfcubemapwrite-object"></span><h4><span class="section-number">7.9.1.12. </span>surfCubemapwrite()<a class="headerlink" href="#surfcubemapwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surfCubemapwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">face</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the cubemap object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate x and y, and face index face.</p>
</section>
<section id="surfcubemaplayeredread">
<span id="surfcubemaplayeredread-object"></span><h4><span class="section-number">7.9.1.13. </span>surfCubemapLayeredread()<a class="headerlink" href="#surfcubemaplayeredread" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">surfCubemapLayeredread</span><span class="p">(</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layerFace</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surfCubemapLayeredread</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layerFace</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the CUDA array specified by the cubemap layered surface object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> using byte coordinate x and y, and index <code class="docutils literal notranslate"><span class="pre">layerFace.</span></code></p>
</section>
<section id="surfcubemaplayeredwrite">
<span id="surfcubemaplayeredwrite-object"></span><h4><span class="section-number">7.9.1.14. </span>surfCubemapLayeredwrite()<a class="headerlink" href="#surfcubemaplayeredwrite" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">surfCubemapLayeredwrite</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaSurfaceObject_t</span><span class="w"> </span><span class="n">surfObj</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">layerFace</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">boundaryMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaBoundaryModeTrap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>writes value data to the CUDA array specified by the cubemap layered object <code class="docutils literal notranslate"><span class="pre">surfObj</span></code> at byte coordinate <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>, and index <code class="docutils literal notranslate"><span class="pre">layerFace</span></code>.</p>
</section>
</section>
</section>
<section id="read-only-data-cache-load-function">
<span id="ldg-function"></span><h2><span class="section-number">7.10. </span>Read-Only Data Cache Load Function<a class="headerlink" href="#read-only-data-cache-load-function" title="Permalink to this headline">ï</a></h2>
<p>The read-only data cache load function is only supported by devices of compute capability 5.0 and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__ldg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>returns the data of type <code class="docutils literal notranslate"><span class="pre">T</span></code> located at address <code class="docutils literal notranslate"><span class="pre">address</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">char2</span></code>, <code class="docutils literal notranslate"><span class="pre">char4</span></code>, <code class="docutils literal notranslate"><span class="pre">short2</span></code>, <code class="docutils literal notranslate"><span class="pre">short4</span></code>, <code class="docutils literal notranslate"><span class="pre">int2</span></code>, <code class="docutils literal notranslate"><span class="pre">int4</span></code>, <code class="docutils literal notranslate"><span class="pre">longlong2</span></code><code class="docutils literal notranslate"><span class="pre">uchar2</span></code>, <code class="docutils literal notranslate"><span class="pre">uchar4</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort2</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort4</span></code>, <code class="docutils literal notranslate"><span class="pre">uint2</span></code>, <code class="docutils literal notranslate"><span class="pre">uint4</span></code>, <code class="docutils literal notranslate"><span class="pre">ulonglong2</span></code><code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">float2</span></code>, <code class="docutils literal notranslate"><span class="pre">float4</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code>, or <code class="docutils literal notranslate"><span class="pre">double2</span></code>. With the <code class="docutils literal notranslate"><span class="pre">cuda_fp16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can be <code class="docutils literal notranslate"><span class="pre">__half</span></code> or <code class="docutils literal notranslate"><span class="pre">__half2</span></code>. Similarly, with the <code class="docutils literal notranslate"><span class="pre">cuda_bf16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code>. The operation is cached in the read-only data cache (see <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="load-functions-using-cache-hints">
<span id="ldx-functions"></span><h2><span class="section-number">7.11. </span>Load Functions Using Cache Hints<a class="headerlink" href="#load-functions-using-cache-hints" title="Permalink to this headline">ï</a></h2>
<p>These load functions are only supported by devices of compute capability 5.0 and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__ldcg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__ldca</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__ldcs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__ldlu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__ldcv</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>returns the data of type <code class="docutils literal notranslate"><span class="pre">T</span></code> located at address <code class="docutils literal notranslate"><span class="pre">address</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">char2</span></code>, <code class="docutils literal notranslate"><span class="pre">char4</span></code>, <code class="docutils literal notranslate"><span class="pre">short2</span></code>, <code class="docutils literal notranslate"><span class="pre">short4</span></code>, <code class="docutils literal notranslate"><span class="pre">int2</span></code>, <code class="docutils literal notranslate"><span class="pre">int4</span></code>, <code class="docutils literal notranslate"><span class="pre">longlong2</span></code><code class="docutils literal notranslate"><span class="pre">uchar2</span></code>, <code class="docutils literal notranslate"><span class="pre">uchar4</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort2</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort4</span></code>, <code class="docutils literal notranslate"><span class="pre">uint2</span></code>, <code class="docutils literal notranslate"><span class="pre">uint4</span></code>, <code class="docutils literal notranslate"><span class="pre">ulonglong2</span></code><code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">float2</span></code>, <code class="docutils literal notranslate"><span class="pre">float4</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code>, or <code class="docutils literal notranslate"><span class="pre">double2</span></code>. With the <code class="docutils literal notranslate"><span class="pre">cuda_fp16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can be <code class="docutils literal notranslate"><span class="pre">__half</span></code> or <code class="docutils literal notranslate"><span class="pre">__half2</span></code>. Similarly, with the <code class="docutils literal notranslate"><span class="pre">cuda_bf16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code>. The operation is using the corresponding cache operator (see <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#cache-operators">PTX ISA</a>)</p>
</section>
<section id="store-functions-using-cache-hints">
<span id="stx-functions"></span><h2><span class="section-number">7.12. </span>Store Functions Using Cache Hints<a class="headerlink" href="#store-functions-using-cache-hints" title="Permalink to this headline">ï</a></h2>
<p>These store functions are only supported by devices of compute capability 5.0 and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__stwb</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__stcg</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__stcs</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__stwt</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>stores the <code class="docutils literal notranslate"><span class="pre">value</span></code> argument of type <code class="docutils literal notranslate"><span class="pre">T</span></code> to the location at address <code class="docutils literal notranslate"><span class="pre">address</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is <code class="docutils literal notranslate"><span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">char2</span></code>, <code class="docutils literal notranslate"><span class="pre">char4</span></code>, <code class="docutils literal notranslate"><span class="pre">short2</span></code>, <code class="docutils literal notranslate"><span class="pre">short4</span></code>, <code class="docutils literal notranslate"><span class="pre">int2</span></code>, <code class="docutils literal notranslate"><span class="pre">int4</span></code>, <code class="docutils literal notranslate"><span class="pre">longlong2</span></code><code class="docutils literal notranslate"><span class="pre">uchar2</span></code>, <code class="docutils literal notranslate"><span class="pre">uchar4</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort2</span></code>, <code class="docutils literal notranslate"><span class="pre">ushort4</span></code>, <code class="docutils literal notranslate"><span class="pre">uint2</span></code>, <code class="docutils literal notranslate"><span class="pre">uint4</span></code>, <code class="docutils literal notranslate"><span class="pre">ulonglong2</span></code><code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">float2</span></code>, <code class="docutils literal notranslate"><span class="pre">float4</span></code>, <code class="docutils literal notranslate"><span class="pre">double</span></code>, or <code class="docutils literal notranslate"><span class="pre">double2</span></code>. With the <code class="docutils literal notranslate"><span class="pre">cuda_fp16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can be <code class="docutils literal notranslate"><span class="pre">__half</span></code> or <code class="docutils literal notranslate"><span class="pre">__half2</span></code>. Similarly, with the <code class="docutils literal notranslate"><span class="pre">cuda_bf16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code>. The operation is using the corresponding cache operator (see <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#cache-operators">PTX ISA</a> )</p>
</section>
<section id="time-function">
<h2><span class="section-number">7.13. </span>Time Function<a class="headerlink" href="#time-function" title="Permalink to this headline">ï</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">clock_t</span><span class="w"> </span><span class="nf">clock</span><span class="p">();</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">clock64</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>when executed in device code, returns the value of a per-multiprocessor counter that is incremented every clock cycle. Sampling this counter at the beginning and at the end of a kernel, taking the difference of the two samples, and recording the result per thread provides a measure for each thread of the number of clock cycles taken by the device to completely execute the thread, but not of the number of clock cycles the device actually spent executing thread instructions. The former number is greater than the latter since threads are time sliced.</p>
</section>
<section id="atomic-functions">
<span id="id169"></span><h2><span class="section-number">7.14. </span>Atomic Functions<a class="headerlink" href="#atomic-functions" title="Permalink to this headline">ï</a></h2>
<p>An atomic function performs a read-modify-write atomic operation on one 32-bit, 64-bit, or 128-bit word residing in global or shared memory. In the case of <code class="docutils literal notranslate"><span class="pre">float2</span></code> or <code class="docutils literal notranslate"><span class="pre">float4</span></code>, the read-modify-write operation is performed on each element of the vector residing in global memory. For example, <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> reads a word at some address in global or shared memory, adds a number to it, and writes the result back to the same address. Atomic functions can only be used in device functions.</p>
<p>The atomic functions described in this section have ordering <a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">cuda::memory_order_relaxed</a> and are only atomic at a particular <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#thread-scopes">scope</a>:</p>
<ul class="simple">
<li><p>Atomic APIs with <code class="docutils literal notranslate"><span class="pre">_system</span></code> suffix (example: <code class="docutils literal notranslate"><span class="pre">atomicAdd_system</span></code>) are atomic at scope <code class="docutils literal notranslate"><span class="pre">cuda::thread_scope_system</span></code> if they meet particular <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#atomicity">conditions</a>.</p></li>
<li><p>Atomic APIs without a suffix (example: <code class="docutils literal notranslate"><span class="pre">atomicAdd</span></code>) are atomic at scope <code class="docutils literal notranslate"><span class="pre">cuda::thread_scope_device</span></code>.</p></li>
<li><p>Atomic APIs with <code class="docutils literal notranslate"><span class="pre">_block</span></code> suffix (example: <code class="docutils literal notranslate"><span class="pre">atomicAdd_block</span></code>) are atomic at scope <code class="docutils literal notranslate"><span class="pre">cuda::thread_scope_block</span></code>.</p></li>
</ul>
<p>In the following example both the CPU and the GPU atomically update an integer value at address <code class="docutils literal notranslate"><span class="pre">addr</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">mykernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">atomicAdd_system</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">       </span><span class="c1">// only available on devices with compute capability 6.x</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">mykernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// CPU atomic operation</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that any atomic operation can be implemented based on <code class="docutils literal notranslate"><span class="pre">atomicCAS()</span></code> (Compare And Swap). For example, <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> for double-precision floating-point numbers is not available on devices with compute capability lower than 6.0 but it can be implemented as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if __CUDA_ARCH__ &lt; 600</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address_as_ull</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">                              </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">address_as_ull</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">assumed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">address_as_ull</span><span class="p">,</span><span class="w"> </span><span class="n">assumed</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="n">__double_as_longlong</span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">+</span><span class="w"></span>
<span class="w">                               </span><span class="n">__longlong_as_double</span><span class="p">(</span><span class="n">assumed</span><span class="p">)));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN)</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">assumed</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">old</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">__longlong_as_double</span><span class="p">(</span><span class="n">old</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>There are system-wide and block-wide variants of the following device-wide atomic APIs, with the following exceptions:</p>
<ul class="simple">
<li><p>Devices with compute capability less than 6.0 only support device-wide atomic operations,</p></li>
<li><p>Tegra devices with compute capability less than 7.2 do not support system-wide atomic operations.</p></li>
</ul>
<p>CUDA 12.8 and later support CUDA compiler builtin functions for atomic operations with memory order and thread scope. We follows the <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html">GNUâs atomic built-in function signature</a> with an extra argument of thread scope.
We use the following atomic operation memory orders and thread scopes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_RELAXED</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_CONSUME</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_ACQUIRE</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_RELEASE</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_ACQ_REL</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_ATOMIC_SEQ_CST</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_THREAD_SCOPE_THREAD</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_THREAD_SCOPE_BLOCK</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_THREAD_SCOPE_CLUSTER</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_THREAD_SCOPE_DEVICE</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_load_n</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>T can be any integral type that is size of 1, 2, 4, 8 and 16 bytes.</p>
<p>These atomic functions cannot operate on local memory. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// defined in local memory</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">__nv_atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_ATOMIC_RELAXED</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>These functions must only be used within the block scope of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">__nv_atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_ATOMIC_RELAXED</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>And these functionsâ address cannot be taken. Here are three unsupported examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Not permitted to be used in a host function</span>
<span class="n">__host__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">u2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">__nv_atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">u2</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_ATOMIC_RELAXED</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Not permitted to be used as a template default argument.</span>
<span class="c1">// The function address cannot be taken.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__nv_atomic_load_n</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Not permitted to be called in a constructor initialization list.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Y</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">   </span><span class="n">__device__</span><span class="w"> </span><span class="n">Y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">__nv_atomic_load_n</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">__NV_ATOMIC_RELAXED</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The memory order corresponds to <a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++ standard atomic operationâs memory order</a>. And for thread scope, we follows cuda::thread_scopeâs <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/memory_model.html#thread-scopes">definition</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_CONSUME</span></code> memory order is currently implemented using stronger <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQUIRE</span></code> memory order.</p>
<p><code class="docutils literal notranslate"><span class="pre">__NV_THREAD_SCOPE_THREAD</span></code> thread scope is currently implemented using wider <code class="docutils literal notranslate"><span class="pre">__NV_THREAD_SCOPE_BLOCK</span></code> thread scope.</p>
<p>For the supported data types, please refer to the corresponding section of different atomic operations.</p>
<section id="arithmetic-functions">
<h3><span class="section-number">7.14.1. </span>Arithmetic Functions<a class="headerlink" href="#arithmetic-functions" title="Permalink to this headline">ï</a></h3>
<section id="atomicadd">
<span id="id170"></span><h4><span class="section-number">7.14.1.1. </span>atomicAdd()<a class="headerlink" href="#atomicadd" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">__half2</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">__half2</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">__half2</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">__half</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">__half</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">__half</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">__nv_bfloat162</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">__nv_bfloat162</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">__nv_bfloat162</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">__nv_bfloat16</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">__nv_bfloat16</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">__nv_bfloat16</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">float2</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">float2</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">float2</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="n">float4</span><span class="w"> </span><span class="nf">atomicAdd</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">float4</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 16-bit, 32-bit or 64-bit <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">+</span> <span class="pre">val)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 32-bit floating-point version of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> is only supported by devices of compute capability 2.x and higher.</p>
<p>The 64-bit floating-point version of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> is only supported by devices of compute capability 6.x and higher.</p>
<p>The 32-bit <code class="docutils literal notranslate"><span class="pre">__half2</span></code> floating-point version of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> is only supported by devices of compute capability 6.x and higher. The atomicity of the <code class="docutils literal notranslate"><span class="pre">__half2</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code> add operation is guaranteed separately for each of the two <code class="docutils literal notranslate"><span class="pre">__half</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> elements; the entire <code class="docutils literal notranslate"><span class="pre">__half2</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code> is not guaranteed to be atomic as a single 32-bit access.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">float2</span></code> and <code class="docutils literal notranslate"><span class="pre">float4</span></code> floating-point vector versions of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> are only supported by devices of compute capability 9.x and higher. The atomicity of the <code class="docutils literal notranslate"><span class="pre">float2</span></code> or <code class="docutils literal notranslate"><span class="pre">float4</span></code> add operation is guaranteed separately for each of the two or four <code class="docutils literal notranslate"><span class="pre">float</span></code> elements; the entire <code class="docutils literal notranslate"><span class="pre">float2</span></code> or <code class="docutils literal notranslate"><span class="pre">float4</span></code> is not guaranteed to be atomic as a single 64-bit or 128-bit access.</p>
<p>The 16-bit <code class="docutils literal notranslate"><span class="pre">__half</span></code> floating-point version of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> is only supported by devices of compute capability 7.x and higher.</p>
<p>The 16-bit <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> floating-point version of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> is only supported by devices of compute capability 8.x and higher.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">float2</span></code> and <code class="docutils literal notranslate"><span class="pre">float4</span></code> floating-point vector versions of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> are only supported by devices of compute capability 9.x and higher.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">float2</span></code> and <code class="docutils literal notranslate"><span class="pre">float4</span></code> floating-point vector versions of <code class="docutils literal notranslate"><span class="pre">atomicAdd()</span></code> are only supported for global memory addresses.</p>
</section>
<section id="atomicsub">
<h4><span class="section-number">7.14.1.2. </span>atomicSub()<a class="headerlink" href="#atomicsub" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicSub</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicSub</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">-</span> <span class="pre">val)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
</section>
<section id="atomicexch">
<h4><span class="section-number">7.14.1.3. </span>atomicExch()<a class="headerlink" href="#atomicexch" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicExch</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicExch</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicExch</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">atomicExch</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory and stores <code class="docutils literal notranslate"><span class="pre">val</span></code> back to memory at the same address. These two operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">atomicExch</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 128-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory and stores <code class="docutils literal notranslate"><span class="pre">val</span></code> back to memory at the same address. These two operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>. The type <code class="docutils literal notranslate"><span class="pre">T</span></code> must meet the following requirements:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copyable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="w"></span>
<span class="c1">// for C++03 and older</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="w"></span>
</pre></div>
</div>
<p>So, <code class="docutils literal notranslate"><span class="pre">T</span></code> must be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.</p>
<p>The 128-bit <code class="docutils literal notranslate"><span class="pre">atomicExch()</span></code> is only supported by devices of compute capability 9.x and higher.</p>
</section>
<section id="atomicmin">
<h4><span class="section-number">7.14.1.4. </span>atomicMin()<a class="headerlink" href="#atomicmin" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMin</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMin</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMin</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMin</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes the minimum of <code class="docutils literal notranslate"><span class="pre">old</span></code> and <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">atomicMin()</span></code> is only supported by devices of compute capability 5.0 and higher.</p>
</section>
<section id="atomicmax">
<h4><span class="section-number">7.14.1.5. </span>atomicMax()<a class="headerlink" href="#atomicmax" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMax</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMax</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMax</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicMax</span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes the maximum of <code class="docutils literal notranslate"><span class="pre">old</span></code> and <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">atomicMax()</span></code> is only supported by devices of compute capability 5.0 and higher.</p>
</section>
<section id="atomicinc">
<h4><span class="section-number">7.14.1.6. </span>atomicInc()<a class="headerlink" href="#atomicinc" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicInc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">((old</span> <span class="pre">&gt;=</span> <span class="pre">val)</span> <span class="pre">?</span> <span class="pre">0</span> <span class="pre">:</span> <span class="pre">(old+1))</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
</section>
<section id="atomicdec">
<h4><span class="section-number">7.14.1.7. </span>atomicDec()<a class="headerlink" href="#atomicdec" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicDec</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(((old</span> <span class="pre">==</span> <span class="pre">0)</span> <span class="pre">||</span> <span class="pre">(old</span> <span class="pre">&gt;</span> <span class="pre">val))</span> <span class="pre">?</span> <span class="pre">val</span> <span class="pre">:</span> <span class="pre">(old-1)</span></code> ), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
</section>
<section id="atomiccas">
<h4><span class="section-number">7.14.1.8. </span>atomicCAS()<a class="headerlink" href="#atomiccas" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicCAS</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicCAS</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicCAS</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicCAS</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 16-bit, 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">==</span> <span class="pre">compare</span> <span class="pre">?</span> <span class="pre">val</span> <span class="pre">:</span> <span class="pre">old)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code> (Compare And Swap).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">compare</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 128-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">==</span> <span class="pre">compare</span> <span class="pre">?</span> <span class="pre">val</span> <span class="pre">:</span> <span class="pre">old)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code> (Compare And Swap). The type <code class="docutils literal notranslate"><span class="pre">T</span></code> must meet the following requirements:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">16</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copyable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="w"></span>
<span class="c1">// for C++03 and older</span>
<span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="w"></span>
</pre></div>
</div>
<p>So, <code class="docutils literal notranslate"><span class="pre">T</span></code> must be 128-bit and properly aligned, be trivially copyable, and on C++03 or older, it must also be default constructible.</p>
<p>The 128-bit <code class="docutils literal notranslate"><span class="pre">atomicCAS()</span></code> is only supported by devices of compute capability 9.x and higher.</p>
</section>
<section id="nv-atomic-exchange">
<h4><span class="section-number">7.14.1.9. </span>__nv_atomic_exchange()<a class="headerlink" href="#nv-atomic-exchange" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_exchange</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and stores the value to where <code class="docutils literal notranslate"><span class="pre">ret</span></code> points to. And it reads the value where <code class="docutils literal notranslate"><span class="pre">val</span></code> points to and stores the value to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to.</p>
<p>This is a generic atomic exchange, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any data type that is size of 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-exchange-n">
<h4><span class="section-number">7.14.1.10. </span>__nv_atomic_exchange_n()<a class="headerlink" href="#nv-atomic-exchange-n" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_exchange_n</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and use this value as the return value. And it stores <code class="docutils literal notranslate"><span class="pre">val</span></code> to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to.</p>
<p>This is a non-generic atomic exchange, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-compare-exchange">
<h4><span class="section-number">7.14.1.11. </span>__nv_atomic_compare_exchange()<a class="headerlink" href="#nv-atomic-compare-exchange" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">__nv_atomic_compare_exchange</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">weak</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">success_order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">failure_order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and compare it with the value where <code class="docutils literal notranslate"><span class="pre">expected</span></code> points to. If they are equal, the return value is <code class="docutils literal notranslate"><span class="pre">true</span></code> and the value where <code class="docutils literal notranslate"><span class="pre">desired</span></code> points to is stored to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. Otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> and the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to is stored to where <code class="docutils literal notranslate"><span class="pre">expected</span></code> points to. The parameter <code class="docutils literal notranslate"><span class="pre">weak</span></code> is ignored and it picks the stronger memory order between <code class="docutils literal notranslate"><span class="pre">success_order</span></code> and <code class="docutils literal notranslate"><span class="pre">failure_order</span></code> to execute the compare-and-exchange operation.</p>
<p>This is a generic atomic compare-and-exchange, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any data type that is size of 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>2-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-compare-exchange-n">
<h4><span class="section-number">7.14.1.12. </span>__nv_atomic_compare_exchange_n()<a class="headerlink" href="#nv-atomic-compare-exchange-n" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">__nv_atomic_compare_exchange_n</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">weak</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">success_order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">failure_order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and compare it with the value where <code class="docutils literal notranslate"><span class="pre">expected</span></code> points to. If they are equal, the return value is <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">desired</span></code> is stored to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. Otherwise, it returns <code class="docutils literal notranslate"><span class="pre">false</span></code> and the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to is stored to where <code class="docutils literal notranslate"><span class="pre">expected</span></code> points to. The parameter <code class="docutils literal notranslate"><span class="pre">weak</span></code> is ignored and it picks the stronger memory order between <code class="docutils literal notranslate"><span class="pre">success_order</span></code> and <code class="docutils literal notranslate"><span class="pre">failure_order</span></code> to execute the compare-and-exchange operation.</p>
<p>This is a non-generic atomic compare-and-exchange, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>2-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-add-and-nv-atomic-add">
<h4><span class="section-number">7.14.1.13. </span>__nv_atomic_fetch_add() and __nv_atomic_add()<a class="headerlink" href="#nv-atomic-fetch-add-and-nv-atomic-add" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_add</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_add</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, adds with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_add</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_add</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-sub-and-nv-atomic-sub">
<h4><span class="section-number">7.14.1.14. </span>__nv_atomic_fetch_sub() and __nv_atomic_sub()<a class="headerlink" href="#nv-atomic-fetch-sub-and-nv-atomic-sub" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_sub</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_sub</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, subtracts with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_sub</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_sub</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-min-and-nv-atomic-min">
<h4><span class="section-number">7.14.1.15. </span>__nv_atomic_fetch_min() and __nv_atomic_min()<a class="headerlink" href="#nv-atomic-fetch-min-and-nv-atomic-min" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_min</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_min</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, compares with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the smaller value back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_min</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_min</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> or <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-max-and-nv-atomic-max">
<h4><span class="section-number">7.14.1.16. </span>__nv_atomic_fetch_max() and __nv_atomic_max()<a class="headerlink" href="#nv-atomic-fetch-max-and-nv-atomic-max" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_max</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_max</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, compares with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the bigger value back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_max</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_max</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> or <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
</section>
<section id="bitwise-functions">
<h3><span class="section-number">7.14.2. </span>Bitwise Functions<a class="headerlink" href="#bitwise-functions" title="Permalink to this headline">ï</a></h3>
<section id="atomicand">
<h4><span class="section-number">7.14.2.1. </span>atomicAnd()<a class="headerlink" href="#atomicand" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAnd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAnd</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicAnd</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">&amp;</span> <span class="pre">val</span></code>), and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">atomicAnd()</span></code> is only supported by devices of compute capability 5.0 and higher.</p>
</section>
<section id="atomicor">
<h4><span class="section-number">7.14.2.2. </span>atomicOr()<a class="headerlink" href="#atomicor" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicOr</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicOr</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicOr</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">|</span> <span class="pre">val)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">atomicOr()</span></code> is only supported by devices of compute capability 5.0 and higher.</p>
</section>
<section id="atomicxor">
<h4><span class="section-number">7.14.2.3. </span>atomicXor()<a class="headerlink" href="#atomicxor" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicXor</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicXor</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">atomicXor</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>reads the 32-bit or 64-bit word <code class="docutils literal notranslate"><span class="pre">old</span></code> located at the address <code class="docutils literal notranslate"><span class="pre">address</span></code> in global or shared memory, computes <code class="docutils literal notranslate"><span class="pre">(old</span> <span class="pre">^</span> <span class="pre">val)</span></code>, and stores the result back to memory at the same address. These three operations are performed in one atomic transaction. The function returns <code class="docutils literal notranslate"><span class="pre">old</span></code>.</p>
<p>The 64-bit version of <code class="docutils literal notranslate"><span class="pre">atomicXor()</span></code> is only supported by devices of compute capability 5.0 and higher.</p>
</section>
<section id="nv-atomic-fetch-or-and-nv-atomic-or">
<h4><span class="section-number">7.14.2.4. </span>__nv_atomic_fetch_or() and __nv_atomic_or()<a class="headerlink" href="#nv-atomic-fetch-or-and-nv-atomic-or" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_or</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_or</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, <code class="docutils literal notranslate"><span class="pre">or</span></code> with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_or</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_or</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 4 or 8 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-xor-and-nv-atomic-xor">
<h4><span class="section-number">7.14.2.5. </span>__nv_atomic_fetch_xor() and __nv_atomic_xor()<a class="headerlink" href="#nv-atomic-fetch-xor-and-nv-atomic-xor" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_xor</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_xor</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, <code class="docutils literal notranslate"><span class="pre">xor</span></code> with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_xor</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_xor</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 4 or 8 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
<section id="nv-atomic-fetch-and-and-nv-atomic-and">
<h4><span class="section-number">7.14.2.6. </span>__nv_atomic_fetch_and() and __nv_atomic_and()<a class="headerlink" href="#nv-atomic-fetch-and-and-nv-atomic-and" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_fetch_and</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_and</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>These two atomic functions are introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to, <code class="docutils literal notranslate"><span class="pre">and</span></code> with <code class="docutils literal notranslate"><span class="pre">val</span></code>, and stores the result back to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_fetch_and</span></code> returns the old value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to. <code class="docutils literal notranslate"><span class="pre">__nv_atomic_and</span></code> does not have return value.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 4 or 8 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
</section>
<section id="other-atomic-functions">
<h3><span class="section-number">7.14.3. </span>Other atomic functions<a class="headerlink" href="#other-atomic-functions" title="Permalink to this headline">ï</a></h3>
<section id="nv-atomic-load">
<h4><span class="section-number">7.14.3.1. </span>__nv_atomic_load()<a class="headerlink" href="#nv-atomic-load" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_load</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It loads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and writes the value to where <code class="docutils literal notranslate"><span class="pre">ret</span></code> points to.</p>
<p>This is a generic atomic load, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any data type that is size of 1, 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables. <code class="docutils literal notranslate"><span class="pre">order</span></code> cannot be <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_RELEASE</span></code> or <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQ_REL</span></code>.</p>
</section>
<section id="nv-atomic-load-n">
<h4><span class="section-number">7.14.3.2. </span>__nv_atomic_load_n()<a class="headerlink" href="#nv-atomic-load-n" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__nv_atomic_load_n</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It loads the value where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to and returns this value.</p>
<p>This is a non-generic atomic load, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables. <code class="docutils literal notranslate"><span class="pre">order</span></code> cannot be <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_RELEASE</span></code> or <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQ_REL</span></code>.</p>
</section>
<section id="nv-atomic-store">
<h4><span class="section-number">7.14.3.3. </span>__nv_atomic_store()<a class="headerlink" href="#nv-atomic-store" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_store</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It reads the value where <code class="docutils literal notranslate"><span class="pre">val</span></code> points to and stores to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to.</p>
<p>This is a generic atomic load, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any data type that is size of 1, 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables. <code class="docutils literal notranslate"><span class="pre">order</span></code> cannot be <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQUIRE</span></code> or <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQ_REL</span></code>.</p>
</section>
<section id="nv-atomic-store-n">
<h4><span class="section-number">7.14.3.4. </span>__nv_atomic_store_n()<a class="headerlink" href="#nv-atomic-store-n" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_store_n</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function is introduced in CUDA 12.8. It stores <code class="docutils literal notranslate"><span class="pre">val</span></code> to where <code class="docutils literal notranslate"><span class="pre">ptr</span></code> points to.</p>
<p>This is a non-generic atomic load, which means that <code class="docutils literal notranslate"><span class="pre">T</span></code> can only be an integral type that is size of 1, 2, 4, 8 or 16 bytes.</p>
<p>The atomic operation with memory order and thread scope is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_60</span></code> and higher.</p>
<p>16-byte data type is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_70</span></code> and higher.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables. <code class="docutils literal notranslate"><span class="pre">order</span></code> cannot be <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_CONSUME</span></code>, <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQUIRE</span></code> or <code class="docutils literal notranslate"><span class="pre">__NV_ATOMIC_ACQ_REL</span></code>.</p>
</section>
<section id="nv-atomic-thread-fence">
<h4><span class="section-number">7.14.3.5. </span>__nv_atomic_thread_fence()<a class="headerlink" href="#nv-atomic-thread-fence" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__nv_atomic_thread_fence</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__NV_THREAD_SCOPE_SYSTEM</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This atomic function establishes an ordering between memory accesses requested by this thread based on the specified memory order. And the thread scope parameter specifies the set of threads that may observe the ordering effect of this operation.</p>
<p>The thread scope of <code class="docutils literal notranslate"><span class="pre">cluster</span></code> is supported on the architecture <code class="docutils literal notranslate"><span class="pre">sm_90</span></code> and higher.</p>
<p>The arguments <code class="docutils literal notranslate"><span class="pre">order</span></code> and <code class="docutils literal notranslate"><span class="pre">scope</span></code> need to be integer literals, i.e., the arguments cannot be variables.</p>
</section>
</section>
</section>
<section id="address-space-predicate-functions">
<h2><span class="section-number">7.15. </span>Address Space Predicate Functions<a class="headerlink" href="#address-space-predicate-functions" title="Permalink to this headline">ï</a></h2>
<p>The functions described in this section have unspecified behavior if the argument is a null pointer.</p>
<section id="isglobal">
<h3><span class="section-number">7.15.1. </span>__isGlobal()<a class="headerlink" href="#isglobal" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__isGlobal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">ptr</span></code> contains the generic address of an object in global memory space, otherwise returns 0.</p>
</section>
<section id="isshared">
<h3><span class="section-number">7.15.2. </span>__isShared()<a class="headerlink" href="#isshared" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__isShared</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">ptr</span></code> contains the generic address of an object in shared memory space, otherwise returns 0.</p>
</section>
<section id="isconstant">
<h3><span class="section-number">7.15.3. </span>__isConstant()<a class="headerlink" href="#isconstant" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__isConstant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">ptr</span></code> contains the generic address of an object in constant memory space, otherwise returns 0.</p>
</section>
<section id="isgridconstant">
<h3><span class="section-number">7.15.4. </span>__isGridConstant()<a class="headerlink" href="#isgridconstant" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__isGridConstant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">ptr</span></code> contains the generic address of a kernel parameter annotated with <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code>, otherwise returns 0. Only supported for compute architectures greater than or equal to 7.x or later.</p>
</section>
<section id="islocal">
<h3><span class="section-number">7.15.5. </span>__isLocal()<a class="headerlink" href="#islocal" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__isLocal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">ptr</span></code> contains the generic address of an object in local memory space, otherwise returns 0.</p>
</section>
</section>
<section id="address-space-conversion-functions">
<h2><span class="section-number">7.16. </span>Address Space Conversion Functions<a class="headerlink" href="#address-space-conversion-functions" title="Permalink to this headline">ï</a></h2>
<section id="cvta-generic-to-global">
<h3><span class="section-number">7.16.1. </span>__cvta_generic_to_global()<a class="headerlink" href="#cvta-generic-to-global" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">__cvta_generic_to_global</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the result of executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.to.global</span></code> instruction on the generic address denoted by <code class="docutils literal notranslate"><span class="pre">ptr</span></code>.</p>
</section>
<section id="cvta-generic-to-shared">
<h3><span class="section-number">7.16.2. </span>__cvta_generic_to_shared()<a class="headerlink" href="#cvta-generic-to-shared" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">__cvta_generic_to_shared</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the result of executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.to.shared</span></code> instruction on the generic address denoted by <code class="docutils literal notranslate"><span class="pre">ptr</span></code>.</p>
</section>
<section id="cvta-generic-to-constant">
<h3><span class="section-number">7.16.3. </span>__cvta_generic_to_constant()<a class="headerlink" href="#cvta-generic-to-constant" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">__cvta_generic_to_constant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the result of executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.to.const</span></code> instruction on the generic address denoted by <code class="docutils literal notranslate"><span class="pre">ptr</span></code>.</p>
</section>
<section id="cvta-generic-to-local">
<h3><span class="section-number">7.16.4. </span>__cvta_generic_to_local()<a class="headerlink" href="#cvta-generic-to-local" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">__cvta_generic_to_local</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the result of executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.to.local</span></code> instruction on the generic address denoted by <code class="docutils literal notranslate"><span class="pre">ptr</span></code>.</p>
</section>
<section id="cvta-global-to-generic">
<h3><span class="section-number">7.16.5. </span>__cvta_global_to_generic()<a class="headerlink" href="#cvta-global-to-generic" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__cvta_global_to_generic</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rawbits</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the generic pointer obtained by executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.global</span></code> instruction on the value provided by <code class="docutils literal notranslate"><span class="pre">rawbits</span></code>.</p>
</section>
<section id="cvta-shared-to-generic">
<h3><span class="section-number">7.16.6. </span>__cvta_shared_to_generic()<a class="headerlink" href="#cvta-shared-to-generic" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__cvta_shared_to_generic</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rawbits</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the generic pointer obtained by executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.shared</span></code> instruction on the value provided by <code class="docutils literal notranslate"><span class="pre">rawbits</span></code>.</p>
</section>
<section id="cvta-constant-to-generic">
<h3><span class="section-number">7.16.7. </span>__cvta_constant_to_generic()<a class="headerlink" href="#cvta-constant-to-generic" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__cvta_constant_to_generic</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rawbits</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the generic pointer obtained by executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.const</span></code> instruction on the value provided by <code class="docutils literal notranslate"><span class="pre">rawbits</span></code>.</p>
</section>
<section id="cvta-local-to-generic">
<h3><span class="section-number">7.16.8. </span>__cvta_local_to_generic()<a class="headerlink" href="#cvta-local-to-generic" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__cvta_local_to_generic</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rawbits</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Returns the generic pointer obtained by executing the <em>PTX</em><code class="docutils literal notranslate"><span class="pre">cvta.local</span></code> instruction on the value provided by <code class="docutils literal notranslate"><span class="pre">rawbits</span></code>.</p>
</section>
</section>
<section id="alloca-function">
<h2><span class="section-number">7.17. </span>Alloca Function<a class="headerlink" href="#alloca-function" title="Permalink to this headline">ï</a></h2>
<section id="synopsis">
<span id="alloca-synopsis"></span><h3><span class="section-number">7.17.1. </span>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">alloca</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="description">
<span id="alloca-description"></span><h3><span class="section-number">7.17.2. </span>Description<a class="headerlink" href="#description" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> function allocates <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of memory in the stack frame of the caller. The returned value is a pointer to allocated memory, the beginning of the memory is 16 bytes aligned when the function is invoked from device code. The allocated memory is automatically freed when the caller to <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> is returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows platform, <code class="docutils literal notranslate"><span class="pre">&lt;malloc.h&gt;</span></code> must be included before using <code class="docutils literal notranslate"><span class="pre">alloca()</span></code>. Using <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> may cause the stack to overflow, user needs to adjust stack size accordingly.</p>
</div>
<p>It is supported with compute capability 5.2 or higher.</p>
</section>
<section id="example">
<span id="alloca-example"></span><h3><span class="section-number">7.17.3. </span>Example<a class="headerlink" href="#example" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">int4</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">int4</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">alloca</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">int4</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="c1">// use of ptr</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="compiler-optimization-hint-functions">
<h2><span class="section-number">7.18. </span>Compiler Optimization Hint Functions<a class="headerlink" href="#compiler-optimization-hint-functions" title="Permalink to this headline">ï</a></h2>
<p>The functions described in this section can be used to provide additional information to the compiler optimizer.</p>
<section id="builtin-assume-aligned">
<h3><span class="section-number">7.18.1. </span>__builtin_assume_aligned()<a class="headerlink" href="#builtin-assume-aligned" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__builtin_assume_aligned</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">align</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Allows the compiler to assume that the argument pointer is aligned to at least <code class="docutils literal notranslate"><span class="pre">align</span></code> bytes, and returns the argument pointer.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_assume_aligned</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiler can assume &#39;res&#39; is</span>
<span class="w">                                               </span><span class="c1">// at least 32-byte aligned</span>
</pre></div>
</div>
<p>Three parameter version:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__builtin_assume_aligned</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="o">&lt;</span><span class="n">integral</span><span class="w"> </span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Allows the compiler to assume that <code class="docutils literal notranslate"><span class="pre">(char</span> <span class="pre">*)exp</span> <span class="pre">-</span> <span class="pre">offset</span></code> is aligned to at least <code class="docutils literal notranslate"><span class="pre">align</span></code> bytes, and returns the argument pointer.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_assume_aligned</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="c1">// compiler can assume</span>
<span class="w">                                                  </span><span class="c1">// &#39;(char *)res - 8&#39; is</span>
<span class="w">                                                  </span><span class="c1">// at least 32-byte aligned.</span>
</pre></div>
</div>
</section>
<section id="builtin-assume">
<h3><span class="section-number">7.18.2. </span>__builtin_assume()<a class="headerlink" href="#builtin-assume" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">__builtin_assume</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Allows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__builtin_assume</span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="assume">
<h3><span class="section-number">7.18.3. </span>__assume()<a class="headerlink" href="#assume" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="kr">__assume</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">exp</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Allows the compiler to assume that the Boolean argument is true. If the argument is not true at run time, then the behavior is undefined. Note that if the argument has side effects, the behavior is unspecified.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kr">__assume</span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="builtin-expect">
<h3><span class="section-number">7.18.4. </span>__builtin_expect()<a class="headerlink" href="#builtin-expect" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">long</span><span class="w"> </span><span class="n">__builtin_expect</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="w"> </span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Indicates to the compiler that it is expected that <code class="docutils literal notranslate"><span class="pre">exp</span> <span class="pre">==</span> <span class="pre">c</span></code>, and returns the value of <code class="docutils literal notranslate"><span class="pre">exp</span></code>. Typically used to indicate branch prediction information to the compiler.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// indicate to the compiler that likely &quot;var == 0&quot;,</span>
<span class="c1">// so the body of the if-block is unlikely to be</span>
<span class="c1">// executed at run time.</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_expect</span><span class="w"> </span><span class="p">(</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">doit</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="builtin-unreachable">
<h3><span class="section-number">7.18.5. </span>__builtin_unreachable()<a class="headerlink" href="#builtin-unreachable" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">__builtin_unreachable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Indicates to the compiler that control flow never reaches the point where this function is being called from. The program has undefined behavior if the control flow does actually reach this point at run time.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// indicates to the compiler that the default case label is never reached.</span>
<span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">__builtin_unreachable</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="restrictions">
<span id="compiler-optimization-hint-functions-restrictions"></span><h3><span class="section-number">7.18.6. </span>Restrictions<a class="headerlink" href="#restrictions" title="Permalink to this headline">ï</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__assume()</span></code> is only supported when using <code class="docutils literal notranslate"><span class="pre">cl.exe</span></code> host compiler. The other functions are supported on all platforms, subject to the following restrictions:</p>
<ul class="simple">
<li><p>If the host compiler supports the function, the function can be invoked from anywhere in translation unit.</p></li>
<li><p>Otherwise, the function must be invoked from within the body of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>/ <code class="docutils literal notranslate"><span class="pre">__global__</span></code>function, or only when the <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro is defined<a class="footnote-reference brackets" href="#fn12" id="id171">12</a>.</p></li>
</ul>
</section>
</section>
<section id="warp-vote-functions">
<span id="id172"></span><h2><span class="section-number">7.19. </span>Warp Vote Functions<a class="headerlink" href="#warp-vote-functions" title="Permalink to this headline">ï</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__all_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__any_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__ballot_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__activemask</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>Deprecation notice: <code class="docutils literal notranslate"><span class="pre">__any</span></code>, <code class="docutils literal notranslate"><span class="pre">__all</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ballot</span></code> have been deprecated in CUDA 9.0 for all devices.</p>
<p>Removal notice: When targeting devices with compute capability 7.x or higher, <code class="docutils literal notranslate"><span class="pre">__any</span></code>, <code class="docutils literal notranslate"><span class="pre">__all</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ballot</span></code> are no longer available and their sync variants should be used instead.</p>
<p>The warp vote functions allow the threads of a given <a class="reference internal" href="#simt-architecture"><span class="std std-ref">warp</span></a> to perform a reduction-and-broadcast operation. These functions take as input an integer <code class="docutils literal notranslate"><span class="pre">predicate</span></code> from each thread in the warp and compare those values with zero. The results of the comparisons are combined (reduced) across the <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">active</span></a> threads of the warp in one of the following ways, broadcasting a single return value to each participating thread:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__all_sync(unsigned</span> <span class="pre">mask,</span> <span class="pre">predicate)</span></code>:</dt><dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">predicate</span></code> for all non-exited threads in <code class="docutils literal notranslate"><span class="pre">mask</span></code> and return non-zero if and only if <code class="docutils literal notranslate"><span class="pre">predicate</span></code> evaluates to non-zero for all of them.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__any_sync(unsigned</span> <span class="pre">mask,</span> <span class="pre">predicate)</span></code>:</dt><dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">predicate</span></code> for all non-exited threads in <code class="docutils literal notranslate"><span class="pre">mask</span></code> and return non-zero if and only if <code class="docutils literal notranslate"><span class="pre">predicate</span></code> evaluates to non-zero for any of them.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__ballot_sync(unsigned</span> <span class="pre">mask,</span> <span class="pre">predicate)</span></code>:</dt><dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">predicate</span></code> for all non-exited threads in <code class="docutils literal notranslate"><span class="pre">mask</span></code> and return an integer whose Nth bit is set if and only if <code class="docutils literal notranslate"><span class="pre">predicate</span></code> evaluates to non-zero for the Nth thread of the warp and the Nth thread is active.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__activemask()</span></code>:</dt><dd><p>Returns a 32-bit integer mask of all currently active threads in the calling warp. The Nth bit is set if the Nth lane in the warp is active when <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code> is called. <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">Inactive</span></a> threads are represented by 0 bits in the returned mask. Threads which have exited the program are always marked as inactive. Note that threads that are convergent at an <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code> call are not guaranteed to be convergent at subsequent instructions unless those instructions are synchronizing warp-builtin functions.</p>
</dd>
</dl>
<p>For <code class="docutils literal notranslate"><span class="pre">__all_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__any_sync</span></code>, and <code class="docutils literal notranslate"><span class="pre">__ballot_sync</span></code>, a mask must be passed that specifies the threads participating in the call. A bit, representing the threadâs lane ID, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.</p>
<p>These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.</p>
</section>
<section id="warp-match-functions">
<span id="id173"></span><h2><span class="section-number">7.20. </span>Warp Match Functions<a class="headerlink" href="#warp-match-functions" title="Permalink to this headline">ï</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">__match_any_sync</span></code> and <code class="docutils literal notranslate"><span class="pre">__match_all_sync</span></code> perform a broadcast-and-compare operation of a variable between threads within a <a class="reference internal" href="#simt-architecture"><span class="std std-ref">warp</span></a>.</p>
<p>Supported by devices of compute capability 7.x or higher.</p>
<section id="synopsis-match">
<span id="id174"></span><h3><span class="section-number">7.20.1. </span>Synopsis<a class="headerlink" href="#synopsis-match" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__match_any_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__match_all_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can be <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</section>
<section id="warp-description-match">
<span id="id175"></span><h3><span class="section-number">7.20.2. </span>Description<a class="headerlink" href="#warp-description-match" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__match_sync()</span></code> intrinsics permit a broadcast-and-compare of a value <code class="docutils literal notranslate"><span class="pre">value</span></code> across threads in a warp after synchronizing threads named in <code class="docutils literal notranslate"><span class="pre">mask</span></code>.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__match_any_sync</span></code></dt><dd><p>Returns mask of threads that have same value of <code class="docutils literal notranslate"><span class="pre">value</span></code> in <code class="docutils literal notranslate"><span class="pre">mask</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__match_all_sync</span></code></dt><dd><p>Returns <code class="docutils literal notranslate"><span class="pre">mask</span></code> if all threads in <code class="docutils literal notranslate"><span class="pre">mask</span></code> have the same value for <code class="docutils literal notranslate"><span class="pre">value</span></code>; otherwise 0 is returned. Predicate <code class="docutils literal notranslate"><span class="pre">pred</span></code> is set to true if all threads in <code class="docutils literal notranslate"><span class="pre">mask</span></code> have the same value of <code class="docutils literal notranslate"><span class="pre">value</span></code>; otherwise the predicate is set to false.</p>
</dd>
</dl>
<p>The new <code class="docutils literal notranslate"><span class="pre">*_sync</span></code> match intrinsics take in a mask indicating the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.</p>
<p>These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.</p>
</section>
</section>
<section id="warp-reduce-functions">
<h2><span class="section-number">7.21. </span>Warp Reduce Functions<a class="headerlink" href="#warp-reduce-functions" title="Permalink to this headline">ï</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">__reduce_sync(unsigned</span> <span class="pre">mask,</span> <span class="pre">T</span> <span class="pre">value)</span></code> intrinsics perform a reduction operation on the data provided in <code class="docutils literal notranslate"><span class="pre">value</span></code> after synchronizing threads named in <code class="docutils literal notranslate"><span class="pre">mask</span></code>. T can be unsigned or signed for {add, min, max} and unsigned only for {and, or, xor} operations.</p>
<p>Supported by devices of compute capability 8.x or higher.</p>
<section id="warp-reduce-synopsis">
<span id="id176"></span><h3><span class="section-number">7.21.1. </span>Synopsis<a class="headerlink" href="#warp-reduce-synopsis" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// add/min/max</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_add_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_min_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_max_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__reduce_add_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__reduce_min_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__reduce_max_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>

<span class="c1">// and/or/xor</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_and_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_or_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">__reduce_xor_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="warp-reduce-description">
<span id="id177"></span><h3><span class="section-number">7.21.2. </span>Description<a class="headerlink" href="#warp-reduce-description" title="Permalink to this headline">ï</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__reduce_add_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__reduce_min_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__reduce_max_sync</span></code></dt><dd><p>Returns the result of applying an arithmetic add, min, or max reduction operation on the values provided in <code class="docutils literal notranslate"><span class="pre">value</span></code> by each thread named in <code class="docutils literal notranslate"><span class="pre">mask</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__reduce_and_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__reduce_or_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__reduce_xor_sync</span></code></dt><dd><p>Returns the result of applying a logical AND, OR, or XOR reduction operation on the values provided in <code class="docutils literal notranslate"><span class="pre">value</span></code> by each thread named in <code class="docutils literal notranslate"><span class="pre">mask</span></code>.</p>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">mask</span></code> indicates the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.</p>
<p>These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.</p>
</section>
</section>
<section id="warp-shuffle-functions">
<span id="id178"></span><h2><span class="section-number">7.22. </span>Warp Shuffle Functions<a class="headerlink" href="#warp-shuffle-functions" title="Permalink to this headline">ï</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">__shfl_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_up_sync</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_down_sync</span></code>, and <code class="docutils literal notranslate"><span class="pre">__shfl_xor_sync</span></code> exchange a variable between threads within a <a class="reference internal" href="#simt-architecture"><span class="std std-ref">warp</span></a>.</p>
<p>Supported by devices of compute capability 5.0 or higher.</p>
<p>Deprecation Notice: <code class="docutils literal notranslate"><span class="pre">__shfl</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_up</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_down</span></code>, and <code class="docutils literal notranslate"><span class="pre">__shfl_xor</span></code> have been deprecated in CUDA 9.0 for all devices.</p>
<p>Removal Notice: When targeting devices with compute capability 7.x or higher, <code class="docutils literal notranslate"><span class="pre">__shfl</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_up</span></code>, <code class="docutils literal notranslate"><span class="pre">__shfl_down</span></code>, and <code class="docutils literal notranslate"><span class="pre">__shfl_xor</span></code> are no longer available and their sync variants should be used instead.</p>
<section id="warp-shuffle-synopsis">
<span id="id179"></span><h3><span class="section-number">7.22.1. </span>Synopsis<a class="headerlink" href="#warp-shuffle-synopsis" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="nf">__shfl_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">srcLane</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="n">warpSize</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__shfl_up_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="n">warpSize</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__shfl_down_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="n">warpSize</span><span class="p">);</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="nf">__shfl_xor_sync</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">laneMask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="n">warpSize</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">T</span></code> can be <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">double</span></code>. With the <code class="docutils literal notranslate"><span class="pre">cuda_fp16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be <code class="docutils literal notranslate"><span class="pre">__half</span></code> or <code class="docutils literal notranslate"><span class="pre">__half2</span></code>. Similarly, with the <code class="docutils literal notranslate"><span class="pre">cuda_bf16.h</span></code> header included, <code class="docutils literal notranslate"><span class="pre">T</span></code> can also be <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_bfloat162</span></code>.</p>
</section>
<section id="warp-shuffle-description">
<span id="id180"></span><h3><span class="section-number">7.22.2. </span>Description<a class="headerlink" href="#warp-shuffle-description" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code> intrinsics permit exchanging of a variable between threads within a warp without use of shared memory. The exchange occurs simultaneously for all <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">active</span></a> threads within the warp (and named in <code class="docutils literal notranslate"><span class="pre">mask</span></code>), moving 4 or 8 bytes of data per thread depending on the type.</p>
<p>Threads within a warp are referred to as <em>lanes</em>, and may have an index between 0 and <code class="docutils literal notranslate"><span class="pre">warpSize-1</span></code> (inclusive). Four source-lane addressing modes are supported:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code></dt><dd><p>Direct copy from indexed lane</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__shfl_up_sync()</span></code></dt><dd><p>Copy from a lane with lower ID relative to caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__shfl_down_sync()</span></code></dt><dd><p>Copy from a lane with higher ID relative to caller</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">__shfl_xor_sync()</span></code></dt><dd><p>Copy from a lane based on bitwise XOR of own lane ID</p>
</dd>
</dl>
<p>Threads may only read data from another thread which is actively participating in the <code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code> command. If the target thread is <a class="reference internal" href="#simt-architecture-notes"><span class="std std-ref">inactive</span></a>, the retrieved value is undefined.</p>
<p>All of the <code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code> intrinsics take an optional <code class="docutils literal notranslate"><span class="pre">width</span></code> parameter which alters the behavior of the intrinsic. <code class="docutils literal notranslate"><span class="pre">width</span></code> must have a value which is a power of two in the range [1, warpSize] (i.e., 1, 2, 4, 8, 16 or 32). Results are undefined for other values.</p>
<p><code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code> returns the value of <code class="docutils literal notranslate"><span class="pre">var</span></code> held by the thread whose ID is given by <code class="docutils literal notranslate"><span class="pre">srcLane</span></code>. If width is less than <code class="docutils literal notranslate"><span class="pre">warpSize</span></code> then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. If <code class="docutils literal notranslate"><span class="pre">srcLane</span></code> is outside the range <code class="docutils literal notranslate"><span class="pre">[0:width-1]</span></code>, the value returned corresponds to the value of var held by the <code class="docutils literal notranslate"><span class="pre">srcLane</span> <span class="pre">modulo</span> <span class="pre">width</span></code> (i.e. within the same subsection).</p>
<p><code class="docutils literal notranslate"><span class="pre">__shfl_up_sync()</span></code> calculates a source lane ID by subtracting <code class="docutils literal notranslate"><span class="pre">delta</span></code> from the callerâs lane ID. The value of <code class="docutils literal notranslate"><span class="pre">var</span></code> held by the resulting lane ID is returned: in effect, <code class="docutils literal notranslate"><span class="pre">var</span></code> is shifted up the warp by <code class="docutils literal notranslate"><span class="pre">delta</span></code> lanes. If width is less than <code class="docutils literal notranslate"><span class="pre">warpSize</span></code> then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. The source lane index will not wrap around the value of <code class="docutils literal notranslate"><span class="pre">width</span></code>, so effectively the lower <code class="docutils literal notranslate"><span class="pre">delta</span></code> lanes will be unchanged.</p>
<p><code class="docutils literal notranslate"><span class="pre">__shfl_down_sync()</span></code> calculates a source lane ID by adding <code class="docutils literal notranslate"><span class="pre">delta</span></code> to the callerâs lane ID. The value of <code class="docutils literal notranslate"><span class="pre">var</span></code> held by the resulting lane ID is returned: this has the effect of shifting <code class="docutils literal notranslate"><span class="pre">var</span></code> down the warp by <code class="docutils literal notranslate"><span class="pre">delta</span></code> lanes. If width is less than <code class="docutils literal notranslate"><span class="pre">warpSize</span></code> then each subsection of the warp behaves as a separate entity with a starting logical lane ID of 0. As for <code class="docutils literal notranslate"><span class="pre">__shfl_up_sync()</span></code>, the ID number of the source lane will not wrap around the value of width and so the upper <code class="docutils literal notranslate"><span class="pre">delta</span></code> lanes will remain unchanged.</p>
<p><code class="docutils literal notranslate"><span class="pre">__shfl_xor_sync()</span></code> calculates a source line ID by performing a bitwise XOR of the callerâs lane ID with <code class="docutils literal notranslate"><span class="pre">laneMask</span></code>: the value of <code class="docutils literal notranslate"><span class="pre">var</span></code> held by the resulting lane ID is returned. If <code class="docutils literal notranslate"><span class="pre">width</span></code> is less than <code class="docutils literal notranslate"><span class="pre">warpSize</span></code> then each group of <code class="docutils literal notranslate"><span class="pre">width</span></code> consecutive threads are able to access elements from earlier groups of threads, however if they attempt to access elements from later groups of threads their own value of <code class="docutils literal notranslate"><span class="pre">var</span></code> will be returned. This mode implements a butterfly addressing pattern such as is used in tree reduction and broadcast.</p>
<p>The new <code class="docutils literal notranslate"><span class="pre">*_sync</span></code> shfl intrinsics take in a mask indicating the threads participating in the call. A bit, representing the threadâs lane id, must be set for each participating thread to ensure they are properly converged before the intrinsic is executed by the hardware. Each calling thread must have its own bit set in the mask and all non-exited threads named in mask must execute the same intrinsic with the same mask, or the result is undefined.</p>
<p>Threads may only read data from another thread which is actively participating in the <code class="docutils literal notranslate"><span class="pre">__shfl_sync()</span></code> command. If the target thread is inactive, the retrieved value is undefined.</p>
<p>These intrinsics do not imply a memory barrier. They do not guarantee any memory ordering.</p>
</section>
<section id="examples">
<span id="warp-examples"></span><h3><span class="section-number">7.22.3. </span>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">ï</a></h3>
<section id="broadcast-of-a-single-value-across-a-warp">
<span id="warp-examples-broadcast"></span><h4><span class="section-number">7.22.3.1. </span>Broadcast of a single value across a warp<a class="headerlink" href="#broadcast-of-a-single-value-across-a-warp" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bcast</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">laneId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">laneId</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">        </span><span class="c1">// Note unused variable for</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="p">;</span><span class="w">        </span><span class="c1">// all threads except lane 0</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">   </span><span class="c1">// Synchronize all threads in warp, and get &quot;value&quot; from lane 0</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">bcast</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inclusive-plus-scan-across-sub-partitions-of-8-threads">
<span id="warp-examples-inclusive"></span><h4><span class="section-number">7.22.3.2. </span>Inclusive plus-scan across sub-partitions of 8 threads<a class="headerlink" href="#inclusive-plus-scan-across-sub-partitions-of-8-threads" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">scan4</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">laneId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Seed sample starting value (inverse of lane ID)</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">laneId</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Loop to accumulate scan within my partition.</span>
<span class="w">    </span><span class="c1">// Scan requires log2(n) == 3 steps for 8 threads</span>
<span class="w">    </span><span class="c1">// It works by an accumulated sum up the warp</span>
<span class="w">    </span><span class="c1">// by 1, 2, 4, 8 etc. steps.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// We do the __shfl_sync unconditionally so that we</span>
<span class="w">        </span><span class="c1">// can read even from threads which won&#39;t do a</span>
<span class="w">        </span><span class="c1">// sum, and then conditionally assign the result.</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_up_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">laneId</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d final value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">scan4</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="reduction-across-a-warp">
<span id="warp-examples-reduction"></span><h4><span class="section-number">7.22.3.3. </span>Reduction across a warp<a class="headerlink" href="#reduction-across-a-warp" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">warpReduce</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">laneId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Seed starting value as inverse lane ID</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">31</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">laneId</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use XOR mode to perform butterfly reduction</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">/=</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">__shfl_xor_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// &quot;value&quot; now contains the sum across all threads</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d final value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">warpReduce</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="nanosleep-function">
<h2><span class="section-number">7.23. </span>Nanosleep Function<a class="headerlink" href="#nanosleep-function" title="Permalink to this headline">ï</a></h2>
<section id="nanosleep-synopsis">
<span id="id181"></span><h3><span class="section-number">7.23.1. </span>Synopsis<a class="headerlink" href="#nanosleep-synopsis" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__nanosleep</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="nanosleep-description">
<span id="id182"></span><h3><span class="section-number">7.23.2. </span>Description<a class="headerlink" href="#nanosleep-description" title="Permalink to this headline">ï</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">__nanosleep(ns)</span></code> suspends the thread for a sleep duration of approximately <code class="docutils literal notranslate"><span class="pre">ns</span></code> nanoseconds.  The maximum sleep duration is approximately 1 millisecond.</p>
<p>It is supported with compute capability 7.0 or higher.</p>
</section>
<section id="nanosleep-example">
<span id="id183"></span><h3><span class="section-number">7.23.3. </span>Example<a class="headerlink" href="#nanosleep-example" title="Permalink to this headline">ï</a></h3>
<p>The following code implements a mutex with exponential back-off.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">mutex_lock</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">mutex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">__nanosleep</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ns</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">256</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">ns</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">mutex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">atomicExch</span><span class="p">(</span><span class="n">mutex</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="warp-matrix-functions">
<span id="wmma"></span><h2><span class="section-number">7.24. </span>Warp Matrix Functions<a class="headerlink" href="#warp-matrix-functions" title="Permalink to this headline">ï</a></h2>
<p>C++ warp matrix operations leverage Tensor Cores to accelerate matrix problems of the form <code class="docutils literal notranslate"><span class="pre">D=A*B+C</span></code>. These operations are supported on mixed-precision floating point data for devices of compute capability 7.0 or higher. This requires co-operation from all threads in a <a class="reference internal" href="#simt-architecture"><span class="std std-ref">warp</span></a>. In addition, these operations are allowed in conditional code only if the condition evaluates identically across the entire <a class="reference internal" href="#simt-architecture"><span class="std std-ref">warp</span></a>, otherwise the code execution is likely to hang.</p>
<section id="wmma-description">
<span id="id184"></span><h3><span class="section-number">7.24.1. </span>Description<a class="headerlink" href="#wmma-description" title="Permalink to this headline">ï</a></h3>
<p>All following functions and types are defined in the namespace <code class="docutils literal notranslate"><span class="pre">nvcuda::wmma</span></code>. Sub-byte operations are considered preview, i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This extra functionality is defined in the <code class="docutils literal notranslate"><span class="pre">nvcuda::wmma::experimental</span></code> namespace.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Use</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Layout</span><span class="o">=</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">fragment</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">load_matrix_sync</span><span class="p">(</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mptr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ldm</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">load_matrix_sync</span><span class="p">(</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mptr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ldm</span><span class="p">,</span><span class="w"> </span><span class="n">layout_t</span><span class="w"> </span><span class="n">layout</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">store_matrix_sync</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">mptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">ldm</span><span class="p">,</span><span class="w"> </span><span class="n">layout_t</span><span class="w"> </span><span class="n">layout</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">fill_fragment</span><span class="p">(</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">mma_sync</span><span class="p">(</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">satf</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fragment</span></code></dt><dd><p>An overloaded class containing a section of a matrix distributed across all threads in the warp. The mapping of matrix elements into <code class="docutils literal notranslate"><span class="pre">fragment</span></code> internal storage is unspecified and subject to change in future architectures.</p>
</dd>
</dl>
<p>Only certain combinations of template arguments are allowed. The first template parameter specifies how the fragment will participate in the matrix operation. Acceptable values for <code class="docutils literal notranslate"><span class="pre">Use</span></code> are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> when the fragment is used as the first multiplicand, <code class="docutils literal notranslate"><span class="pre">A</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matrix_b</span></code> when the fragment is used as the second multiplicand, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">accumulator</span></code> when the fragment is used as the source or destination accumulators (<code class="docutils literal notranslate"><span class="pre">C</span></code> or <code class="docutils literal notranslate"><span class="pre">D</span></code>, respectively).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> sizes describe the shape of the warp-wide matrix tiles participating in the multiply-accumulate operation. The dimension of each tile depends on its role. For <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> the tile takes dimension <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">k</span></code>; for <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code> the dimension is <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">x</span> <span class="pre">n</span></code>, and <code class="docutils literal notranslate"><span class="pre">accumulator</span></code> tiles are <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code>.</p>
<p>The data type, <code class="docutils literal notranslate"><span class="pre">T</span></code>, may be <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">__half</span></code>, <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">char</span></code>, or <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code> for multiplicands and <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">__half</span></code> for accumulators. As documented in <a class="reference internal" href="#wmma-type-sizes"><span class="std std-ref">Element Types and Matrix Sizes</span></a>, limited combinations of accumulator and multiplicand types are supported. The Layout parameter must be specified for <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> and <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code> fragments. <code class="docutils literal notranslate"><span class="pre">row_major</span></code> or <code class="docutils literal notranslate"><span class="pre">col_major</span></code> indicate that elements within a matrix row or column are contiguous in memory, respectively. The <code class="docutils literal notranslate"><span class="pre">Layout</span></code> parameter for an <code class="docutils literal notranslate"><span class="pre">accumulator</span></code> matrix should retain the default value of <code class="docutils literal notranslate"><span class="pre">void</span></code>. A row or column layout is specified only when the accumulator is loaded or stored as described below.</p>
</li>
</ul>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">load_matrix_sync</span></code></dt><dd><p>Waits until all warp lanes have arrived at load_matrix_sync and then loads the matrix fragment a from memory. <code class="docutils literal notranslate"><span class="pre">mptr</span></code> must be a 256-bit aligned pointer pointing to the first element of the matrix in memory. <code class="docutils literal notranslate"><span class="pre">ldm</span></code> describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for <code class="docutils literal notranslate"><span class="pre">__half</span></code> element type or multiple of 4 for <code class="docutils literal notranslate"><span class="pre">float</span></code> element type. (i.e., multiple of 16 bytes in both cases). If the fragment is an <code class="docutils literal notranslate"><span class="pre">accumulator</span></code>, the <code class="docutils literal notranslate"><span class="pre">layout</span></code> argument must be specified as either <code class="docutils literal notranslate"><span class="pre">mem_row_major</span></code> or <code class="docutils literal notranslate"><span class="pre">mem_col_major</span></code>. For <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> and <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code> fragments, the layout is inferred from the fragmentâs <code class="docutils literal notranslate"><span class="pre">layout</span></code> parameter. The values of <code class="docutils literal notranslate"><span class="pre">mptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ldm</span></code>, <code class="docutils literal notranslate"><span class="pre">layout</span></code> and all template parameters for <code class="docutils literal notranslate"><span class="pre">a</span></code> must be the same for all threads in the warp. This function must be called by all threads in the warp, or the result is undefined.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">store_matrix_sync</span></code></dt><dd><p>Waits until all warp lanes have arrived at store_matrix_sync and then stores the matrix fragment a to memory. <code class="docutils literal notranslate"><span class="pre">mptr</span></code> must be a 256-bit aligned pointer pointing to the first element of the matrix in memory. <code class="docutils literal notranslate"><span class="pre">ldm</span></code> describes the stride in elements between consecutive rows (for row major layout) or columns (for column major layout) and must be a multiple of 8 for <code class="docutils literal notranslate"><span class="pre">__half</span></code> element type or multiple of 4 for <code class="docutils literal notranslate"><span class="pre">float</span></code> element type. (i.e., multiple of 16 bytes in both cases). The layout of the output matrix must be specified as either <code class="docutils literal notranslate"><span class="pre">mem_row_major</span></code> or <code class="docutils literal notranslate"><span class="pre">mem_col_major</span></code>. The values of <code class="docutils literal notranslate"><span class="pre">mptr</span></code>, <code class="docutils literal notranslate"><span class="pre">ldm</span></code>, <code class="docutils literal notranslate"><span class="pre">layout</span></code> and all template parameters for a must be the same for all threads in the warp.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fill_fragment</span></code></dt><dd><p>Fill a matrix fragment with a constant value <code class="docutils literal notranslate"><span class="pre">v</span></code>. Because the mapping of matrix elements to each fragment is unspecified, this function is ordinarily called by all threads in the warp with a common value for <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">mma_sync</span></code></dt><dd><p>Waits until all warp lanes have arrived at mma_sync, and then performs the warp-synchronous matrix multiply-accumulate operation <code class="docutils literal notranslate"><span class="pre">D=A*B+C</span></code>. The in-place operation, <code class="docutils literal notranslate"><span class="pre">C=A*B+C</span></code>, is also supported. The value of <code class="docutils literal notranslate"><span class="pre">satf</span></code> and template parameters for each matrix fragment must be the same for all threads in the warp. Also, the template parameters <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> must match between fragments <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">D</span></code>. This function must be called by all threads in the warp, or the result is undefined.</p>
</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">satf</span></code> (saturate to finite value) mode is <code class="docutils literal notranslate"><span class="pre">true</span></code>, the following additional numerical properties apply for the destination accumulator:</p>
<ul class="simple">
<li><p>If an element result is +Infinity, the corresponding accumulator will contain <code class="docutils literal notranslate"><span class="pre">+MAX_NORM</span></code></p></li>
<li><p>If an element result is -Infinity, the corresponding accumulator will contain <code class="docutils literal notranslate"><span class="pre">-MAX_NORM</span></code></p></li>
<li><p>If an element result is NaN, the corresponding accumulator will contain <code class="docutils literal notranslate"><span class="pre">+0</span></code></p></li>
</ul>
<p>Because the map of matrix elements into each threadâs <code class="docutils literal notranslate"><span class="pre">fragment</span></code> is unspecified, individual matrix elements must be accessed from memory (shared or global) after calling <code class="docutils literal notranslate"><span class="pre">store_matrix_sync</span></code>. In the special case where all threads in the warp will apply an element-wise operation uniformly to all fragment elements, direct element access can be implemented using the following <code class="docutils literal notranslate"><span class="pre">fragment</span></code> class members.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="nc">fragment</span><span class="o">&lt;</span><span class="n">Use</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">&gt;::</span><span class="n">num_elements</span><span class="p">;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">fragment</span><span class="o">&lt;</span><span class="n">Use</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">&gt;::</span><span class="n">x</span><span class="p">[</span><span class="n">num_elements</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>As an example, the following code scales an <code class="docutils literal notranslate"><span class="pre">accumulator</span></code> matrix tile by half.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="n">wmma</span><span class="o">::</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">frag</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span><span class="w"> </span><span class="c1">// Same value for all threads in warp</span>
<span class="cm">/*...*/</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="o">&lt;</span><span class="n">frag</span><span class="p">.</span><span class="n">num_elements</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="n">frag</span><span class="p">.</span><span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="alternate-floating-point">
<span id="wmma-altfp"></span><h3><span class="section-number">7.24.2. </span>Alternate Floating Point<a class="headerlink" href="#alternate-floating-point" title="Permalink to this headline">ï</a></h3>
<p>Tensor Cores support alternate types of floating point operations on devices with compute capability 8.0 and higher.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code></dt><dd><p>This data format is an alternate fp16 format that has the same range as f32 but reduced precision (7 bits). You can use this data format directly with the <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> type available in <code class="docutils literal notranslate"><span class="pre">cuda_bf16.h</span></code>. Matrix fragments with <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code> data types are required to be composed with accumulators of <code class="docutils literal notranslate"><span class="pre">float</span></code> type. The shapes and operations supported are the same as with <code class="docutils literal notranslate"><span class="pre">__half</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">tf32</span></code></dt><dd><p>This data format is a special floating point format supported by Tensor Cores, with the same range as f32 and reduced precision (&gt;=10 bits). The internal layout of this format is implementation defined. In order to use this floating point format with WMMA operations, the input matrices must be manually converted to tf32 precision.</p>
<p>To facilitate conversion, a new intrinsic <code class="docutils literal notranslate"><span class="pre">__float_to_tf32</span></code> is provided. While the input and output arguments to the intrinsic are of <code class="docutils literal notranslate"><span class="pre">float</span></code> type, the output will be <code class="docutils literal notranslate"><span class="pre">tf32</span></code> numerically. This new precision is intended to be used with Tensor Cores only, and if mixed with other <code class="docutils literal notranslate"><span class="pre">float</span></code>type operations, the precision and range of the result will be undefined.</p>
<p>Once an input matrix (<code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> or <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code>) is converted to tf32 precision, the combination of a <code class="docutils literal notranslate"><span class="pre">fragment</span></code> with <code class="docutils literal notranslate"><span class="pre">precision::tf32</span></code> precision, and a data type of <code class="docutils literal notranslate"><span class="pre">float</span></code> to <code class="docutils literal notranslate"><span class="pre">load_matrix_sync</span></code> will take advantage of this new capability. Both the accumulator fragments must have <code class="docutils literal notranslate"><span class="pre">float</span></code> data types. The only supported matrix size is 16x16x8 (m-n-k).</p>
<p>The elements of the fragment are represented as <code class="docutils literal notranslate"><span class="pre">float</span></code>, hence the mapping from <code class="docutils literal notranslate"><span class="pre">element_type&lt;T&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">storage_element_type&lt;T&gt;</span></code> is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">precision</span><span class="o">::</span><span class="n">tf32</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">float</span><span class="w"></span>
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="double-precision">
<span id="wmma-double"></span><h3><span class="section-number">7.24.3. </span>Double Precision<a class="headerlink" href="#double-precision" title="Permalink to this headline">ï</a></h3>
<p>Tensor Cores support double-precision floating point operations on devices with compute capability 8.0 and higher. To use this new functionality, a <code class="docutils literal notranslate"><span class="pre">fragment</span></code> with the <code class="docutils literal notranslate"><span class="pre">double</span></code> type must be used. The <code class="docutils literal notranslate"><span class="pre">mma_sync</span></code> operation will be performed with the .rn (rounds to nearest even) rounding modifier.</p>
</section>
<section id="sub-byte-operations">
<span id="wmma-subbyte"></span><h3><span class="section-number">7.24.4. </span>Sub-byte Operations<a class="headerlink" href="#sub-byte-operations" title="Permalink to this headline">ï</a></h3>
<p>Sub-byte WMMA operations provide a way to access the low-precision capabilities of Tensor Cores. They are considered a preview feature i.e. the data structures and APIs for them are subject to change and may not be compatible with future releases. This functionality is available via the <code class="docutils literal notranslate"><span class="pre">nvcuda::wmma::experimental</span></code> namespace:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">precision</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">u4</span><span class="p">;</span><span class="w"> </span><span class="c1">// 4-bit unsigned</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">s4</span><span class="p">;</span><span class="w"> </span><span class="c1">// 4-bit signed</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">b1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1-bit</span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">bmmaBitOp</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">bmmaBitOpXOR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="c1">// compute_75 minimum</span>
<span class="w">        </span><span class="n">bmmaBitOpAND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="c1">// compute_80 minimum</span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">bmmaAccumulateOp</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">bmmaAccumulateOpPOPC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>For 4 bit precision, the APIs available remain the same, but you must specify <code class="docutils literal notranslate"><span class="pre">experimental::precision::u4</span></code> or <code class="docutils literal notranslate"><span class="pre">experimental::precision::s4</span></code> as the fragment data type. Since the elements of the fragment are packed together, <code class="docutils literal notranslate"><span class="pre">num_storage_elements</span></code> will be smaller than <code class="docutils literal notranslate"><span class="pre">num_elements</span></code> for that fragment. The <code class="docutils literal notranslate"><span class="pre">num_elements</span></code> variable for a sub-byte fragment, hence returns the number of elements of sub-byte type <code class="docutils literal notranslate"><span class="pre">element_type&lt;T&gt;</span></code>. This is true for single bit precision as well, in which case, the mapping from <code class="docutils literal notranslate"><span class="pre">element_type&lt;T&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">storage_element_type&lt;T&gt;</span></code> is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">experimental</span><span class="o">::</span><span class="n">precision</span><span class="o">::</span><span class="n">u4</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"></span>
<span class="n">experimental</span><span class="o">::</span><span class="n">precision</span><span class="o">::</span><span class="n">s4</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"></span>
<span class="n">experimental</span><span class="o">::</span><span class="n">precision</span><span class="o">::</span><span class="n">b1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="mi">32</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="c1">//all other types</span>
</pre></div>
</div>
<p>The allowed layouts for sub-byte fragments is always <code class="docutils literal notranslate"><span class="pre">row_major</span></code> for <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> and <code class="docutils literal notranslate"><span class="pre">col_major</span></code> for <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code>.</p>
<p>For sub-byte operations the value of <code class="docutils literal notranslate"><span class="pre">ldm</span></code> in <code class="docutils literal notranslate"><span class="pre">load_matrix_sync</span></code> should be a multiple of 32 for element type <code class="docutils literal notranslate"><span class="pre">experimental::precision::u4</span></code> and <code class="docutils literal notranslate"><span class="pre">experimental::precision::s4</span></code> or a multiple of 128 for element type <code class="docutils literal notranslate"><span class="pre">experimental::precision::b1</span></code> (i.e., multiple of 16 bytes in both cases).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Support for the following variants for MMA instructions is deprecated and will be removed in sm_90:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">experimental::precision::u4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">experimental::precision::s4</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">experimental::precision::b1</span></code> with <code class="docutils literal notranslate"><span class="pre">bmmaBitOp</span></code> set to <code class="docutils literal notranslate"><span class="pre">bmmaBitOpXOR</span></code></p></li>
</ul>
</div></blockquote>
</div>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">bmma_sync</span></code></dt><dd><p>Waits until all warp lanes have executed bmma_sync, and then performs the warp-synchronous bit matrix multiply-accumulate operation <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">=</span> <span class="pre">(A</span> <span class="pre">op</span> <span class="pre">B)</span> <span class="pre">+</span> <span class="pre">C</span></code>, where <code class="docutils literal notranslate"><span class="pre">op</span></code> consists of a logical operation <code class="docutils literal notranslate"><span class="pre">bmmaBitOp</span></code> followed by the accumulation defined by <code class="docutils literal notranslate"><span class="pre">bmmaAccumulateOp</span></code>. The available operations are:</p>
<p><code class="docutils literal notranslate"><span class="pre">bmmaBitOpXOR</span></code>, a 128-bit XOR of a row in <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> with the 128-bit column of <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">bmmaBitOpAND</span></code>, a 128-bit AND of a row in <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code> with the 128-bit column of <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code>, available on devices with compute capability 8.0 and higher.</p>
<p>The accumulate op is always <code class="docutils literal notranslate"><span class="pre">bmmaAccumulateOpPOPC</span></code> which counts the number of set bits.</p>
</dd>
</dl>
</section>
<section id="wmma-restrictions">
<span id="id185"></span><h3><span class="section-number">7.24.5. </span>Restrictions<a class="headerlink" href="#wmma-restrictions" title="Permalink to this headline">ï</a></h3>
<p>The special format required by tensor cores may be different for each major and minor device architecture. This is further complicated by threads holding only a fragment (opaque architecture-specific ABI data structure) of the overall matrix, with the developer not allowed to make assumptions on how the individual parameters are mapped to the registers participating in the matrix multiply-accumulate.</p>
<p>Since fragments are architecture-specific, it is unsafe to pass them from function A to function B if the functions have been compiled for different link-compatible architectures and linked together into the same device executable. In this case, the size and layout of the fragment will be specific to one architecture and using WMMA APIs in the other will lead to incorrect results or potentially, corruption.</p>
<p>An example of two link-compatible architectures, where the layout of the fragment differs, is sm_70 and sm_75.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">fragA</span><span class="p">.</span><span class="n">cu</span><span class="o">:</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mat_a</span><span class="p">;</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mat_a</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">fragB</span><span class="p">.</span><span class="n">cu</span><span class="o">:</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">mat_a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// operate on mat_a }</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// sm_70 fragment layout</span>
<span class="n">$</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nvcc</span><span class="w"> </span><span class="o">-</span><span class="n">dc</span><span class="w"> </span><span class="o">-</span><span class="n">arch</span><span class="o">=</span><span class="n">compute_70</span><span class="w"> </span><span class="o">-</span><span class="n">code</span><span class="o">=</span><span class="n">sm_70</span><span class="w"> </span><span class="n">fragA</span><span class="p">.</span><span class="n">cu</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">fragA</span><span class="p">.</span><span class="n">o</span><span class="w"></span>
<span class="c1">// sm_75 fragment layout</span>
<span class="n">$</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nvcc</span><span class="w"> </span><span class="o">-</span><span class="n">dc</span><span class="w"> </span><span class="o">-</span><span class="n">arch</span><span class="o">=</span><span class="n">compute_75</span><span class="w"> </span><span class="o">-</span><span class="n">code</span><span class="o">=</span><span class="n">sm_75</span><span class="w"> </span><span class="n">fragB</span><span class="p">.</span><span class="n">cu</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">fragB</span><span class="p">.</span><span class="n">o</span><span class="w"></span>
<span class="c1">// Linking the two together</span>
<span class="n">$</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nvcc</span><span class="w"> </span><span class="o">-</span><span class="n">dlink</span><span class="w"> </span><span class="o">-</span><span class="n">arch</span><span class="o">=</span><span class="n">sm_75</span><span class="w"> </span><span class="n">fragA</span><span class="p">.</span><span class="n">o</span><span class="w"> </span><span class="n">fragB</span><span class="p">.</span><span class="n">o</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">frag</span><span class="p">.</span><span class="n">o</span><span class="w"></span>
</pre></div>
</div>
<p>This undefined behavior might also be undetectable at compilation time and by tools at runtime, so extra care is needed to make sure the layout of the fragments is consistent. This linking hazard is most likely to appear when linking with a legacy library that is both built for a different link-compatible architecture and expecting to be passed a WMMA fragment.</p>
<p>Note that in the case of weak linkages (for example, a CUDA C++ inline function), the linker may choose any available function definition which may result in implicit passes between compilation units.</p>
<p>To avoid these sorts of problems, the matrix should always be stored out to memory for transit through external interfaces (e.g. <code class="docutils literal notranslate"><span class="pre">wmma::store_matrix_sync(dst,</span> <span class="pre">â¦);</span></code>) and then it can be safely passed to <code class="docutils literal notranslate"><span class="pre">bar()</span></code> as a pointer type [e.g. <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">*dst</span></code>].</p>
<p>Note that since sm_70 can run on sm_75, the above example sm_75 code can be changed to sm_70 and correctly work on sm_75. However, it is recommended to have sm_75 native code in your application when linking with other sm_75 separately compiled binaries.</p>
</section>
<section id="element-types-and-matrix-sizes">
<span id="wmma-type-sizes"></span><h3><span class="section-number">7.24.6. </span>Element Types and Matrix Sizes<a class="headerlink" href="#element-types-and-matrix-sizes" title="Permalink to this headline">ï</a></h3>
<p>Tensor Cores support a variety of element types and matrix sizes. The following table presents the various combinations of <code class="docutils literal notranslate"><span class="pre">matrix_a</span></code>, <code class="docutils literal notranslate"><span class="pre">matrix_b</span></code> and <code class="docutils literal notranslate"><span class="pre">accumulator</span></code> matrix supported:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Matrix A</p></th>
<th class="head"><p>Matrix B</p></th>
<th class="head"><p>Accumulator</p></th>
<th class="head"><p>Matrix Size (m-n-k)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>float</p></td>
<td><p>16x16x16</p></td>
</tr>
<tr class="row-odd"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>float</p></td>
<td><p>32x8x16</p></td>
</tr>
<tr class="row-even"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>float</p></td>
<td><p>8x32x16</p></td>
</tr>
<tr class="row-odd"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>16x16x16</p></td>
</tr>
<tr class="row-even"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>32x8x16</p></td>
</tr>
<tr class="row-odd"><td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>__half</p></td>
<td><p>8x32x16</p></td>
</tr>
<tr class="row-even"><td><p>unsigned char</p></td>
<td><p>unsigned char</p></td>
<td><p>int</p></td>
<td><p>16x16x16</p></td>
</tr>
<tr class="row-odd"><td><p>unsigned char</p></td>
<td><p>unsigned char</p></td>
<td><p>int</p></td>
<td><p>32x8x16</p></td>
</tr>
<tr class="row-even"><td><p>unsigned char</p></td>
<td><p>unsigned char</p></td>
<td><p>int</p></td>
<td><p>8x32x16</p></td>
</tr>
<tr class="row-odd"><td><p>signed char</p></td>
<td><p>signed char</p></td>
<td><p>int</p></td>
<td><p>16x16x16</p></td>
</tr>
<tr class="row-even"><td><p>signed char</p></td>
<td><p>signed char</p></td>
<td><p>int</p></td>
<td><p>32x8x16</p></td>
</tr>
<tr class="row-odd"><td><p>signed char</p></td>
<td><p>signed char</p></td>
<td><p>int</p></td>
<td><p>8x32x16</p></td>
</tr>
</tbody>
</table>
<p>Alternate Floating Point support:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 18%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Matrix A</p></th>
<th class="head"><p>Matrix B</p></th>
<th class="head"><p>Accumulator</p></th>
<th class="head"><p>Matrix Size (m-n-k)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>__nv_bfloat16</p></td>
<td><p>__nv_bfloat16</p></td>
<td><p>float</p></td>
<td><p>16x16x16</p></td>
</tr>
<tr class="row-odd"><td><p>__nv_bfloat16</p></td>
<td><p>__nv_bfloat16</p></td>
<td><p>float</p></td>
<td><p>32x8x16</p></td>
</tr>
<tr class="row-even"><td><p>__nv_bfloat16</p></td>
<td><p>__nv_bfloat16</p></td>
<td><p>float</p></td>
<td><p>8x32x16</p></td>
</tr>
<tr class="row-odd"><td><p>precision::tf32</p></td>
<td><p>precision::tf32</p></td>
<td><p>float</p></td>
<td><p>16x16x8</p></td>
</tr>
</tbody>
</table>
<p>Double Precision Support:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 24%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Matrix A</p></th>
<th class="head"><p>Matrix B</p></th>
<th class="head"><p>Accumulator</p></th>
<th class="head"><p>Matrix Size (m-n-k)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>double</p></td>
<td><p>double</p></td>
<td><p>double</p></td>
<td><p>8x8x4</p></td>
</tr>
</tbody>
</table>
<p>Experimental support for sub-byte operations:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 20%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Matrix A</p></th>
<th class="head"><p>Matrix B</p></th>
<th class="head"><p>Accumulator</p></th>
<th class="head"><p>Matrix Size (m-n-k)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>precision::u4</p></td>
<td><p>precision::u4</p></td>
<td><p>int</p></td>
<td><p>8x8x32</p></td>
</tr>
<tr class="row-odd"><td><p>precision::s4</p></td>
<td><p>precision::s4</p></td>
<td><p>int</p></td>
<td><p>8x8x32</p></td>
</tr>
<tr class="row-even"><td><p>precision::b1</p></td>
<td><p>precision::b1</p></td>
<td><p>int</p></td>
<td><p>8x8x128</p></td>
</tr>
</tbody>
</table>
</section>
<section id="wmma-example">
<span id="id186"></span><h3><span class="section-number">7.24.7. </span>Example<a class="headerlink" href="#wmma-example" title="Permalink to this headline">ï</a></h3>
<p>The following code implements a 16x16x16 matrix multiplication in a single warp.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mma.h&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">nvcuda</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">wmma_ker</span><span class="p">(</span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Declare the fragments</span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="n">wmma</span><span class="o">::</span><span class="n">matrix_a</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">wmma</span><span class="o">::</span><span class="n">col_major</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a_frag</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="n">wmma</span><span class="o">::</span><span class="n">matrix_b</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">wmma</span><span class="o">::</span><span class="n">row_major</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b_frag</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">fragment</span><span class="o">&lt;</span><span class="n">wmma</span><span class="o">::</span><span class="n">accumulator</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_frag</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Initialize the output to zero</span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">fill_fragment</span><span class="p">(</span><span class="n">c_frag</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Load the inputs</span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">load_matrix_sync</span><span class="p">(</span><span class="n">a_frag</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">load_matrix_sync</span><span class="p">(</span><span class="n">b_frag</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Perform the matrix multiplication</span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">mma_sync</span><span class="p">(</span><span class="n">c_frag</span><span class="p">,</span><span class="w"> </span><span class="n">a_frag</span><span class="p">,</span><span class="w"> </span><span class="n">b_frag</span><span class="p">,</span><span class="w"> </span><span class="n">c_frag</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Store the output</span>
<span class="w">   </span><span class="n">wmma</span><span class="o">::</span><span class="n">store_matrix_sync</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">c_frag</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">wmma</span><span class="o">::</span><span class="n">mem_row_major</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="dpx">
<h2><span class="section-number">7.25. </span>DPX<a class="headerlink" href="#dpx" title="Permalink to this headline">ï</a></h2>
<p>DPX is a set of functions that enable finding min and max values, as well as fused addition and min/max, for up to three 16 and 32-bit signed or unsigned integer parameters, with optional ReLU (clamping to zero):</p>
<ul class="simple">
<li><p>three parameters: <code class="docutils literal notranslate"><span class="pre">__vimax3_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimax3_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimax3_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimax3_u16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_u16x2</span></code></p></li>
<li><p>two parameters, with ReLU: <code class="docutils literal notranslate"><span class="pre">__vimax_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimax_s16x2_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin_s16x2_relu</span></code></p></li>
<li><p>three parameters, with ReLU: <code class="docutils literal notranslate"><span class="pre">__vimax3_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimax3_s16x2_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__vimin3_s16x2_relu</span></code></p></li>
<li><p>two parameters, also returning which parameter was smaller/larger: <code class="docutils literal notranslate"><span class="pre">__vibmax_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmax_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmin_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmin_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmax_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmax_u16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmin_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__vibmin_u16x2</span></code></p></li>
<li><p>three parameters, comparing (first + second) with the third: <code class="docutils literal notranslate"><span class="pre">__viaddmax_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmax_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmax_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmax_u16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_s32</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_s16x2</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_u32</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_u16x2</span></code></p></li>
<li><p>three parameters, with ReLU, comparing (first + second) with the third and a zero: <code class="docutils literal notranslate"><span class="pre">__viaddmax_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmax_s16x2_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_s32_relu</span></code>, <code class="docutils literal notranslate"><span class="pre">__viaddmin_s16x2_relu</span></code></p></li>
</ul>
<p>These instructions are hardware-accelerated on devices with compute capability 9 and higher, and software emulation on older devices.</p>
<p>Full API can be found in <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__INTRINSIC__SIMD.html">CUDA Math API documentation</a>.</p>
<p>DPX is exceptionally useful when implementing dynamic programming algorithms, such as Smith-Waterman or NeedlemanâWunsch in genomics and Floyd-Warshall in route optimization.</p>
<section id="dpx-example">
<span id="id187"></span><h3><span class="section-number">7.25.1. </span>Examples<a class="headerlink" href="#dpx-example" title="Permalink to this headline">ï</a></h3>
<p>Max value of three signed 32-bit integers, with ReLU</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-15</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_value_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__vimax3_s32_relu</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// max(-15, 8, 5, 0) = 8</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-2</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-4</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_value_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__vimax3_s32_relu</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="c1">// max(-15, -2, -4, 0) = 0</span>
</pre></div>
</div>
<p>Min value of the sum of two 32-bit signed integers, another 32-bit signed integer and a zero (ReLU)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-5</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-2</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_value_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__viaddmax_s32_relu</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// max(-5 + 6, -2, 0) = max(1, -2, 0) = 1</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">max_value_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__viaddmax_s32_relu</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// max(-5 + 4, -2, 0) = max(-1, -2, 0) = 0</span>
</pre></div>
</div>
<p>Min value of two unsigned 32-bit integers and determining which value is smaller</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">smaller_value</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">min_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__vibmin_u32</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smaller_value</span><span class="p">);</span><span class="w"> </span><span class="c1">// min_value is 6, smaller_value is true</span>
</pre></div>
</div>
<p>Max values of three pairs of unsigned 16-bit integers</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00050002</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00070004</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00020006</span><span class="p">;</span><span class="w"></span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__vimax3_u16x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">// max(5, 7, 2) and max(2, 4, 6), so max_value is 0x00070006</span>
</pre></div>
</div>
</section>
</section>
<section id="asynchronous-barrier">
<span id="aw-barrier"></span><h2><span class="section-number">7.26. </span>Asynchronous Barrier<a class="headerlink" href="#asynchronous-barrier" title="Permalink to this headline">ï</a></h2>
<p>The NVIDIA C++ standard library introduces a GPU implementation of <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives/barrier.html">std::barrier</a>. Along with the implementation of <code class="docutils literal notranslate"><span class="pre">std::barrier</span></code> the library provides extensions that allow users to specify the scope of barrier objects. The barrier API scopes are documented under <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/memory_model.html#thread-scopes">Thread Scopes</a>. Devices of compute capability 8.0 or higher provide hardware acceleration for barrier operations and integration of these barriers with the <a class="reference internal" href="#asynchronous-data-copies"><span class="std std-ref">memcpy_async</span></a> feature. On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.</p>
<p><code class="docutils literal notranslate"><span class="pre">nvcuda::experimental::awbarrier</span></code> is deprecated in favor of <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>.</p>
<section id="simple-synchronization-pattern">
<span id="split-arrive-then-wait"></span><h3><span class="section-number">7.26.1. </span>Simple Synchronization Pattern<a class="headerlink" href="#simple-synchronization-pattern" title="Permalink to this headline">ï</a></h3>
<p>Without the arrive/wait barrier, synchronization is achieved using <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> (to synchronize all threads in a block) or <code class="docutils literal notranslate"><span class="pre">group.sync()</span></code> when using <a class="reference internal" href="#cooperative-groups"><span class="std std-ref">Cooperative Groups</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">simple_sync</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code before arrive */</span><span class="w"></span>
<span class="w">        </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"> </span><span class="cm">/* wait for all threads to arrive here */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code after wait */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Threads are blocked at the synchronization point (<code class="docutils literal notranslate"><span class="pre">block.sync()</span></code>) until all threads have reached the synchronization point. In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to <code class="docutils literal notranslate"><span class="pre">atomic_thread_fence(memory_order_seq_cst,</span> <span class="pre">thread_scope_block)</span></code> as well as the <code class="docutils literal notranslate"><span class="pre">sync</span></code>.</p>
<p>This pattern has three stages:</p>
<ul class="simple">
<li><p>Code <strong>before</strong> sync performs memory updates that will be read <strong>after</strong> the sync.</p></li>
<li><p>Synchronization point</p></li>
<li><p>Code <strong>after</strong> sync point with visibility of memory updates that happened <strong>before</strong> sync point.</p></li>
</ul>
</section>
<section id="temporal-splitting-and-five-stages-of-synchronization">
<span id="temporal-split-5-stage-sync"></span><h3><span class="section-number">7.26.2. </span>Temporal Splitting and Five Stages of Synchronization<a class="headerlink" href="#temporal-splitting-and-five-stages-of-synchronization" title="Permalink to this headline">ï</a></h3>
<p>The temporally-split synchronization pattern with the <code class="docutils literal notranslate"><span class="pre">std::barrier</span></code> is as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">curr_iteration</span><span class="p">);</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">split_arrive_wait</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w">  </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Initialize the barrier with expected arrival count</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">curr_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">curr_iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">curr_iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code before arrive */</span><span class="w"></span>
<span class="w">       </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">();</span><span class="w"> </span><span class="cm">/* this thread arrives. Arrival does not block a thread */</span><span class="w"></span>
<span class="w">       </span><span class="n">compute</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">curr_iter</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"> </span><span class="cm">/* wait for all threads participating in the barrier to complete bar.arrive()*/</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code after wait */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this pattern, the synchronization point (<code class="docutils literal notranslate"><span class="pre">block.sync()</span></code>) is split into an arrive point (<code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>) and a wait point (<code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code>). A thread begins participating in a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> with its first call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>. When a thread calls <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> it will be blocked until participating threads have completed <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> the expected number of times as specified by the expected arrival count argument passed to <code class="docutils literal notranslate"><span class="pre">init()</span></code>. Memory updates that happen before participating threadsâ call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> are guaranteed to be visible to participating threads after their call to <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code>. Note that the call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threadsâ call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>.</p>
<p>The <em>arrive and then wait</em> pattern has five stages which may be iteratively repeated:</p>
<ul class="simple">
<li><p>Code <strong>before</strong> arrive performs memory updates that will be read <strong>after</strong> the wait.</p></li>
<li><p>Arrive point with implicit memory fence (i.e., equivalent to <code class="docutils literal notranslate"><span class="pre">atomic_thread_fence(memory_order_seq_cst,</span> <span class="pre">thread_scope_block)</span></code>).</p></li>
<li><p>Code <strong>between</strong> arrive and wait.</p></li>
<li><p>Wait point.</p></li>
<li><p>Code <strong>after</strong> the wait, with visibility of updates that were performed <strong>before</strong> the arrive.</p></li>
</ul>
</section>
<section id="bootstrap-initialization-expected-arrival-count-and-participation">
<span id="bootstrap-init-expected-arrive-count"></span><h3><span class="section-number">7.26.3. </span>Bootstrap Initialization, Expected Arrival Count, and Participation<a class="headerlink" href="#bootstrap-initialization-expected-arrival-count-and-participation" title="Permalink to this headline">ï</a></h3>
<p>Initialization must happen before any thread begins participating in a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">init_barrier</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Single thread initializes the total expected arrival count.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Before any thread can participate in <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>, the barrier must be initialized using <code class="docutils literal notranslate"><span class="pre">init()</span></code> with an <strong>expected arrival count</strong>, <code class="docutils literal notranslate"><span class="pre">block.size()</span></code> in this example. Initialization must happen before any thread calls <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>. This poses a bootstrapping challenge in that threads must synchronize before participating in the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>, but threads are creating a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> in order to synchronize. In this example, threads that will participate are part of a cooperative group and use <code class="docutils literal notranslate"><span class="pre">block.sync()</span></code> to bootstrap initialization. In this example a whole thread block is participating in initialization, hence <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> could also be used.</p>
<p>The second parameter of <code class="docutils literal notranslate"><span class="pre">init()</span></code> is the <strong>expected arrival count</strong>, i.e., the number of times <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> will be called by participating threads before a participating thread is unblocked from its call to <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code>. In the prior example the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> is initialized with the number of threads in the thread block i.e., <code class="docutils literal notranslate"><span class="pre">cooperative_groups::this_thread_block().size()</span></code>, and all threads within the thread block participate in the barrier.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> is flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast <code class="docutils literal notranslate"><span class="pre">this_thread_block.sync()</span></code> from cooperative groups or <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> is applicable to whole-thread-block and <code class="docutils literal notranslate"><span class="pre">__syncwarp(mask)</span></code> is a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> and <code class="docutils literal notranslate"><span class="pre">__syncwarp(mask)</span></code> respectively for performance reasons.</p>
</section>
<section id="a-barrier-s-phase-arrival-countdown-completion-and-reset">
<span id="countdown-complete-reset-phase"></span><h3><span class="section-number">7.26.4. </span>A Barrierâs Phase: Arrival, Countdown, Completion, and Reset<a class="headerlink" href="#a-barrier-s-phase-arrival-countdown-completion-and-reset" title="Permalink to this headline">ï</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> counts down from the expected arrival count to zero as participating threads call <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>. When the countdown reaches zero, a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> is complete for the current phase. When the last call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> causes the countdown to reach zero, the countdown is automatically and atomically reset. The reset assigns the countdown to the expected arrival count, and moves the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> to the next phase.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">token</span></code> object of class <code class="docutils literal notranslate"><span class="pre">cuda::barrier::arrival_token</span></code>, as returned from <code class="docutils literal notranslate"><span class="pre">token=bar.arrive()</span></code>, is associated with the current phase of the barrier. A call to <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> blocks the calling thread while the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> is in the current phase, i.e., while the phase associated with the token matches the phase of the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>. If the phase is advanced (because the countdown reaches zero) before the call to <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> then the thread does not block; if the phase is advanced while the thread is blocked in <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code>, the thread is unblocked.</p>
<p><strong>It is essential to know when a reset could or could not occur, especially in non-trivial arrive/wait synchronization patterns.</strong></p>
<ul class="simple">
<li><p>A threadâs calls to <code class="docutils literal notranslate"><span class="pre">token=bar.arrive()</span></code> and <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> must be sequenced such that <code class="docutils literal notranslate"><span class="pre">token=bar.arrive()</span></code> occurs during the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>âs current phase, and <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> occurs during the same or next phase.</p></li>
<li><p>A threadâs call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> must occur when the barrierâs counter is non-zero. After barrier initialization, if a threadâs call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> causes the countdown to reach zero then a call to <code class="docutils literal notranslate"><span class="pre">bar.wait(std::move(token))</span></code> must happen before the barrier can be reused for a subsequent call to <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bar.wait()</span></code> must only be called using a <code class="docutils literal notranslate"><span class="pre">token</span></code> object of the current phase or the immediately preceding phase. For any other values of the <code class="docutils literal notranslate"><span class="pre">token</span></code> object, the behavior is undefined.</p></li>
</ul>
<p>For simple arrive/wait synchronization patterns, compliance with these usage rules is straightforward.</p>
</section>
<section id="spatial-partitioning-also-known-as-warp-specialization">
<span id="warp-specialization"></span><h3><span class="section-number">7.26.5. </span>Spatial Partitioning (also known as Warp Specialization)<a class="headerlink" href="#spatial-partitioning-also-known-as-warp-specialization" title="Permalink to this headline">ï</a></h3>
<p>A thread block can be spatially partitioned such that warps are specialized to perform independent computations. Spatial partitioning is used in a producer or consumer pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.</p>
<p>A producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 53%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Producer</p></th>
<th class="head"><p>Consumer</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>wait for buffer to be ready to be filled</p></td>
<td><p>signal buffer is ready to be filled</p></td>
</tr>
<tr class="row-odd"><td><p>produce data and fill the buffer</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>signal buffer is filled</p></td>
<td><p>wait for buffer to be filled</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>consume data in filled buffer</p></td>
</tr>
</tbody>
</table>
<p>Producer threads wait for consumer threads to signal that the buffer is ready to be filled; however, consumer threads do not wait for this signal. Consumer threads wait for producer threads to signal that the buffer is filled; however, producer threads do not wait for this signal. For full producer/consumer concurrency this pattern has (at least) double buffering where each buffer requires two <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>s.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">producer</span><span class="p">(</span><span class="n">barrier</span><span class="w"> </span><span class="n">ready</span><span class="p">[],</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">filled</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">buffer_len</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ready</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="n">arrive_and_wait</span><span class="p">();</span><span class="w"> </span><span class="cm">/* wait for buffer_(i%2) to be ready to be filled */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* produce, i.e., fill in, buffer_(i%2)  */</span><span class="w"></span>
<span class="w">        </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filled</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="n">arrive</span><span class="p">();</span><span class="w"> </span><span class="cm">/* buffer_(i%2) is filled */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">consumer</span><span class="p">(</span><span class="n">barrier</span><span class="w"> </span><span class="n">ready</span><span class="p">[],</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">filled</span><span class="p">[],</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_len</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ready</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">arrive</span><span class="p">();</span><span class="w"> </span><span class="cm">/* buffer_0 is ready for initial fill */</span><span class="w"></span>
<span class="w">    </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ready</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">arrive</span><span class="p">();</span><span class="w"> </span><span class="cm">/* buffer_1 is ready for initial fill */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">buffer_len</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">filled</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="n">arrive_and_wait</span><span class="p">();</span><span class="w"> </span><span class="cm">/* wait for buffer_(i%2) to be filled */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* consume buffer_(i%2) */</span><span class="w"></span>
<span class="w">        </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ready</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="n">arrive</span><span class="p">();</span><span class="w"> </span><span class="cm">/* buffer_(i%2) is ready to be re-filled */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//N is the total number of float elements in arrays in and out</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">producer_consumer_pattern</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_len</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Shared memory buffer declared below is of size 2 * buffer_len</span>
<span class="w">    </span><span class="c1">// so that we can alternatively work between two buffers.</span>
<span class="w">    </span><span class="c1">// buffer_0 = buffer and buffer_1 = buffer + buffer_len</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">buffer</span><span class="p">[];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled,</span>
<span class="w">    </span><span class="c1">// while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled-in respectively</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>


<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">init</span><span class="p">(</span><span class="n">bar</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">(),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">warpSize</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">producer</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_len</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">consumer</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_len</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call <code class="docutils literal notranslate"><span class="pre">bar.arrive()</span></code> or <code class="docutils literal notranslate"><span class="pre">bar.arrive_and_wait()</span></code>) in each of the four <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>s so the expected arrival counts are equal to <code class="docutils literal notranslate"><span class="pre">block.size()</span></code>.</p>
<p>A producer thread waits for the consumer threads to signal that the shared memory buffer can be filled. In order to wait for a <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> a producer thread must first arrive on that <code class="docutils literal notranslate"><span class="pre">ready[i%2].arrive()</span></code> to get a token and then <code class="docutils literal notranslate"><span class="pre">ready[i%2].wait(token)</span></code> with that token. For simplicity <code class="docutils literal notranslate"><span class="pre">ready[i%2].arrive_and_wait()</span></code> combines these operations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">bar</span><span class="p">.</span><span class="n">arrive_and_wait</span><span class="p">();</span><span class="w"></span>
<span class="cm">/* is equivalent to */</span><span class="w"></span>
<span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>Producer threads compute and fill the ready buffer, they then signal that the buffer is filled by arriving on the filled barrier, <code class="docutils literal notranslate"><span class="pre">filled[i%2].arrive()</span></code>. A producer thread does not wait at this point, instead it waits until the next iterationâs buffer (double buffering) is ready to be filled.</p>
<p>A consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iterationâs buffer to be filled, <code class="docutils literal notranslate"><span class="pre">filled[i%2].arrive_and_wait()</span></code>. After the consumer threads consume the buffer they signal that the buffer is ready to be filled again, <code class="docutils literal notranslate"><span class="pre">ready[i%2].arrive()</span></code>, and then wait for the next iterationâs buffer to be filled.</p>
</section>
<section id="early-exit-dropping-out-of-participation">
<span id="early-exit"></span><h3><span class="section-number">7.26.6. </span>Early Exit (Dropping out of Participation)<a class="headerlink" href="#early-exit-dropping-out-of-participation" title="Permalink to this headline">ï</a></h3>
<p>When a thread that is participating in a sequence of synchronizations must exit early from that sequence, that thread must explicitly drop out of participation before exiting. The remaining participating threads can proceed normally with subsequent <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> arrive and wait operations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">condition_check</span><span class="p">();</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">early_exit_kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition_check</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive_and_drop</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* other threads can proceed normally */</span><span class="w"></span>
<span class="w">        </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code between arrive and wait */</span><span class="w"></span>
<span class="w">        </span><span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"> </span><span class="cm">/* wait for all threads to arrive */</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* code after wait */</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This operation arrives on the <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> to fulfill the participating threadâs obligation to arrive in the <strong>current</strong> phase, and then decrements the expected arrival count for the <strong>next</strong> phase so that this thread is no longer expected to arrive on the barrier.</p>
</section>
<section id="completion-function">
<h3><span class="section-number">7.26.7. </span>Completion Function<a class="headerlink" href="#completion-function" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CompletionFunction</span></code> of <code class="docutils literal notranslate"><span class="pre">cuda::barrier&lt;Scope,</span> <span class="pre">CompletionFunction&gt;</span></code> is executed once per phase, after the last thread <em>arrives</em> and before any thread is unblocked from the <code class="docutils literal notranslate"><span class="pre">wait</span></code>. Memory operations performed by the threads that arrived at the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> during the phase are visible to the thread executing the <code class="docutils literal notranslate"><span class="pre">CompletionFunction</span></code>, and all memory operations performed within the <code class="docutils literal notranslate"><span class="pre">CompletionFunction</span></code> are visible to all threads waiting at the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> once they are unblocked from the <code class="docutils literal notranslate"><span class="pre">wait</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">divergent_compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">independent_computation</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">psum</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">BlockSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem</span><span class="p">[</span><span class="n">BlockSize</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">BlockSize</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">completion_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">smem</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">acc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Barrier storage</span>
<span class="w">  </span><span class="c1">// Note: the barrier is not default-constructible because</span>
<span class="w">  </span><span class="c1">//       completion_fn is not default-constructible due</span>
<span class="w">  </span><span class="c1">//       to the capture.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">completion_fn_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">completion_fn</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">barrier_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="p">,</span><span class="w"></span>
<span class="w">                                  </span><span class="n">completion_fn_t</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">barrier_t</span><span class="p">),</span><span class="w"></span>
<span class="w">                                  </span><span class="k">alignof</span><span class="p">(</span><span class="n">barrier_t</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bar_storage</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initialize barrier:</span>
<span class="w">  </span><span class="n">barrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">barrier_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bar_storage</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">acc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="w"> </span><span class="n">barrier_t</span><span class="p">{</span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">completion_fn</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// equivalent to: init(bar, block.size(), completion_fn);</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Main loop</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">smem</span><span class="p">[</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">acc</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="o">-&gt;</span><span class="n">arrive</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// We can do independent computation here</span>
<span class="w">    </span><span class="n">bar</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="c1">// shared-memory is safe to re-use in the next iteration</span>
<span class="w">    </span><span class="c1">// since all threads are done with it, including the one</span>
<span class="w">    </span><span class="c1">// that did the reduction</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-barrier-primitives-interface">
<h3><span class="section-number">7.26.8. </span>Memory Barrier Primitives Interface<a class="headerlink" href="#memory-barrier-primitives-interface" title="Permalink to this headline">ï</a></h3>
<p>Memory barrier primitives are C-like interfaces to <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> functionality. These primitives are available through including the <code class="docutils literal notranslate"><span class="pre">&lt;cuda_awbarrier_primitives.h&gt;</span></code> header.</p>
<section id="data-types">
<span id="memory-barrier-primitives-datatypes"></span><h4><span class="section-number">7.26.8.1. </span>Data Types<a class="headerlink" href="#data-types" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="cm">/* implementation defined */</span><span class="w"> </span><span class="n">__mbarrier_t</span><span class="p">;</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="cm">/* implementation defined */</span><span class="w"> </span><span class="n">__mbarrier_token_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-barrier-primitives-api">
<h4><span class="section-number">7.26.8.2. </span>Memory Barrier Primitives API<a class="headerlink" href="#memory-barrier-primitives-api" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">__mbarrier_maximum_count</span><span class="p">();</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">__mbarrier_init</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">expected_count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> must be a pointer to <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> memory.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expected_count</span> <span class="pre">&lt;=</span> <span class="pre">__mbarrier_maximum_count()</span></code></p></li>
<li><p>Initialize <code class="docutils literal notranslate"><span class="pre">*bar</span></code> expected arrival count for the current and next phase to <code class="docutils literal notranslate"><span class="pre">expected_count</span></code>.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__mbarrier_inval</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> must be a pointer to the mbarrier object residing in shared memory.</p></li>
<li><p>Invalidation of <code class="docutils literal notranslate"><span class="pre">*bar</span></code> is required before the corresponding shared memory can be repurposed.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__mbarrier_token_t</span><span class="w"> </span><span class="nf">__mbarrier_arrive</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Initialization of <code class="docutils literal notranslate"><span class="pre">*bar</span></code> must happen before this call.</p></li>
<li><p>Pending count must not be zero.</p></li>
<li><p>Atomically decrement the pending count for the current phase of the barrier.</p></li>
<li><p>Return an arrival token associated with the barrier state immediately prior to the decrement.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__mbarrier_token_t</span><span class="w"> </span><span class="nf">__mbarrier_arrive_and_drop</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Initialization of <code class="docutils literal notranslate"><span class="pre">*bar</span></code> must happen before this call.</p></li>
<li><p>Pending count must not be zero.</p></li>
<li><p>Atomically decrement the pending count for the current phase and expected count for the next phase of the barrier.</p></li>
<li><p>Return an arrival token associated with the barrier state immediately prior to the decrement.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">__mbarrier_test_wait</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">__mbarrier_token_t</span><span class="w"> </span><span class="n">token</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">token</span></code> must be associated with the immediately preceding phase or current phase of <code class="docutils literal notranslate"><span class="pre">*this</span></code>.</p></li>
<li><p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if <code class="docutils literal notranslate"><span class="pre">token</span></code> is associated with the immediately preceding phase of <code class="docutils literal notranslate"><span class="pre">*bar</span></code>, otherwise returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//Note: This API has been deprecated in CUDA 11.1</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">__mbarrier_pending_count</span><span class="p">(</span><span class="n">__mbarrier_token_t</span><span class="w"> </span><span class="n">token</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="asynchronous-data-copies">
<span id="id188"></span><h2><span class="section-number">7.27. </span>Asynchronous Data Copies<a class="headerlink" href="#asynchronous-data-copies" title="Permalink to this headline">ï</a></h2>
<p>CUDA 11 introduces Asynchronous Data operations with <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API to allow device code to explicitly manage the asynchronous copying of data. The <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> feature enables CUDA kernels to overlap computation with data movement.</p>
<section id="memcpy-async-api">
<span id="id189"></span><h3><span class="section-number">7.27.1. </span><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API<a class="headerlink" href="#memcpy-async-api" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> APIs are provided in the <code class="docutils literal notranslate"><span class="pre">cuda/barrier</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda/pipeline</span></code>, and <code class="docutils literal notranslate"><span class="pre">cooperative_groups/memcpy_async.h</span></code> header files.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> APIs work with <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> and <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> synchronization primitives, while the <code class="docutils literal notranslate"><span class="pre">cooperative_groups::memcpy_async</span></code> synchronizes using <code class="docutils literal notranslate"><span class="pre">coopertive_groups::wait</span></code>.</p>
<p>These APIs have very similar semantics: copy objects from <code class="docutils literal notranslate"><span class="pre">src</span></code> to <code class="docutils literal notranslate"><span class="pre">dst</span></code> as-if performed by another thread which, on completion of the copy, can be synchronized through <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>, or <code class="docutils literal notranslate"><span class="pre">cooperative_groups::wait</span></code>.</p>
<p>The complete API documentation of the <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> overloads for <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> and <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> is provided in the <a class="reference external" href="https://nvidia.github.io/libcudacxx">libcudacxx API</a> documentation along with some examples.</p>
<p>The API documentation of <a class="reference internal" href="#collectives-cg-memcpy-async"><span class="std std-ref">cooperative_groups::memcpy_async</span></a> is provided in the <a class="reference internal" href="#cooperative-groups"><span class="std std-ref">Cooperative Groups</span></a> section.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> APIs that use <a class="reference internal" href="#aw-barrier"><span class="std std-ref">cuda::barrier</span></a> and <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> require compute capability 7.0 or higher. On devices with compute capability 8.0 or higher, <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operations from global to shared memory can benefit from hardware acceleration.</p>
</section>
<section id="copy-and-compute-pattern-staging-data-through-shared-memory">
<span id="copy-and-compute-pattern"></span><h3><span class="section-number">7.27.2. </span>Copy and Compute Pattern - Staging Data Through Shared Memory<a class="headerlink" href="#copy-and-compute-pattern-staging-data-through-shared-memory" title="Permalink to this headline">ï</a></h3>
<p>CUDA applications often employ a <em>copy and compute</em> pattern that:</p>
<ul class="simple">
<li><p>fetches data from global memory,</p></li>
<li><p>stores data to shared memory, and</p></li>
<li><p>performs computations on shared memory data, and potentially writes results back to global memory.</p></li>
</ul>
<p>The following sections illustrate how this pattern can be expressed without and with the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> feature:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#without-memcpy-async"><span class="std std-ref">Without memcpy_async</span></a> introduces an example that does not overlap computation with data movement and uses an intermediate register to copy data.</p></li>
<li><p><a class="reference internal" href="#with-memcpy-async"><span class="std std-ref">With memcpy_async</span></a> improves the previous example by introducing the <a class="reference internal" href="#collectives-cg-memcpy-async"><span class="std std-ref">memcpy_async</span></a> and the <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> APIs to directly copy data from global to shared memory without using intermediate registers.</p></li>
<li><p><a class="reference internal" href="#memcpy-async-barrier"><span class="std std-ref">Asynchronous Data Copies using cuda::barrier</span></a> shows memcpy with cooperative groups and barrier.</p></li>
<li><p><a class="reference internal" href="#with-memcpy-async-pipeline-pattern-single"><span class="std std-ref">Single-Stage Asynchronous Data Copies using cuda::pipeline</span></a> shows memcpy with single stage pipeline.</p></li>
<li><p><a class="reference internal" href="#with-memcpy-async-pipeline-pattern-multi"><span class="std std-ref">Multi-Stage Asynchronous Data Copies using cuda::pipeline</span></a> shows memcpy with multi stage pipeline.</p></li>
</ul>
</section>
<section id="without-memcpy-async">
<span id="id190"></span><h3><span class="section-number">7.27.3. </span>Without <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code><a class="headerlink" href="#without-memcpy-async" title="Permalink to this headline">ï</a></h3>
<p>Without <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code>, the <em>copy</em> phase of the <em>copy and compute</em> pattern is expressed as <code class="docutils literal notranslate"><span class="pre">shared[local_idx]</span> <span class="pre">=</span> <span class="pre">global[global_idx]</span></code>. This global to shared memory copy is expanded to a read from global memory into a register, followed by a write to shared memory from the register.</p>
<p>When this pattern occurs within an iterative algorithm, each thread block needs to synchronize after the <code class="docutils literal notranslate"><span class="pre">shared[local_idx]</span> <span class="pre">=</span> <span class="pre">global[global_idx]</span></code> assignment, to ensure all writes to shared memory have completed before the compute phase can begin. The thread block also needs to synchronize again after the compute phase, to prevent overwriting shared memory before all threads have completed their computations. This pattern is illustrated in the following code snippet.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">shared_in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Computes using all values of current batch from shared memory.</span>
<span class="w">    </span><span class="c1">// Stores this thread&#39;s result back to global memory.</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">without_memcpy_async</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Exposition: input size fits batch_sz * grid_size</span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// block.size() * sizeof(int) bytes</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">local_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Compute the index of the current batch for this block in global memory:</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">shared</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_in</span><span class="p">[</span><span class="n">global_idx</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"> </span><span class="c1">// Wait for all copies to complete</span>

<span class="w">    </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">);</span><span class="w"> </span><span class="c1">// Compute and write result to global memory</span>

<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"> </span><span class="c1">// Wait for compute using shared memory to finish</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="with-memcpy-async">
<span id="id191"></span><h3><span class="section-number">7.27.4. </span>With <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code><a class="headerlink" href="#with-memcpy-async" title="Permalink to this headline">ï</a></h3>
<p>With <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code>, the assignment of shared memory from global memory</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">shared</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">global_in</span><span class="p">[</span><span class="n">global_idx</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>is replaced with an asynchronous copy operation from <a class="reference internal" href="#cooperative-groups"><span class="std std-ref">cooperative groups</span></a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#collectives-cg-memcpy-async"><span class="std std-ref">cooperative_groups::memcpy_async</span></a> API copies <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">*</span> <span class="pre">block.size()</span></code> bytes from global memory starting at <code class="docutils literal notranslate"><span class="pre">global_in</span> <span class="pre">+</span> <span class="pre">batch_idx</span></code> to the <code class="docutils literal notranslate"><span class="pre">shared</span></code> data. This operation happens as-if performed by another thread, which synchronizes with the current threadâs call to <a class="reference internal" href="#collectives-cg-wait"><span class="std std-ref">cooperative_groups::wait</span></a> after the copy has completed. Until the copy operation completes, modifying the global data or reading or writing the shared data introduces a data race.</p>
<p>On devices with compute capability 8.0 or higher, <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> transfers from global to shared memory can benefit from hardware acceleration, which avoids transfering the data through an intermediate register.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">shared_in</span><span class="p">);</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_memcpy_async</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Exposition: input size fits batch_sz * grid_size</span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// block.size() * sizeof(int) bytes</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Whole thread-group cooperatively copies whole batch to shared memory:</span>
<span class="w">    </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"> </span><span class="c1">// Joins all threads, waits for all copies to complete</span>

<span class="w">    </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="asynchronous-data-copies-using-cuda-barrier">
<span id="memcpy-async-barrier"></span><h3><span class="section-number">7.27.5. </span>Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code><a class="headerlink" href="#asynchronous-data-copies-using-cuda-barrier" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> overload for <a class="reference internal" href="#aw-barrier"><span class="std std-ref">cuda::barrier</span></a> enables synchronizing asynchronous data transfers using a <code class="docutils literal notranslate"><span class="pre">barrier</span></code>. This overloads executes the copy operation as-if performed by another thread bound to the barrier by: incrementing the expected count of the current phase on creation, and decrementing it on completion of the copy operation, such that the phase of the <code class="docutils literal notranslate"><span class="pre">barrier</span></code> will only advance when all threads participating in the barrier have arrived, and all <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> bound to the current phase of the barrier have completed. The following example uses a block-wide <code class="docutils literal notranslate"><span class="pre">barrier</span></code>, where all block threads participate, and swaps the wait operation with a barrier <code class="docutils literal notranslate"><span class="pre">arrive_and_wait</span></code>, while providing the same functionality as the previous example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">shared_in</span><span class="p">);</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_barrier</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Assume input size fits batch_sz * grid_size</span>

<span class="w">  </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// block.size() * sizeof(int) bytes</span>

<span class="w">  </span><span class="c1">// Create a synchronization object (C++20 barrier)</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="n">barrier</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">barrier</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Friend function initializes barrier</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">barrier</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">barrier</span><span class="p">.</span><span class="n">arrive_and_wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// Waits for all copies to complete</span>

<span class="w">    </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="performance-guidance-for-memcpy-async">
<span id="performance-guidance-memcpy-async"></span><h3><span class="section-number">7.27.6. </span>Performance Guidance for <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code><a class="headerlink" href="#performance-guidance-for-memcpy-async" title="Permalink to this headline">ï</a></h3>
<p>For compute capability 8.x, the pipeline mechanism is shared among CUDA threads in the same CUDA warp. This sharing causes batches of <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> to be entangled within a warp, which can impact performance under certain circumstances.</p>
<p>This section highlights the warp-entanglement effect on <em>commit</em>, <em>wait</em>, and <em>arrive</em> operations. Please refer to <a class="reference internal" href="#pipeline-interface"><span class="std std-ref">Pipeline Interface</span></a> and the <a class="reference internal" href="#pipeline-primitives-interface"><span class="std std-ref">Pipeline Primitives Interface</span></a> for an overview of the individual operations.</p>
<section id="alignment">
<span id="aligned-size-t"></span><h4><span class="section-number">7.27.6.1. </span>Alignment<a class="headerlink" href="#alignment" title="Permalink to this headline">ï</a></h4>
<p>On devices with compute capability 8.0, the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async">cp.async family of instructions</a> allows copying data from global to shared memory asynchronously. These instructions support copying 4, 8, and 16 bytes at a time. If the size provided to <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> is a multiple of 4, 8, or 16, and both pointers passed to <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> are aligned to a 4, 8, or 16 alignment boundary, then <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> can be implemented using exclusively asynchronous memory operations.</p>
<p>Additionally for achieving best performance when using <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API, an alignment of 128 Bytes for both shared memory and global memory is required.</p>
<p>For pointers to values of types with an alignment requirement of 1 or 2, it is often not possible to prove that the pointers are always aligned to a higher alignment boundary. Determining whether the <code class="docutils literal notranslate"><span class="pre">cp.async</span></code> instructions can or cannot be used must be delayed until run-time. Performing such a runtime alignment check increases code-size and adds runtime overhead.</p>
<p>The <a class="reference external" href="https://nvidia.github.io/libcudacxx">cuda::aligned_size_t&lt;size_t Align&gt;(size_t size)</a><a class="reference external" href="https://nvidia.github.io/libcudacxx">Shape</a> can be used to supply a proof that both pointers passed to <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> are aligned to an <code class="docutils literal notranslate"><span class="pre">Align</span></code> alignment boundary and that <code class="docutils literal notranslate"><span class="pre">size</span></code> is a multiple of <code class="docutils literal notranslate"><span class="pre">Align</span></code>, by passing it as an argument where the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> APIs expect a <code class="docutils literal notranslate"><span class="pre">Shape</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">aligned_size_t</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>If the proof is incorrect, the behavior is undefined.</p>
</section>
<section id="trivially-copyable">
<h4><span class="section-number">7.27.6.2. </span>Trivially copyable<a class="headerlink" href="#trivially-copyable" title="Permalink to this headline">ï</a></h4>
<p>On devices with compute capability 8.0, the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async">cp.async family of instructions</a> allows copying data from global to shared memory asynchronously. If the pointer types passed to <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> do not point to <a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">TriviallyCopyable</a> types, the copy constructor of each output element needs to be invoked, and these instructions cannot be used to accelerate <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code>.</p>
</section>
<section id="warp-entanglement-commit">
<h4><span class="section-number">7.27.6.3. </span>Warp Entanglement - Commit<a class="headerlink" href="#warp-entanglement-commit" title="Permalink to this headline">ï</a></h4>
<p>The sequence of <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> batches is shared across the warp. The commit operation is coalesced such that the sequence is incremented once for all converged threads that invoke the commit operation. If the warp is fully converged, the sequence is incremented by one; if the warp is fully diverged, the sequence is incremented by 32.</p>
<ul>
<li><p>Let <em>PB</em> be the warp-shared pipelineâs <em>actual</em> sequence of batches.</p>
<p><code class="docutils literal notranslate"><span class="pre">PB</span> <span class="pre">=</span> <span class="pre">{BP0,</span> <span class="pre">BP1,</span> <span class="pre">BP2,</span> <span class="pre">â¦,</span> <span class="pre">BPL}</span></code></p>
</li>
<li><p>Let <em>TB</em> be a threadâs <em>perceived</em> sequence of batches, as if the sequence were only incremented by this threadâs invocation of the commit operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">TB</span> <span class="pre">=</span> <span class="pre">{BT0,</span> <span class="pre">BT1,</span> <span class="pre">BT2,</span> <span class="pre">â¦,</span> <span class="pre">BTL}</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">pipeline::producer_commit()</span></code> return value is from the threadâs <em>perceived</em> batch sequence.</p>
</li>
<li><p>An index in a threadâs perceived sequence always aligns to an equal or larger index in the actual warp-shared sequence. The sequences are equal only when all commit operations are invoked from converged threads.</p>
<p><code class="docutils literal notranslate"><span class="pre">BTn</span> <span class="pre">â¡</span> <span class="pre">BPm</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code></p>
</li>
</ul>
<p>For example, when a warp is fully diverged:</p>
<ul class="simple">
<li><p>The warp-shared pipelineâs actual sequence would be: <code class="docutils literal notranslate"><span class="pre">PB</span> <span class="pre">=</span> <span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">...,</span> <span class="pre">31}</span></code> (<code class="docutils literal notranslate"><span class="pre">PL=31</span></code>).</p></li>
<li><p>The perceived sequence for each thread of this warp would be:</p>
<ul>
<li><p>Thread 0: <code class="docutils literal notranslate"><span class="pre">TB</span> <span class="pre">=</span> <span class="pre">{0}</span></code> (<code class="docutils literal notranslate"><span class="pre">TL=0</span></code>)</p></li>
<li><p>Thread 1: <code class="docutils literal notranslate"><span class="pre">TB</span> <span class="pre">=</span> <span class="pre">{0}</span></code> (<code class="docutils literal notranslate"><span class="pre">TL=0</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">â¦</span></code></p></li>
<li><p>Thread 31: <code class="docutils literal notranslate"><span class="pre">TB</span> <span class="pre">=</span> <span class="pre">{0}</span></code> (<code class="docutils literal notranslate"><span class="pre">TL=0</span></code>)</p></li>
</ul>
</li>
</ul>
</section>
<section id="warp-entanglement-wait">
<h4><span class="section-number">7.27.6.4. </span>Warp Entanglement - Wait<a class="headerlink" href="#warp-entanglement-wait" title="Permalink to this headline">ï</a></h4>
<p>A CUDA thread invokes either <code class="docutils literal notranslate"><span class="pre">pipeline_consumer_wait_prior&lt;N&gt;()</span></code> or <code class="docutils literal notranslate"><span class="pre">pipeline::consumer_wait()</span></code> to wait for batches in the <em>perceived</em> sequence <code class="docutils literal notranslate"><span class="pre">TB</span></code> to complete. Note that <code class="docutils literal notranslate"><span class="pre">pipeline::consumer_wait()</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">pipeline_consumer_wait_prior&lt;N&gt;()</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">PL</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">pipeline_consumer_wait_prior&lt;N&gt;()</span></code> function waits for batches in the <em>actual</em> sequence at least up to and including <code class="docutils literal notranslate"><span class="pre">PL-N</span></code>. Since <code class="docutils literal notranslate"><span class="pre">TL</span> <span class="pre">&lt;=</span> <span class="pre">PL</span></code>, waiting for batch up to and including <code class="docutils literal notranslate"><span class="pre">PL-N</span></code> includes waiting for batch <code class="docutils literal notranslate"><span class="pre">TL-N</span></code>. Thus, when <code class="docutils literal notranslate"><span class="pre">TL</span> <span class="pre">&lt;</span> <span class="pre">PL</span></code>, the thread will unintentionally wait for additional, more recent batches.</p>
<p>In the extreme fully-diverged warp example above, each thread could wait for all 32 batches.</p>
</section>
<section id="warp-entanglement-arrive-on">
<h4><span class="section-number">7.27.6.5. </span>Warp Entanglement - Arrive-On<a class="headerlink" href="#warp-entanglement-arrive-on" title="Permalink to this headline">ï</a></h4>
<p>Warp-divergence affects the number of times an <code class="docutils literal notranslate"><span class="pre">arrive_on(bar)</span></code> operation updates the barrier. If the invoking warp is fully converged, then the barrier is updated once. If the invoking warp is fully diverged, then 32 individual updates are applied to the barrier.</p>
</section>
<section id="keep-commit-and-arrive-on-operations-converged">
<span id="keep-commit-arrive-on-ops-converged"></span><h4><span class="section-number">7.27.6.6. </span>Keep Commit and Arrive-On Operations Converged<a class="headerlink" href="#keep-commit-and-arrive-on-operations-converged" title="Permalink to this headline">ï</a></h4>
<p>It is recommended that commit and arrive-on invocations are by converged threads:</p>
<ul class="simple">
<li><p>to not over-wait, by keeping threadsâ perceived sequence of batches aligned with the actual sequence, and</p></li>
<li><p>to minimize updates to the barrier object.</p></li>
</ul>
<p>When code preceding these operations diverges threads, then the warp should be re-converged, via <code class="docutils literal notranslate"><span class="pre">__syncwarp</span></code> before invoking commit or arrive-on operations.</p>
</section>
</section>
</section>
<section id="asynchronous-data-copies-using-cuda-pipeline">
<span id="memcpy-async-pipeline"></span><h2><span class="section-number">7.28. </span>Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code><a class="headerlink" href="#asynchronous-data-copies-using-cuda-pipeline" title="Permalink to this headline">ï</a></h2>
<p>CUDA provides the <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> synchronization object to manage and overlap asynchronous data movement with computation.</p>
<p>The API documentation for <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> is provided in the <a class="reference external" href="https://nvidia.github.io/libcudacxx">libcudacxx API</a>. A pipeline object is a double-ended N stage queue with a <em>head</em> and a <em>tail</em>, and is used to process work in a first-in first-out (FIFO) order. The pipeline object has following member functions to manage the stages of the pipeline.</p>
<table class="table-no-stripes colwidths-given docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pipeline Class Member Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">producer_acquire</span></code></p></td>
<td><p>Acquires an available stage in the pipeline internal queue.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">producer_commit</span></code></p></td>
<td><p>Commits the asynchronous operations issued after the <code class="docutils literal notranslate"><span class="pre">producer_acquire</span></code> call on the currently acquired stage of the pipeline.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">consumer_wait</span></code></p></td>
<td><p>Wait for completion of all asynchronous operations on the oldest stage of the pipeline.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">consumer_release</span></code></p></td>
<td><p>Release the oldest stage of the pipeline to the pipeline object for reuse. The released stage can be then acquired by the producer.</p></td>
</tr>
</tbody>
</table>
<section id="single-stage-asynchronous-data-copies-using-cuda-pipeline">
<span id="with-memcpy-async-pipeline-pattern-single"></span><h3><span class="section-number">7.28.1. </span>Single-Stage Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code><a class="headerlink" href="#single-stage-asynchronous-data-copies-using-cuda-pipeline" title="Permalink to this headline">ï</a></h3>
<p>In previous examples we showed how to use <a class="reference internal" href="#collectives-cg-wait"><span class="std std-ref">cooperative_groups</span></a> and <a class="reference internal" href="#aw-barrier"><span class="std std-ref">cuda::barrier</span></a> to do asynchronous data transfers. In this section, we will use the <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code> API with a single stage to schedule asynchronous copies. And later we will expand this example to show multi staged overlapped compute and copy.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/pipeline&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">shared_in</span><span class="p">);</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_single_stage</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Assume input size fits batch_sz * grid_size</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">stages_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Pipeline with one stage</span>
<span class="w">    </span><span class="c1">// One batch must fit in shared memory:</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w">  </span><span class="c1">// block.size() * sizeof(int) bytes</span>

<span class="w">    </span><span class="c1">// Allocate shared storage for a single stage cuda::pipeline:</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_shared_state</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">stages_count</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shared_state</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Each thread processes `batch_sz` elements.</span>
<span class="w">    </span><span class="c1">// Compute offset of the batch `batch` of this thread block in global memory:</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively acquire the pipeline head stage from all producer threads:</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Submit async copies to the pipeline&#39;s head stage to be</span>
<span class="w">        </span><span class="c1">// computed in the next loop iteration</span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Collectively commit (advance) the pipeline&#39;s head stage</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively wait for the operations committed to the</span>
<span class="w">        </span><span class="c1">// previous `compute` stage to complete:</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Computation overlapped with the memcpy_async of the &quot;copy&quot; stage:</span>
<span class="w">        </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_idx</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively release the stage resources</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="multi-stage-asynchronous-data-copies-using-cuda-pipeline">
<span id="with-memcpy-async-pipeline-pattern-multi"></span><h3><span class="section-number">7.28.2. </span>Multi-Stage Asynchronous Data Copies using <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code><a class="headerlink" href="#multi-stage-asynchronous-data-copies-using-cuda-pipeline" title="Permalink to this headline">ï</a></h3>
<p>In the previous examples with <a class="reference internal" href="#collectives-cg-wait"><span class="std std-ref">cooperative_groups::wait</span></a> and <a class="reference internal" href="#aw-barrier"><span class="std std-ref">cuda::barrier</span></a>, the kernel threads immediately wait for the data transfer to shared memory to complete. This avoids data transfers from global memory into registers, but does not <em>hide</em> the latency of the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operation by overlapping computation.</p>
<p>For that we use the CUDA <a class="reference internal" href="#pipeline-interface"><span class="std std-ref">pipeline</span></a> feature in the following example. It provides a mechanism for managing a sequence of <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> batches, enabling CUDA kernels to overlap memory transfers with computation. The following example implements a two-stage pipeline that overlaps data-transfer with computation. It:</p>
<ul class="simple">
<li><p>Initializes the pipeline shared state (more below)</p></li>
<li><p>Kickstarts the pipeline by scheduling a <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> for the first batch.</p></li>
<li><p>Loops over all the batches: it schedules <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> for the next batch, blocks all threads on the completion of the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> for the previous batch, and then overlaps the computation on the previous batch with the asynchronous copy of the memory for the next batch.</p></li>
<li><p>Finally, it drains the pipeline by performing the computation on the last batch.</p></li>
</ul>
<p>Note that, for interoperability with <code class="docutils literal notranslate"><span class="pre">cuda::pipeline</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> from the <code class="docutils literal notranslate"><span class="pre">cuda/pipeline</span></code> header is used here.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/pipeline&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">shared_in</span><span class="p">);</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_staging</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Assume input size fits batch_sz * grid_size</span>

<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">stages_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Pipeline with two stages</span>
<span class="w">    </span><span class="c1">// Two batches must fit in shared memory:</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w">  </span><span class="c1">// stages_count * block.size() * sizeof(int) bytes</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">stages_count</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// Offsets to each batch</span>

<span class="w">    </span><span class="c1">// Allocate shared storage for a two-stage cuda::pipeline:</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_shared_state</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">stages_count</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shared_state</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Each thread processes `batch_sz` elements.</span>
<span class="w">    </span><span class="c1">// Compute offset of the batch `batch` of this thread block in global memory:</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize first pipeline stage by submitting a `memcpy_async` to fetch a whole batch for the block:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">batch_sz</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Pipelined copy/compute:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Stage indices for the compute and copy stages:</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">compute_stage_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">batch</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">copy_stage_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively acquire the pipeline head stage from all producer threads:</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Submit async copies to the pipeline&#39;s head stage to be</span>
<span class="w">        </span><span class="c1">// computed in the next loop iteration</span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">copy_stage_idx</span><span class="p">],</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Collectively commit (advance) the pipeline&#39;s head stage</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively wait for the operations commited to the</span>
<span class="w">        </span><span class="c1">// previous `compute` stage to complete:</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Computation overlapped with the memcpy_async of the &quot;copy&quot; stage:</span>
<span class="w">        </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_idx</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">compute_stage_idx</span><span class="p">]);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Collectively release the stage resources</span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Compute the data fetch by the last iteration</span>
<span class="w">    </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_sz</span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[(</span><span class="n">batch_sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A <a class="reference internal" href="#pipeline-interface"><span class="std std-ref">pipeline object</span></a> is a double-ended queue with a <em>head</em> and a <em>tail</em>, and is used to process work in a first-in first-out (FIFO) order. Producer threads commit work to the pipelineâs head, while consumer threads pull work from the pipelineâs tail. In the example above, all threads are both producer and consumer threads. The threads first <em>commit</em><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operations to fetch the <em>next</em> batch while they <em>wait</em> on the <em>previous</em> batch of <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operations to complete.</p>
<ul class="simple">
<li><p>Committing work to a pipeline stage involves:</p>
<ul>
<li><p>Collectively <em>acquiring</em> the pipeline <em>head</em> from a set of producer threads using <code class="docutils literal notranslate"><span class="pre">pipeline.producer_acquire()</span></code>.</p></li>
<li><p>Submitting <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operations to the pipeline head.</p></li>
<li><p>Collectively <em>commiting</em> (advancing) the pipeline head using <code class="docutils literal notranslate"><span class="pre">pipeline.producer_commit()</span></code>.</p></li>
</ul>
</li>
<li><p>Using a previously commited stage involves:</p>
<ul>
<li><p>Collectively waiting for the stage to complete, e.g., using <code class="docutils literal notranslate"><span class="pre">pipeline.consumer_wait()</span></code> to wait on the tail (oldest) stage.</p></li>
<li><p>Collectively <em>releasing</em> the stage using <code class="docutils literal notranslate"><span class="pre">pipeline.consumer_release()</span></code>.</p></li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cuda::pipeline_shared_state&lt;scope,</span> <span class="pre">count&gt;</span></code> encapsulates the finite resources that allow a pipeline to process up to <code class="docutils literal notranslate"><span class="pre">count</span></code> concurrent stages. If all resources are in use, <code class="docutils literal notranslate"><span class="pre">pipeline.producer_acquire()</span></code> blocks producer threads until the resources of the next pipeline stage are released by consumer threads.</p>
<p>This example can be written in a more concise manner by merging the prolog and epilog of the loop with the loop itself as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">stages_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="cm">/* Pipeline with stages_count stages */</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_staging_unified</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Assume input size fits batch_sz * grid_size</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// stages_count * block.size() * sizeof(int) bytes</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">stages_count</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_shared_state</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">stages_count</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shared_state</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// compute_batch: next batch to process</span>
<span class="w">    </span><span class="c1">// fetch_batch:  next batch to fetch from global memory</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">compute_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// The outer loop iterates over the computation of the batches</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">compute_batch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">stages_count</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">fetch_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// This inner loop iterates over the memory transfers, making sure that the pipeline is always full</span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_idx</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">],</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_batch</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_idx</span><span class="p">),</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">pipeline&lt;thread_scope_block&gt;</span></code> primitive used above is very flexible, and supports two features that our examples above are not using: any arbitrary subset of threads in the block can participate in the <code class="docutils literal notranslate"><span class="pre">pipeline</span></code>, and from the threads that participate, any subsets can be producers, consumers, or both. In the following example, threads with an âevenâ thread rank are producers, while other threads are consumers:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared_in</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">stages_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_specialized_staging_unified</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// In this example, threads with &quot;even&quot; thread rank are producers, while threads with &quot;odd&quot; thread rank are consumers:</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_role</span><span class="w"> </span><span class="n">thread_role</span><span class="w"></span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="o">?</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_role</span><span class="o">::</span><span class="n">producer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_role</span><span class="o">::</span><span class="n">consumer</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Each thread block only has half of its threads as producers:</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">producer_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Map adjacent even and odd threads to the same id:</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">elements_per_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">elements_per_batch_per_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elements_per_batch</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">group_dim</span><span class="p">().</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// stages_count * elements_per_batch_per_block * sizeof(int) bytes</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">stages_count</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">elements_per_batch_per_block</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_shared_state</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">stages_count</span><span class="w"></span>
<span class="w">    </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared_state</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">make_pipeline</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shared_state</span><span class="p">,</span><span class="w"> </span><span class="n">thread_role</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Each thread block processes `batch_sz` batches.</span>
<span class="w">    </span><span class="c1">// Compute offset of the batch `batch` of this thread block in global memory:</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">elements_per_batch</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">elements_per_batch_per_block</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">compute_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// The outer loop iterates over the computation of the batches</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">compute_batch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">stages_count</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">fetch_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// This inner loop iterates over the memory transfers, making sure that the pipeline is always full</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_role</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_role</span><span class="o">::</span><span class="n">producer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="c1">// Only the producer threads schedule asynchronous memcpys:</span>
<span class="w">                </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_idx</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_idx</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_idx</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">thread_role</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline_role</span><span class="o">::</span><span class="n">consumer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Only the consumer threads compute:</span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">compute_batch</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_idx</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_idx</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_batch_idx</span><span class="p">));</span><span class="w"></span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>There are some optimizations that <code class="docutils literal notranslate"><span class="pre">pipeline</span></code> performs, for example, when all threads are both producers and consumers, but in general, the cost of supporting all these features cannot be fully eliminated. For example, <code class="docutils literal notranslate"><span class="pre">pipeline</span></code> stores and uses a set of barriers in shared memory for synchronization, which is not really necessary if all threads in the block participate in the pipeline.</p>
<p>For the particular case in which all threads in the block participate in the <code class="docutils literal notranslate"><span class="pre">pipeline</span></code>, we can do better than <code class="docutils literal notranslate"><span class="pre">pipeline&lt;thread_scope_block&gt;</span></code> by using a <code class="docutils literal notranslate"><span class="pre">pipeline&lt;thread_scope_thread&gt;</span></code> combined with <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">stages_count</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">with_staging_scope_thread</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">global_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="c1">// Assume input size fits batch_sz * grid_size</span>

<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shared</span><span class="p">[];</span><span class="w"> </span><span class="c1">// stages_count * block.size() * sizeof(int) bytes</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">stages_count</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// No pipeline::shared_state needed</span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">pipeline</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_thread</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">make_pipeline</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">group_index</span><span class="p">().</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">batch</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">compute_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">batch_sz</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">compute_batch</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">stages_count</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">fetch_batch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fetch_batch</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Each thread fetches its own data:</span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">thread_batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_idx</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="c1">// The copy is performed by a single `thread` and the size of the batch is now that of a single element:</span>
<span class="w">            </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">global_in</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_batch_idx</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">pipeline</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">pipeline</span><span class="p">.</span><span class="n">producer_commit</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_wait</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"> </span><span class="c1">// __syncthreads: All memcpy_async of all threads in the block for this stage have completed here</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">shared_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_batch</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">stages_count</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">batch_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_batch</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">compute</span><span class="p">(</span><span class="n">global_out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">block_batch</span><span class="p">(</span><span class="n">batch_idx</span><span class="p">),</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shared_offset</span><span class="p">[</span><span class="n">shared_idx</span><span class="p">]);</span><span class="w"></span>
<span class="w">        </span><span class="n">pipeline</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">compute</span></code> operation only reads shared memory written to by other threads in the same warp as the current thread, <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> suffices.</p>
</section>
<section id="pipeline-interface">
<span id="id192"></span><h3><span class="section-number">7.28.3. </span>Pipeline Interface<a class="headerlink" href="#pipeline-interface" title="Permalink to this headline">ï</a></h3>
<p>The complete API documentation for <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code> is provided in the <a class="reference external" href="https://nvidia.github.io/libcudacxx">libcudacxx API</a> documentation along with some examples.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">pipeline</span></code> interface requires</p>
<ul class="simple">
<li><p>at least CUDA 11.0,</p></li>
<li><p>at least ISO C++ 2011 compatibility, e.g., to be compiled with <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code>, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;cuda/pipeline&gt;</span></code>.</p></li>
</ul>
<p>For a C-like interface, when compiling without ISO C++ 2011 compatibility, see <a class="reference internal" href="#pipeline-primitives-interface"><span class="std std-ref">Pipeline Primitives Interface</span></a>.</p>
</section>
<section id="pipeline-primitives-interface">
<span id="id193"></span><h3><span class="section-number">7.28.4. </span>Pipeline Primitives Interface<a class="headerlink" href="#pipeline-primitives-interface" title="Permalink to this headline">ï</a></h3>
<p>Pipeline primitives are a C-like interface for <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> functionality. The pipeline primitives interface is available by including the <code class="docutils literal notranslate"><span class="pre">&lt;cuda_pipeline.h&gt;</span></code> header. When compiling without ISO C++ 2011 compatibility, include the <code class="docutils literal notranslate"><span class="pre">&lt;cuda_pipeline_primitives.h&gt;</span></code> header.</p>
<section id="memcpy-async-primitive">
<h4><span class="section-number">7.28.4.1. </span><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> Primitive<a class="headerlink" href="#memcpy-async-primitive" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__pipeline_memcpy_async</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">dst_shared</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">src_global</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size_and_align</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">size_t</span><span class="w"> </span><span class="n">zfill</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul>
<li><p>Request that the following operation be submitted for asynchronous evaluation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size_and_align</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">zfill</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst_shared</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src_global</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="cm">/* copy */</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size_and_align</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst_shared</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* zero-fill */</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Requirements:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dst_shared</span></code> must be a pointer to the shared memory destination for the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">src_global</span></code> must be a pointer to the global memory source for the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_and_align</span></code> must be 4, 8, or 16.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zfill</span> <span class="pre">&lt;=</span> <span class="pre">size_and_align</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_and_align</span></code> must be the alignment of <code class="docutils literal notranslate"><span class="pre">dst_shared</span></code> and <code class="docutils literal notranslate"><span class="pre">src_global</span></code>.</p></li>
</ul>
</li>
<li><p>It is a race condition for any thread to modify the source memory or observe the destination memory prior to waiting for the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operation to complete. Between submitting a <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> operation and waiting for its completion, any of the following actions introduces a race condition:</p>
<ul class="simple">
<li><p>Loading from <code class="docutils literal notranslate"><span class="pre">dst_shared</span></code>.</p></li>
<li><p>Storing to <code class="docutils literal notranslate"><span class="pre">dst_shared</span></code> or <code class="docutils literal notranslate"><span class="pre">src_global</span></code>.</p></li>
<li><p>Applying an atomic update to <code class="docutils literal notranslate"><span class="pre">dst_shared</span></code> or <code class="docutils literal notranslate"><span class="pre">src_global</span></code>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="commit-primitive">
<h4><span class="section-number">7.28.4.2. </span>Commit Primitive<a class="headerlink" href="#commit-primitive" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__pipeline_commit</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Commit submitted <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> to the pipeline as the current batch.</p></li>
</ul>
</section>
<section id="wait-primitive">
<h4><span class="section-number">7.28.4.3. </span>Wait Primitive<a class="headerlink" href="#wait-primitive" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__pipeline_wait_prior</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Let <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">...,</span> <span class="pre">L}</span></code> be the sequence of indices associated with invocations of <code class="docutils literal notranslate"><span class="pre">__pipeline_commit()</span></code> by a given thread.</p></li>
<li><p>Wait for completion of batches <em>at least</em> up to and including <code class="docutils literal notranslate"><span class="pre">L-N</span></code>.</p></li>
</ul>
</section>
<section id="arrive-on-barrier-primitive">
<span id="arrive-primitive"></span><h4><span class="section-number">7.28.4.4. </span>Arrive On Barrier Primitive<a class="headerlink" href="#arrive-on-barrier-primitive" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__pipeline_arrive_on</span><span class="p">(</span><span class="n">__mbarrier_t</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bar</span></code> points to a barrier in shared memory.</p></li>
<li><p>Increments the barrier arrival count by one, when all memcpy_async operations sequenced before this call have completed, the arrival count is decremented by one and hence the net effect on the arrival count is zero. It is userâs responsibility to make sure that the increment on the arrival count does not exceed <code class="docutils literal notranslate"><span class="pre">__mbarrier_maximum_count()</span></code>.</p></li>
</ul>
</section>
</section>
</section>
<section id="asynchronous-data-copies-using-the-tensor-memory-accelerator-tma">
<span id="tensor-memory-access"></span><h2><span class="section-number">7.29. </span>Asynchronous Data Copies using the Tensor Memory Accelerator (TMA)<a class="headerlink" href="#asynchronous-data-copies-using-the-tensor-memory-accelerator-tma" title="Permalink to this headline">ï</a></h2>
<p>Many applications require movement of large amounts of data from and to global
memory. Often, the data is laid out in global memory as a multi-dimensional
array with non-sequential data acess patterns. To reduce global memory usage,
sub-tiles of such arrays are copied to shared memory before use in computations.
The loading and storing involves address-calculations that can be error-prone
and repetitive. To offload these computations, Compute Capability 9.0 introduces the
Tensor Memory Accelerator (TMA). The primary goal of TMA is to provide an efficient
data transfer mechanism from global memory to shared memory for
multi-dimensional arrays.</p>
<p><strong>Naming</strong>. Tensor memory accelerator (TMA) is a broad term used to refer to the
features described in this section. For the purpose of forward-compatibility and
to reduce discrepancies with the PTX ISA, the text in this section refers to TMA
operations as either bulk-asynchronous copies or bulk tensor asynchronous
copies, depending on the specific type of copy used. The term âbulkâ is used to
contrast these operations with the asynchronous memory operations described in
the previous sections.</p>
<p><strong>Dimensions</strong>. TMA supports copying both one-dimensional and multi-dimensional
arrays (up to 5-dimensional). The programming model for <strong>bulk-asynchronous
copies</strong> of one-dimensional contiguous arrays is different from the programming
model for <strong>bulk tensor asynchronous copies</strong> of multi-dimensional arrays. To
perform a bulk tensor asynchronous copy of a multi-dimensional array, the
hardware requires a <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/structCUtensorMap.html#structCUtensorMap">tensor map</a>.
This object describes the layout of the multi-dimensional array in global and
shared memory. A tensor map is typically created on the host using the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY">cuTensorMapEncode
API</a>
and then transferred from host to device as a <code class="docutils literal notranslate"><span class="pre">const</span></code> kernel parameter annotated
with <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code>.
The tensor map is transferred from host to device as a <code class="docutils literal notranslate"><span class="pre">const</span></code> kernel
parameter annotated with <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code>, and can be used on the device to
copy a tile of data between shared and global memory. In contrast, performing a
bulk-asynchronous copy of a contiguous one-dimensional array does not require a
tensor map: it can be performed on-device with a pointer and size parameter.</p>
<p><strong>Source and destination</strong>. The source and destination addresses of bulk-asynchronous copy
operations can be in shared or global memory. The operations can read data from global to
shared memory, write data from shared to global memory, and also copy from
shared memory to <a class="reference internal" href="#distributed-shared-memory"><span class="std std-ref">Distributed Shared Memory</span></a> of another block in the same cluster.
In addition, when in a cluster, a bulk-asynchronous operation can be specified as being
multicast. In this case, data can be transferred from global memory to the
shared memory of multiple blocks within the cluster. The multicast feature is
optimized for target architecture <code class="docutils literal notranslate"><span class="pre">sm_90a</span></code> and may have <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">significantly reduced performance</a> on
other targets. Hence, it is advised to be used with <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-feature-list">compute architecture</a>
<code class="docutils literal notranslate"><span class="pre">sm_90a</span></code>.</p>
<p><strong>Asynchronous</strong>. Data transfers using TMA are <a class="reference internal" href="#asynchronous-simt-programming-model"><span class="std std-ref">asynchronous</span></a>. This allows the initiating
thread to continue computing while the hardware asynchronously copies the data.
<strong>Whether the data transfer occurs asynchronously in practice is up to the hardware implementation and may change in the future</strong>.
There are several <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-asynchronous-copy-completion-mechanisms">completion mechanisms</a>
that bulk-asynchronous operations can use to signal that they have completed.
When the operation reads from global to shared memory, any
thread in the block can wait for the data to be readable in shared memory by
waiting on a <a class="reference internal" href="#aw-barrier"><span class="std std-ref">Shared Memory Barrier</span></a>. When the bulk-asynchronous
operation writes data from shared memory to global or distributed shared memory,
only the initiating thread can wait for the operation to have completed.
This is accomplished using a <em>bulk async-group</em> based completion mechanism. A
table describing the completion mechanisms can be found below and in the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk">PTX ISA</a>.</p>
<table class="small colwidths-auto docutils align-center" id="table-tma-source-dest-state-spaces">
<caption><span class="caption-number">Table 9 </span><span class="caption-text">Asynchronous copies with possible source and destinations memory spaces and completion mechanisms. An empty cell indicates that a source-destination pair is not supported.</span><a class="headerlink" href="#table-tma-source-dest-state-spaces" title="Permalink to this table">ï</a></caption>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Direction</p></th>
<th class="head" colspan="2"><p>Completion mechanism</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Destination</p></th>
<th class="head"><p>Source</p></th>
<th class="head"><p>Asychronous copy</p></th>
<th class="head"><p>Bulk-asynchronous copy (TMA)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Global</p></td>
<td><p>Global</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Global</p></td>
<td><p>Shared::cta</p></td>
<td></td>
<td><p>Bulk async-group</p></td>
</tr>
<tr class="row-odd"><td><p>Shared::cta</p></td>
<td><p>Global</p></td>
<td><p>Async-group, mbarrier</p></td>
<td><p>Mbarrier</p></td>
</tr>
<tr class="row-even"><td><p>Shared::cluster</p></td>
<td><p>Global</p></td>
<td></td>
<td><p>Mbarrier (multicast)</p></td>
</tr>
<tr class="row-odd"><td><p>Shared::cta</p></td>
<td><p>Shared::cluster</p></td>
<td></td>
<td><p>Mbarrier</p></td>
</tr>
<tr class="row-even"><td><p>Shared::cta</p></td>
<td><p>Shared::cta</p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<section id="using-tma-to-transfer-one-dimensional-arrays">
<h3><span class="section-number">7.29.1. </span>Using TMA to transfer one-dimensional arrays<a class="headerlink" href="#using-tma-to-transfer-one-dimensional-arrays" title="Permalink to this headline">ï</a></h3>
<p>This section demonstrates how to write a simple kernel that read-modify-writes a
one-dimensional array using TMA. This shows how to how to load and store data
using bulk-asynchronous copies, as well as how to synchronize threads of
execution with those copies.</p>
<p>The code of the kernel is included below. Some functionality requires inline PTX
assembly that is currently made available through <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx.html">libcu++</a>.
The availability of these wrappers can be
checked with the following code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(__CUDA_MINIMUM_ARCH__) &amp;&amp; __CUDA_MINIMUM_ARCH__ &lt; 900</span>
<span class="k">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Device code is being compiled with older architectures that are incompatible with TMA.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif </span><span class="c1">// __CUDA_MINIMUM_ARCH__</span>
</pre></div>
</div>
<p>The kernel goes through the following stages:</p>
<ol class="arabic simple">
<li><p>Initialize shared memory barrier.</p></li>
<li><p>Initiate bulk-asynchronous copy of a block of memory from global to shared memory.</p></li>
<li><p>Arrive and wait on the shared memory barrier.</p></li>
<li><p>Increment the shared memory buffer values.</p></li>
<li><p>Wait for shared memory writes to be visible to the subsequent bulk-asynchronous copy, i.e., order the shared memory writes in the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#async-proxy">async proxy</a> before the next step.</p></li>
<li><p>Initiate bulk-asynchronous copy of the buffer in shared memory to global memory.</p></li>
<li><p>Wait at end of kernel for bulk-asynchronous copy to have finished reading shared memory.</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/ptx&gt;</span><span class="cp"></span>
<span class="k">using</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cuda</span><span class="o">::</span><span class="nn">ptx</span><span class="p">;</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buf_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">add_one_kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Shared memory buffer. The destination shared memory buffer of</span>
<span class="w">  </span><span class="c1">// a bulk operations should be 16 byte aligned.</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem_data</span><span class="p">[</span><span class="n">buf_len</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 1. a) Initialize shared memory barrier with the number of threads participating in the barrier.</span>
<span class="w">  </span><span class="c1">//    b) Make initialized barrier visible in async proxy.</span>
<span class="w">  </span><span class="cp">#pragma nv_diag_suppress static_var_with_dynamic_init</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w">                      </span><span class="c1">// a)</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">);</span><span class="w">   </span><span class="c1">// b)</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. Initiate TMA transfer to copy global to shared memory.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 3a. cuda::memcpy_async arrives on the barrier and communicates</span>
<span class="w">    </span><span class="c1">//     how many bytes are expected to come in (the transaction count)</span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">smem_data</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">cuda</span><span class="o">::</span><span class="n">aligned_size_t</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">smem_data</span><span class="p">)),</span><span class="w"></span>
<span class="w">        </span><span class="n">bar</span><span class="w"></span>
<span class="w">    </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// 3b. All threads arrive on the barrier</span>
<span class="w">  </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// 3c. Wait for the data to have arrived.</span>
<span class="w">  </span><span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 4. Compute saxpy and write back to shared memory</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buf_len</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">smem_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 5. Wait for shared memory writes to be visible to TMA engine.</span>
<span class="w">  </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">);</span><span class="w">   </span><span class="c1">// b)</span>
<span class="w">  </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// After syncthreads, writes by all threads are visible to TMA engine.</span>

<span class="w">  </span><span class="c1">// 6. Initiate TMA transfer to copy shared memory to global memory</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">cp_async_bulk</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_global</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">smem_data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">smem_data</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="c1">// 7. Wait for TMA transfer to have finished reading shared memory.</span>
<span class="w">    </span><span class="c1">// Create a &quot;bulk async-group&quot; out of the previous bulk copy operation.</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">cp_async_bulk_commit_group</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Wait for the group to have completed reading from shared memory.</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">cp_async_bulk_wait_group_read</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Barrier initialization</strong>. The barrier is initialized with the number of
threads participating in the block. As a result, the barrier will flip only if
all threads have arrived on this barrier. Shared memory barriers are described
in more detail in <a class="reference internal" href="#memcpy-async-barrier"><span class="std std-ref">Asynchronous Data Copies using cuda::barrier</span></a>.
To make the initialized barrier visible to subsequent bulk-asynchronous copies, the
<code class="docutils literal notranslate"><span class="pre">fence.proxy.async.shared::cta</span></code> instruction is used. This instruction ensures that
subsequent bulk-asynchronous copy operations operate on the initialized barrier.</p>
<p><strong>TMA read</strong>. The bulk-asynchronous copy instruction directs the
hardware to copy a large chunk of data into shared memory, and to update the
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier-tracking-async-operations">transaction count</a>
of the shared memory barrier after completing the read. In general, issuing as
few bulk copies with as big a size as possible results in the best performance.
Because the copy can be performed asynchronously by the hardware, it is not
necessary to split the copy into smaller chunks.</p>
<p>The thread that initiates the bulk-asynchronous copy operation arrives at the barrier
using <code class="docutils literal notranslate"><span class="pre">mbarrier.expect_tx</span></code>. This is automatically performed by <code class="docutils literal notranslate"><span class="pre">cuda::memcpy_async</span></code>. This tells the barrier that the thread has
arrived and also how many bytes (tx / transactions) are expected to arrive. Only
a single thread has to update the expected transaction count. If multiple
threads update the transaction count, the expected transaction will be the sum
of the updates. The barrier will only flip once all threads have arrived <strong>and</strong>
all bytes have arrived. Once the barrier has flipped, the bytes are safe to read
from shared memory, both by the threads as well as by subsequent
bulk-asynchronous copies. More information about barrier transaction accounting
can be found in the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier-tracking-async-operations">PTX ISA</a>.</p>
<p><strong>Barrier wait</strong>. Waiting for the barrier to flip is done using
<code class="docutils literal notranslate"><span class="pre">mbarrier.try_wait</span></code>. It can either return true, indicating that the wait is
over, or return false, which may mean that the wait timed out. The while loop
waits for completion, and retries on time-out.</p>
<p><strong>SMEM write and sync</strong>. The increment of the buffer values reads and writes to shared
memory. To make the writes visible to subsequent bulk-asynchronous copies, the
<code class="docutils literal notranslate"><span class="pre">fence.proxy.async.shared::cta</span></code> instruction is used. This orders the writes to
shared memory before subsequent reads from bulk-asynchronous copy operations,
which read through the async proxy. So each thread first orders the writes to
objects in shared memory in the async proxy via the
<code class="docutils literal notranslate"><span class="pre">fence.proxy.async.shared::cta</span></code>, and these operations by all threads are
ordered before the async operation performed in thread 0 using
<code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>.</p>
<p><strong>TMA write and sync</strong>. The write from shared to global memory is again
initiated by a single thread. The completion of the write is not tracked by a
shared memory barrier. Instead, a thread-local mechanism is used. Multiple
writes can be batched into a so-called <em>bulk async-group</em>. Afterwards, the
thread can wait for all operations in this group to have completed reading from
shared memory (as in the code above) or to have completed writing to global
memory, making the writes visible to the initiating thread. For more information,
refer to the PTX ISA documentation of <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-wait-group">cp.async.bulk.wait_group</a>.
Note that the bulk-asynchronous and non-bulk asynchronous copy instructions have
different async-groups: there exist both <code class="docutils literal notranslate"><span class="pre">cp.async.wait_group</span></code> and
<code class="docutils literal notranslate"><span class="pre">cp.async.bulk.wait_group</span></code> instructions.</p>
<p>The bulk-asynchronous instructions have specific alignment requirements on their source and
destination addresses. More information can be found in the table below.</p>
<table class="docutils align-default" id="table-alignment-one-dim-tma">
<caption><span class="caption-number">Table 10 </span><span class="caption-text">Alignment requirements for one-dimensional bulk-asynchronous operations in Compute Capability 9.0.</span><a class="headerlink" href="#table-alignment-one-dim-tma" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address / Size</p></th>
<th class="head"><p>Alignment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Global memory address</p></td>
<td><p>Must be 16 byte aligned.</p></td>
</tr>
<tr class="row-odd"><td><p>Shared memory address</p></td>
<td><p>Must be 16 byte aligned.</p></td>
</tr>
<tr class="row-even"><td><p>Shared memory barrier address</p></td>
<td><p>Must be 8 byte aligned (this is guaranteed by <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p>Size of transfer</p></td>
<td><p>Must be a multiple of 16 bytes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="using-tma-to-transfer-multi-dimensional-arrays">
<h3><span class="section-number">7.29.2. </span>Using TMA to transfer multi-dimensional arrays<a class="headerlink" href="#using-tma-to-transfer-multi-dimensional-arrays" title="Permalink to this headline">ï</a></h3>
<p>The primary difference between the one-dimensional and multi-dimensional case is
that a tensor map must be created on the host and passed to the CUDA kernel.
This section describes how to create a tensor map using the CUDA driver API, how
to pass it to device, and how to use it on device.</p>
<p><strong>Driver API</strong>. A tensor map is created using the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TENSOR__MEMORY.html">cuTensorMapEncodeTiled</a>
driver API. This API can be accessed by linking to the driver directly
(<code class="docutils literal notranslate"><span class="pre">-lcuda</span></code>) or by using the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DRIVER__ENTRY__POINT.html">cudaGetDriverEntryPoint</a>
API. Below, we show how to get a pointer to the <code class="docutils literal notranslate"><span class="pre">cuTensorMapEncodeTiled</span></code> API.
For more information, refer to <a class="reference internal" href="#driver-entry-point-access"><span class="std std-ref">Driver Entry Point Access</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="c1"> // PFN_cuTensorMapEncodeTiled, CUtensorMap</span><span class="cp"></span>

<span class="n">PFN_cuTensorMapEncodeTiled_v12000</span><span class="w"> </span><span class="nf">get_cuTensorMapEncodeTiled</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Get pointer to cuTensorMapEncodeTiled</span>
<span class="w">  </span><span class="n">cudaDriverEntryPointQueryResult</span><span class="w"> </span><span class="n">driver_status</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaGetDriverEntryPointByVersion</span><span class="p">(</span><span class="s">&quot;cuTensorMapEncodeTiled&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cuTensorMapEncodeTiled_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">12000</span><span class="p">,</span><span class="w"> </span><span class="n">cudaEnableDefault</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driver_status</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">driver_status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaDriverEntryPointSuccess</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PFN_cuTensorMapEncodeTiled_v12000</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cuTensorMapEncodeTiled_ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Creation</strong>. Creating a tensor map requires many parameters. Among
them are the base pointer to an array in global memory, the size of the array
(in number of elements), the stride from one row to the next (in bytes), the
size of the shared memory buffer (in number of elements). The code below creates
a tensor map to describe a two-dimensional row-major array of size <code class="docutils literal notranslate"><span class="pre">GMEM_HEIGHT</span>
<span class="pre">x</span> <span class="pre">GMEM_WIDTH</span></code>. Note the order of the parameters: the fastest moving dimension
comes first.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">{};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// rank is the number of dimensions of the array.</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">GMEM_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">GMEM_HEIGHT</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The stride is the number of bytes to traverse from the first element of one row to the next.</span>
<span class="w">  </span><span class="c1">// It must be a multiple of 16.</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">rank</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">GMEM_WIDTH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The box_size is the size of the shared memory buffer that is used as the</span>
<span class="w">  </span><span class="c1">// destination of a TMA transfer.</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">box_size</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">SMEM_WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">SMEM_HEIGHT</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The distance between elements in units of sizeof(element). A stride of 2</span>
<span class="w">  </span><span class="c1">// can be used to load only the real component of a complex-valued tensor, for instance.</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">elem_stride</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Get a function pointer to the cuTensorMapEncodeTiled driver API.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_cuTensorMapEncodeTiled</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create the tensor descriptor.</span>
<span class="w">  </span><span class="n">CUresult</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w">                </span><span class="c1">// CUtensorMap *tensorMap,</span>
<span class="w">    </span><span class="n">CUtensorMapDataType</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_DATA_TYPE_INT32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">rank</span><span class="p">,</span><span class="w">                       </span><span class="c1">// cuuint32_t tensorRank,</span>
<span class="w">    </span><span class="n">tensor_ptr</span><span class="p">,</span><span class="w">                 </span><span class="c1">// void *globalAddress,</span>
<span class="w">    </span><span class="n">size</span><span class="p">,</span><span class="w">                       </span><span class="c1">// const cuuint64_t *globalDim,</span>
<span class="w">    </span><span class="n">stride</span><span class="p">,</span><span class="w">                     </span><span class="c1">// const cuuint64_t *globalStrides,</span>
<span class="w">    </span><span class="n">box_size</span><span class="p">,</span><span class="w">                   </span><span class="c1">// const cuuint32_t *boxDim,</span>
<span class="w">    </span><span class="n">elem_stride</span><span class="p">,</span><span class="w">                </span><span class="c1">// const cuuint32_t *elementStrides,</span>
<span class="w">    </span><span class="c1">// Interleave patterns can be used to accelerate loading of values that</span>
<span class="w">    </span><span class="c1">// are less than 4 bytes long.</span>
<span class="w">    </span><span class="n">CUtensorMapInterleave</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_INTERLEAVE_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Swizzling can be used to avoid shared memory bank conflicts.</span>
<span class="w">    </span><span class="n">CUtensorMapSwizzle</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_SWIZZLE_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// L2 Promotion can be used to widen the effect of a cache-policy to a wider</span>
<span class="w">    </span><span class="c1">// set of L2 cache lines.</span>
<span class="w">    </span><span class="n">CUtensorMapL2promotion</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_L2_PROMOTION_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Any element that is outside of bounds will be set to zero by the TMA transfer.</span>
<span class="w">    </span><span class="n">CUtensorMapFloatOOBfill</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE</span><span class="w"></span>
<span class="w">  </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Host-to-device transfer</strong>. There are three ways to make a tensor map accessible to
device code. The recommended approach is to pass the tensor map as a const <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code>
parameter to a kernel. The other possibilities are copying the tensor map into device <code class="docutils literal notranslate"><span class="pre">__constant__</span></code>
memory using <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol</span></code> or accessing it via global memory. When passing the tensor map as a parameter, some versions of the
GCC C++ compiler issue the warning âthe ABI for passing parameters with 64-byte
alignment has changed in GCC 4.6â. This warning can be ignored.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__grid_constant__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Use tensor_map here.</span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">map</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// [ ..Initialize map.. ]</span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">map</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As an alternative to the <code class="docutils literal notranslate"><span class="pre">__grid_constant__</span></code> kernel parameter, a global
<a class="reference internal" href="#constant"><span class="std std-ref">constant</span></a> variable can be used. An example is included
below.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>

<span class="kt">__constant__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">global_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Use global_tensor_map here.</span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">local_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// [ ..Initialize map.. ]</span>
<span class="w">  </span><span class="n">cudaMemcpyToSymbol</span><span class="p">(</span><span class="n">global_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">local_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUtensorMap</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Finally, it is possible to copy the tensor map to global memory. Using a pointer to a
tensor map in global device memory requires a fence in each thread block before any thread
in the block uses the updated tensor map. Further uses of the tensor map by that thread block
do not need to be fenced unless the tensor map is modified again. Note that this mechanism
may be slower than the two mechanisms described above.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/ptx&gt;</span><span class="cp"></span>
<span class="n">namespace</span><span class="w"> </span><span class="n">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">ptx</span><span class="p">;</span><span class="w"></span>

<span class="kt">__device__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">global_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Fence acquire tensor map:</span>
<span class="w">  </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Since the tensor map was modified from the host using cudaMemcpy,</span>
<span class="w">  </span><span class="c1">// the scope should be .sys.</span>
<span class="w">  </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_tensormap_generic</span><span class="p">(</span><span class="w"></span>
<span class="w">     </span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_sys</span><span class="p">,</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">size_bytes</span><span class="w"></span>
<span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="c1">// Safe to use tensor_map after fence inside this thread..</span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">local_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// [ ..Initialize map.. ]</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">local_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUtensorMap</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">global_tensor_map</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Use</strong>. The kernel below loads a 2D tile of size <code class="docutils literal notranslate"><span class="pre">SMEM_HEIGHT</span> <span class="pre">x</span> <span class="pre">SMEM_WIDTH</span></code>
from a larger 2D array. The top-left corner of the tile is indicated by the
indices <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>. The tile is loaded into shared memory, modified, and
written back to global memory.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="c1">         // CUtensormap</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/barrier&gt;</span><span class="cp"></span>
<span class="n">using</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="n">namespace</span><span class="w"> </span><span class="n">cde</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span><span class="w"></span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__grid_constant__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// The destination shared memory buffer of a bulk tensor operation should be</span>
<span class="w">  </span><span class="c1">// 128 byte aligned.</span>
<span class="w">  </span><span class="kt">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem_buffer</span><span class="p">[</span><span class="n">SMEM_HEIGHT</span><span class="p">][</span><span class="n">SMEM_WIDTH</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Initialize shared memory barrier with the number of threads participating in the barrier.</span>
<span class="w">  </span><span class="cp">#pragma nv_diag_suppress static_var_with_dynamic_init</span>
<span class="w">  </span><span class="kt">__shared__</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialize barrier. All `blockDim.x` threads in block participate.</span>
<span class="w">    </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="nb">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Make initialized barrier visible in async proxy.</span>
<span class="w">    </span><span class="n">cde</span><span class="o">::</span><span class="n">fence_proxy_async_shared_cta</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Syncthreads so initialized barrier is visible to all threads.</span>
<span class="w">  </span><span class="nf">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initiate bulk tensor copy.</span>
<span class="w">    </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_global_to_shared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smem_buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Arrive on the barrier and tell how many bytes are expected to come in.</span>
<span class="w">    </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">barrier_arrive_tx</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">smem_buffer</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Other threads just arrive.</span>
<span class="w">    </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Wait for the data to have arrived.</span>
<span class="w">  </span><span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Symbolically modify a value in shared memory.</span>
<span class="w">  </span><span class="n">smem_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Wait for shared memory writes to be visible to TMA engine.</span>
<span class="w">  </span><span class="n">cde</span><span class="o">::</span><span class="n">fence_proxy_async_shared_cta</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="nf">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// After syncthreads, writes by all threads are visible to TMA engine.</span>

<span class="w">  </span><span class="c1">// Initiate TMA transfer to copy shared memory to global memory</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_shared_to_global</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_buffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Wait for TMA transfer to have finished reading shared memory.</span>
<span class="w">    </span><span class="c1">// Create a &quot;bulk async-group&quot; out of the previous bulk copy operation.</span>
<span class="w">    </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_commit_group</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Wait for the group to have completed reading from shared memory.</span>
<span class="w">    </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_wait_group_read</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Destroy barrier. This invalidates the memory region of the barrier. If</span>
<span class="w">  </span><span class="c1">// further computations were to take place in the kernel, this allows the</span>
<span class="w">  </span><span class="c1">// memory location of the shared memory barrier to be reused.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">barrier</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Negative indices and out of bounds</strong>. When part of the tile that is being
<em>read</em> from global to shared memory is out of bounds, the shared memory that
corresponds to the out of bounds area is zero-filled. The top-left corner
indices of the tile may also be negative. When <em>writing</em> from shared to global
memory, parts of the tile may be out of bounds, but the top left corner cannot
have any negative indices.</p>
<p><strong>Size and stride</strong>. The size of a tensor is the number of elements along one
dimension. All sizes must be greater than one. The stride is the number of bytes
between elements of the same dimension. For instance, a <cite>4 x 4</cite> matrix of
integers has sizes 4 and 4. Since it has 4 bytes per element, the strides are 4
and 16 bytes. Due to alignment requirements, a <cite>4 x 3</cite> row-major matrix of
integers must have strides of 4 and 16 bytes as well. Each row is padded with 4
extra bytes to ensure that the start of the next row is aligned to 16 bytes. For
more information regarding alignment, refer to Table
<a class="reference internal" href="#table-alignment-multi-dim-tma"><span class="std std-ref">Alignment requirements for multi-dimensional bulk tensor asynchronous copy operations in Compute Capability 9.0.</span></a>.</p>
<table class="docutils align-default" id="table-alignment-multi-dim-tma">
<caption><span class="caption-number">Table 11 </span><span class="caption-text">Alignment requirements for multi-dimensional bulk tensor asynchronous copy operations in Compute Capability 9.0.</span><a class="headerlink" href="#table-alignment-multi-dim-tma" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address / Size</p></th>
<th class="head"><p>Alignment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Global memory address</p></td>
<td><p>Must be 16 byte aligned.</p></td>
</tr>
<tr class="row-odd"><td><p>Global memory sizes</p></td>
<td><p>Must be greater than or equal to one. Does not have to be a multiple of 16 bytes.</p></td>
</tr>
<tr class="row-even"><td><p>Global memory strides</p></td>
<td><p>Must be multiples of 16 bytes.</p></td>
</tr>
<tr class="row-odd"><td><p>Shared memory address</p></td>
<td><p>Must be 128 byte aligned.</p></td>
</tr>
<tr class="row-even"><td><p>Shared memory barrier address</p></td>
<td><p>Must be 8 byte aligned (this is guaranteed by <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p>Size of transfer</p></td>
<td><p>Must be a multiple of 16 bytes.</p></td>
</tr>
</tbody>
</table>
<section id="multi-dimensional-tma-ptx-wrappers">
<span id="tma-multi-dim-ptx-wrappers"></span><h4><span class="section-number">7.29.2.1. </span>Multi-dimensional TMA PTX wrappers<a class="headerlink" href="#multi-dimensional-tma-ptx-wrappers" title="Permalink to this headline">ï</a></h4>
<p>Below, the PTX instructions are ordered by their use in the example code above.</p>
<p>The <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor">cp.async.bulk.tensor</a>
instructions initiate a bulk tensor asynchronous copy between global and shared memory. The
wrappers below read from global to shared memory and write from shared to global
memory.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_1d_global_to_shared</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_global_to_shared</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_3d_global_to_shared</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_4d_global_to_shared</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c3</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_5d_global_to_shared</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c3</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c4</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">barrier</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_1d_shared_to_global</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_shared_to_global</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_3d_shared_to_global</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_4d_shared_to_global</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c3</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">experimental</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_5d_shared_to_global</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="o">*</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c3</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c4</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="tma-swizzle">
<span id="id194"></span><h3><span class="section-number">7.29.3. </span>TMA Swizzle<a class="headerlink" href="#tma-swizzle" title="Permalink to this headline">ï</a></h3>
<p>By default, the TMA engine loads data to shared memory in the same order as it is laid out in global memory. However, this
layout may not be optimal for certain shared memory access patterns, as it could cause shared memory bank conflicts. To
improve performance and reduce bank conflicts, we can change the shared memory layout by applying a âswizzle patternâ.</p>
<p>Shared memory has 32 banks that are organized such that successive 32-bit words map to successive banks. Each bank has a
bandwidth of 32 bits per clock cycle. When loading and storing shared memory, bank conflicts arise if the same bank is
used multiple times within a transaction, resulting in reduced bandwidth. See <a class="reference internal" href="#shared-memory-5-x"><span class="std std-ref">Shared Memory</span></a>, bank conflicts.</p>
<p>To ensure that data is laid out in shared memory in such a way that user code can avoid shared memory bank conflicts,
the TMA engine can be instructed to âswizzleâ the data before storing it in shared memory and âunswizzleâ it when copying
the data back from shared memory to global memory. The tensor map encodes the âswizzle modeâ indicating which swizzle pattern is used.</p>
<section id="example-matrix-transpose">
<h4><span class="section-number">7.29.3.1. </span>Example âMatrix Transposeâ<a class="headerlink" href="#example-matrix-transpose" title="Permalink to this headline">ï</a></h4>
<p>An example is the transpose of a matrix where data is mapped from row to column first access. The data is stored row major in
global memory, but we want to also access it column wise in shared memory, which leads to bank conflicts. However, by using
the 128 bytes âswizzleâ mode and new shared memory indices, they are eliminated.</p>
<p>In the example, we load an 8x8 matrix of type <code class="docutils literal notranslate"><span class="pre">int4</span></code>, stored as row major in global memory to shared memory. Then, each set of eight
threads loads a row from the shared memory buffer and stores it to a column in a separate transpose shared memory buffer. This
results in an eight-way bank conflict when storing. Finally, the transpose buffer is written back to global memory.</p>
<p>To avoid bank conflicts, the <code class="docutils literal notranslate"><span class="pre">CU_TENSOR_MAP_SWIZZLE_128B</span></code> layout can be used. This layout matches the 128 bytes row length and
changes the shared memory layout in a way that both the column wise and row wise access donât require the same banks per transaction.</p>
<p>The two tables,  <a class="reference internal" href="#figure-swizzle-example1"><span class="std std-numref">Figure 26</span></a> and  <a class="reference internal" href="#figure-swizzle-example2"><span class="std std-numref">Figure 27</span></a>,  below show the normal and the swizzled shared memory layout of the 8x8 matrix of type <code class="docutils literal notranslate"><span class="pre">int4</span></code> and
its transpose matrix. The colors indicate which of the eight groups of four banks the matrix element is mapped to, and
the margin row and margin column list the global memory row and column indices. The entries show the shared memory
indices of the 16-byte matrix elements.</p>
<figure class="align-center" id="id466">
<span id="figure-swizzle-example1"></span><a class="reference internal image-reference" href="_images/example1.png"><img alt="The shared memory data layout without swizzle" src="_images/example1.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 26 </span><span class="caption-text">In the shared memory data layout without swizzle, the shared memory indices are equivalent to the global memory indices.
Per load instruction, one row is read and stored in a column of the transpose buffer. Since all matrix elements of the
column in the transpose fall in the same bank, the store must be serialized, resulting in eight store transactions, giving
an eight-way bank conflict per stored column.</span><a class="headerlink" href="#id466" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<figure class="align-center" id="id467">
<span id="figure-swizzle-example2"></span><a class="reference internal image-reference" href="_images/example2.png"><img alt="The shared memory data layout with CU_TENSOR_MAP_SWIZZLE_128B swizzle." src="_images/example2.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 27 </span><span class="caption-text">The shared memory data layout with <code class="docutils literal notranslate"><span class="pre">CU_TENSOR_MAP_SWIZZLE_128B</span></code> swizzle. One row is stored in a column, each matrix
element is from a different bank for both the rows and columns, and so without any bank conflicts.</span><a class="headerlink" href="#id467" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel_tma</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__grid_constant__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// The destination shared memory buffer of a bulk tensor operation</span>
<span class="w">   </span><span class="c1">// with the 128-byte swizzle mode, it should be 1024 bytes aligned.</span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="n">int4</span><span class="w"> </span><span class="n">smem_buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="n">int4</span><span class="w"> </span><span class="n">smem_buffer_tr</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Initialize shared memory barrier</span>
<span class="w">   </span><span class="cp">#pragma nv_diag_suppress static_var_with_dynamic_init</span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">cde</span><span class="o">::</span><span class="n">fence_proxy_async_shared_cta</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="n">barrier</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="n">token</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// Initiate bulk tensor copy from global to shared memory,</span>
<span class="w">     </span><span class="c1">// in the same way as without swizzle.</span>
<span class="w">     </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_global_to_shared</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smem_buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
<span class="w">     </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">barrier_arrive_tx</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">smem_buffer</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bar</span><span class="p">.</span><span class="n">arrive</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"></span>

<span class="w">   </span><span class="cm">/* Matrix transpose</span>
<span class="cm">    *  When using the normal shared memory layout, there are eight</span>
<span class="cm">    *  8-way shared memory bank conflict when storing to the transpose.</span>
<span class="cm">    *  When enabling the 128-byte swizzle pattern and using the according access pattern,</span>
<span class="cm">    *  they are eliminated both for load and store. */</span><span class="w"></span>
<span class="w">   </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sidx_j</span><span class="w"> </span><span class="o">=</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">sidx_j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">sidx_j</span><span class="o">+=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">){</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">sidx_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">sidx_i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">sidx_i</span><span class="p">){</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">swiz_j_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sidx_i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">sidx_j</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">swiz_i_idx_tr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">sidx_j</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">sidx_i</span><span class="p">;</span><span class="w"></span>
<span class="w">         </span><span class="n">smem_buffer_tr</span><span class="p">[</span><span class="n">sidx_j</span><span class="p">][</span><span class="n">swiz_i_idx_tr</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smem_buffer</span><span class="p">[</span><span class="n">sidx_i</span><span class="p">][</span><span class="n">swiz_j_idx</span><span class="p">];</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Wait for shared memory writes to be visible to TMA engine.</span>
<span class="w">   </span><span class="n">cde</span><span class="o">::</span><span class="n">fence_proxy_async_shared_cta</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="cm">/* Initiate TMA transfer to copy the transposed shared memory buffer back to global memory,</span>
<span class="cm">    * it will &#39;unswizzle&#39; the data. */</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_tensor_2d_shared_to_global</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_buffer_tr</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_commit_group</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="n">cde</span><span class="o">::</span><span class="n">cp_async_bulk_wait_group_read</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Destroy barrier</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">barrier</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// --------------------------------- main ----------------------------------------</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d_data</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">{};</span><span class="w"></span>
<span class="w">   </span><span class="c1">// rank is the number of dimensions of the array.</span>
<span class="w">   </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// global memory size</span>
<span class="w">   </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"></span>
<span class="w">   </span><span class="c1">// global memory stride, must be a multiple of 16.</span>
<span class="w">   </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">stride</span><span class="p">[</span><span class="n">rank</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">int4</span><span class="p">)};</span><span class="w"></span>
<span class="w">   </span><span class="c1">// The inner shared memory box dimension in bytes, equal to the swizzle span.</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">box_size</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">4</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">elem_stride</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Create the tensor descriptor.</span>
<span class="w">   </span><span class="n">CUresult</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled</span><span class="p">(</span><span class="w"></span>
<span class="w">       </span><span class="o">&amp;</span><span class="n">tensor_map</span><span class="p">,</span><span class="w">                </span><span class="c1">// CUtensorMap *tensorMap,</span>
<span class="w">       </span><span class="n">CUtensorMapDataType</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_DATA_TYPE_INT32</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="n">rank</span><span class="p">,</span><span class="w">                       </span><span class="c1">// cuuint32_t tensorRank,</span>
<span class="w">       </span><span class="n">tensor_ptr</span><span class="p">,</span><span class="w">                 </span><span class="c1">// void *globalAddress,</span>
<span class="w">       </span><span class="n">size</span><span class="p">,</span><span class="w">                       </span><span class="c1">// const cuuint64_t *globalDim,</span>
<span class="w">       </span><span class="n">stride</span><span class="p">,</span><span class="w">                     </span><span class="c1">// const cuuint64_t *globalStrides,</span>
<span class="w">       </span><span class="n">box_size</span><span class="p">,</span><span class="w">                   </span><span class="c1">// const cuuint32_t *boxDim,</span>
<span class="w">       </span><span class="n">elem_stride</span><span class="p">,</span><span class="w">                </span><span class="c1">// const cuuint32_t *elementStrides,</span>
<span class="w">       </span><span class="n">CUtensorMapInterleave</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_INTERLEAVE_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Using a swizzle pattern of 128 bytes.</span>
<span class="w">       </span><span class="n">CUtensorMapSwizzle</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_SWIZZLE_128B</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="n">CUtensorMapL2promotion</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_L2_PROMOTION_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">       </span><span class="n">CUtensorMapFloatOOBfill</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE</span><span class="w"></span>
<span class="w">   </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="n">kernel_tma</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">tensor_map</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Remark.</strong> This example is supposed to show the use of swizzle and âas-isâ is not performant nor does it scale beyond the given dimensions.</p>
<p><strong>Explanation.</strong> During data transfer, the TMA engine shuffles the data according to the swizzle pattern, as described in the following
tables. These swizzle patterns define the mapping of the 16-byte chunks along the swizzle width to subgroups of four banks.
It is of type <code class="docutils literal notranslate"><span class="pre">CUtensorMapSwizzle</span></code> and has four options: none, 32 bytes, 64 bytes and 128 bytes. Note that the shared memory boxâs
inner dimension must be less or equal to the span of the swizzle pattern.</p>
</section>
<section id="the-swizzle-modes">
<h4><span class="section-number">7.29.3.2. </span>The Swizzle Modes<a class="headerlink" href="#the-swizzle-modes" title="Permalink to this headline">ï</a></h4>
<p>As previously mentioned, there are four swizzle modes. The following tables show the different swizzle patterns, including the relation of the new
shared memory indices. The tables define the mapping of the 16-byte chunks along the 128 bytes to eight subgroups of four banks.</p>
<figure class="align-center" id="id468">
<span id="figure-swizzle-overview"></span><a class="reference internal image-reference" href="_images/swizzle-pattern.png"><img alt="An Overview of TMA Swizzle Patterns" src="_images/swizzle-pattern.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Figure 28 </span><span class="caption-text">An Overview of TMA Swizzle Patterns</span><a class="headerlink" href="#id468" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p><strong>Considerations.</strong>  When applying a TMA swizzle pattern, it is crucial to adhere to specific memory requirements:</p>
<ul class="simple">
<li><p><strong>Global memory alignment:</strong>
Global memory must be aligned to 128 bytes.</p></li>
<li><p><strong>Shared memory alignment:</strong>
For simplicity shared memory should be aligned according to the number of bytes after which the swizzle pattern repeats. When the shared memory buffer is not aligned by the number of bytes by which the swizzle pattern repeats itself, there is an offset between the swizzle pattern and the shared memory.
See <a class="reference internal" href="#swizzle-pattern-pointer-offset-computation"><span class="std std-ref">comment</span></a>, below.</p></li>
<li><p><strong>Inner dimension:</strong>
The inner dimension of the shared memory block must meet the size requirements specified in table <a class="reference internal" href="#table-swizzle-pattern-properties-and-requirements"><span class="std std-numref">Table 13</span></a>. If these
requirements are not met, the instruction is considered invalid. Additionally, if the swizzle width exceeds the inner dimension,
ensure that the shared memory is allocated to accommodate the full swizzle width.</p></li>
<li><p><strong>Granularity:</strong>
The granularity of swizzle mapping is fixed at 16 bytes. This means that data is organized and accessed in chunks
of 16 bytes, which must be considered when planning memory layout and access patterns.</p></li>
</ul>
<p id="swizzle-pattern-pointer-offset-computation"><strong>Swizzle Pattern Pointer Offset Computation</strong>. Here, we describe how to determine the offset between the swizzle pattern and the shared memory, when the shared memory buffer is not aligned by the number of bytes by which the swizzle pattern repeats itself.
When using TMA, the shared memory is required to be aligned to 128 bytes. To find how many times the shared memory buffer relative to the swizzle pattern is shifted by that, apply the corresponding offset formula.</p>
<table class="small colwidths-auto docutils align-default" id="table-swizzle-pattern-offset">
<caption><span class="caption-number">Table 12 </span><span class="caption-text">Swizzle Pattern Pointer Offset Formula and Index Relation</span><a class="headerlink" href="#table-swizzle-pattern-offset" title="Permalink to this table">ï</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Swizzle Mode</p></th>
<th class="head"><p>Offset Formula</p></th>
<th class="head"><p>Index Relation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CU_TENSOR_MAP_SWIZZLE_128B</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(reinterpret_cast</span> <span class="pre">&lt;uintptr_t&gt;(smem_ptr)/128)%8</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">smem[y][x]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">smem[y][((y+offset)%8)^x]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>CU_TENSOR_MAP_SWIZZLE_64B</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(reinterpret_cast</span> <span class="pre">&lt;uintptr_t&gt;(smem_ptr)/128)%4</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">smem[y][x]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">smem[y][((y+offset)%4)^x]</span></code></p></td>
</tr>
<tr class="row-even"><td><p>CU_TENSOR_MAP_SWIZZLE_32B</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(reinterpret_cast</span> <span class="pre">&lt;uintptr_t&gt;(smem_ptr)/128)%2</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">smem[y][x]</span> <span class="pre">&lt;-&gt;</span> <span class="pre">smem[y][((y+offset)%2)^x]</span></code></p></td>
</tr>
</tbody>
</table>
<p>In <a class="reference internal" href="#figure-swizzle-overview"><span class="std std-numref">Figure 28</span></a>, this offset represents the initial row offset, thus, in the swizzle index calculation, it is added to the row index <code class="docutils literal notranslate"><span class="pre">y</span></code>.
The following snippet shows how to acces the swizzled shared memory in the <code class="docutils literal notranslate"><span class="pre">CU_TENSOR_MAP_SWIZZLE_128B</span></code> mode.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">data_t</span><span class="o">*</span><span class="w"> </span><span class="n">smem_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">smem_ptr</span><span class="p">)</span><span class="o">/</span><span class="mi">128</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="n">smem</span><span class="p">[</span><span class="n">y</span><span class="p">][((</span><span class="n">y</span><span class="o">+</span><span class="n">offset</span><span class="p">)</span><span class="o">%</span><span class="mi">8</span><span class="p">)</span><span class="o">^</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Summary.</strong> The following table <a class="reference internal" href="#table-swizzle-pattern-properties-and-requirements"><span class="std std-ref">Requirements and properties of the different swizzle patterns for Compute Capability 9</span></a> summarizes the requirements and properties of the different swizzle patterns for Compute Capability 9.</p>
<table class="small colwidths-auto docutils align-default" id="table-swizzle-pattern-properties-and-requirements">
<caption><span class="caption-number">Table 13 </span><span class="caption-text">Requirements and properties of the different swizzle patterns for Compute Capability 9</span><a class="headerlink" href="#table-swizzle-pattern-properties-and-requirements" title="Permalink to this table">ï</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Pattern</p></th>
<th class="head"><p>Swizzle width</p></th>
<th class="head"><p>Shared boxâs
inner dimension</p></th>
<th class="head"><p>Repeats
after</p></th>
<th class="head"><p>Shared
memory
alignment</p></th>
<th class="head"><p>Global
memory
alignment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>CU_TENSOR_MAP_SWIZZLE_128B</p></td>
<td><p>128 bytes</p></td>
<td><p>&lt;=128 bytes</p></td>
<td><p>1024 bytes</p></td>
<td><p>128 bytes</p></td>
<td><p>128 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>CU_TENSOR_MAP_SWIZZLE_64B</p></td>
<td><p>64 bytes</p></td>
<td><p>&lt;=64 bytes</p></td>
<td><p>512 bytes</p></td>
<td><p>128 bytes</p></td>
<td><p>128 bytes</p></td>
</tr>
<tr class="row-even"><td><p>CU_TENSOR_MAP_SWIZZLE_32B</p></td>
<td><p>32 bytes</p></td>
<td><p>&lt;=32 bytes</p></td>
<td><p>256 bytes</p></td>
<td><p>128 bytes</p></td>
<td><p>128 bytes</p></td>
</tr>
<tr class="row-odd"><td><p>CU_TENSOR_MAP_SWIZZLE_NONE
(default)</p></td>
<td></td>
<td></td>
<td></td>
<td><p>128 bytes</p></td>
<td><p>16 bytes</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
<section id="encoding-a-tensor-map-on-device">
<span id="id195"></span><h2><span class="section-number">7.30. </span>Encoding a Tensor Map on Device<a class="headerlink" href="#encoding-a-tensor-map-on-device" title="Permalink to this headline">ï</a></h2>
<p>Previous sections have described how to create a tensor map on the host using the CUDA driver API.</p>
<p>This section explains how to encode a tiled-type tensor map on device. This is useful in situations where the typical
way of transferring the tensor map (using <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">__grid_constant__</span></code> kernel parameters) is undesirable, for instance,
when processing a batch of tensors of various sizes in a single kernel launch.</p>
<p>The recommended pattern is as follows:</p>
<ol class="arabic simple">
<li><p>Create a tensor map âtemplateâ, <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span></code>, using the Driver API on the host.</p></li>
<li><p>In a device kernel, copy the <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span></code>, modify the copy, store in global memory, and appropriately fence.</p></li>
<li><p>Use the tensor map in a kernel with appropriate fencing.</p></li>
</ol>
<p>The high-level code structure is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initialize device context:</span>
<span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">());</span><span class="w"></span>

<span class="c1">// Create a tensor map template using the cuTensorMapEncodeTiled driver function</span>
<span class="n">CUtensorMap</span><span class="w"> </span><span class="n">template_tensor_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_tensormap_template</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Allocate tensor map and tensor in global memory</span>
<span class="n">CUtensorMap</span><span class="o">*</span><span class="w"> </span><span class="n">global_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CUtensorMap</span><span class="p">)));</span><span class="w"></span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">global_buf</span><span class="p">;</span><span class="w"></span>
<span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_buf</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">256</span><span class="p">));</span><span class="w"></span>

<span class="c1">// Fill global buffer with data.</span>
<span class="n">fill_global_buf</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">global_buf</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Define the parameters of the tensor map that will be created on device.</span>
<span class="n">tensormap_params</span><span class="w"> </span><span class="n">p</span><span class="p">{};</span><span class="w"></span>
<span class="n">p</span><span class="p">.</span><span class="n">global_address</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">global_buf</span><span class="p">;</span><span class="w"></span>
<span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="c1">// The box in shared memory has half the width of the full buffer</span>
<span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">   </span><span class="c1">// The box in shared memory has half the height of the full buffer</span>
<span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="c1">//</span>
<span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">   </span><span class="c1">//</span>
<span class="n">p</span><span class="p">.</span><span class="n">global_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"> </span><span class="c1">//</span>
<span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">//</span>
<span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">//</span>

<span class="c1">// Encode global_tensor_map on device:</span>
<span class="n">encode_tensor_map</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">template_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">global_tensor_map</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Use it from another kernel:</span>
<span class="n">consume_tensor_map</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">global_tensor_map</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Check for errors:</span>
<span class="n">CUDA_CHECK</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">());</span><span class="w"></span>
</pre></div>
</div>
<p>The following sections  describe the high-level steps. Throughout the examples, the following <code class="docutils literal notranslate"><span class="pre">tensormap_params</span></code>
struct contains the new values of the fields to be updated. It is included here to reference when reading the examples.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">tensormap_params</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">global_address</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">box_dim</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">global_dim</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_stride</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">element_stride</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<section id="device-side-encoding-and-modification-of-a-tensor-map">
<h3><span class="section-number">7.30.1. </span>Device-side Encoding and Modification of a Tensor Map<a class="headerlink" href="#device-side-encoding-and-modification-of-a-tensor-map" title="Permalink to this headline">ï</a></h3>
<p>The recommended process of encoding a tensor map in global memory proceeds as follows.</p>
<ol class="arabic simple">
<li><p>Pass an existing tensor map, the <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span></code>, to the kernel. In contrast to kernels that use
the tensor map in a <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor</span></code> instruction, this may be done in any way: a pointer to global
memory, kernel parameter, a <code class="docutils literal notranslate"><span class="pre">__const___</span></code> variable, and so on.</p></li>
<li><p>Copy-initialize a tensor map in shared memory with the template_tensor_map value.</p></li>
<li><p>Modify the tensor map in shared memory using the <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx/instructions/tensormap.replace.html">cuda::ptx::tensormap_replace</a>
functions. These functions wrap the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-tensormap-replace">tensormap.replace</a>
PTX instruction, which can be used to modify any field of a tiled-type tensor map, including the
base address, size, stride, and so on.</p></li>
<li><p>Using the <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx/instructions/tensormap.cp_fenceproxy.html#tensormap-cp-fenceproxy">cuda::ptx::tensormap_copy_fenceproxy</a>
function, copy the modified tensor map from shared memory to global memory and perform any necessary fencing.</p></li>
</ol>
<p>The following code contains a kernel that follows these steps. For completeness, it modifies all the fields
of the tensor map. Typically, a kernel will modify just a few fields.</p>
<p>In this kernel, <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span></code> is passed as a kernel parameter. This is the preferred way of moving <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span></code>
from the host to the device. If the kernel is intended to update an existing tensor map in device memory, it can take a
pointer to the existing tensor map to modify.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The format of the tensor map may change over time. Therefore, the <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx/instructions/tensormap.replace.html">cuda::ptx::tensormap_replace</a>
functions and corresponding <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-tensormap-replace">tensormap.replace.tile</a>
PTX instructions are marked as specific to sm_90a. To use them, compile using <code class="docutils literal notranslate"><span class="pre">nvcc</span> <span class="pre">-arch</span> <span class="pre">sm_90a</span> <span class="pre">....</span></code>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>On sm_90a, a zero-initialized buffer in shared memory may also be used as the initial tensor map value. This
enables encoding a tensor map purely on device, without using the driver API to encode the <code class="docutils literal notranslate"><span class="pre">template_tensor_map</span> <span class="pre">value</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On-device modification is only supported for tiled-type tensor maps; other tensor map types cannot be modified on device. For more
information on the tensor map types, refer to the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY">Driver API reference</a>.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/ptx&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cuda</span><span class="o">::</span><span class="nn">ptx</span><span class="p">;</span><span class="w"></span>

<span class="c1">// launch with 1 warp.</span>
<span class="n">__launch_bounds__</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">encode_tensor_map</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">__grid_constant__</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">template_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">tensormap_params</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="o">*</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">smem_tmap</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Copy template to shared memory:</span>
<span class="w">      </span><span class="n">smem_tmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">template_tensor_map</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">space_shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_address</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_address</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="c1">// For field .rank, the operand new_val must be ones less than the desired</span>
<span class="w">      </span><span class="c1">// tensor rank as this field uses zero-based numbering.</span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_rank</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// Set box dimensions:</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_box_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_box_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_box_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_box_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_box_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">box_dim</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Set global dimensions:</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_dim</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_dim</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Set global stride:</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_stride</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_stride</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_stride</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_stride</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_global_stride</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">global_stride</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Set element stride:</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_element_size</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_element_size</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_element_size</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_element_size</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">rank</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_element_size</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">{},</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">element_stride</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// These constants are documented in this table:</span>
<span class="w">      </span><span class="c1">// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#tensormap-new-val-validity</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">u8_elem_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_elemtype</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">u8_elem_type</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">no_interleave</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_interleave_layout</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">no_interleave</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">no_swizzle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_swizzle_mode</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">no_swizzle</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">zero_fill</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">{};</span><span class="w"></span>
<span class="w">      </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_replace_fill_mode</span><span class="p">(</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">zero_fill</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Synchronize the modifications with other threads in warp</span>
<span class="w">   </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Copy the tensor map to global memory collectively with threads in the warp.</span>
<span class="w">   </span><span class="c1">// In addition: make the updated tensor map visible to other threads on device that</span>
<span class="w">   </span><span class="c1">// for use with cp.async.bulk.</span>
<span class="w">   </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bytes_128</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">ptx</span><span class="o">::</span><span class="n">tensormap_cp_fenceproxy</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_release</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_gpu</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">smem_tmap</span><span class="p">,</span><span class="w"> </span><span class="n">bytes_128</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="usage-of-a-modified-tensor-map">
<h3><span class="section-number">7.30.2. </span>Usage of a Modified Tensor Map<a class="headerlink" href="#usage-of-a-modified-tensor-map" title="Permalink to this headline">ï</a></h3>
<p>In contrast to using a tensor map that is passed as a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">__grid_constant__</span></code> kernel parameter, using a tensor map in
global memory requires explicitly establishing a release-acquire pattern in the tensor map proxy between the threads
that modify the tensor map and the threads that use it.</p>
<p>The release part of the pattern was shown in the previous section. It is accomplished using
the <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx/instructions/tensormap.cp_fenceproxy.html">cuda::ptx::tensormap.cp_fenceproxy</a> function.</p>
<p>The acquire part is accomplished using the <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx/instructions/fence.html">cuda::ptx::fence_proxy_tensormap_generic</a>
function that wraps the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-membar-fence">fence.proxy.tensormap::generic.acquire</a>
instruction. If the two threads participating in the release-acquire pattern are on the same device, the <code class="docutils literal notranslate"><span class="pre">.gpu</span></code> scope suffices. If the threads are on
different devices, the <code class="docutils literal notranslate"><span class="pre">.sys</span></code> scope must be used. Once a tensor map has been acquired by one thread, it can be used by other threads in the block
after sufficient synchronization, for example, using <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>. The thread that uses the tensor map and the thread that performs the fence
must be in the same block. That is, if the threads are in, for example, two different thread blocks of the same cluster, the same grid, or a
different kernel, synchronization APIs such as <code class="docutils literal notranslate"><span class="pre">cooperative_groups::cluster</span></code> or <code class="docutils literal notranslate"><span class="pre">grid_group::sync()</span></code> or stream-order synchronization do not
suffice to establish ordering for tensor map updates, that is, threads in these other thread blocks still need to acquire the tensor map proxy
at the right scope before using the updated tensor map. If there are no intermediate modifications, the fence does not have to be repeated
before each <code class="docutils literal notranslate"><span class="pre">cp.async.bulk.tensor</span></code> instruction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fence</span></code> and subsequent use of the tensor map is shown in the following example.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Consumer of tensor map in global memory:</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">consume_tensor_map</span><span class="p">(</span><span class="n">CUtensorMap</span><span class="o">*</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Fence acquire tensor map:</span>
<span class="w">  </span><span class="n">ptx</span><span class="o">::</span><span class="n">n32_t</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size_bytes</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_tensormap_generic</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_sys</span><span class="p">,</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="n">size_bytes</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Safe to use tensor_map after fence..</span>

<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="nf">alignas</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">smem_buf</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Initialize barrier</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Make barrier init visible in async proxy, i.e., to TMA engine</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Issue TMA request</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">cp_async_bulk_tensor</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">space_cluster</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_global</span><span class="p">,</span><span class="w"> </span><span class="n">smem_buf</span><span class="p">,</span><span class="w"> </span><span class="n">tensor_map</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Arrive on barrier. Expect 4 * 128 bytes.</span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_arrive_expect_tx</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_release</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cta</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">smem_buf</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">parity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Wait for load to have completed</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_try_wait_parity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">parity</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// print items:</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Got:</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">smem_buf</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="creating-a-template-tensor-map-value-using-the-driver-api">
<h3><span class="section-number">7.30.3. </span>Creating a Template Tensor Map Value Using the Driver API<a class="headerlink" href="#creating-a-template-tensor-map-value-using-the-driver-api" title="Permalink to this headline">ï</a></h3>
<p>The following code creates a minimal tiled-type tensor map that can be subsequently modified on device.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUtensorMap</span><span class="w"> </span><span class="nf">make_tensormap_template</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CUtensorMap</span><span class="w"> </span><span class="n">template_tensor_map</span><span class="p">{};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_cuTensorMapEncodeTiled</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dims_32</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">dims_strides_64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">elem_strides</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create the tensor descriptor.</span>
<span class="w">  </span><span class="n">CUresult</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuTensorMapEncodeTiled</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">template_tensor_map</span><span class="p">,</span><span class="w"> </span><span class="c1">// CUtensorMap *tensorMap,</span>
<span class="w">    </span><span class="n">CUtensorMapDataType</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_DATA_TYPE_UINT8</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">                </span><span class="c1">// cuuint32_t tensorRank,</span>
<span class="w">    </span><span class="k">nullptr</span><span class="p">,</span><span class="w">          </span><span class="c1">// void *globalAddress,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">dims_strides_64</span><span class="p">,</span><span class="w"> </span><span class="c1">// const cuuint64_t *globalDim,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">dims_strides_64</span><span class="p">,</span><span class="w"> </span><span class="c1">// const cuuint64_t *globalStrides,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">dims_32</span><span class="p">,</span><span class="w">         </span><span class="c1">// const cuuint32_t *boxDim,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">elem_strides</span><span class="p">,</span><span class="w">    </span><span class="c1">// const cuuint32_t *elementStrides,</span>
<span class="w">    </span><span class="n">CUtensorMapInterleave</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_INTERLEAVE_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">CUtensorMapSwizzle</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_SWIZZLE_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">CUtensorMapL2promotion</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_L2_PROMOTION_NONE</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">CUtensorMapFloatOOBfill</span><span class="o">::</span><span class="n">CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">CU_CHECK</span><span class="p">(</span><span class="n">res</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">template_tensor_map</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="profiler-counter-function">
<h2><span class="section-number">7.31. </span>Profiler Counter Function<a class="headerlink" href="#profiler-counter-function" title="Permalink to this headline">ï</a></h2>
<p>Each multiprocessor has a set of sixteen hardware counters that an application can increment with a single instruction by calling the <code class="docutils literal notranslate"><span class="pre">__prof_trigger()</span></code> function.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__prof_trigger</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>increments by one per warp the per-multiprocessor hardware counter of index <code class="docutils literal notranslate"><span class="pre">counter</span></code>. Counters 8 to 15 are reserved and should not be used by applications.</p>
<p>The value of counters 0, 1, â¦, 7 can be obtained via <code class="docutils literal notranslate"><span class="pre">nvprof</span></code> by <code class="docutils literal notranslate"><span class="pre">nvprof</span> <span class="pre">--events</span> <span class="pre">prof_trigger_0x</span></code> where <code class="docutils literal notranslate"><span class="pre">x</span></code> is 0, 1, â¦, 7. All counters are reset before each kernel launch (note that when collecting counters, kernel launches are synchronous as mentioned in <a class="reference internal" href="#concurrent-execution-host-device"><span class="std std-ref">Concurrent Execution between Host and Device</span></a>).</p>
</section>
<section id="assertion">
<h2><span class="section-number">7.32. </span>Assertion<a class="headerlink" href="#assertion" title="Permalink to this headline">ï</a></h2>
<p>Assertion is only supported by devices of compute capability 2.x and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">assert</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">expression</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>stops the kernel execution if <code class="docutils literal notranslate"><span class="pre">expression</span></code> is equal to zero. If the program is run within a debugger, this triggers a breakpoint and the debugger can be used to inspect the current state of the device. Otherwise, each thread for which <code class="docutils literal notranslate"><span class="pre">expression</span></code> is equal to zero prints a message to <em>stderr</em> after synchronization with the host via <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code>, or <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code>. The format of this message is as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;filename&gt;:&lt;line number&gt;:&lt;function&gt;:
block: [blockId.x,blockId.x,blockIdx.z],
thread: [threadIdx.x,threadIdx.y,threadIdx.z]
Assertion `&lt;expression&gt;` failed.
</pre></div>
</div>
<p>Any subsequent host-side synchronization calls made for the same device will return <code class="docutils literal notranslate"><span class="pre">cudaErrorAssert</span></code>. No more commands can be sent to this device until <code class="docutils literal notranslate"><span class="pre">cudaDeviceReset()</span></code> is called to reinitialize the device.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">expression</span></code> is different from zero, the kernel execution is unaffected.</p>
<p>For example, the following program from source file <em>test.cu</em></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">testAssert</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">is_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">should_be_one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This will have no effect</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">is_one</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This will halt kernel execution</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">should_be_one</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">testAssert</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>will output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>test.cu:19: void testAssert(): block: [0,0,0], thread: [0,0,0] Assertion `should_be_one` failed.
</pre></div>
</div>
<p>Assertions are for debugging purposes. They can affect performance and it is therefore recommended to disable them in production code. They can be disabled at compile time by defining the <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> preprocessor macro before including <code class="docutils literal notranslate"><span class="pre">assert.h</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">expression</span></code> should not be an expression with side effects (something like<code class="docutils literal notranslate"><span class="pre">(++i</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>, for example), otherwise disabling the assertion will affect the functionality of the code.</p>
</section>
<section id="trap-function">
<h2><span class="section-number">7.33. </span>Trap function<a class="headerlink" href="#trap-function" title="Permalink to this headline">ï</a></h2>
<p>A trap operation can be initiated by calling the <code class="docutils literal notranslate"><span class="pre">__trap()</span></code> function from any device thread.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__trap</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The execution of the kernel is aborted and an interrupt is raised in the host program.</p>
</section>
<section id="breakpoint-function">
<span id="id196"></span><h2><span class="section-number">7.34. </span>Breakpoint Function<a class="headerlink" href="#breakpoint-function" title="Permalink to this headline">ï</a></h2>
<p>Execution of a kernel function can be suspended by calling the <code class="docutils literal notranslate"><span class="pre">__brkpt()</span></code> function from any device thread.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">__brkpt</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="formatted-output">
<span id="id197"></span><h2><span class="section-number">7.35. </span>Formatted Output<a class="headerlink" href="#formatted-output" title="Permalink to this headline">ï</a></h2>
<p>Formatted output is only supported by devices of compute capability 2.x and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">printf</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">format</span><span class="p">[,</span><span class="w"> </span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="p">...]);</span><span class="w"></span>
</pre></div>
</div>
<p>prints formatted output from a kernel to a host-side output stream.</p>
<p>The in-kernel <code class="docutils literal notranslate"><span class="pre">printf()</span></code> function behaves in a similar way to the standard C-library <code class="docutils literal notranslate"><span class="pre">printf()</span></code> function, and the user is referred to the host systemâs manual pages for a complete description of <code class="docutils literal notranslate"><span class="pre">printf()</span></code> behavior. In essence, the string passed in as <code class="docutils literal notranslate"><span class="pre">format</span></code> is output to a stream on the host, with substitutions made from the argument list wherever a format specifier is encountered. Supported format specifiers are listed below.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">printf()</span></code> command is executed as any other device-side function: per-thread, and in the context of the calling thread. From a multi-threaded kernel, this means that a straightforward call to <code class="docutils literal notranslate"><span class="pre">printf()</span></code> will be executed by every thread, using that threadâs data as specified. Multiple versions of the output string will then appear at the host stream, once for each thread which encountered the <code class="docutils literal notranslate"><span class="pre">printf()</span></code>.</p>
<p>It is up to the programmer to limit the output to a single thread if only a single output string is desired (see <a class="reference internal" href="#examples-per-thread"><span class="std std-ref">Examples</span></a> for an illustrative example).</p>
<p>Unlike the C-standard <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, which returns the number of characters printed, CUDAâs <code class="docutils literal notranslate"><span class="pre">printf()</span></code> returns the number of arguments parsed. If no arguments follow the format string, 0 is returned. If the format string is NULL, -1 is returned. If an internal error occurs, -2 is returned.</p>
<section id="format-specifiers">
<span id="id198"></span><h3><span class="section-number">7.35.1. </span>Format Specifiers<a class="headerlink" href="#format-specifiers" title="Permalink to this headline">ï</a></h3>
<p>As for standard <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, format specifiers take the form: <code class="docutils literal notranslate"><span class="pre">%[flags][width][.precision][size]type</span></code></p>
<p>The following fields are supported (see widely-available documentation for a complete description of all behaviors):</p>
<ul class="simple">
<li><p>Flags: <code class="docutils literal notranslate"><span class="pre">'#'</span> <span class="pre">'</span> <span class="pre">'</span> <span class="pre">'0'</span> <span class="pre">'+'</span> <span class="pre">'-'</span></code></p></li>
<li><p>Width: <code class="docutils literal notranslate"><span class="pre">'*'</span> <span class="pre">'0-9'</span></code></p></li>
<li><p>Precision: <code class="docutils literal notranslate"><span class="pre">'0-9'</span></code></p></li>
<li><p>Size: <code class="docutils literal notranslate"><span class="pre">'h'</span> <span class="pre">'l'</span> <span class="pre">'ll'</span></code></p></li>
<li><p>Type: <code class="docutils literal notranslate"><span class="pre">&quot;%cdiouxXpeEfgGaAs&quot;</span></code></p></li>
</ul>
<p>Note that CUDAâs <code class="docutils literal notranslate"><span class="pre">printf()</span></code>will accept any combination of flag, width, precision, size and type, whether or not overall they form a valid format specifier. In other words, â<code class="docutils literal notranslate"><span class="pre">%hd</span></code>â will be accepted and printf will expect a double-precision variable in the corresponding location in the argument list.</p>
</section>
<section id="limitations">
<h3><span class="section-number">7.35.2. </span>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">ï</a></h3>
<p>Final formatting of the <code class="docutils literal notranslate"><span class="pre">printf()</span></code>output takes place on the host system. This means that the format string must be understood by the host-systemâs compiler and C library. Every effort has been made to ensure that the format specifiers supported by CUDAâs printf function form a universal subset from the most common host compilers, but exact behavior will be host-OS-dependent.</p>
<p>As described in <a class="reference internal" href="#format-specifiers"><span class="std std-ref">Format Specifiers</span></a>, <code class="docutils literal notranslate"><span class="pre">printf()</span></code> will accept <em>all</em> combinations of valid flags and types. This is because it cannot determine what will and will not be valid on the host system where the final output is formatted. The effect of this is that output may be undefined if the program emits a format string which contains invalid combinations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">printf()</span></code> command can accept at most 32 arguments in addition to the format string. Additional arguments beyond this will be ignored, and the format specifier output as-is.</p>
<p>Owing to the differing size of the <code class="docutils literal notranslate"><span class="pre">long</span></code> type on 64-bit Windows platforms (four bytes on 64-bit Windows platforms, eight bytes on other 64-bit platforms), a kernel which is compiled on a non-Windows 64-bit machine but then run on a win64 machine will see corrupted output for all format strings which include â<code class="docutils literal notranslate"><span class="pre">%ld</span></code>â. It is recommended that the compilation platform matches the execution platform to ensure safety.</p>
<p>The output buffer for <code class="docutils literal notranslate"><span class="pre">printf()</span></code> is set to a fixed size before kernel launch (see <a class="reference internal" href="#associated-host-side-api"><span class="std std-ref">Associated Host-Side API</span></a>). It is circular and if more output is produced during kernel execution than can fit in the buffer, older output is overwritten. It is flushed only when one of these actions is performed:</p>
<ul class="simple">
<li><p>Kernel launch via <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel()</span></code> (at the start of the launch, and if the CUDA_LAUNCH_BLOCKING environment variable is set to 1, at the end of the launch as well),</p></li>
<li><p>Synchronization via <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cuCtxSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cuStreamSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code>, or <code class="docutils literal notranslate"><span class="pre">cuEventSynchronize()</span></code>,</p></li>
<li><p>Memory copies via any blocking version of <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuMemcpy*()</span></code>,</p></li>
<li><p>Module loading/unloading via <code class="docutils literal notranslate"><span class="pre">cuModuleLoad()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuModuleUnload()</span></code>,</p></li>
<li><p>Context destruction via <code class="docutils literal notranslate"><span class="pre">cudaDeviceReset()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuCtxDestroy()</span></code>.</p></li>
<li><p>Prior to executing a stream callback added by <code class="docutils literal notranslate"><span class="pre">cudaStreamAddCallback</span></code> or <code class="docutils literal notranslate"><span class="pre">cuStreamAddCallback</span></code>.</p></li>
</ul>
<p>Note that the buffer is not flushed automatically when the program exits. The user must call <code class="docutils literal notranslate"><span class="pre">cudaDeviceReset()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuCtxDestroy()</span></code> explicitly, as shown in the examples below.</p>
<p>Internally <code class="docutils literal notranslate"><span class="pre">printf()</span></code> uses a shared data structure and so it is possible that calling <code class="docutils literal notranslate"><span class="pre">printf()</span></code> might change the order of execution of threads. In particular, a thread which calls <code class="docutils literal notranslate"><span class="pre">printf()</span></code> might take a longer execution path than one which does not call <code class="docutils literal notranslate"><span class="pre">printf()</span></code>, and that path length is dependent upon the parameters of the <code class="docutils literal notranslate"><span class="pre">printf()</span></code>. Note, however, that CUDA makes no guarantees of thread execution order except at explicit <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> barriers, so it is impossible to tell whether execution order has been modified by <code class="docutils literal notranslate"><span class="pre">printf()</span></code> or by other scheduling behavior in the hardware.</p>
</section>
<section id="associated-host-side-api">
<span id="id199"></span><h3><span class="section-number">7.35.3. </span>Associated Host-Side API<a class="headerlink" href="#associated-host-side-api" title="Permalink to this headline">ï</a></h3>
<p>The following API functions get and set the size of the buffer used to transfer the <code class="docutils literal notranslate"><span class="pre">printf()</span></code> arguments and internal metadata to the host (default is 1 megabyte):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit(size_t*</span> <span class="pre">size,cudaLimitPrintfFifoSize)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit(cudaLimitPrintfFifoSize,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></li>
</ul>
</section>
<section id="format-specifier-examples">
<span id="id200"></span><h3><span class="section-number">7.35.4. </span>Examples<a class="headerlink" href="#format-specifier-examples" title="Permalink to this headline">ï</a></h3>
<p>The following code sample:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">helloCUDA</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello thread %d, f=%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">helloCUDA</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mf">1.2345f</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>will output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Hello thread 2, f=1.2345
Hello thread 1, f=1.2345
Hello thread 4, f=1.2345
Hello thread 0, f=1.2345
Hello thread 3, f=1.2345
</pre></div>
</div>
<p>Notice how each thread encounters the <code class="docutils literal notranslate"><span class="pre">printf()</span></code> command, so there are as many lines of output as there were threads launched in the grid. As expected, global values (i.e., <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">f</span></code>) are common between all threads, and local values (i.e., <code class="docutils literal notranslate"><span class="pre">threadIdx.x</span></code>) are distinct per-thread.</p>
<p>The following code sample:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">helloCUDA</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello thread %d, f=%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">helloCUDA</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mf">1.2345f</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>will output:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Hello thread 0, f=1.2345
</pre></div>
</div>
<p>Self-evidently, the <code class="docutils literal notranslate"><span class="pre">if()</span></code> statement limits which threads will call <code class="docutils literal notranslate"><span class="pre">printf</span></code>, so that only a single line of output is seen.</p>
</section>
</section>
<section id="dynamic-global-memory-allocation-and-operations">
<h2><span class="section-number">7.36. </span>Dynamic Global Memory Allocation and Operations<a class="headerlink" href="#dynamic-global-memory-allocation-and-operations" title="Permalink to this headline">ï</a></h2>
<p>Dynamic global memory allocation and operations are only supported by devices of compute capability 2.x and higher.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__nv_aligned_device_malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">align</span><span class="p">);</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>allocate and free memory dynamically from a fixed-size heap in global memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>copy <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from the memory location pointed by <code class="docutils literal notranslate"><span class="pre">src</span></code> to the memory location pointed by <code class="docutils literal notranslate"><span class="pre">dest</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">memset</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>set <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of memory block pointed by <code class="docutils literal notranslate"><span class="pre">ptr</span></code> to <code class="docutils literal notranslate"><span class="pre">value</span></code> (interpreted as an unsigned char).</p>
<p>The CUDA in-kernel <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>function allocates at least <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the request. The returned pointer is guaranteed to be aligned to a 16-byte boundary.</p>
<p>The CUDA in-kernel <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> function allocates at least <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes from the device heap and returns a pointer to the allocated memory or NULL if insufficient memory exists to fulfill the requested size or alignment. The address of the allocated memory will be a multiple of <code class="docutils literal notranslate"><span class="pre">align</span></code>. <code class="docutils literal notranslate"><span class="pre">align</span></code> must be a non-zero power of 2.</p>
<p>The CUDA in-kernel <code class="docutils literal notranslate"><span class="pre">free()</span></code> function deallocates the memory pointed to by <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, which must have been returned by a previous call to <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code>. If <code class="docutils literal notranslate"><span class="pre">ptr</span></code> is NULL, the call to <code class="docutils literal notranslate"><span class="pre">free()</span></code> is ignored. Repeated calls to <code class="docutils literal notranslate"><span class="pre">free()</span></code> with the same <code class="docutils literal notranslate"><span class="pre">ptr</span></code> has undefined behavior.</p>
<p>The memory allocated by a given CUDA thread via <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> remains allocated for the lifetime of the CUDA context, or until it is explicitly released by a call to <code class="docutils literal notranslate"><span class="pre">free()</span></code>. It can be used by any other CUDA threads even from subsequent kernel launches. Any CUDA thread may free memory allocated by another thread, but care should be taken to ensure that the same pointer is not freed more than once.</p>
<section id="heap-memory-allocation">
<h3><span class="section-number">7.36.1. </span>Heap Memory Allocation<a class="headerlink" href="#heap-memory-allocation" title="Permalink to this headline">ï</a></h3>
<p>The device memory heap has a fixed size that must be specified before any program using <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">free()</span></code> is loaded into the context. A default heap of eight megabytes is allocated if any program uses <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> without explicitly specifying the heap size.</p>
<p>The following API functions get and set the heap size:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit(size_t*</span> <span class="pre">size,</span> <span class="pre">cudaLimitMallocHeapSize)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit(cudaLimitMallocHeapSize,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></li>
</ul>
<p>The heap size granted will be at least <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes. <code class="docutils literal notranslate"><span class="pre">cuCtxGetLimit()</span></code>and <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code> return the currently requested heap size.</p>
<p>The actual memory allocation for the heap occurs when a module is loaded into the context, either explicitly via the CUDA driver API (see <a class="reference internal" href="#module"><span class="std std-ref">Module</span></a>), or implicitly via the CUDA runtime API (see <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a>). If the memory allocation fails, the module load will generate a <code class="docutils literal notranslate"><span class="pre">CUDA_ERROR_SHARED_OBJECT_INIT_FAILED</span></code> error.</p>
<p>Heap size cannot be changed once a module load has occurred and it does not resize dynamically according to need.</p>
<p>Memory reserved for the device heap is in addition to memory allocated through host-side CUDA API calls such as <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>.</p>
</section>
<section id="interoperability-with-host-memory-api">
<span id="interoperability-host-memory-api"></span><h3><span class="section-number">7.36.2. </span>Interoperability with Host Memory API<a class="headerlink" href="#interoperability-with-host-memory-api" title="Permalink to this headline">ï</a></h3>
<p>Memory allocated via device <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> cannot be freed using the runtime (i.e., by calling any of the free memory functions from <a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a>).</p>
<p>Similarly, memory allocated via the runtime (i.e., by calling any of the memory allocation functions from <a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a>) cannot be freed via <code class="docutils literal notranslate"><span class="pre">free()</span></code>.</p>
<p>In addition, memory allocated by a call to <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> or <code class="docutils literal notranslate"><span class="pre">__nv_aligned_device_malloc()</span></code> in device code cannot be used in any runtime or driver API calls (i.e. cudaMemcpy, cudaMemset, etc).</p>
</section>
<section id="examples-per-thread">
<span id="id201"></span><h3><span class="section-number">7.36.3. </span>Examples<a class="headerlink" href="#examples-per-thread" title="Permalink to this headline">ï</a></h3>
<section id="per-thread-allocation">
<h4><span class="section-number">7.36.3.1. </span>Per Thread Allocation<a class="headerlink" href="#per-thread-allocation" title="Permalink to this headline">ï</a></h4>
<p>The following code sample:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">mallocTest</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread %d got pointer: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Set a heap size of 128 megabytes. Note that this must</span>
<span class="w">    </span><span class="c1">// be done before any kernel is launched.</span>
<span class="w">    </span><span class="n">cudaDeviceSetLimit</span><span class="p">(</span><span class="n">cudaLimitMallocHeapSize</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">mallocTest</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>will output:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Thread</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="mo">00057020</span><span class="w"></span>
<span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="mo">000570</span><span class="mi">8</span><span class="n">c</span><span class="w"></span>
<span class="n">Thread</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="mf">000570f</span><span class="mi">8</span><span class="w"></span>
<span class="n">Thread</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="mo">00057164</span><span class="w"></span>
<span class="n">Thread</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">got</span><span class="w"> </span><span class="n">pointer</span><span class="o">:</span><span class="w"> </span><span class="mo">000571</span><span class="n">d0</span><span class="w"></span>
</pre></div>
</div>
<p>Notice how each thread encounters the <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">memset()</span></code> commands and so receives and initializes its own allocation. (Exact pointer values will vary: these are illustrative.)</p>
</section>
<section id="per-thread-block-allocation">
<h4><span class="section-number">7.36.3.2. </span>Per Thread Block Allocation<a class="headerlink" href="#per-thread-block-allocation" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">mallocTest</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// The first thread in the block does the allocation and then</span>
<span class="w">    </span><span class="c1">// shares the pointer with all other threads through shared memory,</span>
<span class="w">    </span><span class="c1">// so that access can easily be coalesced.</span>
<span class="w">    </span><span class="c1">// 64 bytes per thread are allocated.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check for failure</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Threads index into the memory, ensuring coalescence</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Ensure all threads complete before freeing</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Only one thread may free the memory!</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSetLimit</span><span class="p">(</span><span class="n">cudaLimitMallocHeapSize</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">mallocTest</span><span class="o">&lt;&lt;&lt;</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocation-persisting-between-kernel-launches">
<span id="allocation-persisting-kernel-launches"></span><h4><span class="section-number">7.36.3.3. </span>Allocation Persisting Between Kernel Launches<a class="headerlink" href="#allocation-persisting-between-kernel-launches" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define NUM_BLOCKS 20</span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">dataptr</span><span class="p">[</span><span class="n">NUM_BLOCKS</span><span class="p">];</span><span class="w"> </span><span class="c1">// Per-block pointer</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">allocmem</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Only the first thread in the block does the allocation</span>
<span class="w">    </span><span class="c1">// since we want only one allocation per block.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">dataptr</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Check for failure</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dataptr</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Zero the data with all threads in parallel</span>
<span class="w">    </span><span class="n">dataptr</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Simple example: store thread ID into each element</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">usemem</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataptr</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ptr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Print the content of the buffer before freeing it</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">freemem</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dataptr</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Block %d, Thread %d: final value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                      </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Only free from one thread!</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSetLimit</span><span class="p">(</span><span class="n">cudaLimitMallocHeapSize</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate memory</span>
<span class="w">    </span><span class="n">allocmem</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use memory</span>
<span class="w">    </span><span class="n">usemem</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">usemem</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">usemem</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Free memory</span>
<span class="w">    </span><span class="n">freemem</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">NUM_BLOCKS</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="execution-configuration">
<span id="id202"></span><h2><span class="section-number">7.37. </span>Execution Configuration<a class="headerlink" href="#execution-configuration" title="Permalink to this headline">ï</a></h2>
<p>Any call to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function must specify the <em>execution configuration</em> for that call. The execution configuration defines the dimension of the grid and blocks that will be used to execute the function on the device, as well as the associated stream (see <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a> for a description of streams).</p>
<p>The execution configuration is specified by inserting an expression of the form <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;</span> <span class="pre">Dg,</span> <span class="pre">Db,</span> <span class="pre">Ns,</span> <span class="pre">S</span> <span class="pre">&gt;&gt;&gt;</span></code> between the function name and the parenthesized argument list, where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dg</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> (see <a class="reference internal" href="#dim3"><span class="std std-ref">dim3</span></a>) and specifies the dimension and size of the grid, such that <code class="docutils literal notranslate"><span class="pre">Dg.x</span> <span class="pre">*</span> <span class="pre">Dg.y</span> <span class="pre">*</span> <span class="pre">Dg.z</span></code> equals the number of blocks being launched;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Db</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> (see <a class="reference internal" href="#dim3"><span class="std std-ref">dim3</span></a>) and specifies the dimension and size of each block, such that <code class="docutils literal notranslate"><span class="pre">Db.x</span> <span class="pre">*</span> <span class="pre">Db.y</span> <span class="pre">*</span> <span class="pre">Db.z</span></code> equals the number of threads per block;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ns</span></code> is of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> and specifies the number of bytes in shared memory that is dynamically allocated per block for this call in addition to the statically allocated memory; this dynamically allocated memory is used by any of the variables declared as an external array as mentioned in <a class="reference internal" href="#shared"><span class="std std-ref">__shared__</span></a>; <code class="docutils literal notranslate"><span class="pre">Ns</span></code> is an optional argument which defaults to 0;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> is of type <code class="docutils literal notranslate"><span class="pre">cudaStream_t</span></code> and specifies the associated stream; <code class="docutils literal notranslate"><span class="pre">S</span></code> is an optional argument which defaults to 0.</p></li>
</ul>
<p>As an example, a function declared as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Func</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">parameter</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>must be called like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">Dg</span><span class="p">,</span><span class="w"> </span><span class="n">Db</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">parameter</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The arguments to the execution configuration are evaluated before the actual function arguments.</p>
<p>The function call will fail if <code class="docutils literal notranslate"><span class="pre">Dg</span></code> or <code class="docutils literal notranslate"><span class="pre">Db</span></code> are greater than the maximum sizes allowed for the device as specified in <a class="reference internal" href="#compute-capabilities"><span class="std std-ref">Compute Capabilities</span></a>, or if <code class="docutils literal notranslate"><span class="pre">Ns</span></code> is greater than the maximum amount of shared memory available on the device, minus the amount of shared memory required for static allocation.</p>
<p>Compute capability 9.0 and above allows users to specify compile time thread block cluster dimensions, so that the kernel can use the cluster hierarchy in CUDA. Compile time cluster dimension can be specified using <code class="docutils literal notranslate"><span class="pre">__cluster_dims__([x,</span> <span class="pre">[y,</span> <span class="pre">[z]]])</span></code>. The example below shows compile time cluster size of 2 in X dimension and 1 in Y and Z dimension.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__cluster_dims__</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">Func</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">parameter</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The default form of <code class="docutils literal notranslate"><span class="pre">__cluster_dims__()</span></code> specifies that a kernel is to be launched as a cluster grid. By not specifying a cluster dimension, the user is free to specify the dimension at launch time. Not specifying a dimension at launch time will result in a launch time error.</p>
<p>Thread block cluster dimensions can also be specified at runtime and kernel with the cluster can be launched using <code class="docutils literal notranslate"><span class="pre">cudaLaunchKernelEx</span></code> API. The API takes a configuration arugument of type <code class="docutils literal notranslate"><span class="pre">cudaLaunchConfig_t</span></code>, kernel function pointer and kernel arguments. Runtime kernel configuration is shown in the example below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Func</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">parameter</span><span class="p">);</span><span class="w"></span>


<span class="c1">// Kernel invocation with runtime cluster size</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaLaunchConfig_t</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The grid dimension is not affected by cluster launch, and is still enumerated</span>
<span class="w">    </span><span class="c1">// using number of blocks.</span>
<span class="w">    </span><span class="c1">// The grid dimension should be a multiple of cluster size.</span>
<span class="w">    </span><span class="n">config</span><span class="p">.</span><span class="n">gridDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">config</span><span class="p">.</span><span class="n">blockDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Db</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">config</span><span class="p">.</span><span class="n">dynamicSmemBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ns</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">cudaLaunchAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaLaunchAttributeClusterDimension</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// Cluster size in X-dimension</span>
<span class="w">    </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">attribute</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">.</span><span class="n">clusterDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">config</span><span class="p">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">config</span><span class="p">.</span><span class="n">numAttrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">parameter</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaLaunchKernelEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="p">,</span><span class="w"> </span><span class="n">parameter</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="launch-bounds">
<span id="id203"></span><h2><span class="section-number">7.38. </span>Launch Bounds<a class="headerlink" href="#launch-bounds" title="Permalink to this headline">ï</a></h2>
<p>As discussed in detail in <a class="reference internal" href="#multiprocessor-level"><span class="std std-ref">Multiprocessor Level</span></a>, the fewer registers a kernel uses, the more threads and thread blocks are likely to reside on a multiprocessor, which can improve performance.</p>
<p>Therefore, the compiler uses heuristics to minimize register usage while keeping register spilling (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a>) and instruction count to a minimum. An application can optionally aid these heuristics by providing additional information to the compiler in the form of launch bounds that are specified using the <code class="docutils literal notranslate"><span class="pre">__launch_bounds__()</span></code> qualifier in the definition of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="n">__launch_bounds__</span><span class="p">(</span><span class="n">maxThreadsPerBlock</span><span class="p">,</span><span class="w"> </span><span class="n">minBlocksPerMultiprocessor</span><span class="p">,</span><span class="w"> </span><span class="n">maxBlocksPerCluster</span><span class="p">)</span><span class="w"></span>
<span class="n">MyKernel</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code> specifies the maximum number of threads per block with which the application will ever launch <code class="docutils literal notranslate"><span class="pre">MyKernel()</span></code>; it compiles to the <code class="docutils literal notranslate"><span class="pre">.maxntid</span></code><em>PTX</em> directive.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> is optional and specifies the desired minimum number of resident blocks per multiprocessor; it compiles to the <code class="docutils literal notranslate"><span class="pre">.minnctapersm</span></code><em>PTX</em> directive.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxBlocksPerCluster</span></code> is optional and specifies the desired maximum number thread blocks per cluster with which the application will ever launch <code class="docutils literal notranslate"><span class="pre">MyKernel()</span></code>; it compiles to the <code class="docutils literal notranslate"><span class="pre">.maxclusterrank</span></code><em>PTX</em> directive.</p></li>
</ul>
<p>If launch bounds are specified, the compiler first derives from them the upper limit <em>L</em> on the number of registers the kernel should use to ensure that <code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> blocks (or a single block if <code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> is not specified) of <code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code> threads can reside on the multiprocessor (see <a class="reference internal" href="#hardware-multithreading"><span class="std std-ref">Hardware Multithreading</span></a> for the relationship between the number of registers used by a kernel and the number of registers allocated per block). The compiler then optimizes register usage in the following way:</p>
<ul class="simple">
<li><p>If the initial register usage is higher than <em>L</em>, the compiler reduces it further until it becomes less or equal to <em>L</em>, usually at the expense of more local memory usage and/or higher number of instructions;</p></li>
<li><p>If the initial register usage is lower than <em>L</em></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code> is specified and <code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> is not, the compiler uses <code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code> to determine the register usage thresholds for the transitions between <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">n+1</span></code> resident blocks (i.e., when using one less register makes room for an additional resident block as in the example of <a class="reference internal" href="#multiprocessor-level"><span class="std std-ref">Multiprocessor Level</span></a>) and then applies similar heuristics as when no launch bounds are specified;</p></li>
<li><p>If both <code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> and <code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code> are specified, the compiler may increase register usage as high as <em>L</em> to reduce the number of instructions and better hide single thread instruction latency.</p></li>
</ul>
</li>
</ul>
<p>A kernel will fail to launch if it is executed with more threads per block than its launch bound <code class="docutils literal notranslate"><span class="pre">maxThreadsPerBlock</span></code>.</p>
<p>A kernel will fail to launch if it is executed with more thread blocks per cluster than its launch bound <code class="docutils literal notranslate"><span class="pre">maxBlocksPerCluster</span></code>.</p>
<p>Per thread resources required by a CUDA kernel might limit the maximum block size in an unwanted way. In order to maintain forward compatibility to future hardware and toolkits and to ensure that at least one thread block can run on an SM, developers should include the single argument <code class="docutils literal notranslate"><span class="pre">__launch_bounds__(maxThreadsPerBlock)</span></code> which specifies the largest block size that the kernel will be launched with. Failure to do so could lead to âtoo many resources requested for launchâ errors. Providing the two argument version of <code class="docutils literal notranslate"><span class="pre">__launch_bounds__(maxThreadsPerBlock,minBlocksPerMultiprocessor)</span></code> can improve performance in some cases. The right value for <code class="docutils literal notranslate"><span class="pre">minBlocksPerMultiprocessor</span></code> should be determined using a detailed per kernel analysis.</p>
<p>Optimal launch bounds for a given kernel will usually differ across major architecture revisions. The sample code below shows how this is typically handled in device code using the <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro introduced in <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define THREADS_PER_BLOCK          256</span>
<span class="cp">#if __CUDA_ARCH__ &gt;= 200</span>
<span class="w">    </span><span class="cp">#define MY_KERNEL_MAX_THREADS  (2 * THREADS_PER_BLOCK)</span>
<span class="w">    </span><span class="cp">#define MY_KERNEL_MIN_BLOCKS   3</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#define MY_KERNEL_MAX_THREADS  THREADS_PER_BLOCK</span>
<span class="w">    </span><span class="cp">#define MY_KERNEL_MIN_BLOCKS   2</span>
<span class="cp">#endif</span>

<span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="n">__launch_bounds__</span><span class="p">(</span><span class="n">MY_KERNEL_MAX_THREADS</span><span class="p">,</span><span class="w"> </span><span class="n">MY_KERNEL_MIN_BLOCKS</span><span class="p">)</span><span class="w"></span>
<span class="n">MyKernel</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the common case where <code class="docutils literal notranslate"><span class="pre">MyKernel</span></code> is invoked with the maximum number of threads per block (specified as the first parameter of <code class="docutils literal notranslate"><span class="pre">__launch_bounds__()</span></code>), it is tempting to use <code class="docutils literal notranslate"><span class="pre">MY_KERNEL_MAX_THREADS</span></code> as the number of threads per block in the execution configuration:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">MY_KERNEL_MAX_THREADS</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
<p>This will not work however since <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is undefined in host code as mentioned in <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>, so <code class="docutils literal notranslate"><span class="pre">MyKernel</span></code> will launch with 256 threads per block even when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is greater or equal to 200. Instead the number of threads per block should be determined:</p>
<ul>
<li><p>Either at compile time using a macro that does not depend on <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>, for example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">THREADS_PER_BLOCK</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Or at runtime based on the compute capability</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Host code</span>
<span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="n">deviceProp</span><span class="p">.</span><span class="n">major</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">?</span><span class="w"></span>
<span class="w">                    </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">THREADS_PER_BLOCK</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">THREADS_PER_BLOCK</span><span class="p">);</span><span class="w"></span>
<span class="n">MyKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
<p>Register usage is reported by the <code class="docutils literal notranslate"><span class="pre">--ptxas-options=-v</span></code> compiler option. The number of resident blocks can be derived from the occupancy reported by the CUDA profiler (see <a class="reference internal" href="#device-memory-accesses"><span class="std std-ref">Device Memory Accesses</span></a> for a definition of occupancy).</p>
</section>
<section id="maximum-number-of-registers-per-thread">
<span id="id204"></span><h2><span class="section-number">7.39. </span>Maximum Number of Registers per Thread<a class="headerlink" href="#maximum-number-of-registers-per-thread" title="Permalink to this headline">ï</a></h2>
<p>To provide a mechanism for low-level performance tuning, CUDA C++ provides the <code class="docutils literal notranslate"><span class="pre">__maxnreg__()</span></code> function qualifier to pass performance tuning information to the backend optimizing compiler. The
<code class="docutils literal notranslate"><span class="pre">__maxnreg__()</span></code> qualifier specifies the maximum number of registers to be allocated to a single thread in a thread block. In the definition of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"></span>
<span class="n">__maxnreg__</span><span class="p">(</span><span class="n">maxNumberRegistersPerThread</span><span class="p">)</span><span class="w"></span>
<span class="n">MyKernel</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">maxNumberRegistersPerThread</span></code> specifies the maximum number of registers to be allocated to a single thread in a thread block of the kernel <code class="docutils literal notranslate"><span class="pre">MyKernel()</span></code>; it compiles to the <code class="docutils literal notranslate"><span class="pre">.maxnreg</span></code><em>PTX</em> directive.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">__launch_bounds__()</span></code> and <code class="docutils literal notranslate"><span class="pre">__maxnreg__()</span></code> qualifiers cannot be applied to the same kernel.</p>
<p>Register usage can also be controlled for all <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions in a file using the <code class="docutils literal notranslate"><span class="pre">maxrregcount</span></code> compiler option. The value of <code class="docutils literal notranslate"><span class="pre">maxrregcount</span></code> is ignored for functions with the <code class="docutils literal notranslate"><span class="pre">__maxnreg__</span></code> qualifier.</p>
</section>
<section id="pragma-unroll">
<span id="id205"></span><h2><span class="section-number">7.40. </span>#pragma unroll<a class="headerlink" href="#pragma-unroll" title="Permalink to this headline">ï</a></h2>
<p>By default, the compiler unrolls small loops with a known trip count. The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">unroll</span></code> directive however can be used to control unrolling of any given loop. It must be placed immediately before the loop and only applies to that loop. It is optionally followed by an integral constant expression (ICE)<a class="footnote-reference brackets" href="#fn13" id="id206">13</a>. If the ICE is absent, the loop will be completely unrolled if its trip count is constant. If the ICE evaluates to 1, the compiler will not unroll the loop. The pragma will be ignored if the ICE evaluates to a non-positive integer or to an integer greater than the maximum value representable by the <code class="docutils literal notranslate"><span class="pre">int</span></code> data type.</p>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="c1">// no argument specified, loop will be completely unrolled</span>
<span class="cp">#pragma unroll</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="c1">// unroll value = 8</span>
<span class="cp">#pragma unroll (X+1)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="c1">// unroll value = 1, loop unrolling disabled</span>
<span class="cp">#pragma unroll 1</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span><span class="w"></span>

<span class="c1">// unroll value = 4</span>
<span class="cp">#pragma unroll (T2::value)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">16</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="n">foo</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="simd-video-instructions">
<span id="simd-video"></span><h2><span class="section-number">7.41. </span>SIMD Video Instructions<a class="headerlink" href="#simd-video-instructions" title="Permalink to this headline">ï</a></h2>
<p>PTX ISA version 3.0 includes SIMD (Single Instruction, Multiple Data) video instructions which operate on pairs of 16-bit values and quads of 8-bit values. These are available on devices of compute capability 3.0.</p>
<p>The SIMD video instructions are:</p>
<ul class="simple">
<li><p>vadd2, vadd4</p></li>
<li><p>vsub2, vsub4</p></li>
<li><p>vavrg2, vavrg4</p></li>
<li><p>vabsdiff2, vabsdiff4</p></li>
<li><p>vmin2, vmin4</p></li>
<li><p>vmax2, vmax4</p></li>
<li><p>vset2, vset4</p></li>
</ul>
<p>PTX instructions, such as the SIMD video instructions, can be included in CUDA programs by way of the assembler, <code class="docutils literal notranslate"><span class="pre">asm()</span></code>, statement.</p>
<p>The basic syntax of an <code class="docutils literal notranslate"><span class="pre">asm()</span></code> statement is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;template-string&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;constraint&quot;</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;constraint&quot;</span><span class="p">(</span><span class="n">input</span><span class="p">)</span><span class="s">&quot;));</span>
</pre></div>
</div>
<p>An example of using the <code class="docutils literal notranslate"><span class="pre">vabsdiff4</span></code> PTX instruction is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">asm</span><span class="p">(</span><span class="s">&quot;vabsdiff4.u32.u32.u32.add&quot;</span><span class="w"> </span><span class="s">&quot; %0, %1, %2, %3;&quot;</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">:</span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">B</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">C</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>This uses the <code class="docutils literal notranslate"><span class="pre">vabsdiff4</span></code> instruction to compute an integer quad byte SIMD sum of absolute differences. The absolute difference value is computed for each byte of the unsigned integers A and B in SIMD fashion. The optional accumulate operation (<code class="docutils literal notranslate"><span class="pre">.add</span></code>) is specified to sum these differences.</p>
<p>Refer to the document âUsing Inline PTX Assembly in CUDAâ for details on using the assembly statement in your code. Refer to the PTX ISA documentation (âParallel Thread Execution ISA Version 3.0â for example) for details on the PTX instructions for the version of PTX that you are using.</p>
</section>
<section id="diagnostic-pragmas">
<span id="nv-diagnostic-pragmas"></span><h2><span class="section-number">7.42. </span>Diagnostic Pragmas<a class="headerlink" href="#diagnostic-pragmas" title="Permalink to this headline">ï</a></h2>
<p>The following pragmas may be used to control the error severity used when a given diagnostic message is issued.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_diag_suppress</span>
<span class="cp">#pragma nv_diag_warning</span>
<span class="cp">#pragma nv_diag_error</span>
<span class="cp">#pragma nv_diag_default</span>
<span class="cp">#pragma nv_diag_once</span>
</pre></div>
</div>
<p>Uses of these pragmas have the following form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_diag_xxx error_number, error_number ...</span>
</pre></div>
</div>
<p>The diagnostic affected is specified using an error number showed in a warning message. Any diagnostic may be overridden to be an error, but only warnings may have their severity suppressed or be restored to a warning after being promoted to an error. The <code class="docutils literal notranslate"><span class="pre">nv_diag_default</span></code> pragma is used to return the severity of a diagnostic to the one that was in effect before any pragmas were issued (i.e., the normal severity of the message as modified by any command-line options). The following example suppresses the <code class="docutils literal notranslate"><span class="pre">&quot;declared</span> <span class="pre">but</span> <span class="pre">never</span> <span class="pre">referenced&quot;</span></code> warning on the declaration of <code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_diag_suppress 177</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma nv_diag_default 177</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following pragmas may be used to save and restore the current diagnostic pragma state:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_diagnostic push</span>
<span class="cp">#pragma nv_diagnostic pop</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_diagnostic push</span>
<span class="cp">#pragma nv_diag_suppress 177</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#pragma nv_diagnostic pop</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the pragmas only affect the nvcc CUDA frontend compiler; they have no effect on the host compiler.</p>
<p>Removal Notice: The support of diagnostic pragmas without <code class="docutils literal notranslate"><span class="pre">nv_</span></code> prefix are removed from CUDA 12.0, if the pragmas are inside the device code, warning <code class="docutils literal notranslate"><span class="pre">unrecognized</span> <span class="pre">#pragma</span> <span class="pre">in</span> <span class="pre">device</span> <span class="pre">code</span></code> will be emitted, otherwise they will be passed to the host compiler. If they are intended for CUDA code, use the pragmas with <code class="docutils literal notranslate"><span class="pre">nv_</span></code> prefix instead.</p>
<dl class="footnote brackets">
<dt class="label" id="fn11"><span class="brackets">11</span></dt>
<dd><p>When the enclosing __host__ function is a template, nvcc may currently fail to issue a diagnostic message in some cases; this behavior may change in the future.</p>
</dd>
<dt class="label" id="fn12"><span class="brackets"><a class="fn-backref" href="#id171">12</a></span></dt>
<dd><p>The intent is to prevent the host compiler from encountering the call to the function if the host compiler does not support it.</p>
</dd>
<dt class="label" id="fn13"><span class="brackets">13</span><span class="fn-backref">(<a href="#id206">1</a>,<a href="#id207">2</a>,<a href="#id322">3</a>)</span></dt>
<dd><p>See the C++ Standard for definition of integral constant expression.</p>
</dd>
</dl>
</section>
<section id="custom-abi-pragmas">
<span id="nv-abi-pragmas"></span><h2><span class="section-number">7.43. </span>Custom ABI Pragmas<a class="headerlink" href="#custom-abi-pragmas" title="Permalink to this headline">ï</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">nv_abi</span></code> directive enables applications compiled in separate compilation mode to achieve performance similar to that of whole program compilation.</p>
<p>The syntax for using this pragma is as follows, where ICE refers to any integral constant expression (ICE): <a class="footnote-reference brackets" href="#fn13" id="id207">13</a>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_abi preserve_n_data(ICE) preserve_n_control(ICE)</span>
</pre></div>
</div>
<p>Note, the arguments that follow <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">nv_abi</span></code> are optional and can be provided in any order; however, at least one argument is required.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">preserve_n</span></code> arguments set a limit on the number of registers preserved during a function call:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">preserve_n_data(ICE)</span></code> limits the number of data registers, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">preserve_n_control(ICE)</span></code> limits the number of control registers.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">nv_abi</span></code> can be placed immediately before a device function declaration or definition. Alternatively, it can be placed directly before an indirect function call within a C++ expression statement inside a device function. Note, indirect function calls to free functions are supported, but indirect calls through function argument references or class member functions are not.</p>
<p>When the pragma is applied to a device function declaration or definition, it modifies the custom ABI properties for any calls to that function. When placed at an indirect function call site, the pragma affects the ABI properties for that indirect function call. The key point is that unlike direct function calls, where you can place the pragma before a function declaration or definition, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">nv_abi</span></code> only affects indirect function calls when the pragma is placed before a call site.</p>
<p>As shown in the following example, we have two device functions, <code class="docutils literal notranslate"><span class="pre">foo()</span></code> and <code class="docutils literal notranslate"><span class="pre">bar()</span></code>. In this example the pragma is placed before the call site of the function pointer fptr to modify the ABI properties of the indirect function call. Notice that placing the pragma before the direct call does not affect the ABI properties of the call. To alter the ABI properties of a direct function call, the pragma must be placed before the function declaration or definition.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">baz</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w">  </span><span class="c1">// function pointer</span>

<span class="w">  </span><span class="cp">#pragma nv_abi preserve_n_data(16) preserve_n_control(8)</span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fptr</span><span class="p">();</span><span class="w">      </span><span class="c1">// The pragma affects the indirect call to foo() via fptr</span>

<span class="w">  </span><span class="cp">#pragma nv_abi preserve_n_data(16) preserve_n_control(8)</span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fptr</span><span class="p">)();</span><span class="w">   </span><span class="c1">// Alternate syntax for the indirect call to foo()</span>

<span class="w">  </span><span class="cp">#pragma nv_abi preserve_n_data(16) preserve_n_control(8)</span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bar</span><span class="p">();</span><span class="w">      </span><span class="c1">// The pragma does NOT affect the direct call to bar()</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As shown in the following example, to modify direct function calls, you must apply the pragma to the function declaration or definition.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma nv_abi preserve_n_data(16)</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>Note that a program is ill-formed if the pragma arguments for a function declaration and its corresponding definition do not match.</p>
</section>
</section>
<section id="cooperative-groups">
<span id="id208"></span><h1><span class="section-number">8. </span>Cooperative Groups<a class="headerlink" href="#cooperative-groups" title="Permalink to this headline">ï</a></h1>
<section id="introduction-cg">
<span id="id209"></span><h2><span class="section-number">8.1. </span>Introduction<a class="headerlink" href="#introduction-cg" title="Permalink to this headline">ï</a></h2>
<p>Cooperative Groups is an extension to the CUDA programming model, introduced in CUDA 9, for organizing groups of communicating threads. Cooperative Groups allows developers to express the granularity at which threads are communicating, helping them to express richer, more efficient parallel decompositions.</p>
<p>Historically, the CUDA programming model has provided a single, simple construct for synchronizing cooperating threads: a barrier across all threads of a thread block, as implemented with the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> intrinsic function. However, programmers would like to define and synchronize groups of threads at other granularities to enable greater performance, design flexibility, and software reuse in the form of âcollectiveâ group-wide function interfaces. In an effort to express broader patterns of parallel interaction, many performance-oriented programmers have resorted to writing their own ad hoc and unsafe primitives for synchronizing threads within a single warp, or across sets of thread blocks running on a single GPU. Whilst the performance improvements achieved have often been valuable, this has resulted in an ever-growing collection of brittle code that is expensive to write, tune, and maintain over time and across GPU generations. Cooperative Groups addresses this by providing a safe and future-proof mechanism to enable performant code.</p>
</section>
<section id="what-s-new-in-cooperative-groups">
<h2><span class="section-number">8.2. </span>Whatâs New in Cooperative Groups<a class="headerlink" href="#what-s-new-in-cooperative-groups" title="Permalink to this headline">ï</a></h2>
<section id="cuda-12-2">
<h3><span class="section-number">8.2.1. </span>CUDA 12.2<a class="headerlink" href="#cuda-12-2" title="Permalink to this headline">ï</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code> member functions were added for <a class="reference internal" href="#grid-group-cg"><span class="std std-ref">grid_group</span></a> and <a class="reference internal" href="#thread-block-group-cg"><span class="std std-ref">thread_block</span></a>. Description of the API is available <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a>.</p></li>
</ul>
</section>
<section id="cuda-12-1">
<h3><span class="section-number">8.2.2. </span>CUDA 12.1<a class="headerlink" href="#cuda-12-1" title="Permalink to this headline">ï</a></h3>
<ul class="simple">
<li><p><a class="reference internal" href="#invoke-one-and-invoke-one-broadcast"><span class="std std-ref">invoke_one and invoke_one_broadcast</span></a> APIs were added.</p></li>
</ul>
</section>
<section id="cuda-12-0">
<h3><span class="section-number">8.2.3. </span>CUDA 12.0<a class="headerlink" href="#cuda-12-0" title="Permalink to this headline">ï</a></h3>
<ul class="simple">
<li><p>The following experimental APIs are now moved to the main namespace:</p>
<ul>
<li><p>asynchronous reduce and scan update added in CUDA 11.7</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code> larger than 32 added in CUDA 11.1</p></li>
</ul>
</li>
<li><p>It is no longer required to provide memory using the <code class="docutils literal notranslate"><span class="pre">block_tile_memory</span></code> object in order to create these large tiles on Compute Capability 8.0 or higher.</p></li>
</ul>
</section>
</section>
<section id="deprecated-items">
<h2><span class="section-number">8.3. </span>Deprecated items<a class="headerlink" href="#deprecated-items" title="Permalink to this headline">ï</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">multi_grid_group</span></code> has been deprecated in CUDA 11.3 for all devices, scheduled to be removed in CUDA 13.0.</p></li>
</ul>
</section>
<section id="programming-model-concept">
<span id="concept-cg"></span><h2><span class="section-number">8.4. </span>Programming Model Concept<a class="headerlink" href="#programming-model-concept" title="Permalink to this headline">ï</a></h2>
<p>The Cooperative Groups programming model describes synchronization patterns both within and across CUDA thread blocks. It provides both the means for applications to define their own groups of threads, and the interfaces to synchronize them. It also provides new launch APIs that enforce certain restrictions and therefore can guarantee the synchronization will work. These primitives enable new patterns of cooperative parallelism within CUDA, including producer-consumer parallelism, opportunistic parallelism, and global synchronization across the entire Grid.</p>
<p>The Cooperative Groups programming model consists of the following elements:</p>
<ul class="simple">
<li><p>Data types for representing groups of cooperating threads;</p></li>
<li><p>Operations to obtain implicit groups defined by the CUDA launch API (e.g., thread blocks);</p></li>
<li><p>Collectives for partitioning existing groups into new groups;</p></li>
<li><p>Collective Algorithms for data movement and manipulation (e.g. memcpy_async, reduce, scan);</p></li>
<li><p>An operation to synchronize all threads within the group;</p></li>
<li><p>Operations to inspect the group properties;</p></li>
<li><p>Collectives that expose low-level, group-specific and often HW accelerated, operations.</p></li>
</ul>
<p>The main concept in Cooperative Groups is that of objects naming the set of threads that are part of it. This expression of groups as first-class program objects improves software composition, since collective functions can receive an explicit object representing the group of participating threads. This object also makes programmer intent explicit, which eliminates unsound architectural assumptions that result in brittle code, undesirable restrictions upon compiler optimizations, and better compatibility with new GPU generations.</p>
<p>To write efficient code, its best to use specialized groups (going generic loses a lot of compile time optimizations), and pass these group objects by reference to functions that intend to use these threads in some cooperative fashion.</p>
<p>Cooperative Groups requires CUDA 9.0 or later. To use Cooperative Groups, include the header file:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Primary header is compatible with pre-C++11, collective algorithm headers require C++11</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="c1">// Optionally include for memcpy_async() collective</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>
<span class="c1">// Optionally include for reduce() collective</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/reduce.h&gt;</span><span class="cp"></span>
<span class="c1">// Optionally include for inclusive_scan() and exclusive_scan() collectives</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/scan.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>and use the Cooperative Groups namespace:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>
<span class="c1">// Alternatively use an alias to avoid polluting the namespace with collective algorithms</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The code can be compiled in a normal way using nvcc, however if you wish to use memcpy_async, reduce or scan functionality and your host compilerâs default dialect is not C++11 or higher, then you must add <code class="docutils literal notranslate"><span class="pre">--std=c++11</span></code> to the command line.</p>
<section id="composition-example">
<h3><span class="section-number">8.4.1. </span>Composition Example<a class="headerlink" href="#composition-example" title="Permalink to this headline">ï</a></h3>
<p>To illustrate the concept of groups, this example attempts to perform a block-wide sum reduction. Previously, there were hidden constraints on the implementation when writing this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">total</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parallel_kernel</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="c1">// Entire thread block must call sum</span>
<span class="w">    </span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>All threads in the thread block must arrive at the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> barrier, however, this constraint is hidden from the developer who might want to use <code class="docutils literal notranslate"><span class="pre">sum(â¦)</span></code>. With Cooperative Groups, a better way of writing this would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">sync</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">total</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parallel_kernel</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="c1">// Entire thread block must call sum</span>
<span class="w">    </span><span class="n">thread_block</span><span class="w"> </span><span class="n">tb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="group-types">
<span id="group-types-cg"></span><h2><span class="section-number">8.5. </span>Group Types<a class="headerlink" href="#group-types" title="Permalink to this headline">ï</a></h2>
<section id="implicit-groups">
<span id="group-types-implicit-cg"></span><h3><span class="section-number">8.5.1. </span>Implicit Groups<a class="headerlink" href="#implicit-groups" title="Permalink to this headline">ï</a></h3>
<p>Implicit groups represent the launch configuration of the kernel. Regardless of how your kernel is written, it always has a set number of threads, blocks and block dimensions, a single grid and grid dimensions. In addition, if the multi-device cooperative launch API is used, it can have multiple grids (single grid per device). These groups provide a starting point for decomposition into finer grained groups which are typically HW accelerated and are more specialized for the problem the developer is solving.</p>
<p>Although you can create an implicit group anywhere in the code, it is dangerous to do so. Creating a handle for an implicit group is a collective operationâall threads in the group must participate. If the group was created in a conditional branch that not all threads reach, this can lead to deadlocks or data corruption. For this reason, it is recommended that you create a handle for the implicit group upfront (as early as possible, before any branching has occurred) and use that handle throughout the kernel. Group handles must be initialized at declaration time (there is no default constructor) for the same reason and copy-constructing them is discouraged.</p>
<section id="thread-block-group">
<span id="thread-block-group-cg"></span><h4><span class="section-number">8.5.1.1. </span>Thread Block Group<a class="headerlink" href="#thread-block-group" title="Permalink to this headline">ï</a></h4>
<p>Any CUDA programmer is already familiar with a certain group of threads: the thread block. The Cooperative Groups extension introduces a new datatype, <code class="docutils literal notranslate"><span class="pre">thread_block</span></code>, to explicitly represent this concept within the kernel.</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">thread_block;</span></code></p>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">thread_block</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">sync()</span></code>: Synchronize the threads named in the group, equivalent to <code class="docutils literal notranslate"><span class="pre">g.barrier_wait(g.barrier_arrive())</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">thread_block::arrival_token</span> <span class="pre">barrier_arrive()</span></code>: Arrive on the thread_block barrier, returns a token that needs to be passed into <code class="docutils literal notranslate"><span class="pre">barrier_wait()</span></code>. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">barrier_wait(thread_block::arrival_token&amp;&amp;</span> <span class="pre">t)</span></code>: Wait on the <code class="docutils literal notranslate"><span class="pre">thread_block</span></code> barrier, takes arrival token returned from <code class="docutils literal notranslate"><span class="pre">barrier_arrive()</span></code> as an rvalue reference. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">thread_rank()</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">group_index()</span></code>: 3-Dimensional index of the block within the launched grid</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">thread_index()</span></code>: 3-Dimensional index of the thread within the launched block</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">dim_threads()</span></code>: Dimensions of the launched block in units of threads</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_threads()</span></code>: Total number of threads in the group</p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size()</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">group_dim()</span></code>: Dimensions of the launched block (alias of <code class="docutils literal notranslate"><span class="pre">dim_threads()</span></code>)</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Loading an integer from global into shared memory</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">globalInput</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">thread_block</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Choose a leader in the thread block</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// load from global into shared for all threads to work with</span>
<span class="w">        </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">globalInput</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// After loading data into shared memory, you want to synchronize</span>
<span class="w">    </span><span class="c1">// if all threads in your thread block need to see it</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"> </span><span class="c1">// equivalent to __syncthreads();</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Note:</strong> that all threads in the group must participate in collective operations, or the behavior is undefined.</p>
<p><strong>Related:</strong> The <code class="docutils literal notranslate"><span class="pre">thread_block</span></code> datatype is derived from the more generic <code class="docutils literal notranslate"><span class="pre">thread_group</span></code> datatype, which can be used to represent a wider class of groups.</p>
</section>
<section id="cluster-group">
<span id="cluster-group-cg"></span><h4><span class="section-number">8.5.1.2. </span>Cluster Group<a class="headerlink" href="#cluster-group" title="Permalink to this headline">ï</a></h4>
<p>This group object represents all the threads launched in a single cluster. Refer to <a class="reference internal" href="#thread-block-clusters"><span class="std std-ref">Thread Block Clusters</span></a>. The APIs are available on all hardware with Compute Capability 9.0+. In such cases, when a non-cluster grid is launched, the APIs assume a 1x1x1 cluster.</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cluster_group;</span></code></p>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cluster_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_cluster</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">sync()</span></code>: Synchronize the threads named in the group, equivalent to <code class="docutils literal notranslate"><span class="pre">g.barrier_wait(g.barrier_arrive())</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">cluster_group::arrival_token</span> <span class="pre">barrier_arrive()</span></code>: Arrive on the cluster barrier, returns a token that needs to be passed into <code class="docutils literal notranslate"><span class="pre">barrier_wait()</span></code>. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">barrier_wait(cluster_group::arrival_token&amp;&amp;</span> <span class="pre">t)</span></code>: Wait on the cluster barrier, takes arrival token returned from <code class="docutils literal notranslate"><span class="pre">barrier_arrive()</span></code> as a rvalue reference. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">thread_rank()</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">block_rank()</span></code>: Rank of the calling block within [0, num_blocks)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_threads()</span></code>: Total number of threads in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_blocks()</span></code>: Total number of blocks in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">dim_threads()</span></code>: Dimensions of the launched cluster in units of threads</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">dim_blocks()</span></code>: Dimensions of the launched cluster in units of blocks</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">block_index()</span></code>: 3-Dimensional index of the calling block within the launched cluster</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">query_shared_rank(const</span> <span class="pre">void</span> <span class="pre">*addr)</span></code>: Obtain the block rank to which a shared memory address belongs</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">T*</span> <span class="pre">map_shared_rank(T</span> <span class="pre">*addr,</span> <span class="pre">int</span> <span class="pre">rank)</span></code>: Obtain the address of a shared memory variable of another block in the cluster</p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">size()</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
</section>
<section id="grid-group">
<span id="grid-group-cg"></span><h4><span class="section-number">8.5.1.3. </span>Grid Group<a class="headerlink" href="#grid-group" title="Permalink to this headline">ï</a></h4>
<p>This group object represents all the threads launched in a single grid. APIs other than <code class="docutils literal notranslate"><span class="pre">sync()</span></code> are available at all times, but to be able to synchronize across the grid, you need to use the cooperative launch API.</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">grid_group;</span></code></p>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">grid_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_valid()</span> <span class="pre">const</span></code>: Returns whether the grid_group can synchronize</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sync()</span> <span class="pre">const</span></code>: Synchronize the threads named in the group, equivalent to <code class="docutils literal notranslate"><span class="pre">g.barrier_wait(g.barrier_arrive())</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">grid_group::arrival_token</span> <span class="pre">barrier_arrive()</span></code>: Arrive on the grid barrier, returns a token that needs to be passed into <code class="docutils literal notranslate"><span class="pre">barrier_wait()</span></code>. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">barrier_wait(grid_group::arrival_token&amp;&amp;</span> <span class="pre">t)</span></code>: Wait on the grid barrier, takes arrival token returned from <code class="docutils literal notranslate"><span class="pre">barrier_arrive()</span></code> as a rvalue reference. More details <a class="reference internal" href="#collectives-cg-sync"><span class="std std-ref">here</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">thread_rank()</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">block_rank()</span></code>: Rank of the calling block within [0, num_blocks)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">cluster_rank()</span></code>: Rank of the calling cluster within [0, num_clusters)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_threads()</span></code>: Total number of threads in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_blocks()</span></code>: Total number of blocks in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_clusters()</span></code>: Total number of clusters in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">dim_blocks()</span></code>: Dimensions of the launched grid in units of blocks</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">dim_clusters()</span></code>: Dimensions of the launched grid in units of clusters</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">block_index()</span></code>: 3-Dimensional index of the block within the launched grid</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">cluster_index()</span></code>: 3-Dimensional index of the cluster within the launched grid</p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size()</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
<p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">dim3</span> <span class="pre">group_dim()</span></code>: Dimensions of the launched grid (alias of <code class="docutils literal notranslate"><span class="pre">dim_blocks()</span></code>)</p>
</section>
<section id="multi-grid-group">
<span id="multi-grid-group-cg"></span><h4><span class="section-number">8.5.1.4. </span>Multi Grid Group<a class="headerlink" href="#multi-grid-group" title="Permalink to this headline">ï</a></h4>
<p><strong>Deprecation Notice</strong>: <code class="docutils literal notranslate"><span class="pre">multi_grid_group</span></code> has been deprecated in CUDA 11.3 for all devices.</p>
<p>This group object represents all the threads launched across all devices of a multi-device cooperative launch. Unlike the grid.group, all the APIs require that you have used the appropriate launch API.</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">multi_grid_group;</span></code></p>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Kernel must be launched with the cooperative multi-device API</span>
<span class="n">multi_grid_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_multi_grid</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">is_valid()</span> <span class="pre">const</span></code>: Returns whether the <code class="docutils literal notranslate"><span class="pre">multi_grid_group</span></code> can be used</p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sync()</span> <span class="pre">const</span></code>: Synchronize the threads named in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_threads()</span> <span class="pre">const</span></code>: Total number of threads in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">thread_rank()</span> <span class="pre">const</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">grid_rank()</span> <span class="pre">const</span></code>: Rank of the grid within [0,num_grids]</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">num_grids()</span> <span class="pre">const</span></code>: Total number of grids launched</p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size()</span> <span class="pre">const</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
</section>
</section>
<section id="explicit-groups">
<span id="group-types-explicit-cg"></span><h3><span class="section-number">8.5.2. </span>Explicit Groups<a class="headerlink" href="#explicit-groups" title="Permalink to this headline">ï</a></h3>
<section id="thread-block-tile">
<span id="thread-block-tile-group-cg"></span><h4><span class="section-number">8.5.2.1. </span>Thread Block Tile<a class="headerlink" href="#thread-block-tile" title="Permalink to this headline">ï</a></h4>
<p>A templated version of a tiled group, where a template parameter is used to specify the size of the tile - with this known at compile time there is the potential for more optimal execution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ParentT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">thread_block_tile</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ParentT</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">_CG_QUALIFIER</span><span class="w"> </span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">ParentT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tiled_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParentT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Size</span></code> must be a power of 2 and less than or equal to 1024. Notes section describes extra steps needed to create tiles of size larger than 32 on hardware with Compute Capability 7.5 or lower.</p>
<p><code class="docutils literal notranslate"><span class="pre">ParentT</span></code> is the parent-type from which this group was partitioned. It is automatically inferred, but a value of void will store this information in the group handle rather than in the type.</p>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sync()</span> <span class="pre">const</span></code>: Synchronize the threads named in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_threads()</span> <span class="pre">const</span></code>: Total number of threads in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">thread_rank()</span> <span class="pre">const</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">meta_group_size()</span> <span class="pre">const</span></code>: Returns the number of groups created when the parent group was partitioned.</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">meta_group_rank()</span> <span class="pre">const</span></code>: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size)</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl(T</span> <span class="pre">var,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">src_rank)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a>, <strong>Note: For sizes larger than 32 all threads in the group have to specify the same src_rank, otherwise the behavior is undefined.</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl_up(T</span> <span class="pre">var,</span> <span class="pre">int</span> <span class="pre">delta)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a>, available only for sizes lower or equal to 32.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl_down(T</span> <span class="pre">var,</span> <span class="pre">int</span> <span class="pre">delta)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a>, available only for sizes lower or equal to 32.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl_xor(T</span> <span class="pre">var,</span> <span class="pre">int</span> <span class="pre">delta)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a>, available only for sizes lower or equal to 32.</p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">any(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a></p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">all(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a></p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ballot(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a>, available only for sizes lower or equal to 32.</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_any(T</span> <span class="pre">val)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-match-functions"><span class="std std-ref">Warp Match Functions</span></a>, available only for sizes lower or equal to 32.</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_all(T</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">&amp;pred)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-match-functions"><span class="std std-ref">Warp Match Functions</span></a>, available only for sizes lower or equal to 32.</p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size()</span> <span class="pre">const</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
<p><strong>Notes:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code> templated data structure is being used here, the size of the group is passed to the <code class="docutils literal notranslate"><span class="pre">tiled_partition</span></code> call as a template parameter rather than an argument.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shfl,</span> <span class="pre">shfl_up,</span> <span class="pre">shfl_down,</span> <span class="pre">and</span> <span class="pre">shfl_xor</span></code> functions accept objects of any type when compiled with C++11 or later. This means itâs possible to shuffle non-integral types as long as they satisfy the below constraints:</p>
<ul class="simple">
<li><p>Qualifies as trivially copyable i.e., <code class="docutils literal notranslate"><span class="pre">is_trivially_copyable&lt;T&gt;::value</span> <span class="pre">==</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code> for tile sizes lower or equal 32, <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">8</span></code> for larger tiles</p></li>
</ul>
</li>
<li><p>On hardware with Compute Capability 7.5 or lower tiles of size larger than 32 need small amount of memory reserved for them. This can be done using <code class="docutils literal notranslate"><span class="pre">cooperative_groups::block_tile_memory</span></code> struct template that has to reside in either shared or global memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MaxBlockSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">block_tile_memory</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MaxBlockSize</span></code> Specifies the maximal number of threads in the current thread block. This parameter can be used to minimize the shared memory usage of <code class="docutils literal notranslate"><span class="pre">block_tile_memory</span></code> in kernels launched only with smaller thread counts.</p>
<p>This <code class="docutils literal notranslate"><span class="pre">block_tile_memory</span></code> needs be then passed into <code class="docutils literal notranslate"><span class="pre">cooperative_groups::this_thread_block</span></code>, allowing the resulting <code class="docutils literal notranslate"><span class="pre">thread_block</span></code> to be partitioned into tiles of sizes larger than 32. Overload of <code class="docutils literal notranslate"><span class="pre">this_thread_block</span></code> accepting <code class="docutils literal notranslate"><span class="pre">block_tile_memory</span></code> argument is a collective operation and has to be called with all threads in the <code class="docutils literal notranslate"><span class="pre">thread_block</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">block_tile_memory</span></code> can be used on hardware with Compute Capability 8.0 or higher in order to be able to write one source targeting multiple different Compute Capabilities. It should consume no memory when instantiated in shared memory in cases where its not required.</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// The following code will create two sets of tiled groups, of size 32 and 4 respectively:</span>
<span class="c1">/// The latter has the provenance encoded in the type, while the first stores it in the handle</span>
<span class="n">thread_block</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tile32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">thread_block</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tile4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// The following code will create tiles of size 128 on all Compute Capabilities.</span>
<span class="c1">/// block_tile_memory can be omitted on Compute Capability 8.0 or higher.</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// reserve shared memory for thread_block_tile usage,</span>
<span class="w">    </span><span class="c1">//   specify that block size will be at most 256 threads.</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">block_tile_memory</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">thread_block</span><span class="w"> </span><span class="n">thb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create tiles with 128 threads.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="p">(</span><span class="n">thb</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="warp-synchronous-code-pattern">
<span id="ws-code-pattern-cg"></span><h5><span class="section-number">8.5.2.1.1. </span>Warp-Synchronous Code Pattern<a class="headerlink" href="#warp-synchronous-code-pattern" title="Permalink to this headline">ï</a></h5>
<p>Developers might have had warp-synchronous codes that they previously made implicit assumptions about the warp size and would code around that number. Now this needs to be specified explicitly.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">cooperative_kernel</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// obtain default &quot;current thread block&quot; group</span>
<span class="w">    </span><span class="n">thread_block</span><span class="w"> </span><span class="n">my_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// subdivide into 32-thread, tiled subgroups</span>
<span class="w">    </span><span class="c1">// Tiled subgroups evenly partition a parent group into</span>
<span class="w">    </span><span class="c1">// adjacent sets of threads - in this case each one warp in size</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">my_tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my_block</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This operation will be performed by only the</span>
<span class="w">    </span><span class="c1">// first 32-thread tile of each block</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">my_tile</span><span class="p">.</span><span class="n">meta_group_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">my_tile</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="single-thread-group">
<span id="this-thread-cg"></span><h5><span class="section-number">8.5.2.1.2. </span>Single Thread Group<a class="headerlink" href="#single-thread-group" title="Permalink to this headline">ï</a></h5>
<p>Group representing the current thread can be obtained from <code class="docutils literal notranslate"><span class="pre">this_thread</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">this_thread</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The following <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API uses a <code class="docutils literal notranslate"><span class="pre">thread_group</span></code>, to copy an int element from source to destination:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>

<span class="n">cooperative_groups</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">cooperative_groups</span><span class="o">::</span><span class="n">this_thread</span><span class="p">(),</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>More detailed examples of using <code class="docutils literal notranslate"><span class="pre">this_thread</span></code> to perform asynchronous copies can be found in the <a class="reference internal" href="#with-memcpy-async-pipeline-pattern-single"><span class="std std-ref">Single-Stage Asynchronous Data Copies using cuda::pipeline</span></a> and <a class="reference internal" href="#with-memcpy-async-pipeline-pattern-multi"><span class="std std-ref">Multi-Stage Asynchronous Data Copies using cuda::pipeline</span></a> sections.</p>
</section>
</section>
<section id="coalesced-groups">
<span id="coalesced-group-cg"></span><h4><span class="section-number">8.5.2.2. </span>Coalesced Groups<a class="headerlink" href="#coalesced-groups" title="Permalink to this headline">ï</a></h4>
<p>In CUDAâs SIMT architecture, at the hardware level the multiprocessor executes threads in groups of 32 called warps. If there exists a data-dependent conditional branch in the application code such that threads within a warp diverge, then the warp serially executes each branch disabling threads not on that path. The threads that remain active on the path are referred to as coalesced. Cooperative Groups has functionality to discover, and create, a group containing all coalesced threads.</p>
<p>Constructing the group handle via <code class="docutils literal notranslate"><span class="pre">coalesced_threads()</span></code> is opportunistic. It returns the set of active threads at that point in time, and makes no guarantee about which threads are returned (as long as they are active) or that they will stay coalesced throughout execution (they will be brought back together for the execution of a collective but can diverge again afterwards).</p>
<p><code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">coalesced_group;</span></code></p>
<p>Constructed via:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coalesced_threads</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Public Member Functions:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">sync()</span> <span class="pre">const</span></code>: Synchronize the threads named in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">num_threads()</span> <span class="pre">const</span></code>: Total number of threads in the group</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">thread_rank()</span> <span class="pre">const</span></code>: Rank of the calling thread within [0, num_threads)</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">meta_group_size()</span> <span class="pre">const</span></code>: Returns the number of groups created when the parent group was partitioned. If this group was created by querying the set of active threads, for example <code class="docutils literal notranslate"><span class="pre">coalesced_threads()</span></code> the value of <code class="docutils literal notranslate"><span class="pre">meta_group_size()</span></code> will be 1.</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">meta_group_rank()</span> <span class="pre">const</span></code>: Linear rank of the group within the set of tiles partitioned from a parent group (bounded by meta_group_size). If this group was created by querying the set of active threads, e.g. <code class="docutils literal notranslate"><span class="pre">coalesced_threads()</span></code> the value of <code class="docutils literal notranslate"><span class="pre">meta_group_rank()</span></code> will always be 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl(T</span> <span class="pre">var,</span> <span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">src_rank)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl_up(T</span> <span class="pre">var,</span> <span class="pre">int</span> <span class="pre">delta)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">shfl_down(T</span> <span class="pre">var,</span> <span class="pre">int</span> <span class="pre">delta)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">any(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a></p>
<p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">all(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a></p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ballot(int</span> <span class="pre">predicate)</span> <span class="pre">const</span></code>: Refer to <a class="reference external" href="index.html#warp-vote-functions">Warp Vote Functions</a></p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_any(T</span> <span class="pre">val)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-match-functions"><span class="std std-ref">Warp Match Functions</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">match_all(T</span> <span class="pre">val,</span> <span class="pre">int</span> <span class="pre">&amp;pred)</span> <span class="pre">const</span></code>: Refer to <a class="reference internal" href="#warp-match-functions"><span class="std std-ref">Warp Match Functions</span></a></p>
<p>Legacy member functions (aliases):</p>
<p><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span> <span class="pre">size()</span> <span class="pre">const</span></code>: Total number of threads in the group (alias of <code class="docutils literal notranslate"><span class="pre">num_threads()</span></code>)</p>
<p><strong>Notes:</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">shfl,</span> <span class="pre">shfl_up,</span> <span class="pre">and</span> <span class="pre">shfl_down</span></code> functions accept objects of any type when compiled with C++11 or later. This means itâs possible to shuffle non-integral types as long as they satisfy the below constraints:</p>
<ul class="simple">
<li><p>Qualifies as trivially copyable i.e. <code class="docutils literal notranslate"><span class="pre">is_trivially_copyable&lt;T&gt;::value</span> <span class="pre">==</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code></p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Consider a situation whereby there is a branch in the</span>
<span class="c1">/// code in which only the 2nd, 4th and 8th threads in each warp are</span>
<span class="c1">/// active. The coalesced_threads() call, placed in that branch, will create (for each</span>
<span class="c1">/// warp) a group, active, that has three threads (with</span>
<span class="c1">/// ranks 0-2 inclusive).</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">globalInput</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Lets say globalInput says that threads 2, 4, 8 should handle the data</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">*</span><span class="n">globalInput</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coalesced_threads</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// active contains 0-2 inclusive</span>
<span class="w">        </span><span class="n">active</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<section id="discovery-pattern">
<span id="discovery-pattern-cg"></span><h5><span class="section-number">8.5.2.2.1. </span>Discovery Pattern<a class="headerlink" href="#discovery-pattern" title="Permalink to this headline">ï</a></h5>
<p>Commonly developers need to work with the current active set of threads. No assumption is made about the threads that are present, and instead developers work with the threads that happen to be there. This is seen in the following âaggregating atomic increment across threads in a warpâ example (written using the correct CUDA 9.0 set of intrinsics):</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">writemask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__popc</span><span class="p">(</span><span class="n">writemask</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__popc</span><span class="p">(</span><span class="n">writemask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">__lanemask_lt</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Find the lowest-numbered active lane</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">elected_lane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ffs</span><span class="p">(</span><span class="n">writemask</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prefix</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">total</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_sync</span><span class="p">(</span><span class="n">writemask</span><span class="p">,</span><span class="w"> </span><span class="n">base_offset</span><span class="p">,</span><span class="w"> </span><span class="n">elected_lane</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prefix</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">base_offset</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">thread_offset</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This can be re-written with Cooperative Groups as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_group</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">num_threads</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">shfl</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="group-partitioning">
<span id="partitions-cg"></span><h2><span class="section-number">8.6. </span>Group Partitioning<a class="headerlink" href="#group-partitioning" title="Permalink to this headline">ï</a></h2>
<section id="tiled-partition">
<span id="partitions-cg-tiled"></span><h3><span class="section-number">8.6.1. </span><code class="docutils literal notranslate"><span class="pre">tiled_partition</span></code><a class="headerlink" href="#tiled-partition" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ParentT</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="n">ParentT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tiled_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParentT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">thread_group</span><span class="w"> </span><span class="nf">tiled_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_group</span><span class="o">&amp;</span><span class="w"> </span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tilesz</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">tiled_partition</span></code> method is a collective operation that partitions the parent group into a one-dimensional, row-major, tiling of subgroups. A total of ((size(parent)/tilesz) subgroups will be created, therefore the parent group size must be evenly divisible by the <code class="docutils literal notranslate"><span class="pre">Size</span></code>. The allowed parent groups are <code class="docutils literal notranslate"><span class="pre">thread_block</span></code> or <code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code>.</p>
<p>The implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution. Functionality is limited to native hardware sizes, 1/2/4/8/16/32 and the <code class="docutils literal notranslate"><span class="pre">cg::size(parent)</span></code> must be greater than the <code class="docutils literal notranslate"><span class="pre">Size</span></code> parameter. The templated version of <code class="docutils literal notranslate"><span class="pre">tiled_partition</span></code> supports 64/128/256/512 sizes as well, but some additional steps are required on Compute Capability 7.5 or lower, refer to <a class="reference internal" href="#thread-block-tile-group-cg"><span class="std std-ref">Thread Block Tile</span></a> for details.</p>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, C++11 for sizes larger than 32</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// The following code will create a 32-thread tile</span>
<span class="n">thread_block</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tile32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>We can partition each of these groups into even smaller groups, each of size 4 threads:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">tile4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tile32</span><span class="p">);</span><span class="w"></span>
<span class="c1">// or using a general group</span>
<span class="c1">// thread_group tile4 = tiled_partition(tile32, 4);</span>
</pre></div>
</div>
<p>If, for instance, if we were to then include the following line of code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tile4</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello from tile4 rank 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>then the statement would be printed by every fourth thread in the block: the threads of rank 0 in each <code class="docutils literal notranslate"><span class="pre">tile4</span></code> group, which correspond to those threads with ranks 0,4,8,12,etc. in the <code class="docutils literal notranslate"><span class="pre">block</span></code> group.</p>
</section>
<section id="labeled-partition">
<span id="partitions-cg-labeled"></span><h3><span class="section-number">8.6.2. </span><code class="docutils literal notranslate"><span class="pre">labeled_partition</span></code><a class="headerlink" href="#labeled-partition" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Label</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">coalesced_group</span><span class="w"> </span><span class="n">labeled_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">coalesced_group</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">Label</span><span class="w"> </span><span class="n">label</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Label</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">coalesced_group</span><span class="w"> </span><span class="n">labeled_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="n">Size</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">Label</span><span class="w"> </span><span class="n">label</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">labeled_partition</span></code> method is a collective operation that partitions the parent group into one-dimensional subgroups within which the threads are coalesced. The implementation will evaluate a condition label and assign threads that have the same value for label into the same group.</p>
<p><code class="docutils literal notranslate"><span class="pre">Label</span></code> can be any integral type.</p>
<p>The implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.</p>
<p><strong>Note:</strong> This functionality is still being evaluated and may slightly change in the future.</p>
<p><strong>Codegen Requirements:</strong> Compute Capability 7.0 minimum, C++11</p>
</section>
<section id="binary-partition">
<span id="partitions-cg-binary"></span><h3><span class="section-number">8.6.3. </span><code class="docutils literal notranslate"><span class="pre">binary_partition</span></code><a class="headerlink" href="#binary-partition" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">coalesced_group</span><span class="w"> </span><span class="nf">binary_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">coalesced_group</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Size</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">coalesced_group</span><span class="w"> </span><span class="n">binary_partition</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="n">Size</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pred</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">binary_partition()</span></code> method is a collective operation that partitions the parent group into one-dimensional subgroups within which the threads are coalesced. The implementation will evaluate a predicate and assign threads that have the same value into the same group. This is a specialized form of <code class="docutils literal notranslate"><span class="pre">labeled_partition()</span></code>, where the label can only be 0 or 1.</p>
<p>The implementation may cause the calling thread to wait until all the members of the parent group have invoked the operation before resuming execution.</p>
<p><strong>Note:</strong> This functionality is still being evaluated and may slightly change in the future.</p>
<p><strong>Codegen Requirements:</strong> Compute Capability 7.0 minimum, C++11</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// This example divides a 32-sized tile into a group with odd</span>
<span class="c1">/// numbers and a group with even numbers</span>
<span class="n">_global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">oddEven</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">inputArr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// inputArr contains random integers</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputArr</span><span class="p">[</span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()];</span><span class="w"></span>
<span class="w">    </span><span class="c1">// after this, tile32 is split into 2 groups,</span>
<span class="w">    </span><span class="c1">// a subtile where elem&amp;1 is true and one where its false</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">subtile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">binary_partition</span><span class="p">(</span><span class="n">tile32</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">elem</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="group-collectives">
<span id="collectives-cg"></span><h2><span class="section-number">8.7. </span>Group Collectives<a class="headerlink" href="#group-collectives" title="Permalink to this headline">ï</a></h2>
<p>Cooperative Groups library provides a set of collective operations that can be performed by a group of threads.
These operations require participation of all threads in the specified group in order to complete the operation.
All threads in the group need to pass the same values for corresponding arguments to each collective call, unless
different values are explicitly allowed in the argument description. Otherwise the behavior of the call is undefined.</p>
<section id="synchronization">
<span id="sync-collectives-cg"></span><h3><span class="section-number">8.7.1. </span>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">ï</a></h3>
<section id="barrier-arrive-and-barrier-wait">
<span id="collectives-cg-sync"></span><h4><span class="section-number">8.7.1.1. </span><code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code><a class="headerlink" href="#barrier-arrive-and-barrier-wait" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="o">::</span><span class="n">arrival_token</span><span class="w"> </span><span class="nf">T::barrier_arrive</span><span class="p">();</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">T::barrier_wait</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">arrival_token</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code> member functions provide a synchronization API similar to <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code> <a class="reference internal" href="#aw-barrier"><span class="std std-ref">(read more)</span></a>. Cooperative Groups automatically initializes the group barrier, but arrive and wait operations have an additional restriction resulting from collective nature of those operations: All threads in the group must arrive and wait at the barrier once per phase.
When <code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> is called with a group, result of calling any collective operation or another barrier arrival with that group is undefined until completion of the barrier phase is observed with <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code> call. Threads blocked on <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code> might be released from the synchronization before other threads call <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code>, but only after all threads in the group called <code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code>.
Group type <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any of the <a class="reference internal" href="#group-types-implicit-cg"><span class="std std-ref">implicit groups</span></a>.This allows threads to do independent work after they arrive and before they wait for the synchronization to resolve, allowing to hide some of the synchronization latency.
<code class="docutils literal notranslate"><span class="pre">barrier_arrive</span></code> returns an <code class="docutils literal notranslate"><span class="pre">arrival_token</span></code> object that must be passed into the corresponding <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code>. Token is consumed this way and can not be used for another <code class="docutils literal notranslate"><span class="pre">barrier_wait</span></code> call.</p>
<p><strong>Example of barrier_arrive and barrier_wait used to synchronize initization of shared memory across the cluster:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="nf">init_shared_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block</span><span class="o">&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="nf">local_processing</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block</span><span class="o">&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="nf">process_shared_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">thread_block</span><span class="o">&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">cluster_kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">cluster</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_cluster</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use this thread block to initialize some shared state</span>
<span class="w">    </span><span class="n">init_shared_data</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">barrier_arrive</span><span class="p">();</span><span class="w"> </span><span class="c1">// Let other blocks know this block is running and data was initialized</span>

<span class="w">    </span><span class="c1">// Do some local processing to hide the synchronization latency</span>
<span class="w">    </span><span class="n">local_processing</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Map data in shared memory from the next block in the cluster</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">dsmem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">map_shared_rank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="p">(</span><span class="n">cluster</span><span class="p">.</span><span class="n">block_rank</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">cluster</span><span class="p">.</span><span class="n">num_blocks</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Make sure all other blocks in the cluster are running and initialized shared data before accessing dsmem</span>
<span class="w">    </span><span class="n">cluster</span><span class="p">.</span><span class="n">barrier_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Consume data in distributed shared memory</span>
<span class="w">    </span><span class="n">process_shared_data</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">dsmem</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cluster</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="sync">
<h4><span class="section-number">8.7.1.2. </span><code class="docutils literal notranslate"><span class="pre">sync</span></code><a class="headerlink" href="#sync" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">T::sync</span><span class="p">();</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">sync</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sync</span></code> synchronizes the threads named in the group. Group type <code class="docutils literal notranslate"><span class="pre">T</span></code> can be any of the existing group types, as all of them support synchronization. Its available as a member function in every group type or as a free function taking a group as parameter.
If the group is a <code class="docutils literal notranslate"><span class="pre">grid_group</span></code> or a <code class="docutils literal notranslate"><span class="pre">multi_grid_group</span></code> the kernel must have been launched using the appropriate cooperative launch APIs. Equivalent to <code class="docutils literal notranslate"><span class="pre">T.barrier_wait(T.barrier_arrive())</span></code>.</p>
</section>
</section>
<section id="data-transfer">
<span id="data-transfer-collectives-cg"></span><h3><span class="section-number">8.7.2. </span>Data Transfer<a class="headerlink" href="#data-transfer" title="Permalink to this headline">ï</a></h3>
<section id="memcpy-async">
<span id="collectives-cg-memcpy-async"></span><h4><span class="section-number">8.7.2.1. </span><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code><a class="headerlink" href="#memcpy-async" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> is a group-wide collective memcpy that utilizes hardware accelerated support for non-blocking memory transactions from global to shared memory. Given a set of threads named in the group, <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> will move specified amount of bytes or elements of the input type through a single pipeline stage. Additionally for achieving best performance when using the <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API, an alignment of 16 bytes for both shared memory and global memory is required. It is important to note that while this is a memcpy in the general case, it is only asynchronous if the source is global memory and the destination is shared memory and both can be addressed with 16, 8, or 4 byte alignments. Asynchronously copied data should only be read following a call to wait or wait_prior which signals that the corresponding stage has completed moving data to shared memory.</p>
<p>Having to wait on all outstanding requests can lose some flexibility (but gain simplicity). In order to efficiently overlap data transfer and execution, its important to be able to kick off an <strong>N+1</strong><code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> request while waiting on and operating on request <strong>N</strong>. To do so, use <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> and wait on it using the collective stage-based <code class="docutils literal notranslate"><span class="pre">wait_prior</span></code> API. See <a class="reference internal" href="#collectives-cg-wait"><span class="std std-ref">wait and wait_prior</span></a> for more details.</p>
<p>Usage 1</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyElem</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyShape</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">memcpy_async</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="w"> </span><span class="o">&amp;</span><span class="n">group</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">TyElem</span><span class="w"> </span><span class="o">*</span><span class="n">__restrict__</span><span class="w"> </span><span class="n">_dst</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyElem</span><span class="w"> </span><span class="o">*</span><span class="n">__restrict__</span><span class="w"> </span><span class="n">_src</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyShape</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shape</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Performs a copy of <strong>``shape`` bytes</strong>.</p>
<p>Usage 2</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyElem</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyDstLayout</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TySrcLayout</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">memcpy_async</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="w"> </span><span class="o">&amp;</span><span class="n">group</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">TyElem</span><span class="w"> </span><span class="o">*</span><span class="n">__restrict__</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyDstLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dstLayout</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TyElem</span><span class="w"> </span><span class="o">*</span><span class="n">__restrict__</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">TySrcLayout</span><span class="w"> </span><span class="o">&amp;</span><span class="n">srcLayout</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Performs a copy of <strong>``min(dstLayout, srcLayout)`` elements</strong>. If layouts are of type <code class="docutils literal notranslate"><span class="pre">cuda::aligned_size_t&lt;N&gt;</span></code>, both must specify the same alignment.</p>
<p><strong>Errata</strong>
The <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> API introduced in CUDA 11.1 with both src and dst input layouts, expects the layout to be provided in elements rather than bytes. The element type is inferred from <code class="docutils literal notranslate"><span class="pre">TyElem</span></code> and has the size <code class="docutils literal notranslate"><span class="pre">sizeof(TyElem)</span></code>. If <code class="docutils literal notranslate"><span class="pre">cuda::aligned_size_t&lt;N&gt;</span></code> type is used as the layout, the number of elements specified times <code class="docutils literal notranslate"><span class="pre">sizeof(TyElem)</span></code> must be a multiple of N and it is recommended to use <code class="docutils literal notranslate"><span class="pre">std::byte</span></code> or <code class="docutils literal notranslate"><span class="pre">char</span></code> as the element type.</p>
<p>If specified shape or layout of the copy is of type <code class="docutils literal notranslate"><span class="pre">cuda::aligned_size_t&lt;N&gt;</span></code>, alignment will be guaranteed to be at least <code class="docutils literal notranslate"><span class="pre">min(16,</span> <span class="pre">N)</span></code>. In that case both <code class="docutils literal notranslate"><span class="pre">dst</span></code> and <code class="docutils literal notranslate"><span class="pre">src</span></code> pointers need to be aligned to N bytes and the number of bytes copied needs to be a multiple of N.</p>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11</p>
<p><code class="docutils literal notranslate"><span class="pre">cooperative_groups/memcpy_async.h</span></code> header needs to be included.</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// This example streams elementsPerThreadBlock worth of data from global memory</span>
<span class="c1">/// into a limited sized shared memory (elementsInShared) block to operate on.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="w"> </span><span class="n">tb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">elementsInShared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_smem</span><span class="p">[</span><span class="n">elementsInShared</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">copy_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span><span class="w"> </span><span class="n">local_smem</span><span class="p">,</span><span class="w"> </span><span class="n">elementsInShared</span><span class="p">,</span><span class="w"> </span><span class="n">global_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">copy_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">elementsInShared</span><span class="p">,</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Work with local_smem</span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">copy_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="wait-and-wait-prior">
<span id="collectives-cg-wait"></span><h4><span class="section-number">8.7.2.2. </span><code class="docutils literal notranslate"><span class="pre">wait</span> <span class="pre">and</span> <span class="pre">wait_prior</span></code><a class="headerlink" href="#wait-and-wait-prior" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">wait</span><span class="p">(</span><span class="n">TyGroup</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NumStages</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">wait_prior</span><span class="p">(</span><span class="n">TyGroup</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">wait</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_prior</span></code> collectives allow to wait for memcpy_async copies to complete. <code class="docutils literal notranslate"><span class="pre">wait</span></code> blocks calling threads until all previous copies are done. <code class="docutils literal notranslate"><span class="pre">wait_prior</span></code> allows that the latest NumStages are still not done and waits for all the previous requests. So with <code class="docutils literal notranslate"><span class="pre">N</span></code> total copies requested, it waits until the first <code class="docutils literal notranslate"><span class="pre">N-NumStages</span></code> are done and the last <code class="docutils literal notranslate"><span class="pre">NumStages</span></code> might still be in progress. Both <code class="docutils literal notranslate"><span class="pre">wait</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_prior</span></code> will synchronize the named group.</p>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, Compute Capability 8.0 for asynchronicity, C++11</p>
<p><code class="docutils literal notranslate"><span class="pre">cooperative_groups/memcpy_async.h</span></code> header needs to be included.</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// This example streams elementsPerThreadBlock worth of data from global memory</span>
<span class="c1">/// into a limited sized shared memory (elementsInShared) block to operate on in</span>
<span class="c1">/// multiple (two) stages. As stage N is kicked off, we can wait on and operate on stage N-1.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/memcpy_async.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="w"> </span><span class="n">tb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">elementsInShared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__align__</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_smem</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">elementsInShared</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// First kick off an extra request</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">copy_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elementsInShared</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_count</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span><span class="w"> </span><span class="n">local_smem</span><span class="p">[</span><span class="n">stage</span><span class="p">],</span><span class="w"> </span><span class="n">elementsInShared</span><span class="p">,</span><span class="w"> </span><span class="n">global_data</span><span class="p">,</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Now we kick off the next request...</span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span><span class="w"> </span><span class="n">local_smem</span><span class="p">[</span><span class="n">stage</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">elementsInShared</span><span class="p">,</span><span class="w"> </span><span class="n">global_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ... but we wait on the one before it</span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">wait_prior</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Its now available and we can work with local_smem[stage] here</span>
<span class="w">        </span><span class="c1">// (...)</span>
<span class="w">        </span><span class="c1">//</span>

<span class="w">        </span><span class="c1">// Calculate the amount fo data that was actually copied, for the next iteration.</span>
<span class="w">        </span><span class="n">copy_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">elementsInShared</span><span class="p">,</span><span class="w"> </span><span class="n">elementsPerThreadBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">copy_count</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// A cg::sync(tb) might be needed here depending on whether</span>
<span class="w">        </span><span class="c1">// the work done with local_smem[stage] can release threads to race ahead or not</span>
<span class="w">        </span><span class="c1">// Wrap to the next stage</span>
<span class="w">        </span><span class="n">stage</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">wait</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The last local_smem[stage] can be handled here</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="data-manipulation">
<span id="reduce-collectives-cg"></span><h3><span class="section-number">8.7.3. </span>Data Manipulation<a class="headerlink" href="#data-manipulation" title="Permalink to this headline">ï</a></h3>
<section id="reduce">
<span id="collectives-cg-reduce"></span><h4><span class="section-number">8.7.3.1. </span><code class="docutils literal notranslate"><span class="pre">reduce</span></code><a class="headerlink" href="#reduce" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyArg</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyOp</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">reduce</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyArg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyOp</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">reduce</span></code> performs a reduction operation on the data provided by each thread named in the group passed in. This takes advantage of hardware acceleration (on compute 80 and higher devices) for the arithmetic add, min, or max operations and the logical AND, OR, or XOR, as well as providing a software fallback on older generation hardware. Only 4B types are accelerated by hardware.</p>
<p><code class="docutils literal notranslate"><span class="pre">group</span></code>: Valid group types are <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and <code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">val</span></code>: Any type that satisfies the below requirements:</p>
<ul class="simple">
<li><p>Qualifies as trivially copyable i.e. <code class="docutils literal notranslate"><span class="pre">is_trivially_copyable&lt;TyArg&gt;::value</span> <span class="pre">==</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code> for <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and tiles of size lower or equal 32, <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">8</span></code> for larger tiles</p></li>
<li><p>Has suitable arithmetic or comparative operators for the given function object.</p></li>
</ul>
<p><strong>Note:</strong> Different threads in the group can pass different values for this argument.</p>
<p><code class="docutils literal notranslate"><span class="pre">op</span></code>: Valid function objects that will provide hardware acceleration with integral types are <code class="docutils literal notranslate"><span class="pre">plus(),</span> <span class="pre">less(),</span> <span class="pre">greater(),</span> <span class="pre">bit_and(),</span> <span class="pre">bit_xor(),</span> <span class="pre">bit_or()</span></code>. These must be constructed, hence the TyVal template argument is required, i.e. <code class="docutils literal notranslate"><span class="pre">plus&lt;int&gt;()</span></code>. Reduce also supports lambdas and other function objects that can be invoked using <code class="docutils literal notranslate"><span class="pre">operator()</span></code></p>
<p>Asynchronous reduce</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyArg</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyOp</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">reduce_update_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyArg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyOp</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyArg</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyOp</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">reduce_store_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyArg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyOp</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyArg</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyOp</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">reduce_store_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyArg</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">TyArg</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyOp</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*_async</span></code> variants of the API are asynchronously calculating the result to either store to or update a specified destination by one of the participating threads, instead of returning it by each thread. To observe the effect of these asynchronous calls, calling group of threads or a larger group containing them need to be synchronized.</p>
<ul class="simple">
<li><p>In case of the atomic store or update variant, <code class="docutils literal notranslate"><span class="pre">atomic</span></code> argument can be either of <code class="docutils literal notranslate"><span class="pre">cuda::atomic</span></code> or <code class="docutils literal notranslate"><span class="pre">cuda::atomic_ref</span></code> available in <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives.html">CUDA C++ Standard Library</a>. This variant of the API is available only on platforms and devices, where these types are supported by the CUDA C++ Standard Library. Result of the reduction is used to atomically update the atomic according to the specified <code class="docutils literal notranslate"><span class="pre">op</span></code>, eg. the result is atomically added to the atomic in case of <code class="docutils literal notranslate"><span class="pre">cg::plus()</span></code>. Type held by the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> must match the type of <code class="docutils literal notranslate"><span class="pre">TyArg</span></code>. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it. Atomic update is performed with relaxed memory ordering.</p></li>
<li><p>In case of the pointer store variant, result of the reduction will be weakly stored into the <code class="docutils literal notranslate"><span class="pre">dst</span></code> pointer.</p></li>
</ul>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, Compute Capability 8.0 for HW acceleration, C++11.</p>
<p><code class="docutils literal notranslate"><span class="pre">cooperative_groups/reduce.h</span></code> header needs to be included.</p>
<p><strong>Example of approximate standard deviation for integer vector:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/reduce.h&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="c1">/// Calculate approximate standard deviation of integers in vec</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">std_dev</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// calculate average first</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">num_threads</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">thread_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// cg::plus&lt;int&gt; allows cg::reduce() to know it can use hardware acceleration for addition</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">avg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">thread_sum</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">())</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_diffs_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">num_threads</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">avg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">thread_diffs_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">diff</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// temporarily use floats to calculate the square root</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">diff_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">thread_diffs_sum</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sqrtf</span><span class="p">(</span><span class="n">diff_sum</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of block wide reduction:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/reduce.h&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="o">=</span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="c1">/// The following example accepts input in *A and outputs a result into *sum</span>
<span class="c1">/// It spreads the data equally within the block</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">block_reduce</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">total_sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Stride loop over all values, each thread accumulates its part of the array.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">thread_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// reduce thread sums across the tile, add the result to the atomic</span>
<span class="w">    </span><span class="c1">// cg::plus&lt;int&gt; allows cg::reduce() to know it can use hardware acceleration for addition</span>
<span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce_update_async</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">total_sum</span><span class="p">,</span><span class="w"> </span><span class="n">thread_sum</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>

<span class="w"> </span><span class="c1">// synchronize the block, to ensure all async reductions are ready</span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="reduce-operators">
<span id="collectives-cg-reduce-operators"></span><h4><span class="section-number">8.7.3.2. </span><code class="docutils literal notranslate"><span class="pre">Reduce</span></code> Operators<a class="headerlink" href="#reduce-operators" title="Permalink to this headline">ï</a></h4>
<p>Below are the prototypes of function objects for some of the basic operations that can be done with <code class="docutils literal notranslate"><span class="pre">reduce</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">plus</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">less</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">greater</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">bit_and</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">bit_xor</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ty</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cg</span><span class="o">::</span><span class="n">bit_or</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Reduce is limited to the information available to the implementation at compile time. Thus in order to make use of intrinsics introduced in CC 8.0, the <code class="docutils literal notranslate"><span class="pre">cg::</span></code> namespace exposes several functional objects that mirror the hardware. These objects appear similar to those presented in the C++ STL, with the exception of <code class="docutils literal notranslate"><span class="pre">less/greater</span></code>. The reason for any difference from the STL is that these function objects are designed to actually mirror the operation of the hardware intrinsics.</p>
<p><strong>Functional description:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cg::plus:</span></code> Accepts two values and returns the sum of both using operator+.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg::less:</span></code> Accepts two values and returns the lesser using operator&lt;. This differs in that the <strong>lower value is returned</strong> rather than a Boolean.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg::greater:</span></code> Accepts two values and returns the greater using operator&lt;. This differs in that the <strong>greater value is returned</strong> rather than a Boolean.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg::bit_and:</span></code> Accepts two values and returns the result of operator&amp;.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg::bit_xor:</span></code> Accepts two values and returns the result of operator^.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cg::bit_or:</span></code> Accepts two values and returns the result of operator|.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// cg::plus&lt;int&gt; is specialized within cg::reduce and calls __reduce_add_sync(...) on CC 8.0+</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="c1">// cg::plus&lt;float&gt; fails to match with an accelerator and instead performs a standard shuffle based reduction</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="c1">// While individual components of a vector are supported, reduce will not use hardware intrinsics for the following</span>
<span class="w">    </span><span class="c1">// It will also be necessary to define a corresponding operator for vector and any custom types that may be used</span>
<span class="w">    </span><span class="n">int4</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{...};</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="n">int4</span><span class="o">&gt;</span><span class="p">())</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Finally lambdas and other function objects cannot be inspected for dispatch</span>
<span class="w">    </span><span class="c1">// and will instead perform shuffle based reductions using the provided function object.</span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">;});</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inclusive-scan-and-exclusive-scan">
<span id="collectives-cg-scan"></span><h4><span class="section-number">8.7.3.3. </span><code class="docutils literal notranslate"><span class="pre">inclusive_scan</span></code> and <code class="docutils literal notranslate"><span class="pre">exclusive_scan</span></code><a class="headerlink" href="#inclusive-scan-and-exclusive-scan" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyFn</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">inclusive_scan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyFn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">TyVal</span><span class="w"> </span><span class="n">inclusive_scan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyFn</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">exclusive_scan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyFn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">TyVal</span><span class="w"> </span><span class="n">exclusive_scan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">inclusive_scan</span></code> and <code class="docutils literal notranslate"><span class="pre">exclusive_scan</span></code> performs a scan operation on the data provided by each thread named in the group passed in. Result for each thread is a reduction of data from threads with lower <code class="docutils literal notranslate"><span class="pre">thread_rank</span></code> than that thread in case of <code class="docutils literal notranslate"><span class="pre">exclusive_scan</span></code>. <code class="docutils literal notranslate"><span class="pre">inclusive_scan</span></code> result also includes the calling thread data in the reduction.</p>
<p><code class="docutils literal notranslate"><span class="pre">group</span></code>: Valid group types are <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and <code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">val</span></code>: Any type that satisfies the below requirements:</p>
<ul class="simple">
<li><p>Qualifies as trivially copyable i.e. <code class="docutils literal notranslate"><span class="pre">is_trivially_copyable&lt;TyArg&gt;::value</span> <span class="pre">==</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code> for <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and tiles of size lower or equal 32, <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">8</span></code> for larger tiles</p></li>
<li><p>Has suitable arithmetic or comparative operators for the given function object.</p></li>
</ul>
<p><strong>Note:</strong> Different threads in the group can pass different values for this argument.</p>
<p><code class="docutils literal notranslate"><span class="pre">op</span></code>: Function objects defined for convenience are <code class="docutils literal notranslate"><span class="pre">plus(),</span> <span class="pre">less(),</span> <span class="pre">greater(),</span> <span class="pre">bit_and(),</span> <span class="pre">bit_xor(),</span> <span class="pre">bit_or()</span></code> described in <a class="reference internal" href="#collectives-cg-reduce-operators"><span class="std std-ref">Reduce Operators</span></a>. These must be constructed, hence the TyVal template argument is required, i.e. <code class="docutils literal notranslate"><span class="pre">plus&lt;int&gt;()</span></code>. <code class="docutils literal notranslate"><span class="pre">inclusive_scan</span></code> and <code class="docutils literal notranslate"><span class="pre">exclusive_scan</span></code> also supports lambdas and other function objects that can be invoked using <code class="docutils literal notranslate"><span class="pre">operator()</span></code>. Overloads without this argument use <code class="docutils literal notranslate"><span class="pre">cg::plus&lt;TyVal&gt;()</span></code>.</p>
<p><strong>Scan update</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyFn</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">inclusive_scan_update</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyFn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">TyVal</span><span class="w"> </span><span class="n">inclusive_scan_update</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyFn</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">exclusive_scan_update</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">TyFn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">));</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TyGroup</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyAtomic</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyVal</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">TyVal</span><span class="w"> </span><span class="n">exclusive_scan_update</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TyGroup</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">TyAtomic</span><span class="o">&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">,</span><span class="w"> </span><span class="n">TyVal</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">*_scan_update</span></code> collectives take an additional argument <code class="docutils literal notranslate"><span class="pre">atomic</span></code> that can be either of <code class="docutils literal notranslate"><span class="pre">cuda::atomic</span></code> or <code class="docutils literal notranslate"><span class="pre">cuda::atomic_ref</span></code> available in <a class="reference external" href="https://nvidia.github.io/libcudacxx/extended_api/synchronization_primitives.html">CUDA C++ Standard Library</a>. These variants of the API are available only on platforms and devices, where these types are supported by the CUDA C++ Standard Library. These variants will perform an update to the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> according to <code class="docutils literal notranslate"><span class="pre">op</span></code> with value of the sum of input values of all threads in the group. Previous value of the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> will be combined with the result of scan by each thread and returned. Type held by the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> must match the type of <code class="docutils literal notranslate"><span class="pre">TyVal</span></code>. Scope of the atomic must include all the threads in the group and if multiple groups are using the same atomic concurrently, scope must include all threads in all groups using it. Atomic update is performed with relaxed memory ordering.</p>
<p>Following pseudocode illustrates how the update variant of scan works:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> inclusive_scan_update behaves as the following block,</span>
<span class="cm"> except both reduce and inclusive_scan is calculated simultaneously.</span>
<span class="cm">auto total = reduce(group, val, op);</span>
<span class="cm">TyVal old;</span>
<span class="cm">if (group.thread_rank() == selected_thread) {</span>
<span class="cm">    atomicaly {</span>
<span class="cm">        old = atomic.load();</span>
<span class="cm">        atomic.store(op(old, total));</span>
<span class="cm">    }</span>
<span class="cm">}</span>
<span class="cm">old = group.shfl(old, selected_thread);</span>
<span class="cm">return op(inclusive_scan(group, val, op), old);</span>
<span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, C++11.</p>
<p><code class="docutils literal notranslate"><span class="pre">cooperative_groups/scan.h</span></code> header needs to be included.</p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/scan.h&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">thread_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">thread_block</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">inclusive_scan</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%u: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">(),</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cm">/*  prints for each group:</span>
<span class="cm">    0: 0</span>
<span class="cm">    1: 1</span>
<span class="cm">    2: 3</span>
<span class="cm">    3: 6</span>
<span class="cm">    4: 10</span>
<span class="cm">    5: 15</span>
<span class="cm">    6: 21</span>
<span class="cm">    7: 28</span>
<span class="cm">*/</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of stream compaction using exclusive_scan:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/scan.h&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="c1">// put data from input into output only if it passes test_fn predicate</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Group</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Data</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">TyFn</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">stream_compaction</span><span class="p">(</span><span class="n">Group</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">TyFn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">test_fn</span><span class="p">,</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">per_thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">num_threads</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">thread_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">per_thread</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">my_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">per_thread</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">thread_start</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// get all passing items from my part of the input</span>
<span class="w">    </span><span class="c1">//  into a contagious part of the array and count them.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread_start</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_fn</span><span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">my_count</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">my_count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">thread_start</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// scan over counts from each thread to calculate my starting</span>
<span class="w">    </span><span class="c1">//  index in the output</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">my_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">my_count</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">my_count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">output</span><span class="p">[</span><span class="n">my_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">thread_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// return the total number of items in the output</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">shfl</span><span class="p">(</span><span class="n">my_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">my_count</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">num_threads</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Example of dynamic buffer space allocation using exclusive_scan_update:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups/scan.h&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Buffer partitioning is static to make the example easier to follow,</span>
<span class="c1">// but any arbitrary dynamic allocation scheme can be implemented by replacing this function.</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">calculate_buffer_space_needed</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block_tile</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">tile</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tile</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">my_thread_data</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_block</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_used</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">this_thread_block</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">tiled_partition</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">buffer_used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// each thread calculates buffer size it needs</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_needed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_buffer_space_needed</span><span class="p">(</span><span class="n">tile</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// scan over the needs of each thread, result for each thread is an offset</span>
<span class="w">    </span><span class="c1">// of that threadâs part of the buffer. buffer_used is atomically updated with</span>
<span class="w">    </span><span class="c1">// the sum of all thread&#39;s inputs, to correctly offset other tileâs allocations</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">buf_offset</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">exclusive_scan_update</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_used</span><span class="p">,</span><span class="w"> </span><span class="n">buf_needed</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// each thread fills its own part of the buffer with thread specific data</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buf_needed</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">buffer</span><span class="p">[</span><span class="n">buf_offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_thread_data</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">block</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// buffer_used now holds total amount of memory allocated</span>
<span class="w">    </span><span class="c1">// buffer is {0, 0, 1, 0, 0, 1 ...};</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="execution-control">
<h3><span class="section-number">8.7.4. </span>Execution control<a class="headerlink" href="#execution-control" title="Permalink to this headline">ï</a></h3>
<section id="invoke-one-and-invoke-one-broadcast">
<span id="id210"></span><h4><span class="section-number">8.7.4.1. </span><code class="docutils literal notranslate"><span class="pre">invoke_one</span></code> and <code class="docutils literal notranslate"><span class="pre">invoke_one_broadcast</span></code><a class="headerlink" href="#invoke-one-and-invoke-one-broadcast" title="Permalink to this headline">ï</a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Group</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Fn</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">invoke_one</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Group</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">Fn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Group</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Fn</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">invoke_one_broadcast</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Group</span><span class="o">&amp;</span><span class="w"> </span><span class="n">group</span><span class="p">,</span><span class="w"> </span><span class="n">Fn</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">fn</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">args</span><span class="p">...));</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invoke_one</span></code> selects a single arbitrary thread from the calling <code class="docutils literal notranslate"><span class="pre">group</span></code> and uses that thread to call the supplied invocable <code class="docutils literal notranslate"><span class="pre">fn</span></code> with the supplied arguments <code class="docutils literal notranslate"><span class="pre">args</span></code>.
In case of <code class="docutils literal notranslate"><span class="pre">invoke_one_broadcast</span></code> the result of the call is also distributed to all threads in the group and returned from this collective.</p>
<p>Calling group can be synchronized with the selected thread before and/or after it calls the supplied invocable. It means that communication within the calling group
is not allowed inside the supplied invocable body, otherwise forward progress is not guaranteed. Communication with threads outside of the calling group is allowed in the
body of the supplied invocable. Thread selection mechanism is <strong>not</strong> guranteed to be deterministic.</p>
<p>On devices with Compute Capability 9.0 or higher hardware acceleration might be used to select the thread when called with <a class="reference internal" href="#group-types-explicit-cg"><span class="std std-ref">explicit group types</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">group</span></code>: All group types are valid for <code class="docutils literal notranslate"><span class="pre">invoke_one</span></code>, <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and <code class="docutils literal notranslate"><span class="pre">thread_block_tile</span></code> are valid for <code class="docutils literal notranslate"><span class="pre">invoke_one_broadcast</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">fn</span></code>: Function or object that can be invoked using <code class="docutils literal notranslate"><span class="pre">operator()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">args</span></code>: Parameter pack of types matching types of parameters of the supplied invocable <code class="docutils literal notranslate"><span class="pre">fn</span></code>.</p>
<p>In case of <code class="docutils literal notranslate"><span class="pre">invoke_one_broadcast</span></code> the return type of the supplied invocable <code class="docutils literal notranslate"><span class="pre">fn</span></code> must satisfy the below requirements:</p>
<ul class="simple">
<li><p>Qualifies as trivially copyable i.e. <code class="docutils literal notranslate"><span class="pre">is_trivially_copyable&lt;T&gt;::value</span> <span class="pre">==</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code> for <code class="docutils literal notranslate"><span class="pre">coalesced_group</span></code> and tiles of size lower or equal 32, <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span> <span class="pre">&lt;=</span> <span class="pre">8</span></code> for larger tiles</p></li>
</ul>
<p><strong>Codegen Requirements:</strong> Compute Capability 5.0 minimum, Compute Capability 9.0 for hardware acceleration, C++11.</p>
<p><strong>Aggregated atomic example from</strong> <a class="reference internal" href="#discovery-pattern-cg"><span class="std std-ref">Discovery pattern section</span></a> <strong>re-written to use invoke_one_broadcast:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/atomic&gt;</span><span class="cp"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope</span><span class="w"> </span><span class="n">Scope</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomicAddOneRelaxed</span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Scope</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">atomic</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">invoke_one_broadcast</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">atomic</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">num_threads</span><span class="p">(),</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">prev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">thread_rank</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="grid-synchronization">
<span id="grid-synchronization-cg"></span><h2><span class="section-number">8.8. </span>Grid Synchronization<a class="headerlink" href="#grid-synchronization" title="Permalink to this headline">ï</a></h2>
<p>Prior to the introduction of Cooperative Groups, the CUDA programming model only allowed synchronization between thread blocks at a kernel completion boundary. The kernel boundary carries with it an implicit invalidation of state, and with it, potential performance implications.</p>
<p>For example, in certain use cases, applications have a large number of small kernels, with each kernel representing a stage in a processing pipeline. The presence of these kernels is required by the current CUDA programming model to ensure that the thread blocks operating on one pipeline stage have produced data before the thread block operating on the next pipeline stage is ready to consume it. In such cases, the ability to provide global inter thread block synchronization would allow the application to be restructured to have persistent thread blocks, which are able to synchronize on the device when a given stage is complete.</p>
<p>To synchronize across the grid, from within a kernel, you would simply use the <code class="docutils literal notranslate"><span class="pre">grid.sync()</span></code> function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">grid_group</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_grid</span><span class="p">();</span><span class="w"></span>
<span class="n">grid</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>And when launching the kernel it is necessary to use, instead of the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code> execution configuration syntax, the <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernel</span></code> CUDA runtime launch API or the <code class="docutils literal notranslate"><span class="pre">CUDA</span> <span class="pre">driver</span> <span class="pre">equivalent</span></code>.</p>
<p><strong>Example:</strong></p>
<p>To guarantee co-residency of the thread blocks on the GPU, the number of blocks launched needs to be carefully considered. For example, as many blocks as there are SMs can be launched as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="c1">// initialize, then launch</span>
<span class="n">cudaLaunchCooperativeKernel</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">my_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">.</span><span class="n">multiProcessorCount</span><span class="p">,</span><span class="w"> </span><span class="n">numThreads</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Alternatively, you can maximize the exposed parallelism by calculating how many blocks can fit simultaneously per-SM using the occupancy calculator as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// This will launch a grid that can maximally fill the GPU, on the default stream with kernel arguments</span>
<span class="kt">int</span><span class="w"> </span><span class="n">numBlocksPerSm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="c1">// Number of threads my_kernel will be launched with</span>
<span class="kt">int</span><span class="w"> </span><span class="n">numThreads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numBlocksPerSm</span><span class="p">,</span><span class="w"> </span><span class="n">my_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">numThreads</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="c1">// launch</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernelArgs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* add kernel args */</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">dim3</span><span class="w"> </span><span class="nf">dimBlock</span><span class="p">(</span><span class="n">numThreads</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">dim3</span><span class="w"> </span><span class="nf">dimGrid</span><span class="p">(</span><span class="n">deviceProp</span><span class="p">.</span><span class="n">multiProcessorCount</span><span class="o">*</span><span class="n">numBlocksPerSm</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaLaunchCooperativeKernel</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">my_kernel</span><span class="p">,</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">,</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">,</span><span class="w"> </span><span class="n">kernelArgs</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>It is good practice to first ensure the device supports cooperative launches by querying the device attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrCooperativeLaunch</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">supportsCoopLaunch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">supportsCoopLaunch</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrCooperativeLaunch</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>which will set <code class="docutils literal notranslate"><span class="pre">supportsCoopLaunch</span></code> to 1 if the property is supported on device 0. Only devices with compute capability of 6.0 and higher are supported. In addition, you need to be running on either of these:</p>
<ul class="simple">
<li><p>The Linux platform without MPS</p></li>
<li><p>The Linux platform with MPS and on a device with compute capability 7.0 or higher</p></li>
<li><p>The latest Windows platform</p></li>
</ul>
</section>
<section id="multi-device-synchronization">
<span id="multi-device-synchronization-cg"></span><h2><span class="section-number">8.9. </span>Multi-Device Synchronization<a class="headerlink" href="#multi-device-synchronization" title="Permalink to this headline">ï</a></h2>
<p>In order to enable synchronization across multiple devices with Cooperative Groups, use of the <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernelMultiDevice</span></code> CUDA API is required. This, a significant departure from existing CUDA APIs, will allow a single host thread to launch a kernel across multiple devices. In addition to the constraints and guarantees made by <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernel</span></code>, this API has additional semantics:</p>
<ul class="simple">
<li><p>This API will ensure that a launch is atomic, i.e. if the API call succeeds, then the provided number of thread blocks will launch on all specified devices.</p></li>
<li><p>The functions launched via this API must be identical. No explicit checks are done by the driver in this regard because it is largely not feasible. It is up to the application to ensure this.</p></li>
<li><p>No two entries in the provided <code class="docutils literal notranslate"><span class="pre">cudaLaunchParams</span></code> may map to the same device.</p></li>
<li><p>All devices being targeted by this launch must be of the same compute capability - major and minor versions.</p></li>
<li><p>The block size, grid size and amount of shared memory per grid must be the same across all devices. Note that this means the maximum number of blocks that can be launched per device will be limited by the device with the least number of SMs.</p></li>
<li><p>Any user defined <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> or <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> device global variables present in the module that owns the CUfunction being launched are independently instantiated on every device. The user is responsible for initializing such device global variables appropriately.</p></li>
</ul>
<p>Deprecation Notice: <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernelMultiDevice</span></code> has been deprecated in CUDA 11.3 for all devices. Example of an alternative approach can be found in the multi device conjugate gradient sample.</p>
<p>Optimal performance in multi-device synchronization is achieved by enabling peer access via <code class="docutils literal notranslate"><span class="pre">cuCtxEnablePeerAccess</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaDeviceEnablePeerAccess</span></code> for all participating devices.</p>
<p>The launch parameters should be defined using an array of structs (one per device), and launched with <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernelMultiDevice</span></code></p>
<p><strong>Example:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaDeviceProp</span><span class="w"> </span><span class="n">deviceProp</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numGpus</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Per device launch parameters</span>
<span class="n">cudaLaunchParams</span><span class="w"> </span><span class="o">*</span><span class="n">launchParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cudaLaunchParams</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cudaLaunchParams</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numGpus</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStream_t</span><span class="w"> </span><span class="o">*</span><span class="n">streams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cudaStream_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numGpus</span><span class="p">);</span><span class="w"></span>

<span class="c1">// The kernel arguments are copied over during launch</span>
<span class="c1">// Its also possible to have individual copies of kernel arguments per device, but</span>
<span class="c1">// the signature and name of the function/kernel must be the same.</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernelArgs</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Add kernel arguments */</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGpus</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Per device stream, but its also possible to use the default NULL stream of each device</span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Loop over other devices and cudaDeviceEnablePeerAccess to get a faster barrier implementation</span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Since all devices must be of the same compute capability and have the same launch configuration</span>
<span class="c1">// it is sufficient to query device 0 here</span>
<span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceProp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">dim3</span><span class="w"> </span><span class="nf">dimBlock</span><span class="p">(</span><span class="n">numThreads</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">dim3</span><span class="w"> </span><span class="nf">dimGrid</span><span class="p">(</span><span class="n">deviceProp</span><span class="p">.</span><span class="n">multiProcessorCount</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numGpus</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">my_kernel</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gridDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dimGrid</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">blockDim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dimBlock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sharedMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="n">launchParamsList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernelArgs</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">cudaLaunchCooperativeKernelMultiDevice</span><span class="p">(</span><span class="n">launchParams</span><span class="p">,</span><span class="w"> </span><span class="n">numGpus</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Also, as with grid-wide synchronization, the resulting device code looks very similar:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">multi_grid_group</span><span class="w"> </span><span class="n">multi_grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this_multi_grid</span><span class="p">();</span><span class="w"></span>
<span class="n">multi_grid</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>However, the code needs to be compiled in separate compilation by passing <code class="docutils literal notranslate"><span class="pre">-rdc=true</span></code> to nvcc.</p>
<p>It is good practice to first ensure the device supports multi-device cooperative launches by querying the device attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrCooperativeMultiDeviceLaunch</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">supportsMdCoopLaunch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">supportsMdCoopLaunch</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrCooperativeMultiDeviceLaunch</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>which will set <code class="docutils literal notranslate"><span class="pre">supportsMdCoopLaunch</span></code> to 1 if the property is supported on device 0. Only devices with compute capability of 6.0 and higher are supported. In addition, you need to be running on the Linux platform (without MPS) or on current versions of Windows with the device in TCC mode.</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">cudaLaunchCooperativeKernelMultiDevice</span></code> API documentation for more information.</p>
</section>
</section>
<section id="cluster-launch-control">
<span id="id211"></span><h1><span class="section-number">9. </span>Cluster Launch Control<a class="headerlink" href="#cluster-launch-control" title="Permalink to this headline">ï</a></h1>
<section id="introduction-clc">
<span id="id212"></span><h2><span class="section-number">9.1. </span>Introduction<a class="headerlink" href="#introduction-clc" title="Permalink to this headline">ï</a></h2>
<p>Compute Capability 10.0 introduces Cluster Launch Control, a new
feature that provides developer with more control over thread block scheduling
by cancelling thread blocks or thread block clusters.</p>
<p>When dealing with problems of variable size, there are two main
approaches to determining the number of kernel thread blocks.</p>
<p><strong>Approach 1: Fixed Work per Thread Block:</strong></p>
<p>In this approach, the number of thread blocks is determined by the problem
size, while the amount of work done by each thread block remains constant
or is limited.</p>
<p>Key advantages of this approach:</p>
<ul>
<li><p>Load balancing between SMs.</p>
<p>In particular, when thread block run-times exhibit variability
and/or when the number of thread blocks is much larger than what
the GPU can execute simultaneously (resulting in a low-tail effect),
this approach allows the GPU scheduler to run more thread blocks
on some SMs than others.</p>
</li>
<li><p>Preemption.</p>
<p>The GPU scheduler can start executing a
<a class="reference internal" href="#stream-priorities"><span class="std std-ref">higher-priority kernel</span></a>,
even if it is launched after the execution of a lower-priority kernel has
already begun, by scheduling the higher-priority kernelâs thread blocks
as the currently running lower-priority kernelâs thread blocks finish.
It can then return to the lower-priority kernel once the higher-priority
kernel has finished.</p>
</li>
</ul>
<p><strong>Approach 2: Fixed Number of Thread Blocks:</strong></p>
<p>In this approach, often implemented as a block-stride or grid-stride loop,
the number of thread blocks does not directly depend
on the problem size. Instead, the amount of work done by each thread block
is a function of the problem size. Typically, the number of thread blocks is
based on the number of SMs on the GPU where the kernel is executed
and the desired occupancy.</p>
<p>Key advantage of this approach:</p>
<ul>
<li><p>Reduced thread block overheads.</p>
<p>This approach not only reduces amortized thread block launch latency
but also minimizes the computational overhead associated with shared
operations across all thread blocks.
These overheads can be significantly higher than launch latency overheads.</p>
<p>For example, in convolution kernels, a prologue for calculating
convolution coefficients â independent of the thread block index â
can be computed fewer times due to the fixed number of thread blocks,
thus reducing redundant computations.</p>
</li>
</ul>
<p><strong>Cluster Launch Control Approach:</strong></p>
<p>Cluster Launch Control allows a kernel to request (<strong>cancel</strong>)
the thread block index of a block that has not yet started execution.</p>
<p>This mechanism enables work-stealing among thread blocks:
a thread block attempts to cancel the launch of another thread block
that has not started running yet. If cancellation succeeds,
it âstealsâ the other thread blockâs work by using cancelled block index
to perform the task.</p>
<p>The cancellation will fail if there are no more thread block indices
available and may fail for other reasons, such as a higher-priority kernel
being scheduled. In the latter case, if a thread block exits after a
cancellation failure, the scheduler can start executing the higher-priority
kernel, after which it will continue scheduling the remaining thread blocks
of the current kernel for execution.</p>
<p>The table below summarizes advantages and disadvantages of the three approaches:</p>
<table class="table-no-stripes colwidths-given docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p class="centered">
<strong>Fixed Work per Thread Block</strong></p></th>
<th class="head"><p class="centered">
<strong>Fixed Number of Thread Blocks</strong></p></th>
<th class="head"><p class="centered">
<strong>Cluster Launch Control</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Reduced overheads</p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{red}{\textbf{X}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
</tr>
<tr class="row-odd"><td><p>Preemption</p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{red}{\textbf{X}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
</tr>
<tr class="row-even"><td><p>Load balancing</p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{red}{\textbf{X}}\)</span></strong></p></td>
<td><p class="centered">
<strong><span class="math notranslate nohighlight">\(\textcolor{lime}{\textbf{V}}\)</span></strong></p></td>
</tr>
</tbody>
</table>
</section>
<section id="cluster-launch-control-api-details">
<span id="api-details-clc"></span><h2><span class="section-number">9.2. </span>Cluster Launch Control API Details<a class="headerlink" href="#cluster-launch-control-api-details" title="Permalink to this headline">ï</a></h2>
<p>Cancelling a thread block via the Cluster Launch Control API is done
asynchronously and synchronized using a memory barrier,
following a programming pattern similar
to <a class="reference internal" href="#memcpy-async-barrier"><span class="std std-ref">asynchronous data copies</span></a>.</p>
<p>The API, currently available through
<a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/ptx.html">libcu++</a>,
provides a request instruction that writes the encoded cancellation result
into a <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variable, along with instructions to decode the result
into a <em>Success</em>/<em>Fail</em> flag and the index of the cancelled thread block
in case of <em>Success</em>.</p>
<section id="thread-block-cancellation-steps">
<h3><span class="section-number">9.2.1. </span>Thread block cancellation steps<a class="headerlink" href="#thread-block-cancellation-steps" title="Permalink to this headline">ï</a></h3>
<p>The preferred way to use Cluster Launch Control is from a single thread,
i.e., one request at a time.</p>
<p>The following are the five steps of the thread block cancellation process.
The first two steps are declarations and initialization of cancellation result
and synchronization variables, which are done before the work-stealing.
The last three steps are typically executed inside a work-stealing loop
over thread block indices.</p>
<ol class="arabic">
<li><p>Declare variables for thread block cancellation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__shared__</span><span class="w"> </span><span class="n">uint4</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="c1">// Request result.</span>
<span class="n">__shared__</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"> </span><span class="c1">// Synchronization barrier.</span>
<span class="kt">int</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">           </span><span class="c1">// Synchronization barrier phase.</span>
</pre></div>
</div>
</li>
<li><p>Initialize shared memory barrier with a single arrival count:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Submit asynchronous cancellation request by a single thread and
set transaction count:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cg</span><span class="o">::</span><span class="n">invoke_one</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">(),</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_arrive_expect_tx</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_relaxed</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cta</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint4</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since thread block cancellation is a uniform instruction,
it is recommended to submit it inside
<a class="reference internal" href="#invoke-one-and-invoke-one-broadcast"><span class="std std-ref">invoke_one</span></a> thread selector.
This allows the compliler to optimize out the peeling loop.</p>
</div>
</li>
<li><p>Synchronize (complete) asynchronous cancellation request:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_try_wait_parity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">phase</span><span class="p">))</span><span class="w"></span>
<span class="p">{}</span><span class="w"></span>
<span class="n">phase</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Retrieve cancellation status and cancelled thread block index:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_is_canceled</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Don&#39;t need all three for 1D/2D thread blocks:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_get_first_ctaid_x</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_get_first_ctaid_y</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_get_first_ctaid_z</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Ensure visibility of shared memory operations between async and generic
<a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#proxies">proxies</a>,
and protect against data races between iterations of the work-stealing loop.</p></li>
</ol>
</section>
<section id="thread-block-cancellation-constraints">
<h3><span class="section-number">9.2.2. </span>Thread block cancellation constraints<a class="headerlink" href="#thread-block-cancellation-constraints" title="Permalink to this headline">ï</a></h3>
<p>The constraints are related to failed cancellation requests:</p>
<ul>
<li><p>Submitting another cancellation request after <strong>observing</strong> a
previously failed request is Undefined Behavior.</p>
<p>In the two code examples below, assuming the first cancellation request
fails, only the first example exhibits undefined behavior.
The second example is correct because there is no observation between the
cancellation requests:</p>
<p><strong>Invalid code:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// First request:</span>
<span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// First request query:</span>
<span class="p">[</span><span class="n">Synchronize</span><span class="w"> </span><span class="n">bar0</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">here</span><span class="p">.]</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">success0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_is_canceled</span><span class="p">(</span><span class="n">result0</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">success0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Observed failure; second cacellation will be invalid.</span>

<span class="c1">// Second request - next line is Undefined Behavior:</span>
<span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Valid code:</strong></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// First request:</span>
<span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Second request:</span>
<span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar1</span><span class="p">);</span><span class="w"></span>

<span class="c1">// First request query:</span>
<span class="p">[</span><span class="n">Synchronize</span><span class="w"> </span><span class="n">bar0</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">here</span><span class="p">.]</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">success0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_is_canceled</span><span class="p">(</span><span class="n">result0</span><span class="p">);</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">success0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Observed failure; second cacellation was valid.</span>
</pre></div>
</div>
</li>
<li><p>Retrieving the thread block index of a failed cancellation request
is Undefined Behavior.</p></li>
<li><p>Submitting a cancellation request from multiple threads is not recommended.
It results in the cancellation of multiple thread blocks
and requires careful handling,
such as:</p>
<ul class="simple">
<li><p>Each submitting thread must proivde a unique <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> result
pointer to avoid data races.</p></li>
<li><p>If the same barrier is used for synchronization, the arrival and
transaction counts must be adjusted accordingly.</p></li>
</ul>
</li>
</ul>
</section>
<section id="kernel-example-vector-scalar-multiplication">
<h3><span class="section-number">9.2.3. </span>Kernel Example: Vector-Scalar Multiplication<a class="headerlink" href="#kernel-example-vector-scalar-multiplication" title="Permalink to this headline">ï</a></h3>
<p>The three kernels below demonstrate the Fixed Work per Thread Block,
Fixed Number of Thread Blocks, and Cluster Launch Control approaches
for vector-scalar multiplication
<span class="math notranslate nohighlight">\(\overline{v} := \alpha \overline{v}\)</span>.</p>
<ul>
<li><p>Fixed Work per Thread Block:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_fixed_work</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Prologue:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_scalar</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Computation:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Launch: kernel_fixed_work&lt;&lt;&lt;1024, (n + 1023) / 1024&gt;&gt;&gt;(data, n);</span>
</pre></div>
</div>
</li>
<li><p>Fixed Number of Thread Blocks:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_fixed_blocks</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Prologue:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_scalar</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Computation:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Launch: kernel_fixed_blocks&lt;&lt;&lt;1024, SM_COUNT&gt;&gt;&gt;(data, n);</span>
</pre></div>
</div>
</li>
<li><p>Cluster Launch Control:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/ptx&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cuda</span><span class="o">::</span><span class="nn">ptx</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_cluster_launch_control</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Cluster launch control initialization:</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">uint4</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prologue:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_scalar</span><span class="p">();</span><span class="w"> </span><span class="c1">// Device function not shown in this code snippet.</span>

<span class="w">    </span><span class="c1">// Work-stealing loop:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assuming 1D x-axis thread blocks.</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Protect result from overwrite in the next iteration,</span>
<span class="w">        </span><span class="c1">// (also ensure barrier initialization at 1st iteration):</span>
<span class="w">        </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Acquire write of result in the async proxy:</span>
<span class="w">            </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async_generic_sync_restrict</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_cluster</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="n">cg</span><span class="o">::</span><span class="n">invoke_one</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);});</span><span class="w"></span>
<span class="w">            </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_arrive_expect_tx</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_relaxed</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cta</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint4</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Computation:</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request synchronization:</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_try_wait_parity</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cta</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">phase</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="n">phase</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request decoding:</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_is_canceled</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_get_first_ctaid_x</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Release read of result to the async proxy:</span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async_generic_sync_restrict</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_release</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Launch: kernel_cluster_launch_control&lt;&lt;&lt;1024, (n + 1023) / 1024&gt;&gt;&gt;(data, n);</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="cluster-launch-control-for-thread-block-clusters">
<h3><span class="section-number">9.2.4. </span>Cluster Launch Control for Thread Block Clusters<a class="headerlink" href="#cluster-launch-control-for-thread-block-clusters" title="Permalink to this headline">ï</a></h3>
<p>In the case of a <a class="reference internal" href="#thread-block-clusters"><span class="std std-ref">thread block clusters</span></a>,
the thread block cancellation steps are the same as in a non-cluster setting,
with minor adjustments.
As in the non-cluster case, submitting a cancellation request from multiple
threads <strong>within a cluster</strong> is not recommended,
as this will attempt to cancel multiple clusters.</p>
<ul class="simple">
<li><p>The cancellation is submitted by a single cluster thread.</p></li>
<li><p>The shared memory result of each clusterâs thread block will receive
the same (encoded) value of the cancelled thread block index
(i.e., the result value is multicasted).
The result received by all thread blocks corresponds to the local
block index <code class="docutils literal notranslate"><span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0}</span></code> within a cluster.
Therefore, thread blocks within the cluster need to add
the local block index.</p></li>
<li><p>Synchronization is performed by each clusterâs thread block using
a local <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> memory barrier. Barrier operations must be performed
with the <code class="docutils literal notranslate"><span class="pre">ptx::scope_cluster</span></code> scope.</p></li>
<li><p>Cancelling in the cluster case requires all the thread blocks to exist.
A user can guarantee that all thread blocks are running by using
<code class="docutils literal notranslate"><span class="pre">cg::cluster_group::sync()</span></code> from <a class="reference internal" href="#cluster-group-cg"><span class="std std-ref">Cluster Group</span></a> API.</p></li>
</ul>
<p>The kernel below demonstrates Cluster Launch Control approach
in a thread block cluster case:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cooperative_groups.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/ptx&gt;</span><span class="cp"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cooperative_groups</span><span class="p">;</span><span class="w"></span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ptx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">cuda</span><span class="o">::</span><span class="nn">ptx</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="nf">__cluster_dims__</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">kernel_cluster_launch_control</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Cluster launch control initialization:</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="n">uint4</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_mbarrier_init</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_release</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">);</span><span class="w"> </span><span class="c1">// CGA-level fence.</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Prologue:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_scalar</span><span class="p">();</span><span class="w"> </span><span class="c1">// Device function not shown in this code snippet.</span>

<span class="w">    </span><span class="c1">// Work-stealing loop:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Assuming 1D x-axis thread blocks.</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Protect result from overwrite in the next iteration,</span>
<span class="w">        </span><span class="c1">// (also ensure all thread blocks have started at 1st iteration):</span>
<span class="w">        </span><span class="n">cg</span><span class="o">::</span><span class="n">cluster_group</span><span class="o">::</span><span class="n">sync</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request by a single cluster thread:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">cluster_group</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Acquire write of result in the async proxy:</span>
<span class="w">            </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async_generic_sync_restrict</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_cluster</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">);</span><span class="w"></span>

<span class="w">            </span><span class="n">cg</span><span class="o">::</span><span class="n">invoke_one</span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">coalesced_threads</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](){</span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_try_cancel_multicast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">);});</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation completion tracked by each thread block:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cg</span><span class="o">::</span><span class="n">thread_block</span><span class="o">::</span><span class="n">thread_rank</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_arrive_expect_tx</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_relaxed</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint4</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Computation:</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request synchronization:</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ptx</span><span class="o">::</span><span class="n">mbarrier_try_wait_parity</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_acquire</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">phase</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">{}</span><span class="w"></span>
<span class="w">        </span><span class="n">phase</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Cancellation request decoding:</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_is_canceled</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">clusterlaunchcontrol_query_cancel_get_first_ctaid_x</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cg</span><span class="o">::</span><span class="n">cluster_group</span><span class="o">::</span><span class="n">block_index</span><span class="p">().</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Add local offset.</span>

<span class="w">        </span><span class="c1">// Release read of result to the async proxy:</span>
<span class="w">        </span><span class="n">ptx</span><span class="o">::</span><span class="n">fence_proxy_async_generic_sync_restrict</span><span class="p">(</span><span class="n">ptx</span><span class="o">::</span><span class="n">sem_release</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">space_shared</span><span class="p">,</span><span class="w"> </span><span class="n">ptx</span><span class="o">::</span><span class="n">scope_cluster</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Launch: kernel_cluster_launch_control&lt;&lt;&lt;1024, (n + 1023) / 1024&gt;&gt;&gt;(data, n);</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="cuda-dynamic-parallelism">
<span id="id213"></span><h1><span class="section-number">10. </span>CUDA Dynamic Parallelism<a class="headerlink" href="#cuda-dynamic-parallelism" title="Permalink to this headline">ï</a></h1>
<section id="introduction-cuda-dynamic-parallelism">
<span id="id214"></span><h2><span class="section-number">10.1. </span>Introduction<a class="headerlink" href="#introduction-cuda-dynamic-parallelism" title="Permalink to this headline">ï</a></h2>
<section id="overview">
<h3><span class="section-number">10.1.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">ï</a></h3>
<p><em>Dynamic Parallelism</em> is an extension to the CUDA programming model enabling a CUDA kernel to create and synchronize with new work directly on the GPU. The creation of parallelism dynamically at whichever point in a program that it is needed offers exciting capabilities.</p>
<p>The ability to create work directly from the GPU can reduce the need to transfer execution control and data between host and device, as launch configuration decisions can now be made at runtime by threads executing on the device. Additionally, data-dependent parallel work can be generated inline within a kernel at run-time, taking advantage of the GPUâs hardware schedulers and load balancers dynamically and adapting in response to data-driven decisions or workloads. Algorithms and programming patterns that had previously required modifications to eliminate recursion, irregular loop structure, or other constructs that do not fit a flat, single-level of parallelism may more transparently be expressed.</p>
<p>This document describes the extended capabilities of CUDA which enable Dynamic Parallelism, including the modifications and additions to the CUDA programming model necessary to take advantage of these, as well as guidelines and best practices for exploiting this added capacity.</p>
<p>Dynamic Parallelism is only supported by devices of compute capability 3.5 and higher.</p>
</section>
<section id="glossary">
<h3><span class="section-number">10.1.2. </span>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">ï</a></h3>
<p>Definitions for terms used in this guide.</p>
<dl class="simple">
<dt>Grid</dt><dd><p>A Grid is a collection of <em>Threads</em>. Threads in a Grid execute a <em>Kernel Function</em> and are divided into <em>Thread Blocks</em>.</p>
</dd>
<dt>Thread Block</dt><dd><p>A Thread Block is a group of threads which execute on the same multiprocessor (<em>SM</em>). Threads within a Thread Block have access to shared memory and can be explicitly synchronized.</p>
</dd>
<dt>Kernel Function</dt><dd><p>A Kernel Function is an implicitly parallel subroutine that executes under the CUDA execution and memory model for every Thread in a Grid.</p>
</dd>
<dt>Host</dt><dd><p>The Host refers to the execution environment that initially invoked CUDA. Typically the thread running on a systemâs CPU processor.</p>
</dd>
<dt>Parent</dt><dd><p>A <em>Parent Thread</em>, Thread Block, or Grid is one that has launched new grid(s), the <em>Child</em> Grid(s). The Parent is not considered completed until all of its launched Child Grids have also completed.</p>
</dd>
<dt>Child</dt><dd><p>A Child thread, block, or grid is one that has been launched by a Parent grid. A Child grid must complete before the Parent Thread, Thread Block, or Grid are considered complete.</p>
</dd>
<dt>Thread Block Scope</dt><dd><p>Objects with Thread Block Scope have the lifetime of a single Thread Block. They only have defined behavior when operated on by Threads in the Thread Block that created the object and are destroyed when the Thread Block that created them is complete.</p>
</dd>
<dt>Device Runtime</dt><dd><p>The Device Runtime refers to the runtime system and APIs available to enable Kernel Functions to use Dynamic Parallelism.</p>
</dd>
</dl>
</section>
</section>
<section id="execution-environment-and-memory-model">
<span id="execution-environment-and-memory-model-cdp2"></span><h2><span class="section-number">10.2. </span>Execution Environment and Memory Model<a class="headerlink" href="#execution-environment-and-memory-model" title="Permalink to this headline">ï</a></h2>
<section id="execution-environment">
<span id="execution-environment-cdp2"></span><h3><span class="section-number">10.2.1. </span>Execution Environment<a class="headerlink" href="#execution-environment" title="Permalink to this headline">ï</a></h3>
<p>The CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the gridâs properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and implicitly synchronize upon new grids to threads that are running on the device.</p>
<section id="parent-and-child-grids">
<span id="parent-and-child-grids-cdp2"></span><h4><span class="section-number">10.2.1.1. </span>Parent and Child Grids<a class="headerlink" href="#parent-and-child-grids" title="Permalink to this headline">ï</a></h4>
<p>A device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.</p>
<p>The invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed, and the runtime guarantees an implicit synchronization between the parent and child.</p>
<figure class="align-center" id="parent-child-launch-nesting-figure">
<img alt="Parent-Child Launch Nesting" src="_images/parent-child-launch-nesting.png" />
<figcaption>
<p><span class="caption-number">Figure 29 </span><span class="caption-text">Parent-Child Launch Nesting</span><a class="headerlink" href="#parent-child-launch-nesting-figure" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="scope-of-cuda-primitives">
<span id="scope-of-cuda-primitives-cdp2"></span><h4><span class="section-number">10.2.1.2. </span>Scope of CUDA Primitives<a class="headerlink" href="#scope-of-cuda-primitives" title="Permalink to this headline">ï</a></h4>
<p>On both host and device, the CUDA runtime offers an API for launching kernels and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.</p>
<p>On the device, launched kernels and CUDA objects are visible to all threads in a grid. This means, for example, that a stream may be created by one thread and used by any other thread in the grid.</p>
</section>
<section id="dynamic-parallelism-synchronization">
<span id="id215"></span><h4><span class="section-number">10.2.1.3. </span>Synchronization<a class="headerlink" href="#dynamic-parallelism-synchronization" title="Permalink to this headline">ï</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6 and removed for compute_90+ compilation. For compute capability &lt; 9.0, compile-time opt-in by specifying <code class="docutils literal notranslate"><span class="pre">-DCUDA_FORCE_CDP1_IF_SUPPORTED</span></code> is required to continue using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code. Note that this is slated for full removal in a future CUDA release.</p>
</div>
<p>CUDA runtime operations from any thread, including kernel launches, are visible across all the threads in a grid. This means that an invoking thread in the parent grid may perform synchronization to control the launch order of grids launched by any thread in the grid on streams created by any thread in the grid. Execution of a grid is not considered complete until all launches by all threads in the grid have completed. If all threads in a grid exit before all child launches have completed, an implicit synchronization operation will automatically be triggered.</p>
</section>
<section id="streams-and-events">
<span id="streams-and-events-cdp2"></span><h4><span class="section-number">10.2.1.4. </span>Streams and Events<a class="headerlink" href="#streams-and-events" title="Permalink to this headline">ï</a></h4>
<p>CUDA <em>Streams</em> and <em>Events</em> allow control over dependencies between grid launches: grids launched into the same stream execute in-order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.</p>
<p>Streams and events created within a grid exist within grid scope, but have undefined behavior when used outside of the grid where they were created. As described above, all work launched by a grid is implicitly synchronized when the grid exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of grid scope is undefined.</p>
<p>Streams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid.</p>
</section>
<section id="ordering-and-concurrency">
<span id="ordering-and-concurrency-cdp2"></span><h4><span class="section-number">10.2.1.5. </span>Ordering and Concurrency<a class="headerlink" href="#ordering-and-concurrency" title="Permalink to this headline">ï</a></h4>
<p>The ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a grid, all kernel launches into the same stream (with the exception of the fire-and-forget stream discussed later) are executed in-order. With multiple threads in the same grid launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the grid, which may be controlled with synchronization primitives such as <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>.</p>
<p>Note that while named streams are shared by all threads within a grid, the implicit <em>NULL</em> stream is only shared by all threads within a thread block. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in-order. If multiple threads in different thread blocks launch into the implicit stream, then these launches may be executed concurrently. If concurrency is desired for launches by multiple threads within a thread block, explicit named streams should be used.</p>
<p><em>Dynamic Parallelism</em> enables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.</p>
<p>The lack of concurrency guarantee extends to a parent grid and their child grids. When a parent grid launches a child grid, the child may start to execute once stream dependencies are satisfied and hardware resources are available to host the child, but is not guaranteed to begin execution until the parent grid reaches an implicit synchronization point.</p>
<p>While concurrency will often easily be achieved, it may vary as a function of device configuration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks.</p>
</section>
<section id="device-management">
<h4><span class="section-number">10.2.1.6. </span>Device Management<a class="headerlink" href="#device-management" title="Permalink to this headline">ï</a></h4>
<p>There is no multi-GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.</p>
</section>
</section>
<section id="memory-model">
<span id="id216"></span><h3><span class="section-number">10.2.2. </span>Memory Model<a class="headerlink" href="#memory-model" title="Permalink to this headline">ï</a></h3>
<p>Parent and child grids share the same global and constant memory storage, but have distinct local and shared memory.</p>
<section id="coherence-and-consistency">
<span id="coherence-and-consistency-cdp2"></span><h4><span class="section-number">10.2.2.1. </span>Coherence and Consistency<a class="headerlink" href="#coherence-and-consistency" title="Permalink to this headline">ï</a></h4>
<section id="global-memory">
<span id="global-memory-cdp2"></span><h5><span class="section-number">10.2.2.1.1. </span>Global Memory<a class="headerlink" href="#global-memory" title="Permalink to this headline">ï</a></h5>
<p>Parent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There is only one point of time in the execution of a child grid when its view of memory is fully consistent with the parent thread: at the point when the child grid is invoked by the parent.</p>
<p>All global memory operations in the parent thread prior to the child gridâs invocation are visible to the child grid. With the removal of <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>, it is no longer possible to access the modifications made by the threads in the child grid from the parent grid. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> stream.</p>
<p>In the following example, the child grid executing <code class="docutils literal notranslate"><span class="pre">child_launch</span></code> is only guaranteed to see the modifications to <code class="docutils literal notranslate"><span class="pre">data</span></code> made before the child grid was launched. Since thread 0 of the parent is performing the launch, the child will be consistent with the memory seen by thread 0 of the parent. Due to the first <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call, the child will see <code class="docutils literal notranslate"><span class="pre">data[0]=0</span></code>, <code class="docutils literal notranslate"><span class="pre">data[1]=1</span></code>, â¦, <code class="docutils literal notranslate"><span class="pre">data[255]=255</span></code> (without the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call, only <code class="docutils literal notranslate"><span class="pre">data[0]=0</span></code> would be guaranteed to be seen by the child). The child grid is only guaranteed to return at an implicit synchronization. This means that the modifications made by the threads in the child grid are never guaranteed to become available to the parent grid. To access modifications made by <code class="docutils literal notranslate"><span class="pre">child_launch</span></code>, a <code class="docutils literal notranslate"><span class="pre">tail_launch</span></code> kernel is launched into the <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">tail_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">child_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parent_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">child_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">tail_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">host_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">parent_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="zero-copy-memory">
<span id="id217"></span><h5><span class="section-number">10.2.2.1.2. </span>Zero Copy Memory<a class="headerlink" href="#zero-copy-memory" title="Permalink to this headline">ï</a></h5>
<p>Zero-copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero-copy memory, but may use pointers to zero-copy passed in from the host program.</p>
</section>
<section id="constant-memory">
<span id="id218"></span><h5><span class="section-number">10.2.2.1.3. </span>Constant Memory<a class="headerlink" href="#constant-memory" title="Permalink to this headline">ï</a></h5>
<p>Constants may not be modified from the device. They may only be modified from the host, but the behavior of modifying a constant from the host while there is a concurrent grid that access that constant at any point during its lifetime is undefined.</p>
</section>
<section id="shared-and-local-memory">
<span id="shared-and-local-memory-cdp2"></span><h5><span class="section-number">10.2.2.1.4. </span>Shared and Local Memory<a class="headerlink" href="#shared-and-local-memory" title="Permalink to this headline">ï</a></h5>
<p>Shared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.</p>
<p>The NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the <code class="docutils literal notranslate"><span class="pre">__isGlobal()</span></code> intrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch.</p>
<p>Note that calls to <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*Async()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMemset*Async()</span></code> may invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error.</p>
</section>
<section id="local-memory">
<span id="local-memory-cdp2"></span><h5><span class="section-number">10.2.2.1.5. </span>Local Memory<a class="headerlink" href="#local-memory" title="Permalink to this headline">ï</a></h5>
<p>Local memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.</p>
<p>For example the following is illegal, with undefined behavior if <code class="docutils literal notranslate"><span class="pre">x_array</span></code> is accessed by <code class="docutils literal notranslate"><span class="pre">child_launch</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w">       </span><span class="c1">// Creates x_array in parent&#39;s local memory</span>
<span class="n">child_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">x_array</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>It is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global-memory heap, either with <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>, <code class="docutils literal notranslate"><span class="pre">new()</span></code> or by declaring <code class="docutils literal notranslate"><span class="pre">__device__</span></code> storage at global scope. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Correct - &quot;value&quot; is global storage</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">child</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Invalid - &quot;value&quot; is local storage</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">child</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="texture-memory-cdp">
<span id="id219"></span><h5><span class="section-number">10.2.2.1.6. </span>Texture Memory<a class="headerlink" href="#texture-memory-cdp" title="Permalink to this headline">ï</a></h5>
<p>Writes to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly to Global Memory above, writes to memory by a child are never guaranteed to be reflected in the texture memory accesses by a parent. The only way to access the modifications made by the threads in the child grid before the parent grid exits is via a kernel launched into the <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> stream. Concurrent accesses by parent and child may result in inconsistent data.</p>
</section>
</section>
</section>
</section>
<section id="programming-interface-cdp">
<span id="id220"></span><h2><span class="section-number">10.3. </span>Programming Interface<a class="headerlink" href="#programming-interface-cdp" title="Permalink to this headline">ï</a></h2>
<section id="cuda-c-reference">
<span id="id221"></span><h3><span class="section-number">10.3.1. </span>CUDA C++ Reference<a class="headerlink" href="#cuda-c-reference" title="Permalink to this headline">ï</a></h3>
<p>This section describes changes and additions to the CUDA C++ language extensions for supporting <em>Dynamic Parallelism</em>.</p>
<p>The language interface and API available to CUDA kernels using CUDA C++ for Dynamic Parallelism, referred to as the <em>Device Runtime</em>, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments.</p>
<p>As with all code in CUDA C++, the APIs and code outlined here is per-thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock.</p>
<section id="device-side-kernel-launch">
<h4><span class="section-number">10.3.1.1. </span>Device-Side Kernel Launch<a class="headerlink" href="#device-side-kernel-launch" title="Permalink to this headline">ï</a></h4>
<p>Kernels may be launched from the device using the standard CUDA &lt;&lt;&lt; &gt;&gt;&gt; syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">kernel_name</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">Dg</span><span class="p">,</span><span class="w"> </span><span class="n">Db</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">([</span><span class="n">kernel</span><span class="w"> </span><span class="n">arguments</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dg</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> and specifies the dimensions and size of the grid</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Db</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> and specifies the dimensions and size of each thread block</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ns</span></code> is of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> and specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call in addition to statically allocated memory. <code class="docutils literal notranslate"><span class="pre">Ns</span></code> is an optional argument that defaults to 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> is of type <code class="docutils literal notranslate"><span class="pre">cudaStream_t</span></code> and specifies the stream associated with this call. The stream must have been allocated in the same grid where the call is being made. <code class="docutils literal notranslate"><span class="pre">S</span></code> is an optional argument that defaults to the NULL stream.</p></li>
</ul>
<section id="launches-are-asynchronous">
<span id="id222"></span><h5><span class="section-number">10.3.1.1.1. </span>Launches are Asynchronous<a class="headerlink" href="#launches-are-asynchronous" title="Permalink to this headline">ï</a></h5>
<p>Identical to host-side launches, all device-side kernel launches are asynchronous with respect to the launching thread. That is to say, the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> launch command will return immediately and the launching thread will continue to execute until it hits an implicit launch-synchronization point (such as at a kernel launched into the <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> stream).</p>
<p>The child grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an implicit launch-synchronization point.</p>
</section>
<section id="launch-environment-configuration">
<span id="id223"></span><h5><span class="section-number">10.3.1.1.2. </span>Launch Environment Configuration<a class="headerlink" href="#launch-environment-configuration" title="Permalink to this headline">ï</a></h5>
<p>All global device configuration settings (for example, shared memory and L1 cache size as returned from <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetCacheConfig()</span></code>, and device limits returned from <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code>) will be inherited from the parent. Likewise, device limits such as stack size will remain as-configured.</p>
<p>For host-launched kernels, per-kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernelâs environment from the device.</p>
</section>
</section>
<section id="streams-cdp">
<span id="id224"></span><h4><span class="section-number">10.3.1.2. </span>Streams<a class="headerlink" href="#streams-cdp" title="Permalink to this headline">ï</a></h4>
<p>Both named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a grid, but stream handles may not be passed to other child/parent kernels. In other words, a stream should be treated as private to the grid in which it is created.</p>
<p>Similar to host-side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior.</p>
<p>The host-side NULL streamâs cross-stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the <code class="docutils literal notranslate"><span class="pre">cudaStreamCreateWithFlags()</span></code> API, passing the <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag. The <code class="docutils literal notranslate"><span class="pre">cudaStreamCreate()</span></code> call is a host-runtime- only API and will fail to compile for the device.</p>
<p>As <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaStreamQuery()</span></code> are unsupported by the device runtime, a kernel launched into the <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> stream should be used instead when the application needs to know that stream-launched child kernels have completed.</p>
<section id="the-implicit-null-stream">
<span id="id225"></span><h5><span class="section-number">10.3.1.2.1. </span>The Implicit (NULL) Stream<a class="headerlink" href="#the-implicit-null-stream" title="Permalink to this headline">ï</a></h5>
<p>Within a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see <a class="reference internal" href="#default-stream"><span class="std std-ref">Default Stream</span></a> for details). The device runtime offers a single implicit, unnamed stream shared between all threads in a thread block, but as all named streams must be created with the <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks).</p>
</section>
<section id="the-fire-and-forget-stream">
<span id="fire-and-forget-stream"></span><h5><span class="section-number">10.3.1.2.2. </span>The Fire-and-Forget Stream<a class="headerlink" href="#the-fire-and-forget-stream" title="Permalink to this headline">ï</a></h5>
<p>The fire-and-forget named stream (<code class="docutils literal notranslate"><span class="pre">cudaStreamFireAndForget</span></code>) allows the user to launch fire-and-forget work with less boilerplate and without stream tracking overhead. It is functionally identical to, but faster than, creating a new stream per launch, and launching into that stream.</p>
<p>Fire-and-forget launches are immediately scheduled for launch without any dependency on the completion of previously launched grids. No other grid launches can depend on the completion of a fire-and-forget launch, except through the implicit synchronization at the end of the parent grid. So a tail launch or the next grid in parent gridâs stream wonât launch before a parent gridâs fire-and-forget work has completed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In this example, C2&#39;s launch will not wait for C1&#39;s completion</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">C1</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamFireAndForget</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">C2</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamFireAndForget</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The fire-and-forget stream cannot be used to record or wait on events. Attempting to do so results in <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code>. The fire-and-forget stream is not supported when compiled with <code class="docutils literal notranslate"><span class="pre">CUDA_FORCE_CDP1_IF_SUPPORTED</span></code> defined. Fire-and-forget stream usage requires compilation to be in 64-bit mode.</p>
</section>
<section id="the-tail-launch-stream">
<span id="tail-launch-stream"></span><h5><span class="section-number">10.3.1.2.3. </span>The Tail Launch Stream<a class="headerlink" href="#the-tail-launch-stream" title="Permalink to this headline">ï</a></h5>
<p>The tail launch named stream (<code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code>) allows a grid to schedule a new grid for launch after its completion. It should be possible to to use a tail launch to achieve the same functionality as a <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in most cases.</p>
<p>Each grid has its own tail launch stream. All non-tail launch work launched by a grid is implicitly synchronized before the tail stream is kicked off. I.e. A parent gridâs tail launch does not launch until the parent grid and all work launched by the parent grid to ordinary streams or per-thread or fire-and-forget streams have completed. If two grids are launched to the same gridâs tail launch stream, the later grid does not launch until the earlier grid and all its descendent work has completed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In this example, C2 will only launch after C1 completes.</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">C1</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">C2</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Grids launched into the tail launch stream will not launch until the completion of all work by the parent grid, including all other grids (and their descendants) launched by the parent in all non-tail launched streams, including work executed or launched after the tail launch.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In this example, C will only launch after all X, F and P complete.</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">C</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">X</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">F</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamFireAndForget</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The next grid in the parent gridâs stream will not be launched before a parent gridâs tail launch work has completed. In other words, the tail launch stream behaves as if it were inserted between its parent grid and the next grid in its parent gridâs stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In this example, P2 will only launch after C completes.</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P1</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">C</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P2</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">P1</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">P2</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Each grid only gets one tail launch stream. To tail launch concurrent grids, it can be done like the example below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// In this example,  C1 and C2 will launch concurrently after P&#39;s completion</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">C1</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamFireAndForget</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">C2</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamFireAndForget</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="n">T</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamTailLaunch</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The tail launch stream cannot be used to record or wait on events. Attempting to do so results in <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code>. The tail launch stream is not supported when compiled with <code class="docutils literal notranslate"><span class="pre">CUDA_FORCE_CDP1_IF_SUPPORTED</span></code> defined. Tail launch stream usage requires compilation to be in 64-bit mode.</p>
</section>
</section>
<section id="events-cdp">
<span id="id226"></span><h4><span class="section-number">10.3.1.3. </span>Events<a class="headerlink" href="#events-cdp" title="Permalink to this headline">ï</a></h4>
<p>Only the inter-stream synchronization capabilities of CUDA events are supported. This means that <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code> is supported, but <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaEventElapsedTime()</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaEventQuery()</span></code> are not. As <code class="docutils literal notranslate"><span class="pre">cudaEventElapsedTime()</span></code> is not supported, cudaEvents must be created via <code class="docutils literal notranslate"><span class="pre">cudaEventCreateWithFlags()</span></code>, passing the <code class="docutils literal notranslate"><span class="pre">cudaEventDisableTiming</span></code> flag.</p>
<p>As with named streams, event objects may be shared between all threads within the grid which created them but are local to that grid and may not be passed to other kernels. Event handles are not guaranteed to be unique between grids, so using an event handle within a grid that did not create it will result in undefined behavior.</p>
</section>
<section id="synchronization-programming-interface">
<span id="id227"></span><h4><span class="section-number">10.3.1.4. </span>Synchronization<a class="headerlink" href="#synchronization-programming-interface" title="Permalink to this headline">ï</a></h4>
<p>It is up to the program to perform sufficient inter-thread synchronization, for example via a CUDA Event, if the calling thread is intended to synchronize with child grids invoked from other threads.</p>
<p>As it is not possible to explicitly synchronize child work from a parent thread, there is no way to guarantee that changes occuring in child grids are visible to threads within the parent grid.</p>
</section>
<section id="device-management-programming">
<span id="id228"></span><h4><span class="section-number">10.3.1.5. </span>Device Management<a class="headerlink" href="#device-management-programming" title="Permalink to this headline">ï</a></h4>
<p>Only the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> are not supported by the device runtime. The active device as seen from the GPU (returned from <code class="docutils literal notranslate"><span class="pre">cudaGetDevice()</span></code>) will have the same device number as seen from the host system. The <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute()</span></code> call may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch-all <code class="docutils literal notranslate"><span class="pre">cudaGetDeviceProperties()</span></code> API is not offered by the device runtime - properties must be queried individually.</p>
</section>
<section id="memory-declarations">
<span id="id229"></span><h4><span class="section-number">10.3.1.6. </span>Memory Declarations<a class="headerlink" href="#memory-declarations" title="Permalink to this headline">ï</a></h4>
<section id="device-and-constant-memory">
<span id="id230"></span><h5><span class="section-number">10.3.1.6.1. </span>Device and Constant Memory<a class="headerlink" href="#device-and-constant-memory" title="Permalink to this headline">ï</a></h5>
<p>Memory declared at file scope with <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> memory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of <code class="docutils literal notranslate"><span class="pre">__constant__</span></code>s as declared at the module scope.</p>
</section>
<section id="textures-and-surfaces">
<span id="id231"></span><h5><span class="section-number">10.3.1.6.2. </span>Textures and Surfaces<a class="headerlink" href="#textures-and-surfaces" title="Permalink to this headline">ï</a></h5>
<p>CUDA supports dynamically created texture and surface objects<a class="footnote-reference brackets" href="#fn14" id="id232">14</a>, where a texture object may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The device runtime does not support legacy module-scope (i.e., Fermi-style) textures and surfaces within a kernel launched from the device. Module-scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top-level kernel (i.e., the one which is launched from the host).</p>
</div>
</section>
<section id="shared-memory-variable-declarations">
<span id="id233"></span><h5><span class="section-number">10.3.1.6.3. </span>Shared Memory Variable Declarations<a class="headerlink" href="#shared-memory-variable-declarations" title="Permalink to this headline">ï</a></h5>
<p>In CUDA C++ shared memory can be declared either as a statically sized file-scope or function-scoped variable, or as an <code class="docutils literal notranslate"><span class="pre">extern</span></code> variable with the size determined at runtime by the kernelâs caller via a launch configuration argument. Both types of declarations are valid under the device runtime.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">permute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem</span><span class="p">[];</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">smem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="n">permute_data</span><span class="p">(</span><span class="n">smem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Write back to GMEM since we can&#39;t pass SMEM to children.</span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">host_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="symbol-addresses">
<span id="id234"></span><h5><span class="section-number">10.3.1.6.4. </span>Symbol Addresses<a class="headerlink" href="#symbol-addresses" title="Permalink to this headline">ï</a></h5>
<p>Device-side symbols (i.e., those marked <code class="docutils literal notranslate"><span class="pre">__device__</span></code>) may be referenced from within a kernel simply via the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator, as all global-scope device variables are in the kernelâs visible address space. This also applies to <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> symbols, although in this case the pointer will reference read-only data.</p>
<p>Given that device-side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (e.g., <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolAddress()</span></code>) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> space are read-only.</p>
</section>
</section>
<section id="api-errors-and-launch-failures">
<span id="id235"></span><h4><span class="section-number">10.3.1.7. </span>API Errors and Launch Failures<a class="headerlink" href="#api-errors-and-launch-failures" title="Permalink to this headline">ï</a></h4>
<p>As usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> call. Errors are recorded per-thread, so that each thread can identify the most recent error that it has generated. The error code is of type <code class="docutils literal notranslate"><span class="pre">cudaError_t</span></code>.</p>
<p>Similar to a host-side launch, device-side launches may fail for many reasons (invalid arguments, etc). The user must call <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> to determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.</p>
<p>For device-side exceptions, e.g., access to an invalid address, an error in a child grid will be returned to the host.</p>
<section id="launch-setup-apis">
<span id="id236"></span><h5><span class="section-number">10.3.1.7.1. </span>Launch Setup APIs<a class="headerlink" href="#launch-setup-apis" title="Permalink to this headline">ï</a></h5>
<p>Kernel launch is a system-level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> APIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX. In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures.</p>
<p>As with host-side launch, the device-side operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> maps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front-end can translate <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> into these calls.</p>
<table class="docutils align-default" id="id469">
<caption><span class="caption-number">Table 14 </span><span class="caption-text">New Device-only Launch Implementation Functions</span><a class="headerlink" href="#id469" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Runtime API Launch Functions</p></th>
<th class="head"><p>Description of Difference From Host Runtime Behaviour (behavior is identical if no description)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer</span></code></p></td>
<td><p>Generated automatically from <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code>. Note different API to host equivalent.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice</span></code></p></td>
<td><p>Generated automatically from <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code>. Note different API to host equivalent.</p></td>
</tr>
</tbody>
</table>
<p>The APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w">   </span><span class="n">device</span><span class="w">   </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaGetParameterBuffer</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">params</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="n">gridDim</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">dim3</span><span class="w"> </span><span class="n">blockDim</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="api-reference">
<span id="api-reference-cdp2"></span><h4><span class="section-number">10.3.1.8. </span>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">ï</a></h4>
<p>The portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The following table provides an overview of the API relative to the version available from the host.</p>
<table class="docutils align-default" id="id470">
<caption><span class="caption-number">Table 15 </span><span class="caption-text">Supported API Functions</span><a class="headerlink" href="#id470" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 37%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Runtime API Functions</p></th>
<th class="head"><p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetCacheConfig</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetLastError</span></code></p></td>
<td><p>Last error is per-thread state, not per-block state</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetErrorString</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetDeviceCount</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute</span></code></p></td>
<td><p>Will return attributes for any device</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetDevice</span></code></p></td>
<td><p>Always returns current device ID as would be seen from host</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamCreateWithFlags</span></code></p></td>
<td><p>Must pass <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamDestroy</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventCreateWithFlags</span></code></p></td>
<td><p>Must pass <code class="docutils literal notranslate"><span class="pre">cudaEventDisableTiming</span></code> flag</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventRecord</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventDestroy</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFuncGetAttributes</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpyAsync</span></code></p></td>
<td rowspan="4"><p>Notes about all <code class="docutils literal notranslate"><span class="pre">memcpy/memset</span></code> functions:</p>
<ul class="simple">
<li><p>Only async <code class="docutils literal notranslate"><span class="pre">memcpy/set</span></code> functions are supported</p></li>
<li><p>Only device-to-device <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> is permitted</p></li>
<li><p>May not pass in local or shared memory pointers</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpy2DAsync</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpy3DAsync</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemsetAsync</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemset2DAsync</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemset3DAsync</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaRuntimeGetVersion</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code></p></td>
<td rowspan="2"><p>May not call <code class="docutils literal notranslate"><span class="pre">cudaFree</span></code> on the device on a pointer created on the host, and vice-versa</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSize</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSizeVariableSMem</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="device-side-launch-from-ptx">
<span id="device-side-launch-from-ptx-cdp2"></span><h3><span class="section-number">10.3.2. </span>Device-side Launch from PTX<a class="headerlink" href="#device-side-launch-from-ptx" title="Permalink to this headline">ï</a></h3>
<p>This section is for the programming language and compiler implementers who target <em>Parallel Thread Execution</em> (PTX) and plan to support <em>Dynamic Parallelism</em> in their language. It provides the low-level details related to supporting kernel launches at the PTX level.</p>
<section id="kernel-launch-apis">
<span id="id237"></span><h4><span class="section-number">10.3.2.1. </span>Kernel Launch APIs<a class="headerlink" href="#kernel-launch-apis" title="Permalink to this headline">ï</a></h4>
<p>Device-side kernel launches can be implemented using the following two APIs accessible from PTX: <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code>. <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> launches the specified kernel with the parameter buffer that is obtained by calling <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> and filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code>, if the launched kernel does not take any parameters.</p>
<section id="cudalaunchdevice">
<span id="cudalaunchdevice-cdp2"></span><h5><span class="section-number">10.3.2.1.1. </span>cudaLaunchDevice<a class="headerlink" href="#cudalaunchdevice" title="Permalink to this headline">ï</a></h5>
<p>At the PTX level, <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code>needs to be declared in one of the two forms shown below before it is used.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaLaunchDevice() when .address_size is 64</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">parameterBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">gridDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">blockDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">stream</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The CUDA-level declaration below is mapped to one of the aforementioned PTX-level declarations and is found in the system header file <code class="docutils literal notranslate"><span class="pre">cuda_device_runtime_api.h</span></code>. The function is defined in the <code class="docutils literal notranslate"><span class="pre">cudadevrt</span></code> system library, which must be linked with a program in order to use device-side kernel launch functionality.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// CUDA-level declaration of cudaLaunchDevice()</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">__device__</span><span class="w"></span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">parameterBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">dim3</span><span class="w"> </span><span class="n">gridDimension</span><span class="p">,</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="n">blockDimension</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in <a class="reference internal" href="#parameter-buffer-layout"><span class="std std-ref">Parameter Buffer Layout</span></a>, below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to <a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a> for the detailed description of launch configuration.</p>
</section>
<section id="cudagetparameterbuffer">
<span id="cudagetparameterbuffer-cdp2"></span><h5><span class="section-number">10.3.2.1.2. </span>cudaGetParameterBuffer<a class="headerlink" href="#cudagetparameterbuffer" title="Permalink to this headline">ï</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> needs to be declared at the PTX level before itâs used. The PTX-level declaration must be in one of the two forms given below, depending on address size:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 64</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaGetParameterBuffer</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">size</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The following CUDA-level declaration of <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> is mapped to the aforementioned PTX-level declaration:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// CUDA-level Declaration of cudaGetParameterBuffer()</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cudaGetParameterBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> is always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> to ensure portability in the future.</p>
</section>
</section>
<section id="parameter-buffer-layout">
<span id="id238"></span><h4><span class="section-number">10.3.2.2. </span>Parameter Buffer Layout<a class="headerlink" href="#parameter-buffer-layout" title="Permalink to this headline">ï</a></h4>
<p>Parameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the <em>n</em><sup>th</sup> byte in the parameter buffer, where <em>n</em> is the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.</p>
<p>For a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX-3.5 specification.</p>
</section>
</section>
<section id="toolkit-support-for-dynamic-parallelism">
<span id="id239"></span><h3><span class="section-number">10.3.3. </span>Toolkit Support for Dynamic Parallelism<a class="headerlink" href="#toolkit-support-for-dynamic-parallelism" title="Permalink to this headline">ï</a></h3>
<section id="including-device-runtime-api-in-cuda-code">
<span id="including-device-runtime-api-in-cuda-code-cdp2"></span><h4><span class="section-number">10.3.3.1. </span>Including Device Runtime API in CUDA Code<a class="headerlink" href="#including-device-runtime-api-in-cuda-code" title="Permalink to this headline">ï</a></h4>
<p>Similar to the host-side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include<code class="docutils literal notranslate"><span class="pre">cuda_device_runtime_api.h</span></code> explicitly.</p>
</section>
<section id="compiling-and-linking">
<span id="id240"></span><h4><span class="section-number">10.3.3.2. </span>Compiling and Linking<a class="headerlink" href="#compiling-and-linking" title="Permalink to this headline">ï</a></h4>
<p>When compiling and linking CUDA programs using dynamic parallelism with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code>, the program will automatically link against the static device runtime library <code class="docutils literal notranslate"><span class="pre">libcudadevrt</span></code>.</p>
<p>The device runtime is offered as a static library (<code class="docutils literal notranslate"><span class="pre">cudadevrt.lib</span></code> on Windows, <code class="docutils literal notranslate"><span class="pre">libcudadevrt.a</span></code> under Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> and/or <code class="docutils literal notranslate"><span class="pre">nvlink</span></code>. Two simple examples are shown below.</p>
<p>A device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt
</pre></div>
</div>
<p>It is also possible to compile CUDA .cu source files first to object files, and then link these together in a two-stage process:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -dc hello_world.cu -o hello_world.o
$ nvcc -arch=sm_75 -rdc=true hello_world.o -o hello -lcudadevrt
</pre></div>
</div>
<p>Please see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details.</p>
</section>
</section>
</section>
<section id="programming-guidelines">
<span id="id241"></span><h2><span class="section-number">10.4. </span>Programming Guidelines<a class="headerlink" href="#programming-guidelines" title="Permalink to this headline">ï</a></h2>
<section id="basics">
<span id="id242"></span><h3><span class="section-number">10.4.1. </span>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">ï</a></h3>
<p>The device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.</p>
<p>Programming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.</p>
<p>The following example shows a simple <em>Hello World</em> program incorporating dynamic parallelism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">childKernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">tailKernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parentKernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// launch child</span>
<span class="w">    </span><span class="n">childKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaGetLastError</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// launch tail into cudaStreamTailLaunch stream</span>
<span class="w">    </span><span class="c1">// implicitly synchronizes: waits for child to complete</span>
<span class="w">    </span><span class="n">tailKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">cudaStreamTailLaunch</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// launch parent</span>
<span class="w">    </span><span class="n">parentKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaGetLastError</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// wait for parent to complete</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaDeviceSynchronize</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This program may be built in a single step from the command line as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt
</pre></div>
</div>
</section>
<section id="performance">
<span id="id243"></span><h3><span class="section-number">10.4.2. </span>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">ï</a></h3>
<section id="dynamic-parallelism-enabled-kernel-overhead">
<span id="id244"></span><h4><span class="section-number">10.4.2.1. </span>Dynamic-parallelism-enabled Kernel Overhead<a class="headerlink" href="#dynamic-parallelism-enabled-kernel-overhead" title="Permalink to this headline">ï</a></h4>
<p>System software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtimeâs execution tracking and management software and may result in decreased performance. This overhead is, in general, incurred for applications that link against the device runtime library.</p>
</section>
</section>
<section id="implementation-restrictions-and-limitations">
<span id="id245"></span><h3><span class="section-number">10.4.3. </span>Implementation Restrictions and Limitations<a class="headerlink" href="#implementation-restrictions-and-limitations" title="Permalink to this headline">ï</a></h3>
<p><em>Dynamic Parallelism</em> guarantees all semantics described in this document, however, certain hardware and software resources are implementation-dependent and limit the scale, performance and other properties of a program which uses the device runtime.</p>
<section id="runtime">
<span id="id246"></span><h4><span class="section-number">10.4.3.1. </span>Runtime<a class="headerlink" href="#runtime" title="Permalink to this headline">ï</a></h4>
<section id="memory-footprint">
<span id="id247"></span><h5><span class="section-number">10.4.3.1.1. </span>Memory Footprint<a class="headerlink" href="#memory-footprint" title="Permalink to this headline">ï</a></h5>
<p>The device runtime system software reserves memory for various management purposes, in particular a reservation for tracking pending grid launches. Configuration controls are available to reduce the size of this reservation in exchange for certain launch limitations. See <a class="reference internal" href="#configuration-options"><span class="std std-ref">Configuration Options</span></a>, below, for details.</p>
</section>
<section id="pending-kernel-launches">
<span id="id248"></span><h5><span class="section-number">10.4.3.1.2. </span>Pending Kernel Launches<a class="headerlink" href="#pending-kernel-launches" title="Permalink to this headline">ï</a></h5>
<p>When a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system-managed launch pool.</p>
<p>The size of the fixed-size launch pool is configurable by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> from the host and specifying <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code>.</p>
</section>
<section id="configuration-options">
<span id="id249"></span><h5><span class="section-number">10.4.3.1.3. </span>Configuration Options<a class="headerlink" href="#configuration-options" title="Permalink to this headline">ï</a></h5>
<p>Resource allocation for the device runtime system software is controlled via the <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> API from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.</p>
<p>The following named limits may be set:</p>
<table class="table-no-stripes colwidths-given docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Limit</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code></p></td>
<td><p>Controls the amount of memory set aside for buffering kernel launches and events which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, an attempt to allocate a launch slot during a device side kernel launch will fail and return <code class="docutils literal notranslate"><span class="pre">cudaErrorLaunchOutOfResources</span></code>, while an attempt to allocate an event slot will fail and return <code class="docutils literal notranslate"><span class="pre">cudaErrorMemoryAllocation</span></code>. The default number of launch slots is 2048. Applications may increase the number of launch and/or event slots by setting <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code>. The number of event slots allocated is twice the value of that limit.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitStackSize</span></code></p></td>
<td><p>Controls the stack size in bytes of each GPU thread. The CUDA driver automatically increases the per-thread stack size for each kernel launch as needed. This size isnât reset back to the original value after each launch. To set the per-thread stack size to a different value, <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> can be called to set this limit. The stack will be immediately resized, and if necessary, the device will block until all preceding requested tasks are complete. <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code> can be called to get the current per-thread stack size.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="memory-allocation-and-lifetime">
<span id="id250"></span><h5><span class="section-number">10.4.3.1.4. </span>Memory Allocation and Lifetime<a class="headerlink" href="#memory-allocation-and-lifetime" title="Permalink to this headline">ï</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> have distinct semantics between the host and device environments. When invoked from the host, <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> allocates a new region from unused device memory. When invoked from the device runtime these functions map to device-side <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">free()</span></code>. This implies that within the device environment the total allocatable memory is limited to the device <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> heap size, which may be smaller than the available unused device memory. Also, it is an error to invoke <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> from the host program on a pointer which was allocated by <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on the device or vice-versa.</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on Host</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on Device</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> on Host</p></td>
<td><p>Supported</p></td>
<td><p>Not Supported</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> on Device</p></td>
<td><p>Not Supported</p></td>
<td><p>Supported</p></td>
</tr>
<tr class="row-even"><td><p>Allocation limit</p></td>
<td><p>Free device memory</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitMallocHeapSize</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="sm-id-and-warp-id">
<span id="id251"></span><h5><span class="section-number">10.4.3.1.5. </span>SM Id and Warp Id<a class="headerlink" href="#sm-id-and-warp-id" title="Permalink to this headline">ï</a></h5>
<p>Note that in PTX <code class="docutils literal notranslate"><span class="pre">%smid</span></code> and <code class="docutils literal notranslate"><span class="pre">%warpid</span></code> are defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon <code class="docutils literal notranslate"><span class="pre">%smid</span></code> or <code class="docutils literal notranslate"><span class="pre">%warpid</span></code> remaining unchanged across the lifetime of a thread or thread block.</p>
</section>
<section id="ecc-errors">
<span id="id252"></span><h5><span class="section-number">10.4.3.1.6. </span>ECC Errors<a class="headerlink" href="#ecc-errors" title="Permalink to this headline">ï</a></h5>
<p>No notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration).</p>
</section>
</section>
</section>
</section>
<section id="cdp2-vs-cdp1">
<span id="id253"></span><h2><span class="section-number">10.5. </span>CDP2 vs CDP1<a class="headerlink" href="#cdp2-vs-cdp1" title="Permalink to this headline">ï</a></h2>
<p>This section summarises the differences between, and the compatibility and interoperability of, the new (CDP2) and legacy (CDP1) CUDA Dynamic Parallelism interfaces. It also shows how to opt-out of the CDP2 interface on devices of compute capability less than 9.0.</p>
<section id="differences-between-cdp1-and-cdp2">
<span id="differences"></span><h3><span class="section-number">10.5.1. </span>Differences Between CDP1 and CDP2<a class="headerlink" href="#differences-between-cdp1-and-cdp2" title="Permalink to this headline">ï</a></h3>
<p>Explicit device-side synchronization is no longer possible with CDP2 or on devices of compute capability 9.0 or higher. Implicit synchronization (such as tail launches) must be used instead.</p>
<p>Attempting to query or set <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimeSyncDepth</span></code> (or <code class="docutils literal notranslate"><span class="pre">CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH</span></code>) with CDP2 or on devices of compute capability 9.0 or higher results in <code class="docutils literal notranslate"><span class="pre">cudaErrorUnsupportedLimit</span></code>.</p>
<p>CDP2 no longer has a virtualized pool for pending launches that donât fit in the fixed-sized pool. <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code> must be set to be large enough to avoid running out of launch slots.</p>
<p>For CDP2, there is a limit to the total number of events existing at once (note that events are destroyed only after a launch completes), equal to twice the pending launch count. <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code> must be set to be large enough to avoid running out of event slots.</p>
<p>Streams are tracked per grid with CDP2 or on devices of compute capability 9.0 or higher, not per thread block. This allows work to be launched into a stream created by another thread block. Attempting to do so with the CDP1 results in <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code>.</p>
<p>CDP2 introduces the tail launch (<code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code>) and fire-and-forget (<code class="docutils literal notranslate"><span class="pre">cudaStreamFireAndForget</span></code>) named streams.</p>
<p>CDP2 is supported only under 64-bit compilation mode.</p>
</section>
<section id="compatibility-and-interoperability">
<span id="id254"></span><h3><span class="section-number">10.5.2. </span>Compatibility and Interoperability<a class="headerlink" href="#compatibility-and-interoperability" title="Permalink to this headline">ï</a></h3>
<p>CDP2 is the default. Functions can be compiled with <code class="docutils literal notranslate"><span class="pre">-DCUDA_FORCE_CDP1_IF_SUPPORTED</span></code> to opt-out of using CDP2 on devices of compute capability less than 9.0.</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 17%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Function compiler with CUDA 12.0 and newer (default)</p></th>
<th class="head"><p>Function compiled with pre-CUDA 12.0 or with CUDA 12.0 and newer with <code class="docutils literal notranslate"><span class="pre">-DCUDA_FORCE_CDP1_IF_SUPPORTED</span></code> specified</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Compilation</p></td>
<td><p>Compile error if device code references <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code>.</p></td>
<td><p>Compile error if code references <code class="docutils literal notranslate"><span class="pre">cudaStreamTailLaunch</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaStreamFireAndForget</span></code>. Compile error if device code references <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code> and code is compiled for sm_90 or newer.</p></td>
</tr>
<tr class="row-odd"><td><p>Compute capability &lt; 9.0</p></td>
<td><p>New interface is used.</p></td>
<td><p>Legacy interface is used.</p></td>
</tr>
<tr class="row-even"><td><p>Compute capability 9.0 and higher</p></td>
<td><p>New interface is used.</p></td>
<td><p>New interface is used. If function references <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code> in device code, function load returns <code class="docutils literal notranslate"><span class="pre">cudaErrorSymbolNotFound</span></code> (this could happen if the code is compiled for devices of compute capability less than 9.0, but run on devices of compute capability 9.0 or higher using JIT).</p></td>
</tr>
</tbody>
</table>
<p>Functions using CDP1 and CDP2 may be loaded and run simultaneously in the same context. The CDP1 functions are able to use CDP1-specific features (e.g. <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code>) and CDP2 functions are able to use CDP2-specific features (e.g. tail launch and fire-and-forget launch).</p>
<p>A function using CDP1 cannot launch a function using CDP2, and vice versa. If a function that would use CDP1 contains in its call graph a function that would use CDP2, or vice versa, <code class="docutils literal notranslate"><span class="pre">cudaErrorCdpVersionMismatch</span></code> would result during function load.</p>
</section>
</section>
<section id="legacy-cuda-dynamic-parallelism-cdp1">
<span id="cuda-dynamic-parallelism-cdp1"></span><h2><span class="section-number">10.6. </span>Legacy CUDA Dynamic Parallelism (CDP1)<a class="headerlink" href="#legacy-cuda-dynamic-parallelism-cdp1" title="Permalink to this headline">ï</a></h2>
<p>See <a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a>, above, for CDP2 version of document.</p>
<section id="execution-environment-and-memory-model-cdp1">
<span id="id255"></span><h3><span class="section-number">10.6.1. </span>Execution Environment and Memory Model (CDP1)<a class="headerlink" href="#execution-environment-and-memory-model-cdp1" title="Permalink to this headline">ï</a></h3>
<p>See <a class="reference internal" href="#execution-environment-and-memory-model-cdp2"><span class="std std-ref">Execution Environment and Memory Model</span></a>, above, for CDP2 version of document.</p>
<section id="execution-environment-cdp1">
<span id="id256"></span><h4><span class="section-number">10.6.1.1. </span>Execution Environment (CDP1)<a class="headerlink" href="#execution-environment-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#execution-environment-cdp2"><span class="std std-ref">Execution Environment</span></a>, above, for CDP2 version of document.</p>
<p>The CUDA execution model is based on primitives of threads, thread blocks, and grids, with kernel functions defining the program executed by individual threads within a thread block and grid. When a kernel function is invoked the gridâs properties are described by an execution configuration, which has a special syntax in CUDA. Support for dynamic parallelism in CUDA extends the ability to configure, launch, and synchronize upon new grids to threads that are running on the device.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) block is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<section id="parent-and-child-grids-cdp1">
<span id="id257"></span><h5><span class="section-number">10.6.1.1.1. </span>Parent and Child Grids (CDP1)<a class="headerlink" href="#parent-and-child-grids-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#parent-and-child-grids-cdp2"><span class="std std-ref">Parent and Child Grids</span></a>, above, for CDP2 version of document.</p>
<p>A device thread that configures and launches a new grid belongs to the parent grid, and the grid created by the invocation is a child grid.</p>
<p>The invocation and completion of child grids is properly nested, meaning that the parent grid is not considered complete until all child grids created by its threads have completed. Even if the invoking threads do not explicitly synchronize on the child grids launched, the runtime guarantees an implicit synchronization between the parent and child.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<figure class="align-center" id="parent-child-launch-nesting">
<a class="reference internal image-reference" href="_images/parent-child-launch-nesting.png"><img alt="The GPU Devotes More Transistors to Data Processing" src="_images/parent-child-launch-nesting.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 30 </span><span class="caption-text">Parent-Child Launch Nesting</span><a class="headerlink" href="#parent-child-launch-nesting" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="scope-of-cuda-primitives-cdp1">
<span id="id258"></span><h5><span class="section-number">10.6.1.1.2. </span>Scope of CUDA Primitives (CDP1)<a class="headerlink" href="#scope-of-cuda-primitives-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#scope-of-cuda-primitives-cdp2"><span class="std std-ref">Scope of CUDA Primitives</span></a>, above, for CDP2 version of document.</p>
<p>On both host and device, the CUDA runtime offers an API for launching kernels, for waiting for launched work to complete, and for tracking dependencies between launches via streams and events. On the host system, the state of launches and the CUDA primitives referencing streams and events are shared by all threads within a process; however processes execute independently and may not share CUDA objects.</p>
<p>A similar hierarchy exists on the device: launched kernels and CUDA objects are visible to all threads in a thread block, but are independent between thread blocks. This means for example that a stream may be created by one thread and used by any other thread in the same thread block, but may not be shared with threads in any other thread block.</p>
</section>
<section id="synchronization-cdp1">
<span id="id259"></span><h5><span class="section-number">10.6.1.1.3. </span>Synchronization (CDP1)<a class="headerlink" href="#synchronization-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#dynamic-parallelism-synchronization"><span class="std std-ref">Synchronization</span></a>, above, for CDP2 version of document.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>CUDA runtime operations from any thread, including kernel launches, are visible across a thread block. This means that an invoking thread in the parent grid may perform synchronization on the grids launched by that thread, by other threads in the thread block, or on streams created within the same thread block. Execution of a thread block is not considered complete until all launches by all threads in the block have completed. If all threads in a block exit before all child launches have completed, a synchronization operation will automatically be triggered.</p>
</section>
<section id="streams-and-events-cdp1">
<span id="id260"></span><h5><span class="section-number">10.6.1.1.4. </span>Streams and Events (CDP1)<a class="headerlink" href="#streams-and-events-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#streams-and-events-cdp2"><span class="std std-ref">Streams and Events</span></a>, above, for CDP2 version of document.</p>
<p>CUDA <em>Streams</em> and <em>Events</em> allow control over dependencies between grid launches: grids launched into the same stream execute in-order, and events may be used to create dependencies between streams. Streams and events created on the device serve this exact same purpose.</p>
<p>Streams and events created within a grid exist within thread block scope but have undefined behavior when used outside of the thread block where they were created. As described above, all work launched by a thread block is implicitly synchronized when the block exits; work launched into streams is included in this, with all dependencies resolved appropriately. The behavior of operations on a stream that has been modified outside of thread block scope is undefined.</p>
<p>Streams and events created on the host have undefined behavior when used within any kernel, just as streams and events created by a parent grid have undefined behavior if used within a child grid.</p>
</section>
<section id="ordering-and-concurrency-cdp1">
<span id="id261"></span><h5><span class="section-number">10.6.1.1.5. </span>Ordering and Concurrency (CDP1)<a class="headerlink" href="#ordering-and-concurrency-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#ordering-and-concurrency-cdp2"><span class="std std-ref">Ordering and Concurrency</span></a>, above, for CDP2 version of document.</p>
<p>The ordering of kernel launches from the device runtime follows CUDA Stream ordering semantics. Within a thread block, all kernel launches into the same stream are executed in-order. With multiple threads in the same thread block launching into the same stream, the ordering within the stream is dependent on the thread scheduling within the block, which may be controlled with synchronization primitives such as <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>.</p>
<p>Note that because streams are shared by all threads within a thread block, the implicit <em>NULL</em> stream is also shared. If multiple threads in a thread block launch into the implicit stream, then these launches will be executed in-order. If concurrency is desired, explicit named streams should be used.</p>
<p><em>Dynamic Parallelism</em> enables concurrency to be expressed more easily within a program; however, the device runtime introduces no new concurrency guarantees within the CUDA execution model. There is no guarantee of concurrent execution between any number of different thread blocks on a device.</p>
<p>The lack of concurrency guarantee extends to parent thread blocks and their child grids. When a parent thread block launches a child grid, the child is not guaranteed to begin execution until the parent thread block reaches an explicit synchronization point (such as <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>While concurrency will often easily be achieved, it may vary as a function of deviceconfiguration, application workload, and runtime scheduling. It is therefore unsafe to depend upon any concurrency between different thread blocks.</p>
</section>
<section id="device-management-cdp1">
<span id="id262"></span><h5><span class="section-number">10.6.1.1.6. </span>Device Management (CDP1)<a class="headerlink" href="#device-management-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#device-management-programming"><span class="std std-ref">Device Management</span></a>, above, for CDP2 version of document.</p>
<p>There is no multi-GPU support from the device runtime; the device runtime is only capable of operating on the device upon which it is currently executing. It is permitted, however, to query properties for any CUDA capable device in the system.</p>
</section>
</section>
<section id="memory-model-cdp1">
<span id="id263"></span><h4><span class="section-number">10.6.1.2. </span>Memory Model (CDP1)<a class="headerlink" href="#memory-model-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#memory-model"><span class="std std-ref">Memory Model</span></a>, above, for CDP2 version of document.</p>
<p>Parent and child grids share the same global and constant memory storage, but have distinct local and shared memory.</p>
<section id="coherence-and-consistency-cdp1">
<span id="id264"></span><h5><span class="section-number">10.6.1.2.1. </span>Coherence and Consistency (CDP1)<a class="headerlink" href="#coherence-and-consistency-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#coherence-and-consistency-cdp2"><span class="std std-ref">Coherence and Consistency</span></a>, above, for CDP2 version of document.</p>
<section id="global-memory-cdp1">
<span id="id265"></span><h6><span class="section-number">10.6.1.2.1.1. </span>Global Memory (CDP1)<a class="headerlink" href="#global-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#global-memory-cdp2"><span class="std std-ref">Global Memory</span></a>, above, for CDP2 version of document.</p>
<p>Parent and child grids have coherent access to global memory, with weak consistency guarantees between child and parent. There are two points in the execution of a child grid when its view of memory is fully consistent with the parent thread: when the child grid is invoked by the parent, and when the child grid completes as signaled by a synchronization API invocation in the parent thread.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>All global memory operations in the parent thread prior to the child gridâs invocation are visible to the child grid. All memory operations of the child grid are visible to the parent after the parent has synchronized on the child gridâs completion.</p>
<p>In the following example, the child grid executing <code class="docutils literal notranslate"><span class="pre">child_launch</span></code> is only guaranteed to see the modifications to <code class="docutils literal notranslate"><span class="pre">data</span></code> made before the child grid was launched. Since thread 0 of the parent is performing the launch, the child will be consistent with the memory seen by thread 0 of the parent. Due to the first <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call, the child will see <code class="docutils literal notranslate"><span class="pre">data[0]=0</span></code>, <code class="docutils literal notranslate"><span class="pre">data[1]=1</span></code>, â¦, <code class="docutils literal notranslate"><span class="pre">data[255]=255</span></code> (without the <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call, only <code class="docutils literal notranslate"><span class="pre">data[0]</span></code> would be guaranteed to be seen by the child). When the child grid returns, thread 0 is guaranteed to see modifications made by the threads in its child grid. Those modifications become available to the other threads of the parent grid only after the second <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">child_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parent_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">child_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">host_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">parent_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="zero-copy-memory-cdp1">
<span id="id266"></span><h6><span class="section-number">10.6.1.2.1.2. </span>Zero Copy Memory (CDP1)<a class="headerlink" href="#zero-copy-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#zero-copy-memory"><span class="std std-ref">Zero Copy Memory</span></a>, above, for CDP2 version of document.</p>
<p>Zero-copy system memory has identical coherence and consistency guarantees to global memory, and follows the semantics detailed above. A kernel may not allocate or free zero-copy memory, but may use pointers to zero-copy passed in from the host program.</p>
</section>
<section id="constant-memory-cdp1">
<span id="id267"></span><h6><span class="section-number">10.6.1.2.1.3. </span>Constant Memory (CDP1)<a class="headerlink" href="#constant-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#constant-memory"><span class="std std-ref">Constant Memory</span></a>, above, for CDP2 version of document.</p>
<p>Constants are immutable and may not be modified from the device, even between parent and child launches. That is to say, the value of all <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables must be set from the host prior to launch. Constant memory is inherited automatically by all child kernels from their respective parents.</p>
<p>Taking the address of a constant memory object from within a kernel thread has the same semantics as for all CUDA programs, and passing that pointer from parent to child or from a child to parent is naturally supported.</p>
</section>
<section id="shared-and-local-memory-cdp1">
<span id="id268"></span><h6><span class="section-number">10.6.1.2.1.4. </span>Shared and Local Memory (CDP1)<a class="headerlink" href="#shared-and-local-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#shared-and-local-memory-cdp2"><span class="std std-ref">Shared and Local Memory</span></a>, above, for CDP2 version of document.</p>
<p>Shared and Local memory is private to a thread block or thread, respectively, and is not visible or coherent between parent and child. Behavior is undefined when an object in one of these locations is referenced outside of the scope within which it belongs, and may cause an error.</p>
<p>The NVIDIA compiler will attempt to warn if it can detect that a pointer to local or shared memory is being passed as an argument to a kernel launch. At runtime, the programmer may use the <code class="docutils literal notranslate"><span class="pre">__isGlobal()</span></code> intrinsic to determine whether a pointer references global memory and so may safely be passed to a child launch.</p>
<p>Note that calls to <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*Async()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMemset*Async()</span></code> may invoke new child kernels on the device in order to preserve stream semantics. As such, passing shared or local memory pointers to these APIs is illegal and will return an error.</p>
</section>
<section id="local-memory-cdp1">
<span id="id269"></span><h6><span class="section-number">10.6.1.2.1.5. </span>Local Memory (CDP1)<a class="headerlink" href="#local-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#local-memory-cdp2"><span class="std std-ref">Local Memory</span></a>, above, for CDP2 version of document.</p>
<p>Local memory is private storage for an executing thread, and is not visible outside of that thread. It is illegal to pass a pointer to local memory as a launch argument when launching a child kernel. The result of dereferencing such a local memory pointer from a child will be undefined.</p>
<p>For example the following is illegal, with undefined behavior if <code class="docutils literal notranslate"><span class="pre">x_array</span></code> is accessed by <code class="docutils literal notranslate"><span class="pre">child_launch</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">x_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w">       </span><span class="c1">// Creates x_array in parent&#39;s local memory</span>
<span class="n">child_launch</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">x_array</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>It is sometimes difficult for a programmer to be aware of when a variable is placed into local memory by the compiler. As a general rule, all storage passed to a child kernel should be allocated explicitly from the global-memory heap, either with <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>, <code class="docutils literal notranslate"><span class="pre">new()</span></code> or by declaring <code class="docutils literal notranslate"><span class="pre">__device__</span></code> storage at global scope. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Correct - &quot;value&quot; is global storage</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">x</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">child</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Invalid - &quot;value&quot; is local storage</span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">child</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="texture-memory-cdp1">
<span id="texture-memory-cdp-cdp1"></span><h6><span class="section-number">10.6.1.2.1.6. </span>Texture Memory (CDP1)<a class="headerlink" href="#texture-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#texture-memory-cdp"><span class="std std-ref">Texture Memory</span></a>, above, for CDP2 version of document.</p>
<p>Writes to the global memory region over which a texture is mapped are incoherent with respect to texture accesses. Coherence for texture memory is enforced at the invocation of a child grid and when a child grid completes. This means that writes to memory prior to a child kernel launch are reflected in texture memory accesses of the child. Similarly, writes to memory by a child will be reflected in the texture memory accesses by a parent, but only after the parent synchronizes on the childâs completion. Concurrent accesses by parent and child may result in inconsistent data.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
</section>
</section>
</section>
</section>
<section id="programming-interface-cdp1">
<span id="programming-interface-cdp-cdp1"></span><h3><span class="section-number">10.6.2. </span>Programming Interface (CDP1)<a class="headerlink" href="#programming-interface-cdp1" title="Permalink to this headline">ï</a></h3>
<p>See <a class="reference internal" href="#programming-interface-cdp"><span class="std std-ref">Programming Interface</span></a>, above, for CDP2 version of document.</p>
<section id="cuda-c-reference-cdp1">
<span id="id270"></span><h4><span class="section-number">10.6.2.1. </span>CUDA C++ Reference (CDP1)<a class="headerlink" href="#cuda-c-reference-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#cuda-c-reference"><span class="std std-ref">CUDA C++ Reference</span></a>, above, for CDP2 version of document.</p>
<p>This section describes changes and additions to the CUDA C++ language extensions for supporting <em>Dynamic Parallelism</em>.</p>
<p>The language interface and API available to CUDA kernels using CUDA C++ for Dynamic Parallelism, referred to as the <em>Device Runtime</em>, is substantially like that of the CUDA Runtime API available on the host. Where possible the syntax and semantics of the CUDA Runtime API have been retained in order to facilitate ease of code reuse for routines that may run in either the host or device environments.</p>
<p>As with all code in CUDA C++, the APIs and code outlined here is per-thread code. This enables each thread to make unique, dynamic decisions regarding what kernel or operation to execute next. There are no synchronization requirements between threads within a block to execute any of the provided device runtime APIs, which enables the device runtime API functions to be called in arbitrarily divergent kernel code without deadlock.</p>
<section id="device-side-kernel-launch-cdp1">
<span id="id271"></span><h5><span class="section-number">10.6.2.1.1. </span>Device-Side Kernel Launch (CDP1)<a class="headerlink" href="#device-side-kernel-launch-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#id237"><span class="std std-ref">Kernel Launch APIs</span></a>, above, for CDP2 version of document.</p>
<p>Kernels may be launched from the device using the standard CUDA &lt;&lt;&lt; &gt;&gt;&gt; syntax:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">kernel_name</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">Dg</span><span class="p">,</span><span class="w"> </span><span class="n">Db</span><span class="p">,</span><span class="w"> </span><span class="n">Ns</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">([</span><span class="n">kernel</span><span class="w"> </span><span class="n">arguments</span><span class="p">]);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Dg</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> and specifies the dimensions and size of the grid</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Db</span></code> is of type <code class="docutils literal notranslate"><span class="pre">dim3</span></code> and specifies the dimensions and size of each thread block</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ns</span></code> is of type <code class="docutils literal notranslate"><span class="pre">size_t</span></code> and specifies the number of bytes of shared memory that is dynamically allocated per thread block for this call and addition to statically allocated memory. <code class="docutils literal notranslate"><span class="pre">Ns</span></code> is an optional argument that defaults to 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> is of type <code class="docutils literal notranslate"><span class="pre">cudaStream_t</span></code> and specifies the stream associated with this call. The stream must have been allocated in the same thread block where the call is being made. <code class="docutils literal notranslate"><span class="pre">S</span></code> is an optional argument that defaults to 0.</p></li>
</ul>
<section id="launches-are-asynchronous-cdp1">
<span id="id272"></span><h6><span class="section-number">10.6.2.1.1.1. </span>Launches are Asynchronous (CDP1)<a class="headerlink" href="#launches-are-asynchronous-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#launches-are-asynchronous"><span class="std std-ref">Launches are Asynchronous</span></a>, above, for CDP2 version of document.</p>
<p>Identical to host-side launches, all device-side kernel launches are asynchronous with respect to the launching thread. That is to say, the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> launch command will return immediately and the launching thread will continue to execute until it hits an explicit launch-synchronization point such as <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>The grid launch is posted to the device and will execute independently of the parent thread. The child grid may begin execution at any time after launch, but is not guaranteed to begin execution until the launching thread reaches an explicit launch-synchronization point.</p>
</section>
<section id="launch-environment-configuration-cdp1">
<span id="id273"></span><h6><span class="section-number">10.6.2.1.1.2. </span>Launch Environment Configuration (CDP1)<a class="headerlink" href="#launch-environment-configuration-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#launch-environment-configuration"><span class="std std-ref">Launch Environment Configuration</span></a>, above, for CDP2 version of document.</p>
<p>All global device configuration settings (for example, shared memory and L1 cache size as returned from <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetCacheConfig()</span></code>, and device limits returned from <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code>) will be inherited from the parent. Likewise, device limits such as stack size will remain as-configured.</p>
<p>For host-launched kernels, per-kernel configurations set from the host will take precedence over the global setting. These configurations will be used when the kernel is launched from the device as well. It is not possible to reconfigure a kernelâs environment from the device.</p>
</section>
</section>
<section id="streams-cdp1">
<span id="streams-cdp-cdp1"></span><h5><span class="section-number">10.6.2.1.2. </span>Streams (CDP1)<a class="headerlink" href="#streams-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#streams-cdp"><span class="std std-ref">Streams</span></a>, above, for CDP2 version of document.</p>
<p>Both named and unnamed (NULL) streams are available from the device runtime. Named streams may be used by any thread within a thread-block, but stream handles may not be passed to other blocks or child/parent kernels. In other words, a stream should be treated as private to the block in which it is created. Stream handles are not guaranteed to be unique between blocks, so using a stream handle within a block that did not allocate it will result in undefined behavior.</p>
<p>Similar to host-side launch, work launched into separate streams may run concurrently, but actual concurrency is not guaranteed. Programs that depend upon concurrency between child kernels are not supported by the CUDA programming model and will have undefined behavior.</p>
<p>The host-side NULL streamâs cross-stream barrier semantic is not supported on the device (see below for details). In order to retain semantic compatibility with the host runtime, all device streams must be created using the <code class="docutils literal notranslate"><span class="pre">cudaStreamCreateWithFlags()</span></code> API, passing the <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag. The <code class="docutils literal notranslate"><span class="pre">cudaStreamCreate()</span></code> call is a host-runtime- only API and will fail to compile for the device.</p>
<p>As <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaStreamQuery()</span></code> are unsupported by the device runtime, <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> should be used instead when the application needs to know that stream-launched child kernels have completed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<section id="the-implicit-null-stream-cdp1">
<span id="id274"></span><h6><span class="section-number">10.6.2.1.2.1. </span>The Implicit (NULL) Stream (CDP1)<a class="headerlink" href="#the-implicit-null-stream-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#the-implicit-null-stream"><span class="std std-ref">The Implicit (NULL) Stream</span></a>, above, for CDP2 version of document.</p>
<p>Within a host program, the unnamed (NULL) stream has additional barrier synchronization semantics with other streams (see <a class="reference internal" href="#default-stream"><span class="std std-ref">Default Stream</span></a> for details). The device runtime offers a single implicit, unnamed stream shared between all threads in a block, but as all named streams must be created with the <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag, work launched into the NULL stream will not insert an implicit dependency on pending work in any other streams (including NULL streams of other thread blocks).</p>
</section>
</section>
<section id="events-cdp1">
<span id="events-cdp-cdp1"></span><h5><span class="section-number">10.6.2.1.3. </span>Events (CDP1)<a class="headerlink" href="#events-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#events-cdp"><span class="std std-ref">Events</span></a>, above, for CDP2 version of document.</p>
<p>Only the inter-stream synchronization capabilities of CUDA events are supported. This means that <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code> is supported, but <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaEventElapsedTime()</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaEventQuery()</span></code> are not. As <code class="docutils literal notranslate"><span class="pre">cudaEventElapsedTime()</span></code> is not supported, cudaEvents must be created via <code class="docutils literal notranslate"><span class="pre">cudaEventCreateWithFlags()</span></code>, passing the <code class="docutils literal notranslate"><span class="pre">cudaEventDisableTiming</span></code> flag.</p>
<p>As for all device runtime objects, event objects may be shared between all threads within the thread-block which created them but are local to that block and may not be passed to other kernels, or between blocks within the same kernel. Event handles are not guaranteed to be unique between blocks, so using an event handle within a block that did not create it will result in undefined behavior.</p>
</section>
<section id="synchronization-programming-interface-cdp1">
<span id="id275"></span><h5><span class="section-number">10.6.2.1.4. </span>Synchronization (CDP1)<a class="headerlink" href="#synchronization-programming-interface-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#synchronization-programming-interface"><span class="std std-ref">Synchronization</span></a>, above, for CDP2 version of document.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> function will synchronize on all work launched by any thread in the thread-block up to the point where <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> was called. Note that <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> may be called from within divergent code (see <a class="reference internal" href="#block-wide-synchronization-cdp1"><span class="std std-ref">Block Wide Synchronization (CDP1)</span></a>).</p>
<p>It is up to the program to perform sufficient additional inter-thread synchronization, for example via a call to <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code>, if the calling thread is intended to synchronize with child grids invoked from other threads.</p>
<section id="block-wide-synchronization-cdp1">
<span id="id276"></span><h6><span class="section-number">10.6.2.1.4.1. </span>Block Wide Synchronization (CDP1)<a class="headerlink" href="#block-wide-synchronization-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a>, above, for CDP2 version of document.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> function does not imply intra-block synchronization. In particular, without explicit synchronization via a <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> directive the calling thread can make no assumptions about what work has been launched by any thread other than itself. For example if multiple threads within a block are each launching work and synchronization is desired for all this work at once (perhaps because of event-based dependencies), it is up to the program to guarantee that this work is submitted by all threads before calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>.</p>
<p>Because the implementation is permitted to synchronize on launches from any thread in the block, it is quite possible that simultaneous calls to <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> by multiple threads will drain all work in the first call and then have no effect for the later calls.</p>
</section>
</section>
<section id="device-management-programming-cdp1">
<span id="id277"></span><h5><span class="section-number">10.6.2.1.5. </span>Device Management (CDP1)<a class="headerlink" href="#device-management-programming-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#device-management-programming"><span class="std std-ref">Device Management</span></a>, above, for CDP2 version of document.</p>
<p>Only the device on which a kernel is running will be controllable from that kernel. This means that device APIs such as <code class="docutils literal notranslate"><span class="pre">cudaSetDevice()</span></code> are not supported by the device runtime. The active device as seen from the GPU (returned from <code class="docutils literal notranslate"><span class="pre">cudaGetDevice()</span></code>) will have the same device number as seen from the host system. The <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute()</span></code> call may request information about another device as this API allows specification of a device ID as a parameter of the call. Note that the catch-all <code class="docutils literal notranslate"><span class="pre">cudaGetDeviceProperties()</span></code> API is not offered by the device runtime - properties must be queried individually.</p>
</section>
<section id="memory-declarations-cdp1">
<span id="id278"></span><h5><span class="section-number">10.6.2.1.6. </span>Memory Declarations (CDP1)<a class="headerlink" href="#memory-declarations-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#memory-declarations"><span class="std std-ref">Memory Declarations</span></a>, above, for CDP2 version of document.</p>
<section id="device-and-constant-memory-cdp1">
<span id="id279"></span><h6><span class="section-number">10.6.2.1.6.1. </span>Device and Constant Memory (CDP1)<a class="headerlink" href="#device-and-constant-memory-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#device-and-constant-memory"><span class="std std-ref">Device and Constant Memory</span></a>, above, for CDP2 version of document.</p>
<p>Memory declared at file scope with <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> memory space specifiers behaves identically when using the device runtime. All kernels may read or write device variables, whether the kernel was initially launched by the host or device runtime. Equivalently, all kernels will have the same view of <code class="docutils literal notranslate"><span class="pre">__constant__</span></code>s as declared at the module scope.</p>
</section>
<section id="textures-and-surfaces-cdp1">
<span id="id280"></span><h6><span class="section-number">10.6.2.1.6.2. </span>Textures and Surfaces (CDP1)<a class="headerlink" href="#textures-and-surfaces-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#textures-and-surfaces"><span class="std std-ref">Textures and Surfaces</span></a>, above, for CDP2 version of document.</p>
<p>CUDA supports dynamically created texture and surface objects<a class="footnote-reference brackets" href="#fn14" id="id281">14</a>, where a texture object may be created on the host, passed to a kernel, used by that kernel, and then destroyed from the host. The device runtime does not allow creation or destruction of texture or surface objects from within device code, but texture and surface objects created from the host may be used and passed around freely on the device. Regardless of where they are created, dynamically created texture objects are always valid and may be passed to child kernels from a parent.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The device runtime does not support legacy module-scope (i.e., Fermi-style) textures and surfaces within a kernel launched from the device. Module-scope (legacy) textures may be created from the host and used in device code as for any kernel, but may only be used by a top-level kernel (i.e., the one which is launched from the host).</p>
</div>
</section>
<section id="shared-memory-variable-declarations-cdp1">
<span id="id282"></span><h6><span class="section-number">10.6.2.1.6.3. </span>Shared Memory Variable Declarations (CDP1)<a class="headerlink" href="#shared-memory-variable-declarations-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#shared-memory-variable-declarations"><span class="std std-ref">Shared Memory Variable Declarations</span></a>, above, for CDP2 version of document.</p>
<p>In CUDA C++ shared memory can be declared either as a statically sized file-scope or function-scoped variable, or as an <code class="docutils literal notranslate"><span class="pre">extern</span></code> variable with the size determined at runtime by the kernelâs caller via a launch configuration argument. Both types of declarations are valid under the device runtime.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">permute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">smem</span><span class="p">[];</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">       </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="n">smem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="n">permute_data</span><span class="p">(</span><span class="n">smem</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Write back to GMEM since we can&#39;t pass SMEM to children.</span>
<span class="w">   </span><span class="n">data</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smem</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">host_launch</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">permute</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="symbol-addresses-cdp1">
<span id="id283"></span><h6><span class="section-number">10.6.2.1.6.4. </span>Symbol Addresses (CDP1)<a class="headerlink" href="#symbol-addresses-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#symbol-addresses"><span class="std std-ref">Symbol Addresses</span></a>, above, for CDP2 version of document.</p>
<p>Device-side symbols (i.e., those marked <code class="docutils literal notranslate"><span class="pre">__device__</span></code>) may be referenced from within a kernel simply via the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator, as all global-scope device variables are in the kernelâs visible address space. This also applies to <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> symbols, although in this case the pointer will reference read-only data.</p>
<p>Given that device-side symbols can be referenced directly, those CUDA runtime APIs which reference symbols (for example, <code class="docutils literal notranslate"><span class="pre">cudaMemcpyToSymbol()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolAddress()</span></code>) are redundant and hence not supported by the device runtime. Note this implies that constant data cannot be altered from within a running kernel, even ahead of a child kernel launch, as references to <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> space are read-only.</p>
</section>
</section>
<section id="api-errors-and-launch-failures-cdp1">
<span id="id284"></span><h5><span class="section-number">10.6.2.1.7. </span>API Errors and Launch Failures (CDP1)<a class="headerlink" href="#api-errors-and-launch-failures-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#api-errors-and-launch-failures"><span class="std std-ref">API Errors and Launch Failures</span></a>, above, for CDP2 version of document.</p>
<p>As usual for the CUDA runtime, any function may return an error code. The last error code returned is recorded and may be retrieved via the <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> call. Errors are recorded per-thread, so that each thread can identify the most recent error that it has generated. The error code is of type <code class="docutils literal notranslate"><span class="pre">cudaError_t</span></code>.</p>
<p>Similar to a host-side launch, device-side launches may fail for many reasons (invalid arguments, and so on). The user must call <code class="docutils literal notranslate"><span class="pre">cudaGetLastError()</span></code> to determine if a launch generated an error, however lack of an error after launch does not imply the child kernel completed successfully.</p>
<p>For device-side exceptions, for example, access to an invalid address, an error in a child grid will be returned to the host instead of being returned by the parentâs call to <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>.</p>
<section id="launch-setup-apis-cdp1">
<span id="id285"></span><h6><span class="section-number">10.6.2.1.7.1. </span>Launch Setup APIs (CDP1)<a class="headerlink" href="#launch-setup-apis-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#launch-setup-apis"><span class="std std-ref">Launch Setup APIs</span></a>, above, for CDP2 version of document.</p>
<p>Kernel launch is a system-level mechanism exposed through the device runtime library, and as such is available directly from PTX via the underlying <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> APIs. It is permitted for a CUDA application to call these APIs itself, with the same requirements as for PTX. In both cases, the user is then responsible for correctly populating all necessary data structures in the correct format according to specification. Backwards compatibility is guaranteed in these data structures.</p>
<p>As with host-side launch, the device-side operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> maps to underlying kernel launch APIs. This is so that users targeting PTX will be able to enact a launch, and so that the compiler front-end can translate <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code> into these calls.</p>
<table class="table-no-stripes docutils align-default" id="id471">
<caption><span class="caption-number">Table 16 </span><span class="caption-text">New Device-only Launch Implementation Functions</span><a class="headerlink" href="#id471" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 24%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Runtime API Launch Functions</p></th>
<th class="head"><p>Description of Difference From Host Runtime Behaviour (behavior is identical if no description)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer</span></code></p></td>
<td><p>Generated automatically from <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code>. Note different API to host equivalent.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice</span></code></p></td>
<td><p>Generated automatically from <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;&gt;&gt;&gt;</span></code>. Note different API to host equivalent.</p></td>
</tr>
</tbody>
</table>
<p>The APIs for these launch functions are different to those of the CUDA Runtime API, and are defined as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w">   </span><span class="n">device</span><span class="w">   </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaGetParameterBuffer</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">params</span><span class="p">);</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kernel</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="p">,</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="n">gridDim</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">dim3</span><span class="w"> </span><span class="n">blockDim</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="api-reference-cdp1">
<span id="id286"></span><h5><span class="section-number">10.6.2.1.8. </span>API Reference (CDP1)<a class="headerlink" href="#api-reference-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#api-reference-cdp2"><span class="std std-ref">API Reference</span></a>, above, for CDP2 version of document.</p>
<p>The portions of the CUDA Runtime API supported in the device runtime are detailed here. Host and device runtime APIs have identical syntax; semantics are the same except where indicated. The table below provides an overview of the API relative to the version available from the host.</p>
<table class="table-no-stripes docutils align-default" id="id472">
<caption><span class="caption-number">Table 17 </span><span class="caption-text">Supported API Functions</span><a class="headerlink" href="#id472" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Runtime API Functions</p></th>
<th class="head"><p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code></p></td>
<td><p>Synchronizes on work launched from threadâs own block only.</p>
<p>Warning: Note that calling this API from device code is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetCacheConfig</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetLastError</span></code></p></td>
<td><p>Last error is per-thread state, not per-block state</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaPeekAtLastError</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetErrorString</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetDeviceCount</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute</span></code></p></td>
<td><p>Will return attributes for any device</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGetDevice</span></code></p></td>
<td><p>Always returns current device ID as would be seen from host</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamCreateWithFlags</span></code></p></td>
<td><p>Must pass <code class="docutils literal notranslate"><span class="pre">cudaStreamNonBlocking</span></code> flag</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamDestroy</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventCreateWithFlags</span></code></p></td>
<td><p>Must pass <code class="docutils literal notranslate"><span class="pre">cudaEventDisableTiming</span></code> flag</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventRecord</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEventDestroy</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFuncGetAttributes</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpyAsync</span></code></p></td>
<td rowspan="4"><p>Notes about all <code class="docutils literal notranslate"><span class="pre">memcpy/memset</span></code> functions:</p>
<ul class="simple">
<li><p>Only async <code class="docutils literal notranslate"><span class="pre">memcpy/set</span></code> functions are supported</p></li>
<li><p>Only device-to-device <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> is permitted</p></li>
<li><p>May not pass in local or shared memory pointers</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpy2DAsync</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemcpy3DAsync</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemsetAsync</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemset2DAsync</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemset3DAsync</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaRuntimeGetVersion</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code></p></td>
<td rowspan="2"><p>May not call <code class="docutils literal notranslate"><span class="pre">cudaFree</span></code> on the device on a pointer created on the host, and vice-versa</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxActiveBlocksPerMultiprocessor</span></code></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSize</span></code></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaOccupancyMaxPotentialBlockSizeVariableSMem</span></code></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="device-side-launch-from-ptx-cdp1">
<span id="id287"></span><h4><span class="section-number">10.6.2.2. </span>Device-side Launch from PTX (CDP1)<a class="headerlink" href="#device-side-launch-from-ptx-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#device-side-launch-from-ptx-cdp2"><span class="std std-ref">Device-side Launch from PTX</span></a>, above, for CDP2 version of document.</p>
<p>This section is for the programming language and compiler implementers who target <em>Parallel Thread Execution</em> (PTX) and plan to support <em>Dynamic Parallelism</em> in their language. It provides the low-level details related to supporting kernel launches at the PTX level.</p>
<section id="kernel-launch-apis-cdp1">
<span id="id288"></span><h5><span class="section-number">10.6.2.2.1. </span>Kernel Launch APIs (CDP1)<a class="headerlink" href="#kernel-launch-apis-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#id237"><span class="std std-ref">Kernel Launch APIs</span></a>, above, for CDP2 version of document.</p>
<p>Device-side kernel launches can be implemented using the following two APIs accessible from PTX: <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code>. <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code> launches the specified kernel with the parameter buffer that is obtained by calling <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> and filled with the parameters to the launched kernel. The parameter buffer can be NULL, i.e., no need to invoke <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code>, if the launched kernel does not take any parameters.</p>
<section id="cudalaunchdevice-cdp1">
<span id="id289"></span><h6><span class="section-number">10.6.2.2.1.1. </span>cudaLaunchDevice (CDP1)<a class="headerlink" href="#cudalaunchdevice-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#cudalaunchdevice-cdp2"><span class="std std-ref">cudaLaunchDevice</span></a>, above, for CDP2 version of document.</p>
<p>At the PTX level, <code class="docutils literal notranslate"><span class="pre">cudaLaunchDevice()</span></code>needs to be declared in one of the two forms shown below before it is used.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaLaunchDevice() when .address_size is 64</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">parameterBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">gridDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">blockDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">stream</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaLaunchDevice() when .address_size is 32</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">parameterBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">gridDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">align</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">.</span><span class="n">b8</span><span class="w"> </span><span class="n">blockDimension</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">stream</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The CUDA-level declaration below is mapped to one of the aforementioned PTX-level declarations and is found in the system header file <code class="docutils literal notranslate"><span class="pre">cuda_device_runtime_api.h</span></code>. The function is defined in the <code class="docutils literal notranslate"><span class="pre">cudadevrt</span></code> system library, which must be linked with a program in order to use device-side kernel launch functionality.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// CUDA-level declaration of cudaLaunchDevice()</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">__device__</span><span class="w"></span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaLaunchDevice</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">parameterBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">dim3</span><span class="w"> </span><span class="n">gridDimension</span><span class="p">,</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="n">blockDimension</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sharedMemSize</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The first parameter is a pointer to the kernel to be is launched, and the second parameter is the parameter buffer that holds the actual parameters to the launched kernel. The layout of the parameter buffer is explained in <a class="reference internal" href="#parameter-buffer-layout-cdp1"><span class="std std-ref">Parameter Buffer Layout (CDP1)</span></a>, below. Other parameters specify the launch configuration, i.e., as grid dimension, block dimension, shared memory size, and the stream associated with the launch (please refer to <a class="reference internal" href="#execution-configuration"><span class="std std-ref">Execution Configuration</span></a> for the detailed description of launch configuration.</p>
</section>
<section id="cudagetparameterbuffer-cdp1">
<span id="id290"></span><h6><span class="section-number">10.6.2.2.1.2. </span>cudaGetParameterBuffer (CDP1)<a class="headerlink" href="#cudagetparameterbuffer-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#cudagetparameterbuffer-cdp2"><span class="std std-ref">cudaGetParameterBuffer</span></a>, above, for CDP2 version of document.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> needs to be declared at the PTX level before itâs used. The PTX-level declaration must be in one of the two forms given below, depending on address size:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 64</span>
<span class="c1">// When .address_size is 64</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaGetParameterBuffer</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b64</span><span class="w"> </span><span class="n">size</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// PTX-level Declaration of cudaGetParameterBuffer() when .address_size is 32</span>
<span class="p">.</span><span class="k">extern</span><span class="w"> </span><span class="p">.</span><span class="n">func</span><span class="p">(.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">func_retval0</span><span class="p">)</span><span class="w"> </span><span class="n">cudaGetParameterBuffer</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">param</span><span class="w"> </span><span class="p">.</span><span class="n">b32</span><span class="w"> </span><span class="n">size</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The following CUDA-level declaration of <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> is mapped to the aforementioned PTX-level declaration:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// CUDA-level Declaration of cudaGetParameterBuffer()</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">__device__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">cudaGetParameterBuffer</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The first parameter specifies the alignment requirement of the parameter buffer and the second parameter the size requirement in bytes. In the current implementation, the parameter buffer returned by <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> is always guaranteed to be 64- byte aligned, and the alignment requirement parameter is ignored. However, it is recommended to pass the correct alignment requirement value - which is the largest alignment of any parameter to be placed in the parameter buffer - to <code class="docutils literal notranslate"><span class="pre">cudaGetParameterBuffer()</span></code> to ensure portability in the future.</p>
</section>
</section>
<section id="parameter-buffer-layout-cdp1">
<span id="id291"></span><h5><span class="section-number">10.6.2.2.2. </span>Parameter Buffer Layout (CDP1)<a class="headerlink" href="#parameter-buffer-layout-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#parameter-buffer-layout"><span class="std std-ref">Parameter Buffer Layout</span></a>, above, for CDP2 version of document.</p>
<p>Parameter reordering in the parameter buffer is prohibited, and each individual parameter placed in the parameter buffer is required to be aligned. That is, each parameter must be placed at the <em>n</em><sup>th</sup> byte in the parameter buffer, where <em>n</em> is the smallest multiple of the parameter size that is greater than the offset of the last byte taken by the preceding parameter. The maximum size of the parameter buffer is 4KB.</p>
<p>For a more detailed description of PTX code generated by the CUDA compiler, please refer to the PTX-3.5 specification.</p>
</section>
</section>
<section id="toolkit-support-for-dynamic-parallelism-cdp1">
<span id="id292"></span><h4><span class="section-number">10.6.2.3. </span>Toolkit Support for Dynamic Parallelism (CDP1)<a class="headerlink" href="#toolkit-support-for-dynamic-parallelism-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#toolkit-support-for-dynamic-parallelism"><span class="std std-ref">Toolkit Support for Dynamic Parallelism</span></a>, above, for CDP2 version of document.</p>
<section id="including-device-runtime-api-in-cuda-code-cdp1">
<span id="id293"></span><h5><span class="section-number">10.6.2.3.1. </span>Including Device Runtime API in CUDA Code (CDP1)<a class="headerlink" href="#including-device-runtime-api-in-cuda-code-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#including-device-runtime-api-in-cuda-code-cdp2"><span class="std std-ref">Including Device Runtime API in CUDA Code</span></a>, above, for CDP2 version of document.</p>
<p>Similar to the host-side runtime API, prototypes for the CUDA device runtime API are included automatically during program compilation. There is no need to include <code class="docutils literal notranslate"><span class="pre">cuda_device_runtime_api.h</span></code> explicitly.</p>
</section>
<section id="compiling-and-linking-cdp1">
<span id="id294"></span><h5><span class="section-number">10.6.2.3.2. </span>Compiling and Linking (CDP1)<a class="headerlink" href="#compiling-and-linking-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#compiling-and-linking"><span class="std std-ref">Compiling and Linking</span></a>, above, for CDP2 version of document.</p>
<p>When compiling and linking CUDA programs using dynamic parallelism with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code>, the program will automatically link against the static device runtime library <code class="docutils literal notranslate"><span class="pre">libcudadevrt</span></code>.</p>
<p>The device runtime is offered as a static library (<code class="docutils literal notranslate"><span class="pre">cudadevrt.lib</span></code> on Windows, <code class="docutils literal notranslate"><span class="pre">libcudadevrt.a</span></code> under Linux), against which a GPU application that uses the device runtime must be linked. Linking of device libraries can be accomplished through <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> and/or <code class="docutils literal notranslate"><span class="pre">nvlink</span></code>. Two simple examples are shown below.</p>
<p>A device runtime program may be compiled and linked in a single step, if all required source files can be specified from the command line:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt
</pre></div>
</div>
<p>It is also possible to compile CUDA .cu source files first to object files, and then link these together in a two-stage process:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -dc hello_world.cu -o hello_world.o
$ nvcc -arch=sm_75 -rdc=true hello_world.o -o hello -lcudadevrt
</pre></div>
</div>
<p>Please see the Using Separate Compilation section of The CUDA Driver Compiler NVCC guide for more details.</p>
</section>
</section>
</section>
<section id="programming-guidelines-cdp1">
<span id="id295"></span><h3><span class="section-number">10.6.3. </span>Programming Guidelines (CDP1)<a class="headerlink" href="#programming-guidelines-cdp1" title="Permalink to this headline">ï</a></h3>
<p>See <a class="reference internal" href="#programming-guidelines"><span class="std std-ref">Programming Guidelines</span></a>, above, for CDP2 version of document.</p>
<section id="basics-cdp1">
<span id="id296"></span><h4><span class="section-number">10.6.3.1. </span>Basics (CDP1)<a class="headerlink" href="#basics-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#basics"><span class="std std-ref">Basics</span></a>, above, for CDP2 version of document.</p>
<p>The device runtime is a functional subset of the host runtime. API level device management, kernel launching, device memcpy, stream management, and event management are exposed from the device runtime.</p>
<p>Programming for the device runtime should be familiar to someone who already has experience with CUDA. Device runtime syntax and semantics are largely the same as that of the host API, with any exceptions detailed earlier in this document.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>The following example shows a simple <em>Hello World</em> program incorporating dynamic parallelism:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">childKernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">parentKernel</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// launch child</span>
<span class="w">    </span><span class="n">childKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaGetLastError</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// wait for child to complete</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaDeviceSynchronize</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// launch parent</span>
<span class="w">    </span><span class="n">parentKernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaGetLastError</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// wait for parent to complete</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaDeviceSynchronize</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This program may be built in a single step from the command line as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ nvcc -arch=sm_75 -rdc=true hello_world.cu -o hello -lcudadevrt
</pre></div>
</div>
</section>
<section id="performance-cdp1">
<span id="id297"></span><h4><span class="section-number">10.6.3.2. </span>Performance (CDP1)<a class="headerlink" href="#performance-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#performance"><span class="std std-ref">Performance</span></a>, above, for CDP2 version of document.</p>
<section id="synchronization-performance-cdp1">
<span id="id298"></span><h5><span class="section-number">10.6.3.2.1. </span>Synchronization (CDP1)<a class="headerlink" href="#synchronization-performance-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a>, above, for CDP2 version of document.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (such as using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>Synchronization by one thread may impact the performance of other threads in the same <em>Thread Block</em>, even when those other threads do not call <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> themselves. This impact will depend upon the underlying implementation. In general the implicit synchronization of child kernels done when a thread block ends is more efficient compared to calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> explicitly. It is therefore recommended to only call <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> if it is needed to synchronize with a child kernel before a thread block ends.</p>
</section>
<section id="dynamic-parallelism-enabled-kernel-overhead-cdp1">
<span id="id299"></span><h5><span class="section-number">10.6.3.2.2. </span>Dynamic-parallelism-enabled Kernel Overhead (CDP1)<a class="headerlink" href="#dynamic-parallelism-enabled-kernel-overhead-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#dynamic-parallelism-enabled-kernel-overhead"><span class="std std-ref">Dynamic-parallelism-enabled Kernel Overhead</span></a>, above, for CDP2 version of document.</p>
<p>System software which is active when controlling dynamic launches may impose an overhead on any kernel which is running at the time, whether or not it invokes kernel launches of its own. This overhead arises from the device runtimeâs execution tracking and management software and may result in decreased performance for example, library calls when made from the device compared to from the host side. This overhead is, in general, incurred for applications that link against the device runtime library.</p>
</section>
</section>
<section id="implementation-restrictions-and-limitations-cdp1">
<span id="id300"></span><h4><span class="section-number">10.6.3.3. </span>Implementation Restrictions and Limitations (CDP1)<a class="headerlink" href="#implementation-restrictions-and-limitations-cdp1" title="Permalink to this headline">ï</a></h4>
<p>See <a class="reference internal" href="#implementation-restrictions-and-limitations"><span class="std std-ref">Implementation Restrictions and Limitations</span></a>, above, for CDP2 version of document.</p>
<p><em>Dynamic Parallelism</em> guarantees all semantics described in this document, however, certain hardware and software resources are implementation-dependent and limit the scale, performance and other properties of a program which uses the device runtime.</p>
<section id="runtime-cdp1">
<span id="id301"></span><h5><span class="section-number">10.6.3.3.1. </span>Runtime (CDP1)<a class="headerlink" href="#runtime-cdp1" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#runtime"><span class="std std-ref">Runtime</span></a>, above, for CDP2 version of document.</p>
<section id="memory-footprint-cdp1">
<span id="id302"></span><h6><span class="section-number">10.6.3.3.1.1. </span>Memory Footprint (CDP1)<a class="headerlink" href="#memory-footprint-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#memory-footprint"><span class="std std-ref">Memory Footprint</span></a>, above, for CDP2 version of document.</p>
<p>The device runtime system software reserves memory for various management purposes, in particular one reservation which is used for saving parent-grid state during synchronization, and a second reservation for tracking pending grid launches. Configuration controls are available to reduce the size of these reservations in exchange for certain launch limitations. See <a class="reference internal" href="#configuration-options-cdp1"><span class="std std-ref">Configuration Options (CDP1)</span></a>, below, for details.</p>
<p>The majority of reserved memory is allocated as backing-store for parent kernel state, for use when synchronizing on a child launch. Conservatively, this memory must support storing of state for the maximum number of live threads possible on the device. This means that each parent generation at which <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> is callable may require up to 860MB of device memory, depending on the device configuration, which will be unavailable for program use even if it is not all consumed.</p>
</section>
<section id="nesting-and-synchronization-depth-cdp1">
<span id="id303"></span><h6><span class="section-number">10.6.3.3.1.2. </span>Nesting and Synchronization Depth (CDP1)<a class="headerlink" href="#nesting-and-synchronization-depth-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a>, above, for CDP2 version of document.</p>
<p>Using the device runtime, one kernel may launch another kernel, and that kernel may launch another, and so on. Each subordinate launch is considered a new <em>nesting level</em>, and the total number of levels is the <em>nesting depth</em> of the program. The <em>synchronization depth</em> is defined as the deepest level at which the program will explicitly synchronize on a child launch. Typically this is one less than the nesting depth of the program, but if the program does not need to call <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> at all levels then the synchronization depth might be substantially different to the nesting depth.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>The overall maximum nesting depth is limited to 24, but practically speaking the real limit will be the amount of memory required by the system for each new level (see <a class="reference internal" href="#memory-footprint-cdp1"><span class="std std-ref">Memory Footprint (CDP1)</span></a> above). Any launch which would result in a kernel at a deeper level than the maximum will fail. Note that this may also apply to <code class="docutils literal notranslate"><span class="pre">cudaMemcpyAsync()</span></code>, which might itself generate a kernel launch. See <a class="reference internal" href="#configuration-options-cdp1"><span class="std std-ref">Configuration Options (CDP1)</span></a> for details.</p>
<p>By default, sufficient storage is reserved for two levels of synchronization. This maximum synchronization depth (and hence reserved storage) may be controlled by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> and specifying <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimeSyncDepth</span></code>. The number of levels to be supported must be configured before the top-level kernel is launched from the host, in order to guarantee successful execution of a nested program. Calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> at a depth greater than the specified maximum synchronization depth will return an error.</p>
<p>An optimization is permitted where the system detects that it need not reserve space for the parentâs state in cases where the parent kernel never calls <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>. In this case, because explicit parent/child synchronization never occurs, the memory footprint required for a program will be much less than the conservative maximum. Such a program could specify a shallower maximum synchronization depth to avoid over-allocation of backing store.</p>
</section>
<section id="pending-kernel-launches-cdp1">
<span id="id304"></span><h6><span class="section-number">10.6.3.3.1.3. </span>Pending Kernel Launches (CDP1)<a class="headerlink" href="#pending-kernel-launches-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#pending-kernel-launches"><span class="std std-ref">Pending Kernel Launches</span></a>, above, for CDP2 version of document.</p>
<p>When a kernel is launched, all associated configuration and parameter data is tracked until the kernel completes. This data is stored within a system-managed launch pool.</p>
<p>The launch pool is divided into a fixed-size pool and a virtualized pool with lower performance. The device runtime system software will try to track launch data in the fixed-size pool first. The virtualized pool will be used to track new launches when the fixed-size pool is full.</p>
<p>The size of the fixed-size launch pool is configurable by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> from the host and specifying <code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code>.</p>
</section>
<section id="configuration-options-cdp1">
<span id="id305"></span><h6><span class="section-number">10.6.3.3.1.4. </span>Configuration Options (CDP1)<a class="headerlink" href="#configuration-options-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#configuration-options"><span class="std std-ref">Configuration Options</span></a>, above, for CDP2 version of document.</p>
<p>Resource allocation for the device runtime system software is controlled via the <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> API from the host program. Limits must be set before any kernel is launched, and may not be changed while the GPU is actively running programs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Explicit synchronization with child kernels from a parent block (i.e. using <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> in device code) is deprecated in CUDA 11.6, removed for compute_90+ compilation, and is slated for full removal in a future CUDA release.</p>
</div>
<p>The following named limits may be set:</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Limit</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimeSyncDepth</span></code></p></td>
<td><p>Sets the maximum depth at which <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> may be called. Launches may be performed deeper than this, but explicit synchronization deeper than this limit will return the <code class="docutils literal notranslate"><span class="pre">cudaErrorLaunchMaxDepthExceeded</span></code>. The default maximum sync depth is 2.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitDevRuntimePendingLaunchCount</span></code></p></td>
<td><p>Controls the amount of memory set aside for buffering kernel launches which have not yet begun to execute, due either to unresolved dependencies or lack of execution resources. When the buffer is full, the device runtime system software will attempt to track new pending launches in a lower performance virtualized buffer. If the virtualized buffer is also full, i.e. when all available heap space is consumed, launches will not occur, and the threadâs last error will be set to <code class="docutils literal notranslate"><span class="pre">cudaErrorLaunchPendingCountExceeded</span></code>. The default pending launch count is 2048 launches.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitStackSize</span></code></p></td>
<td><p>Controls the stack size in bytes of each GPU thread. The CUDA driver automatically increases the per-thread stack size for each kernel launch as needed. This size isnât reset back to the original value after each launch. To set the per-thread stack size to a different value, <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetLimit()</span></code> can be called to set this limit. The stack will be immediately resized, and if necessary, the device will block until all preceding requested tasks are complete. <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetLimit()</span></code> can be called to get the current per-thread stack size.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="memory-allocation-and-lifetime-cdp1">
<span id="id306"></span><h6><span class="section-number">10.6.3.3.1.5. </span>Memory Allocation and Lifetime (CDP1)<a class="headerlink" href="#memory-allocation-and-lifetime-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#memory-allocation-and-lifetime"><span class="std std-ref">Memory Allocation and Lifetime</span></a>, above, for CDP2 version of document.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> have distinct semantics between the host and device environments. When invoked from the host, <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> allocates a new region from unused device memory. When invoked from the device runtime these functions map to device-side <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">free()</span></code>. This implies that within the device environment the total allocatable memory is limited to the device <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> heap size, which may be smaller than the available unused device memory. Also, it is an error to invoke <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> from the host program on a pointer which was allocated by <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on the device or vice-versa.</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 32%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on Host</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> on Device</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> on Host</p></td>
<td><p>Supported</p></td>
<td><p>Not Supported</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> on Device</p></td>
<td><p>Not Supported</p></td>
<td><p>Supported</p></td>
</tr>
<tr class="row-even"><td><p>Allocation limit</p></td>
<td><p>Free device memory</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaLimitMallocHeapSize</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="sm-id-and-warp-id-cdp1">
<span id="id307"></span><h6><span class="section-number">10.6.3.3.1.6. </span>SM Id and Warp Id (CDP1)<a class="headerlink" href="#sm-id-and-warp-id-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#sm-id-and-warp-id"><span class="std std-ref">SM Id and Warp Id</span></a>, above, for CDP2 version of document.</p>
<p>Note that in PTX <code class="docutils literal notranslate"><span class="pre">%smid</span></code> and <code class="docutils literal notranslate"><span class="pre">%warpid</span></code> are defined as volatile values. The device runtime may reschedule thread blocks onto different SMs in order to more efficiently manage resources. As such, it is unsafe to rely upon <code class="docutils literal notranslate"><span class="pre">%smid</span></code> or <code class="docutils literal notranslate"><span class="pre">%warpid</span></code> remaining unchanged across the lifetime of a thread or thread block.</p>
</section>
<section id="ecc-errors-cdp1">
<span id="id308"></span><h6><span class="section-number">10.6.3.3.1.7. </span>ECC Errors (CDP1)<a class="headerlink" href="#ecc-errors-cdp1" title="Permalink to this headline">ï</a></h6>
<p>See <a class="reference internal" href="#ecc-errors"><span class="std std-ref">ECC Errors</span></a>, above, for CDP2 version of document.</p>
<p>No notification of ECC errors is available to code within a CUDA kernel. ECC errors are reported at the host side once the entire launch tree has completed. Any ECC errors which arise during execution of a nested program will either generate an exception or continue execution (depending upon error and configuration).</p>
<dl class="footnote brackets">
<dt class="label" id="fn14"><span class="brackets">14</span><span class="fn-backref">(<a href="#id232">1</a>,<a href="#id281">2</a>,<a href="#id326">3</a>)</span></dt>
<dd><p>Dynamically created texture and surface objects are an addition to the CUDA memory model introduced with CUDA 5.0. Please see the <em>CUDA Programming Guide</em> for details.</p>
</dd>
</dl>
</section>
</section>
</section>
</section>
</section>
</section>
<section id="virtual-memory-management">
<span id="id309"></span><h1><span class="section-number">11. </span>Virtual Memory Management<a class="headerlink" href="#virtual-memory-management" title="Permalink to this headline">ï</a></h1>
<section id="introduction-virtual-memory-management">
<span id="id310"></span><h2><span class="section-number">11.1. </span>Introduction<a class="headerlink" href="#introduction-virtual-memory-management" title="Permalink to this headline">ï</a></h2>
<p>The <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__VA.html">Virtual Memory Management APIs</a> provide a way for the application to directly manage the unified virtual address space that CUDA provides to map physical memory to virtual addresses accessible by the GPU. Introduced in CUDA 10.2, these APIs additionally provide a new way to interop with other processes and graphics APIs like OpenGL and Vulkan, as well as provide newer memory attributes that a user can tune to fit their applications.</p>
<p>Historically, memory allocation calls (such as <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>) in the CUDA programming model have returned a memory address that points to the GPU memory. The address thus obtained could be used with any CUDA API or inside a device kernel. However, the memory allocated could not be resized depending on the userâs memory needs. In order to increase an allocationâs size, the user had to explicitly allocate a larger buffer, copy data from the initial allocation, free it and then continue to keep track of the newer allocationâs address. This often leads to lower performance and higher peak memory utilization for applications. Essentially, users had a malloc-like interface for allocating GPU memory, but did not have a corresponding realloc to complement it. The Virtual Memory Management APIs decouple the idea of an address and memory and allow the application to handle them separately. The APIs allow applications to map and unmap memory from a virtual address range as they see fit.</p>
<p>In the case of enabling peer device access to memory allocations by using <code class="docutils literal notranslate"><span class="pre">cudaEnablePeerAccess</span></code>, all past and future user allocations are mapped to the target peer device. This lead to users unwittingly paying runtime cost of mapping all cudaMalloc allocations to peer devices. However, in most situations applications communicate by sharing only a few allocations with another device and not all allocations are required to be mapped to all the devices. With Virtual Memory Management, applications can specifically choose certain allocations to be accessible from target devices.</p>
<p>The CUDA Virtual Memory Management APIs expose fine grained control to the user for managing the GPU memory in applications. It provides APIs that let users:</p>
<ul class="simple">
<li><p>Place memory allocated on different devices into a contiguous VA range.</p></li>
<li><p>Perform interprocess communication for memory sharing using platform-specific mechanisms.</p></li>
<li><p>Opt into newer memory types on the devices that support them.</p></li>
</ul>
<p>In order to allocate memory, the Virtual Memory Management programming model exposes the following functionality:</p>
<ul class="simple">
<li><p>Allocating physical memory.</p></li>
<li><p>Reserving a VA range.</p></li>
<li><p>Mapping allocated memory to the VA range.</p></li>
<li><p>Controlling access rights on the mapped range.</p></li>
</ul>
<p>Note that the suite of APIs described in this section require a system that supports UVA.</p>
</section>
<section id="query-for-support">
<span id="querying-vmm-support"></span><h2><span class="section-number">11.2. </span>Query for Support<a class="headerlink" href="#query-for-support" title="Permalink to this headline">ï</a></h2>
<p>Before attempting to use Virtual Memory Management APIs, applications must ensure that the devices they want to use support CUDA Virtual Memory Management. The following code sample shows querying for Virtual Memory Management support:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsVmm</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsVmm</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deviceSupportsVmm</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `device` supports Virtual Memory Management</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocating-physical-memory">
<h2><span class="section-number">11.3. </span>Allocating Physical Memory<a class="headerlink" href="#allocating-physical-memory" title="Permalink to this headline">ï</a></h2>
<p>The first step in memory allocation using Virtual Memory Management APIs is to create a physical memory chunk that will provide a backing for the allocation. In order to allocate physical memory, applications must use the <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> API. The allocation created by this function does not have any device or host mappings. The function argument <code class="docutils literal notranslate"><span class="pre">CUmemGenericAllocationHandle</span></code> describes the properties of the memory to allocate such as the location of the allocation, if the allocation is going to be shared to another process (or other Graphics APIs), or the physical attributes of the memory to be allocated. Users must ensure the requested allocationâs size must be aligned to appropriate granularity. Information regarding an allocationâs granularity requirements can be queried using <code class="docutils literal notranslate"><span class="pre">cuMemGetAllocationGranularity</span></code>. The following code snippet shows allocating physical memory with <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="nf">allocatePhysicalMemory</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">prop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_TYPE_PINNED</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_DEVICE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemGetAllocationGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">CU_MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Ensure size matches granularity requirements for the allocation</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate physical memory</span>
<span class="w">    </span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The memory allocated by <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> is referenced by the <code class="docutils literal notranslate"><span class="pre">CUmemGenericAllocationHandle</span></code> it returns. This is a departure from the cudaMalloc-style of allocation, which returns a pointer to the GPU memory, which was directly accessible by CUDA kernel executing on the device. The memory allocated cannot be used for any operations other than querying properties using <code class="docutils literal notranslate"><span class="pre">cuMemGetAllocationPropertiesFromHandle</span></code>. In order to make this memory accessible, applications must map this memory into a VA range reserved by <code class="docutils literal notranslate"><span class="pre">cuMemAddressReserve</span></code> and provide suitable access rights to it. Applications must free the allocated memory using the <code class="docutils literal notranslate"><span class="pre">cuMemRelease</span></code> API.</p>
<section id="shareable-memory-allocations">
<span id="shareable-physical-memory"></span><h3><span class="section-number">11.3.1. </span>Shareable Memory Allocations<a class="headerlink" href="#shareable-memory-allocations" title="Permalink to this headline">ï</a></h3>
<p>With <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> users now have the facility to indicate to CUDA, at allocation time, that they have earmarked a particular allocation for Inter process communication and graphics interop purposes. Applications can do this by setting <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::requestedHandleTypes</span></code> to a platform-specific field. On Windows, when <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::requestedHandleTypes</span></code> is set to <code class="docutils literal notranslate"><span class="pre">CU_MEM_HANDLE_TYPE_WIN32</span></code> applications must also specify an LPSECURITYATTRIBUTES attribute in <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::win32HandleMetaData</span></code>. This security attribute defines the scope of which exported allocations may be transferred to other processes.</p>
<p>The CUDA Virtual Memory Management API functions do not support the legacy interprocess communication functions with their memory. Instead, they expose a new mechanism for interprocess communication that uses OS-specific handles. Applications can obtain these OS-specific handles corresponding to the allocations by using <code class="docutils literal notranslate"><span class="pre">cuMemExportToShareableHandle</span></code>. The handles thus obtained can be transferred by using the usual OS native mechanisms for inter process communication. The recipient process should import the allocation by using <code class="docutils literal notranslate"><span class="pre">cuMemImportFromShareableHandle</span></code>.</p>
<p>Users must ensure they query for support of the requested handle type before attempting to export memory allocated with <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>. The following code snippet illustrates query for handle type support in a platform-specific way.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsIpcHandle</span><span class="p">;</span><span class="w"></span>
<span class="cp">#if defined(__linux__)</span>
<span class="w">    </span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsIpcHandle</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsIpcHandle</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">));</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Users should set the <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::requestedHandleTypes</span></code> appropriately as shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(__linux__)</span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">requestedHandleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">requestedHandleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_HANDLE_TYPE_WIN32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">prop</span><span class="p">.</span><span class="n">win32HandleMetaData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// Windows specific LPSECURITYATTRIBUTES attribute.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/NVIDIA/cuda-samples/tree/master/Samples/3_CUDA_Features/memMapIPCDrv/">memMapIpcDrv</a> sample can be used as an example for using IPC with Virtual Memory Management allocations.</p>
</section>
<section id="memory-type">
<span id="physical-memory-type"></span><h3><span class="section-number">11.3.2. </span>Memory Type<a class="headerlink" href="#memory-type" title="Permalink to this headline">ï</a></h3>
<p>Before CUDA 10.2, applications had no user-controlled way of allocating any special type of memory that certain devices may support. With <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>, applications can additionally specify memory type requirements using the <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::allocFlags</span></code> to opt into any specific memory features. Applications must also ensure that the requested memory type is supported on the device of allocation.</p>
<section id="compressible-memory">
<span id="physical-memory-type-compression"></span><h4><span class="section-number">11.3.2.1. </span>Compressible Memory<a class="headerlink" href="#compressible-memory" title="Permalink to this headline">ï</a></h4>
<p>Compressible memory can be used to accelerate accesses to data with unstructured sparsity and other compressible data patterns. Compression can save DRAM bandwidth, L2 read bandwidth and L2 capacity depending on the data being operated on. Applications that want to allocate compressible memory on devices that support Compute Data Compression can do so by setting <code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp::allocFlags::compressionType</span></code> to <code class="docutils literal notranslate"><span class="pre">CU_MEM_ALLOCATION_COMP_GENERIC</span></code>. Users must query if device supports Compute Data Compression by using <code class="docutils literal notranslate"><span class="pre">CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED</span></code>. The following code snippet illustrates querying compressible memory support <code class="docutils literal notranslate"><span class="pre">cuDeviceGetAttribute</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">compressionSupported</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compressionSupported</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>On devices that support Compute Data Compression, users must opt in at allocation time as shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">prop</span><span class="p">.</span><span class="n">allocFlags</span><span class="p">.</span><span class="n">compressionType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_COMP_GENERIC</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Due to various reasons such as limited HW resources, the allocation may not have compression attributes, the user is expected to query back the properties of the allocated memory using <code class="docutils literal notranslate"><span class="pre">cuMemGetAllocationPropertiesFromHandle</span></code> and check for compression attribute.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">allocationProp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="n">cuMemGetAllocationPropertiesFromHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocationProp</span><span class="p">,</span><span class="w"> </span><span class="n">allocationHandle</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">allocationProp</span><span class="p">.</span><span class="n">allocFlags</span><span class="p">.</span><span class="n">compressionType</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_COMP_GENERIC</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Obtained compressible memory allocation</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="reserving-a-virtual-address-range">
<h2><span class="section-number">11.4. </span>Reserving a Virtual Address Range<a class="headerlink" href="#reserving-a-virtual-address-range" title="Permalink to this headline">ï</a></h2>
<p>Since with Virtual Memory Management the notions of address and memory are distinct, applications must carve out an address range that can hold the memory allocations made by <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>. The address range reserved must be at least as large as the sum of the sizes of all the physical memory allocations the user plans to place in them.</p>
<p>Applications can reserve a virtual address range by passing appropriate parameters to <code class="docutils literal notranslate"><span class="pre">cuMemAddressReserve</span></code>. The address range obtained will not have any device or host physical memory associated with it. The reserved virtual address range can be mapped to memory chunks belonging to any device in the system, thus providing the application a continuous VA range backed and mapped by memory belonging to different devices. Applications are expected to return the virtual address range back to CUDA using <code class="docutils literal notranslate"><span class="pre">cuMemAddressFree</span></code>. Users must ensure that the entire VA range is unmapped before calling <code class="docutils literal notranslate"><span class="pre">cuMemAddressFree</span></code>. These functions are conceptually similar to mmap/munmap (on Linux) or VirtualAlloc/VirtualFree (on Windows) functions. The following code snippet illustrates the usage for the function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="c1">// `ptr` holds the returned start of virtual address range reserved.</span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuMemAddressReserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// alignment = 0 for default alignment</span>
</pre></div>
</div>
</section>
<section id="virtual-aliasing-support">
<span id="id311"></span><h2><span class="section-number">11.5. </span>Virtual Aliasing Support<a class="headerlink" href="#virtual-aliasing-support" title="Permalink to this headline">ï</a></h2>
<p>The Virtual Memory Management APIs provide a way to create multiple virtual memory mappings or âproxiesâ to the same allocation using multiple calls to <code class="docutils literal notranslate"><span class="pre">cuMemMap</span></code> with different virtual addresses, so-called virtual aliasing. Unless otherwise noted in the PTX ISA, writes to one proxy of the allocation are considered inconsistent and incoherent with any other proxy of the same memory until the writing device operation (grid launch, memcpy, memset, and so on) completes. Grids present on the GPU prior to a writing device operation but reading after the writing device operation completes are also considered to have inconsistent and incoherent proxies.</p>
<p>For example, the following snippet is considered undefined, assuming device pointers A and B are virtual aliases of the same memory allocation:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">);</span><span class="w">    </span><span class="c1">// Undefined behavior!  *B can take on either</span>
<span class="c1">// the previous value or some value in-between.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following is defined behavior, assuming these two kernels are ordered monotonically (by streams or events).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo1</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo2</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">);</span><span class="w">    </span><span class="c1">// *B == *A == 0x1 assuming foo2 waits for foo1</span>
<span class="c1">// to complete before launching</span>
<span class="p">}</span><span class="w"></span>

<span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="p">);</span><span class="w">    </span><span class="c1">// Aliases are allowed at</span>
<span class="c1">// operation boundaries</span>
<span class="n">foo1</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">stream1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w">                  </span><span class="c1">// allowing foo1 to access A.</span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
<span class="n">foo2</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">stream2</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">B</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream3</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMemcpyAsync</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">stream3</span><span class="p">);</span><span class="w">  </span><span class="c1">// Both launches of foo2 and</span>
<span class="w">                                            </span><span class="c1">// cudaMemcpy (which both</span>
<span class="w">                                            </span><span class="c1">// read) wait for foo1 (which writes)</span>
<span class="w">                                            </span><span class="c1">// to complete before proceeding</span>
</pre></div>
</div>
<p>If accessing same allocation through different âproxiesâ is required in the same kernel a <code class="docutils literal notranslate"><span class="pre">fence.proxy.alias</span></code> can be used between the two accesses. The above example can thus be made legal with inline PTX assembly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;fence.proxy.alias;&quot;</span><span class="w"> </span><span class="o">:::</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">);</span><span class="w">    </span><span class="c1">// *B == *A == 0x1</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="mapping-memory">
<h2><span class="section-number">11.6. </span>Mapping Memory<a class="headerlink" href="#mapping-memory" title="Permalink to this headline">ï</a></h2>
<p>The allocated physical memory and the carved out virtual address space from the previous two sections represent the memory and address distinction introduced by the Virtual Memory Management APIs. For the allocated memory to be useable, the user must first place the memory in the address space. The address range obtained from <code class="docutils literal notranslate"><span class="pre">cuMemAddressReserve</span></code> and the physical allocation obtained from <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> or <code class="docutils literal notranslate"><span class="pre">cuMemImportFromShareableHandle</span></code> must be associated with each other by using <code class="docutils literal notranslate"><span class="pre">cuMemMap</span></code>.</p>
<p>Users can associate allocations from multiple devices to reside in contiguous virtual address ranges as long as they have carved out enough address space. In order to decouple the physical allocation and the address range, users must unmap the address of the mapping by using <code class="docutils literal notranslate"><span class="pre">cuMemUnmap</span></code>. Users can map and unmap memory to the same address range as many times as they want, as long as they ensure that they donât attempt to create mappings on VA range reservations that are already mapped. The following code snippet illustrates the usage for the function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="c1">// `ptr`: address in the address range previously reserved by cuMemAddressReserve.</span>
<span class="c1">// `allocHandle`: CUmemGenericAllocationHandle obtained by a previous call to cuMemCreate.</span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuMemMap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="controlling-access-rights">
<h2><span class="section-number">11.7. </span>Controlling Access Rights<a class="headerlink" href="#controlling-access-rights" title="Permalink to this headline">ï</a></h2>
<p>The Virtual Memory Management APIs enable applications to explicitly protect their VA ranges with access control mechanisms. Mapping the allocation to a region of the address range using <code class="docutils literal notranslate"><span class="pre">cuMemMap</span></code> does not make the address accessible, and would result in a program crash if accessed by a CUDA kernel. Users must specifically select access control using the <code class="docutils literal notranslate"><span class="pre">cuMemSetAccess</span></code> function, which allows or restricts access for specific devices to a mapped address range. The following code snippet illustrates the usage for the function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">setAccessOnDevice</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CUmemAccessDesc</span><span class="w"> </span><span class="n">accessDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_DEVICE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ACCESS_FLAGS_PROT_READWRITE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Make the address accessible</span>
<span class="w">    </span><span class="n">cuMemSetAccess</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">accessDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The access control mechanism exposed with Virtual Memory Management allows users to be explicit about which allocations they want to share with other peer devices on the system. As specified earlier, <code class="docutils literal notranslate"><span class="pre">cudaEnablePeerAccess</span></code> forces all prior and future cudaMallocâd allocations to be mapped to the target peer device. This can be convenient in many cases as user doesnât have to worry about tracking the mapping state of every allocation to every device in the system. But for users concerned with performance of their applications this approach <a class="reference external" href="https://devblogs.nvidia.com/introducing-low-level-gpu-virtual-memory-management/">has performance implications</a>. With access control at allocation granularity Virtual Memory Management exposes a mechanism to have peer mappings with minimal overhead.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">vectorAddMMAP</span></code> sample can be used as an example for using the Virtual Memory Management APIs.</p>
</section>
<section id="fabric-memory">
<span id="fabric-mem"></span><h2><span class="section-number">11.8. </span>Fabric Memory<a class="headerlink" href="#fabric-memory" title="Permalink to this headline">ï</a></h2>
<p>CUDA 12.4 introduced a new VMM allocation handle type <code class="docutils literal notranslate"><span class="pre">CU_MEM_HANDLE_TYPE_FABRIC</span></code>. On supported platforms and provided the NVIDIA IMEX daemon
is running this allocation handle type enables sharing allocations not only intra node with any communication mechanism, e.g. MPI, but also inter
node. This allows GPUs in a Multi Node NVLINK System to map the memory of all other GPUs part of the same NVLINK fabric even if they are in
different nodes greatly increasing the scale of multi-GPU Programming with NVLINK.</p>
<section id="querying-fabric-mem-support">
<span id="id312"></span><h3><span class="section-number">11.8.1. </span>Query for Support<a class="headerlink" href="#querying-fabric-mem-support" title="Permalink to this headline">ï</a></h3>
<p>Before attempting to use Fabric Memory, applications must ensure that the devices they want to use support Fabric Memory. The following code
sample shows querying for Fabric Memory support:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsFabricMem</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsFabricMem</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deviceSupportsFabricMem</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `device` supports Fabric Memory</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Aside from using <code class="docutils literal notranslate"><span class="pre">CU_MEM_HANDLE_TYPE_FABRIC</span></code> as handle type and not requiring OS native mechanisms for inter process communication to exchange
sharable handles there is no difference in using Fabric Memory compared to other allocation handle types.</p>
</section>
</section>
<section id="multicast-support">
<span id="multicast-obj-mem"></span><h2><span class="section-number">11.9. </span>Multicast Support<a class="headerlink" href="#multicast-support" title="Permalink to this headline">ï</a></h2>
<p>The <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MULTICAST.html#group__CUDA__MULTICAST/">Multicast Object Management APIs</a>
provide a way for the application to create Multicast Objects and in combination with the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__VA.html/">Virtual Memory Management APIs</a>
described above allow applications to leverage NVLINK SHARP on supported NVLINK connected GPUs if they are connected with NVSWITCH. NVLINK SHARP
allows CUDA applications to leverage in fabric computing to accelerate operations like broadcast and reductions between GPUs connected with
NVSWITCH. For this to work multiple NVLINK connected GPUs form a Multicast Team and each GPU from the team backs up a Multicast Object with
physical memory. So a Multicast Team of N GPUs has N physical replicas, each local to one participating GPU, of a Multicast Object.
The <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-multimem-ld-reduce-multimem-st-multimem-red/">multimem PTX instructions</a>
using mappings of Multicast Objects work with all replicas of the Multicast Object.</p>
<p>To work with Multicast Objects an application needs to</p>
<ul class="simple">
<li><p>Query Multicast Support</p></li>
<li><p>Create a Multicast Handle with <code class="docutils literal notranslate"><span class="pre">cuMulticastCreate</span></code>.</p></li>
<li><p>Share the Multicast Handle with all processes that control a GPU which should participate in a Multicast Team. This works with <code class="docutils literal notranslate"><span class="pre">cuMemExportToShareableHandle</span></code> as described above.</p></li>
<li><p>Add all GPUs that should participate in the Multicast Team with <code class="docutils literal notranslate"><span class="pre">cuMulticastAddDevice</span></code>.</p></li>
<li><p>For each participating GPU bind physical memory allocated with <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> as described above to the Multicast Handle. All devices need to be added to the Multicast Team before binding memory on any device.</p></li>
<li><p>Reserve an address range, map the Multicast Handle and set Access Rights as described above for regular Unicast mappings. Unicast and Multicast mappings to the same physical memory are possible. See the <a class="reference internal" href="#virtual-aliasing-support"><span class="std std-ref">Virtual Aliasing Support</span></a> section above how to ensure consistency between multiple mappings to the same physical memory.</p></li>
<li><p>Use the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-multimem-ld-reduce-multimem-st-multimem-red/">multimem PTX instructions</a> with the multicast mappings.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">multi_node_p2p</span></code> example in the <a class="reference external" href="https://github.com/NVIDIA/multi-gpu-programming-models/">Multi GPU Programming Models</a> GitHub
repository contains a complete example using Fabric Memory including Multicast Objects to leverage NVLINK SHARP. Please note that this example is
for developers of libraries like NCCL or NVSHMEM. It shows how higher-level programming models like NVSHMEM work internally within a (multinode)
NVLINK domain. Application developers generally should use the higher-level MPI, NCCL, or NVSHMEM interfaces instead of this API.</p>
<section id="querying-multicast-obj-mem-support">
<span id="id313"></span><h3><span class="section-number">11.9.1. </span>Query for Support<a class="headerlink" href="#querying-multicast-obj-mem-support" title="Permalink to this headline">ï</a></h3>
<p>Before attempting to use Multicast Objects, applications must ensure that the devices they want to use support them. The following code sample
shows querying for Fabric Memory support:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsMultiCast</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsMultiCast</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deviceSupportsMultiCast</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `device` supports Multicast Objects</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocating-multicast-objects">
<span id="alloc-multicast-obj"></span><h3><span class="section-number">11.9.2. </span>Allocating Multicast Objects<a class="headerlink" href="#allocating-multicast-objects" title="Permalink to this headline">ï</a></h3>
<p>Multicast Objects can be created with <code class="docutils literal notranslate"><span class="pre">cuMulticastCreate</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="nf">createMCHandle</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">numDevices</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">mcProp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">mcProp</span><span class="p">.</span><span class="n">numDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numDevices</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">mcProp</span><span class="p">.</span><span class="n">handleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_HANDLE_TYPE_FABRIC</span><span class="p">;</span><span class="w"> </span><span class="c1">// or on single node CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMulticastGetGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mcProp</span><span class="p">,</span><span class="w"> </span><span class="n">CU_MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Ensure size matches granularity requirements for the allocation</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">mcProp</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">padded_size</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create Multicast Object this has no devices and no physical memory associated yet</span>
<span class="w">    </span><span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">mcHandle</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMulticastCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mcProp</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mcHandle</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="add-devices-to-multicast-objects">
<span id="add-devices-to-multicast-obj"></span><h3><span class="section-number">11.9.3. </span>Add Devices to Multicast Objects<a class="headerlink" href="#add-devices-to-multicast-objects" title="Permalink to this headline">ï</a></h3>
<p>Devices can be added to a Multicast Team with <code class="docutils literal notranslate"><span class="pre">cuMulticastAddDevice</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cuMulticastAddDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mcHandle</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This step needs to be completed on all processes controlling devices that should participate in a Multicast Team before memory on any device is
bound to the Multicast Object.</p>
</section>
<section id="bind-memory-to-multicast-objects">
<span id="bind-mem-to-multicast-obj"></span><h3><span class="section-number">11.9.4. </span>Bind Memory to Multicast Objects<a class="headerlink" href="#bind-memory-to-multicast-objects" title="Permalink to this headline">ï</a></h3>
<p>After a Multicast Object has been created and all participating devices have been added to the Multicast Object it needs to be backed with
physical memory allocated with <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> for each device:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cuMulticastBindMem</span><span class="p">(</span><span class="n">mcHandle</span><span class="p">,</span><span class="w"> </span><span class="n">mcOffset</span><span class="p">,</span><span class="w"> </span><span class="n">memHandle</span><span class="p">,</span><span class="w"> </span><span class="n">memOffset</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="cm">/*flags*/</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="use-multicast-mappings">
<span id="id314"></span><h3><span class="section-number">11.9.5. </span>Use Multicast Mappings<a class="headerlink" href="#use-multicast-mappings" title="Permalink to this headline">ï</a></h3>
<p>To use Multicast Mappings in CUDA C++ it is required to use the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-multimem-ld-reduce-multimem-st-multimem-red/">multimem PTX instructions</a>
with Inline PTX Assembly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">all_reduce_norm_barrier_kernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">l2_norm</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">partial_l2_norm_mc</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arrival_counter_uc</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arrival_counter_mc</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">expected_count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">gridDim</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">l2_norm_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="cp">#if __CUDA_ARCH__ &gt;= 900</span>

<span class="w">    </span><span class="c1">// atomic reduction to all replicas</span>
<span class="w">    </span><span class="c1">// this can be conceptually thought of as __threadfence_system(); atomicAdd_system(arrival_counter_mc, 1);</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;multimem.red.release.sys.global.add.u32 [%0], %1;&quot;</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">(</span><span class="n">arrival_counter_mc</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;n&quot;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Need a fence between Multicast (mc) and Unicast (uc) access to the same memory `arrival_counter_uc` and `arrival_counter_mc`:</span>
<span class="w">    </span><span class="c1">// - fence.proxy instructions establish an ordering between memory accesses that may happen through different proxies</span>
<span class="w">    </span><span class="c1">// - Value .alias of the .proxykind qualifier refers to memory accesses performed using virtually aliased addresses to the same memory location.</span>
<span class="w">    </span><span class="c1">// from https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-membar</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;fence.proxy.alias;&quot;</span><span class="w"> </span><span class="o">:::</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// spin wait with acquire ordering on UC mapping till all peers have arrived in this iteration</span>
<span class="w">    </span><span class="c1">// Note: all ranks need to reach another barrier after this kernel, such that it is not possible for the barrier to be unblocked by an</span>
<span class="w">    </span><span class="c1">// arrival of a rank for the next iteration if some other rank is slow.</span>
<span class="w">    </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_system</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ac</span><span class="p">(</span><span class="n">arrival_counter_uc</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">expected_count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ac</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Atomic load reduction from all replicas. It does not provide ordering so it can be relaxed.</span>
<span class="w">    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;multimem.ld_reduce.relaxed.sys.global.add.f32 %0, [%1];&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=f&quot;</span><span class="p">(</span><span class="n">l2_norm_sum</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">(</span><span class="n">partial_l2_norm_mc</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>

<span class="cp">#else</span>
<span class="w">    </span><span class="cp">#error &quot;ERROR: multimem instructions require compute capability 9.0 or larger.&quot;</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="o">*</span><span class="n">l2_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">l2_norm_sum</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="stream-ordered-memory-allocator">
<span id="id315"></span><h1><span class="section-number">12. </span>Stream Ordered Memory Allocator<a class="headerlink" href="#stream-ordered-memory-allocator" title="Permalink to this headline">ï</a></h1>
<section id="stream-ordered-memory-allocator-intro">
<span id="id316"></span><h2><span class="section-number">12.1. </span>Introduction<a class="headerlink" href="#stream-ordered-memory-allocator-intro" title="Permalink to this headline">ï</a></h2>
<p>Managing memory allocations using <code class="docutils literal notranslate"><span class="pre">cudaMalloc</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFree</span></code> causes GPU to synchronize across all executing CUDA streams. The Stream Order Memory Allocator enables applications to order memory allocation and deallocation with other work launched into a CUDA stream such as kernel launches and asynchronous copies. This improves application memory use by taking advantage of stream-ordering semantics to reuse memory allocations. The allocator also allows applications to control the allocatorâs memory caching behavior. When set up with an appropriate release threshold, the caching behavior allows the allocator to avoid expensive calls into the OS when the application indicates it is willing to accept a bigger memory footprint. The allocator also supports the easy and secure sharing of allocations between processes.</p>
<p>For many applications, the Stream Ordered Memory Allocator reduces the need for custom memory management abstractions, and makes it easier to create high-performance custom memory management for applications that need it. For applications and libraries that already have custom memory allocators, adopting the Stream Ordered Memory Allocator enables multiple libraries to share a common pool of memory managed by the driver, thus reducing excess memory consumption. Additionally, the driver can perform optimizations based on its awareness of the allocator and other stream management APIs. Finally, Nsight Compute and the Next-Gen CUDA debugger is aware of the allocator as part of their CUDA 11.3 toolkit support.</p>
</section>
<section id="stream-ordered-querying-memory-support">
<span id="id317"></span><h2><span class="section-number">12.2. </span>Query for Support<a class="headerlink" href="#stream-ordered-querying-memory-support" title="Permalink to this headline">ï</a></h2>
<p>The user can determine whether or not a device supports the stream ordered memory allocator by calling <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetAttribute()</span></code> with the device attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrMemoryPoolsSupported</span></code>.</p>
<p>Starting with CUDA 11.3, IPC memory pool support can be queried with the <code class="docutils literal notranslate"><span class="pre">cudaDevAttrMemoryPoolSupportedHandleTypes</span></code> device attribute. Previous drivers will return <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code> as those drivers are unaware of the attribute enum.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">driverVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsMemoryPools</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">poolSupportedHandleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverVersion</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">driverVersion</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">11020</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsMemoryPools</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">cudaDevAttrMemoryPoolsSupported</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deviceSupportsMemoryPools</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `device` supports the Stream Ordered Memory Allocator</span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">driverVersion</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">11030</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poolSupportedHandleTypes</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">cudaDevAttrMemoryPoolSupportedHandleTypes</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">poolSupportedHandleTypes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cudaMemHandleTypePosixFileDescriptor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Pools on the specified device can be created with posix file descriptor-based IPC</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Performing the driver version check before the query avoids hitting a <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidValue</span></code> error on drivers where the attribute was not yet defined. One can use <code class="docutils literal notranslate"><span class="pre">cudaGetLastError</span></code> to clear the error instead of avoiding it.</p>
</section>
<section id="api-fundamentals-cudamallocasync-and-cudafreeasync">
<span id="stream-ordered-api-fundamentals"></span><h2><span class="section-number">12.3. </span>API Fundamentals (cudaMallocAsync and cudaFreeAsync)<a class="headerlink" href="#api-fundamentals-cudamallocasync-and-cudafreeasync" title="Permalink to this headline">ï</a></h2>
<p>The APIs <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code> form the core of the allocator. <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> returns an allocation and <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code> frees an allocation. Both APIs accept stream arguments to define when the allocation will become and stop being available for use. The pointer value returned by <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> is determined synchronously and is available for constructing future work. It is important to note that <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> ignores the current device/context when determining where the allocation will reside. Instead, <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> determines the resident device based on the specified memory pool or the supplied stream. The simplest use pattern is when the memory is allocated, used, and freed back into the same stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="p">);</span><span class="w"></span>
<span class="c1">// do work using the allocation</span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="c1">// An asynchronous free can be specified without synchronizing the cpu and GPU</span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When using an allocation in a stream other than the allocating stream, the user must guarantee that the access will happen after the allocation operation, otherwise the behavior is undefined. The user may make this guarantee either by synchronizing the allocating stream, or by using CUDA events to synchronize the producing and consuming streams.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaFreeAsync()</span></code> inserts a free operation into the stream. The user must guarantee that the free operation happens after the allocation operation and any use of the allocation. Also, any use of the allocation after the free operation starts results in undefined behavior. Events and/or stream synchronizing operations should be used to guarantee any access to the allocation on other streams is complete before the freeing stream begins the free operation.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event1</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="c1">//stream2 must wait for the allocation to be ready before accessing</span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span><span class="n">event1</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream2</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event2</span><span class="p">,</span><span class="w"> </span><span class="n">stream2</span><span class="p">);</span><span class="w"></span>
<span class="c1">// stream3 must wait for stream2 to finish accessing the allocation before</span>
<span class="c1">// freeing the allocation</span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream3</span><span class="p">,</span><span class="w"> </span><span class="n">event2</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">stream3</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The user can free allocations allocated with <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> with <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync()</span></code>. The user must make the same guarantees about accesses being complete before the free operation begins.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The user can free memory allocated with <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> with <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>. When freeing such allocations through the <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code> API, the driver assumes that all accesses to the allocation are complete and performs no further synchronization. The user can use <code class="docutils literal notranslate"><span class="pre">cudaStreamQuery</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaEventQuery</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize</span></code> to guarantee that the appropriate asynchronous work is complete and that the GPU will not try to access the allocation.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="c1">// synchronize is needed to avoid prematurely freeing the memory</span>
<span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-pools-and-the-cudamempool-t">
<span id="stream-ordered-memory-pools"></span><h2><span class="section-number">12.4. </span>Memory Pools and the cudaMemPool_t<a class="headerlink" href="#memory-pools-and-the-cudamempool-t" title="Permalink to this headline">ï</a></h2>
<p>Memory pools encapsulate virtual address and physical memory resources that are allocated and managed according to the pools attributes and properties. The primary aspect of a memory pool is the kind and location of memory it manages.</p>
<p>All calls to <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> use the resources of a memory pool. In the absence of a specified memory pool, <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> uses the current memory pool of the supplied streamâs device. The current memory pool for a device may be set with <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetMempool</span></code> and queried with <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetMempool</span></code>. By default (in the absence of a <code class="docutils literal notranslate"><span class="pre">cudaDeviceSetMempool</span></code> call), the current memory pool is the default memory pool of a device. The API <code class="docutils literal notranslate"><span class="pre">cudaMallocFromPoolAsync</span></code> and <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1ga31efcffc48981621feddd98d71a0feb">c++ overloads of cudaMallocAsync</a> allow a user to specify the pool to be used for an allocation without setting it as the current pool. The APIs <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetDefaultMempool</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code> give users handles to memory pools.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The mempool current to a device will be local to that device. So allocating without specifying a memory pool will always yield an allocation local to the streamâs device.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAttribute</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolGetAttribute</span></code> control the attributes of the memory pools.</p>
</div>
</section>
<section id="default-implicit-pools">
<span id="stream-ordered-default-implicit"></span><h2><span class="section-number">12.5. </span>Default/Implicit Pools<a class="headerlink" href="#default-implicit-pools" title="Permalink to this headline">ï</a></h2>
<p>The default memory pool of a device may be retrieved with the <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetDefaultMempool</span></code> API. Allocations from the default memory pool of a device are non-migratable device allocation located on that device. These allocations will always be accessible from that device. The accessibility of the default memory pool may be modified with <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code> and queried by <code class="docutils literal notranslate"><span class="pre">cudaMemPoolGetAccess</span></code>. Since the default pools do not need to be explicitly created, they are sometimes referred to as implicit pools. The default memory pool of a device does not support IPC.</p>
</section>
<section id="explicit-pools">
<span id="stream-ordered-explicit-pools"></span><h2><span class="section-number">12.6. </span>Explicit Pools<a class="headerlink" href="#explicit-pools" title="Permalink to this headline">ï</a></h2>
<p>The API <code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code> creates an explicit pool. This allows applications to request properties for their allocation beyond what is provided by the default/implict pools. These include properties such as IPC capability, maximum pool size, allocations resident on a specific CPU NUMA node on supported platforms etc.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a pool similar to the implicit pool on device 0</span>
<span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolProps</span><span class="w"> </span><span class="n">poolProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">allocType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAllocationTypePinned</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeDevice</span><span class="p">;</span><span class="w"></span>

<span class="n">cudaMemPoolCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">poolProps</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>The following code snippet illustrates an example of creating an IPC capable memory pool on a valid CPU NUMA node.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a pool resident on a CPU NUMA node that is capable of IPC sharing (via a file descriptor).</span>
<span class="kt">int</span><span class="w"> </span><span class="n">cpu_numa_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolProps</span><span class="w"> </span><span class="n">poolProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">allocType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAllocationTypePinned</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_numa_id</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeHostNuma</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">handleType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemHandleTypePosixFileDescriptor</span><span class="p">;</span><span class="w"></span>

<span class="n">cudaMemPoolCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipcMemPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">poolProps</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="physical-page-caching-behavior">
<span id="stream-ordered-physical-page-caching-behavior"></span><h2><span class="section-number">12.7. </span>Physical Page Caching Behavior<a class="headerlink" href="#physical-page-caching-behavior" title="Permalink to this headline">ï</a></h2>
<p>By default, the allocator tries to minimize the physical memory owned by a pool. To minimize the OS calls to allocate and free physical memory, applications must configure a memory footprint for each pool. Applications can do this with the release threshold attribute (<code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReleaseThreshold</span></code>).</p>
<p>The release threshold is the amount of memory in bytes a pool should hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or device synchronize. Setting the release threshold to UINT64_MAX will prevent the driver from attempting to shrink the pool after every synchronization.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Cuuint64_t</span><span class="w"> </span><span class="n">setVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UINT64_MAX</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolSetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrReleaseThreshold</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">setVal</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Applications that set <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReleaseThreshold</span></code> high enough to effectively disable memory pool shrinking may wish to explicitly shrink a memory poolâs memory footprint. <code class="docutils literal notranslate"><span class="pre">cudaMemPoolTrimTo</span></code> allows such applications to do so. When trimming a memory poolâs footprint, the <code class="docutils literal notranslate"><span class="pre">minBytesToKeep</span></code> parameter allows an application to hold onto an amount of memory it expects to need in a subsequent phase of execution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Cuuint64_t</span><span class="w"> </span><span class="n">setVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UINT64_MAX</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolSetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrReleaseThreshold</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">setVal</span><span class="p">);</span><span class="w"></span>

<span class="c1">// application phase needing a lot of memory from the stream ordered allocator</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptrs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptrs</span><span class="p">,...);</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptrs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Process does not need as much memory for the next phase.</span>
<span class="c1">// Synchronize so that the trim operation will know that the allocations are no</span>
<span class="c1">// longer in use.</span>
<span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMemPoolTrimTo</span><span class="p">(</span><span class="n">mempool</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Some other process/allocation mechanism can now use the physical memory</span>
<span class="c1">// released by the trimming operation.</span>
</pre></div>
</div>
</section>
<section id="resource-usage-statistics">
<span id="stream-ordered-resource-usage-statisitics"></span><h2><span class="section-number">12.8. </span>Resource Usage Statistics<a class="headerlink" href="#resource-usage-statistics" title="Permalink to this headline">ï</a></h2>
<p>In CUDA 11.3, the pool attributes <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReservedMemCurrent</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReservedMemHigh</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrUsedMemCurrent</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrUsedMemHigh</span></code> were added to query the memory usage of a pool.</p>
<p>Querying the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReservedMemCurrent</span></code> attribute of a pool reports the current total physical GPU memory consumed by the pool. Querying the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrUsedMemCurrent</span></code> of a pool returns the total size of all of the memory allocated from the pool and not available for reuse.</p>
<p>The<code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttr*MemHigh</span></code> attributes are watermarks recording the max value achieved by the respective <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttr*MemCurrent</span></code> attribute since last reset. They can be reset to the current value by using the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAttribute</span></code> API.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// sample helper functions for getting the usage statistics in bulk</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">usageStatistics</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cuuint64_t</span><span class="w"> </span><span class="n">reserved</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuuint64_t</span><span class="w"> </span><span class="n">reservedHigh</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuuint64_t</span><span class="w"> </span><span class="n">used</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuuint64_t</span><span class="w"> </span><span class="n">usedHigh</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">getUsageStatistics</span><span class="p">(</span><span class="n">cudaMemoryPool_t</span><span class="w"> </span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">usageStatistics</span><span class="w"> </span><span class="o">*</span><span class="n">statistics</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolGetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrReservedMemCurrent</span><span class="p">,</span><span class="w"> </span><span class="n">statistics</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolGetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrReservedMemHigh</span><span class="p">,</span><span class="w"> </span><span class="n">statistics</span><span class="o">-&gt;</span><span class="n">reservedHigh</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolGetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrUsedMemCurrent</span><span class="p">,</span><span class="w"> </span><span class="n">statistics</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolGetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrUsedMemHigh</span><span class="p">,</span><span class="w"> </span><span class="n">statistics</span><span class="o">-&gt;</span><span class="n">usedHigh</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="c1">// resetting the watermarks will make them take on the current value.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">resetStatistics</span><span class="p">(</span><span class="n">cudaMemoryPool_t</span><span class="w"> </span><span class="n">memPool</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cuuint64_t</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolSetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrReservedMemHigh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemPoolSetAttribute</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemPoolAttrUsedMemHigh</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="memory-reuse-policies">
<span id="stream-ordered-memory-reuse-policies"></span><h2><span class="section-number">12.9. </span>Memory Reuse Policies<a class="headerlink" href="#memory-reuse-policies" title="Permalink to this headline">ï</a></h2>
<p>In order to service an allocation request, the driver attempts to reuse memory that was previously freed via <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync()</span></code> before attempting to allocate more memory from the OS. For example, memory freed in a stream can immediately be reused for a subsequent allocation request in the same stream. Similarly, when a stream is synchronized with the CPU, the memory that was previously freed in that stream becomes available for reuse for an allocation in any stream.</p>
<p>The stream ordered allocator has a few controllable allocation policies. The pool attributes <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseFollowEventDependencies</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseAllowOpportunistic</span></code>, and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseAllowInternalDependencies</span></code> control these policies. Upgrading to a newer CUDA driver may change, enhance, augment and/or reorder the reuse policies.</p>
<section id="cudamempoolreusefolloweventdependencies">
<span id="stream-ordered-mempoolreusefollow"></span><h3><span class="section-number">12.9.1. </span>cudaMemPoolReuseFollowEventDependencies<a class="headerlink" href="#cudamempoolreusefolloweventdependencies" title="Permalink to this headline">ï</a></h3>
<p>Before allocating more physical GPU memory, the allocator examines dependency information established by CUDA events and tries to allocate from memory freed in another stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">originalStream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>

<span class="c1">// waiting on the event that captures the free in another stream</span>
<span class="c1">// allows the allocator to reuse the memory to satisfy</span>
<span class="c1">// a new allocation request in the other stream when</span>
<span class="c1">// cudaMemPoolReuseFollowEventDependencies is enabled.</span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">otherStream</span><span class="p">,</span><span class="w"> </span><span class="n">event</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr2</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">otherStream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="cudamempoolreuseallowopportunistic">
<span id="stream-ordered-mempoolreuseallowopportunistic"></span><h3><span class="section-number">12.9.2. </span>cudaMemPoolReuseAllowOpportunistic<a class="headerlink" href="#cudamempoolreuseallowopportunistic" title="Permalink to this headline">ï</a></h3>
<p>According to the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseAllowOpportunistic</span></code> policy, the allocator examines freed allocations to see if the freeâs stream order semantic has been met (such as the stream has passed the point of execution indicated by the free). When this is disabled, the allocator will still reuse memory made available when a stream is synchronized with the CPU. Disabling this policy does not stop the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseFollowEventDependencies</span></code> from applying.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">originalStream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>


<span class="c1">// after some time, the kernel finishes running</span>
<span class="n">wait</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w"></span>

<span class="c1">// When cudaMemPoolReuseAllowOpportunistic is enabled this allocation request</span>
<span class="c1">// can be fulfilled with the prior allocation based on the progress of originalStream.</span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr2</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">otherStream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="cudamempoolreuseallowinternaldependencies">
<span id="stream-ordered-mempoolreuseallowinternal"></span><h3><span class="section-number">12.9.3. </span>cudaMemPoolReuseAllowInternalDependencies<a class="headerlink" href="#cudamempoolreuseallowinternaldependencies" title="Permalink to this headline">ï</a></h3>
<p>Failing to allocate and map more physical memory from the OS, the driver will look for memory whose availability depends on another streamâs pending progress. If such memory is found, the driver will insert the required dependency into the allocating stream and reuse the memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">originalStream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">originalStream</span><span class="p">);</span><span class="w"></span>

<span class="c1">// When cudaMemPoolReuseAllowInternalDependencies is enabled</span>
<span class="c1">// and the driver fails to allocate more physical memory, the driver may</span>
<span class="c1">// effectively perform a cudaStreamWaitEvent in the allocating stream</span>
<span class="c1">// to make sure that future work in âotherStreamâ happens after the work</span>
<span class="c1">// in the original stream that would be allowed to access the original allocation.</span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr2</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">otherStream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="disabling-reuse-policies">
<span id="stream-ordered-disabling-reuse-policies"></span><h3><span class="section-number">12.9.4. </span>Disabling Reuse Policies<a class="headerlink" href="#disabling-reuse-policies" title="Permalink to this headline">ï</a></h3>
<p>While the controllable reuse policies improve memory reuse, users may want to disable them. Allowing opportunistic reuse (such as <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseAllowOpportunistic</span></code>) introduces run to run variance in allocation patterns based on the interleaving of CPU and GPU execution. Internal dependency insertion (such as <code class="docutils literal notranslate"><span class="pre">cudaMemPoolReuseAllowInternalDependencies</span></code>) can serialize work in unexpected and potentially non-deterministic ways when the user would rather explicitly synchronize an event or stream on allocation failure.</p>
</section>
</section>
<section id="device-accessibility-for-multi-gpu-support">
<span id="stream-ordered-deviceaccessibility"></span><h2><span class="section-number">12.10. </span>Device Accessibility for Multi-GPU Support<a class="headerlink" href="#device-accessibility-for-multi-gpu-support" title="Permalink to this headline">ï</a></h2>
<p>Just like allocation accessibility controlled through the virtual memory management APIs, memory pool allocation accessibility does not follow <code class="docutils literal notranslate"><span class="pre">cudaDeviceEnablePeerAccess</span></code> or <code class="docutils literal notranslate"><span class="pre">cuCtxEnablePeerAccess</span></code>. Instead, the API <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code> modifies what devices can access allocations from a pool. By default, allocations are accessible from the device where the allocations are located. This access cannot be revoked. To enable access from other devices, the accessing device must be peer capable with the memory poolâs device; check with <code class="docutils literal notranslate"><span class="pre">cudaDeviceCanAccessPeer</span></code>. If the peer capability is not checked, the set access may fail with <code class="docutils literal notranslate"><span class="pre">cudaErrorInvalidDevice</span></code>. If no allocations had been made from the pool, the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code> call may succeed even when the devices are not peer capable; in this case, the next allocation from the pool will fail.</p>
<p>It is worth noting that <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code> affects all allocations from the memory pool, not just future ones. Also the accessibility reported by <code class="docutils literal notranslate"><span class="pre">cudaMemPoolGetAccess</span></code> applies to all allocations from the pool, not just future ones. It is recommended that the accessibility settings of a pool for a given GPU not be changed frequently; once a pool is made accessible from a given GPU, it should remain accessible from that GPU for the lifetime of the pool.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// snippet showing usage of cudaMemPoolSetAccess:</span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="nf">setAccessOnDevice</span><span class="p">(</span><span class="n">cudaMemPool_t</span><span class="w"> </span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">residentDevice</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="kt">int</span><span class="w"> </span><span class="n">accessingDevice</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMemAccessDesc</span><span class="w"> </span><span class="n">accessDesc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accessingDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">accessDesc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAccessFlagsProtReadWrite</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">canAccess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaDeviceCanAccessPeer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">canAccess</span><span class="p">,</span><span class="w"> </span><span class="n">accessingDevice</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="n">residentDevice</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">canAccess</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cudaErrorPeerAccessUnsupported</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Make the address accessible</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cudaMemPoolSetAccess</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">accessDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="ipc-memory-pools">
<span id="stream-ordered-ipc-memory-pools"></span><h2><span class="section-number">12.11. </span>IPC Memory Pools<a class="headerlink" href="#ipc-memory-pools" title="Permalink to this headline">ï</a></h2>
<p>IPC capable memory pools allow easy, efficient and secure sharing of GPU memory between processes. CUDAâs IPC memory pools provide the same security benefits as CUDAâs virtual memory management APIs.</p>
<p>There are two phases to sharing memory between processes with memory pools. The processes first need to share access to the pool, then share specific allocations from that pool. The first phase establishes and enforces security. The second phase coordinates what virtual addresses are used in each process and when mappings need to be valid in the importing process.</p>
<section id="creating-and-sharing-ipc-memory-pools">
<span id="stream-ordered-creating-and-sharing-ipc-memory-pools"></span><h3><span class="section-number">12.11.1. </span>Creating and Sharing IPC Memory Pools<a class="headerlink" href="#creating-and-sharing-ipc-memory-pools" title="Permalink to this headline">ï</a></h3>
<p>Sharing access to a pool involves retrieving an OS native handle to the pool (with the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolExportToShareableHandle()</span></code> API), transferring the handle to the importing process using the usual OS native IPC mechanisms, and creating an imported memory pool (with the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolImportFromShareableHandle()</span></code> API). For <code class="docutils literal notranslate"><span class="pre">cudaMemPoolExportToShareableHandle</span></code> to succeed, the memory pool had to be created with the requested handle type specified in the pool properties structure. Please reference samples for the appropriate IPC mechanisms to transfer the OS native handle between processes. The rest of the procedure can be found in the following code snippets.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// in exporting process</span>
<span class="c1">// create an exportable IPC capable pool on device 0</span>
<span class="n">cudaMemPoolProps</span><span class="w"> </span><span class="n">poolProps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">allocType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAllocationTypePinned</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeDevice</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Setting handleTypes to a non zero value will make the pool exportable (IPC capable)</span>
<span class="n">poolProps</span><span class="p">.</span><span class="n">handleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR</span><span class="p">;</span><span class="w"></span>

<span class="n">cudaMemPoolCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">poolProps</span><span class="p">));</span><span class="w"></span>

<span class="c1">// FD based handles are integer types</span>
<span class="kt">int</span><span class="w"> </span><span class="n">fdHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>


<span class="c1">// Retrieve an OS native handle to the pool.</span>
<span class="c1">// Note that a pointer to the handle memory is passed in here.</span>
<span class="n">cudaMemPoolExportToShareableHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdHandle</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">memPool</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="c1">// The handle must be sent to the importing process with the appropriate</span>
<span class="c1">// OS specific APIs.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// in importing process</span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">fdHandle</span><span class="p">;</span><span class="w"></span>
<span class="c1">// The handle needs to be retrieved from the exporting process with the</span>
<span class="c1">// appropriate OS specific APIs.</span>
<span class="c1">// Create an imported pool from the shareable handle.</span>
<span class="c1">// Note that the handle is passed by value here.</span>
<span class="n">cudaMemPoolImportFromShareableHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">importedMemPool</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fdHandle</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="set-access-in-the-importing-process">
<span id="stream-ordered-set-access-importing-process"></span><h3><span class="section-number">12.11.2. </span>Set Access in the Importing Process<a class="headerlink" href="#set-access-in-the-importing-process" title="Permalink to this headline">ï</a></h3>
<p>Imported memory pools are initially only accessible from their resident device. The imported memory pool does not inherit any accessibility set by the exporting process. The importing process needs to enable access (with <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code>) from any GPU it plans to access the memory from.</p>
<p>If the imported memory pool belongs to a non-visible device in the importing process, the user must use the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code> API to enable access from the GPUs the allocations will be used on.</p>
</section>
<section id="creating-and-sharing-allocations-from-an-exported-pool">
<span id="stream-ordered-allocations-from-exported-pool"></span><h3><span class="section-number">12.11.3. </span>Creating and Sharing Allocations from an Exported Pool<a class="headerlink" href="#creating-and-sharing-allocations-from-an-exported-pool" title="Permalink to this headline">ï</a></h3>
<p>Once the pool has been shared, allocations made with <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync()</span></code> from the pool in the exporting process can be shared with other processes that have imported the pool. Since the poolâs security policy is established and verified at the pool level, the OS does not need extra bookkeeping to provide security for specific pool allocations; In other words, the opaque <code class="docutils literal notranslate"><span class="pre">cudaMemPoolPtrExportData</span></code> required to import a pool allocation may be sent to the importing process using any mechanism.</p>
<p>While allocations may be exported and even imported without synchronizing with the allocating stream in any way, the importing process must follow the same rules as the exporting process when accessing the allocation. Namely, access to the allocation must happen after the stream ordering of the allocation operation in the allocating stream. The two following code snippets show <code class="docutils literal notranslate"><span class="pre">cudaMemPoolExportPointer()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolImportPointer()</span></code> sharing the allocation with an IPC event used to guarantee that the allocation isnât accessed in the importing process before the allocation is ready.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// preparing an allocation in the exporting process</span>
<span class="n">cudaMemPoolPtrExportData</span><span class="w"> </span><span class="n">exportData</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaEvent_t</span><span class="w"> </span><span class="n">readyIpcEvent</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaIpcEventHandle_t</span><span class="w"> </span><span class="n">readyIpcEventHandle</span><span class="p">;</span><span class="w"></span>

<span class="c1">// ipc event for coordinating between processes</span>
<span class="c1">// cudaEventInterprocess flag makes the event an ipc event</span>
<span class="c1">// cudaEventDisableTiming  is set for performance reasons</span>

<span class="n">cudaEventCreate</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">readyIpcEvent</span><span class="p">,</span><span class="w"> </span><span class="n">cudaEventDisableTiming</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cudaEventInterprocess</span><span class="p">)</span><span class="w"></span>

<span class="c1">// allocate from the exporting mem pool</span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="n">exportMemPool</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="c1">// event for sharing when the allocation is ready.</span>
<span class="n">cudaEventRecord</span><span class="p">(</span><span class="n">readyIpcEvent</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMemPoolExportPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exportData</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaIpcGetEventHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readyIpcEventHandle</span><span class="p">,</span><span class="w"> </span><span class="n">readyIpcEvent</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Share IPC event and pointer export data with the importing process using</span>
<span class="c1">//  any mechanism. Here we copy the data into shared memory</span>
<span class="n">shmem</span><span class="o">-&gt;</span><span class="n">ptrData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exportData</span><span class="p">;</span><span class="w"></span>
<span class="n">shmem</span><span class="o">-&gt;</span><span class="n">readyIpcEventHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readyIpcEventHandle</span><span class="p">;</span><span class="w"></span>
<span class="c1">// signal consumers data is ready</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Importing an allocation</span>
<span class="n">cudaMemPoolPtrExportData</span><span class="w"> </span><span class="o">*</span><span class="n">importData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shmem</span><span class="o">-&gt;</span><span class="n">prtData</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaEvent_t</span><span class="w"> </span><span class="n">readyIpcEvent</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaIpcEventHandle_t</span><span class="w"> </span><span class="o">*</span><span class="n">readyIpcEventHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">shmem</span><span class="o">-&gt;</span><span class="n">readyIpcEventHandle</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Need to retrieve the ipc event handle and the export data from the</span>
<span class="c1">// exporting process using any mechanism.  Here we are using shmem and just</span>
<span class="c1">// need synchronization to make sure the shared memory is filled in.</span>

<span class="n">cudaIpcOpenEventHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readyIpcEvent</span><span class="p">,</span><span class="w"> </span><span class="n">readyIpcEventHandle</span><span class="p">);</span><span class="w"></span>

<span class="c1">// import the allocation. The operation does not block on the allocation being ready.</span>
<span class="n">cudaMemPoolImportPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">importedMemPool</span><span class="p">,</span><span class="w"> </span><span class="n">importData</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Wait for the prior stream operations in the allocating stream to complete before</span>
<span class="c1">// using the allocation in the importing process.</span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">readyIpcEvent</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
</pre></div>
</div>
<p>When freeing the allocation, the allocation needs to be freed in the importing process before it is freed in the exporting process. The following code snippet demonstrates the use of CUDA IPC events to provide the required synchronization between the <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code> operations in both processes. Access to the allocation from the importing process is obviously restricted by the free operation in the importing process side. It is worth noting that <code class="docutils literal notranslate"><span class="pre">cudaFree</span></code> can be used to free the allocation in both processes and that other stream synchronization APIs may be used instead of CUDA IPC events.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The free must happen in importing process before the exporting process</span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>

<span class="c1">// Last access in importing process</span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Access not allowed in the importing process after the free</span>
<span class="n">cudaIpcEventRecord</span><span class="p">(</span><span class="n">finishedIpcEvent</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Exporting process</span>
<span class="c1">// The exporting process needs to coordinate its free with the stream order</span>
<span class="c1">// of the importing processâs free.</span>
<span class="n">cudaStreamWaitEvent</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">finishedIpcEvent</span><span class="p">);</span><span class="w"></span>
<span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">...,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptrInExportingProcess</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>

<span class="c1">// The free in the importing process doesnât stop the exporting process</span>
<span class="c1">// from using the allocation.</span>
<span class="n">cudFreeAsync</span><span class="p">(</span><span class="n">ptrInExportingProcess</span><span class="p">,</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="ipc-export-pool-limitations">
<span id="stream-ordered-export-pool-limitations"></span><h3><span class="section-number">12.11.4. </span>IPC Export Pool Limitations<a class="headerlink" href="#ipc-export-pool-limitations" title="Permalink to this headline">ï</a></h3>
<p>IPC pools currently do not support releasing physical blocks back to the OS. As a result the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolTrimTo</span></code> API acts as a no-op and the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReleaseThreshold</span></code> effectively gets ignored. This behavior is controlled by the driver, not the runtime and may change in a future driver update.</p>
</section>
<section id="ipc-import-pool-limitations">
<span id="stream-ordered-import-pool-limitations"></span><h3><span class="section-number">12.11.5. </span>IPC Import Pool Limitations<a class="headerlink" href="#ipc-import-pool-limitations" title="Permalink to this headline">ï</a></h3>
<p>Allocating from an import pool is not allowed; specifically, import pools cannot be set current and cannot be used in the <code class="docutils literal notranslate"><span class="pre">cudaMallocFromPoolAsync</span></code> API. As such, the allocation reuse policy attributes are meaningless for these pools.</p>
<p>IPC pools currently do not support releasing physical blocks back to the OS. As a result the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolTrimTo</span></code> API acts as a no-op and the <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReleaseThreshold</span></code> effectively gets ignored.</p>
<p>The resource usage stat attribute queries only reflect the allocations imported into the process and the associated physical memory.</p>
</section>
</section>
<section id="synchronization-api-actions">
<span id="stream-ordered-synchronization-api-actions"></span><h2><span class="section-number">12.12. </span>Synchronization API Actions<a class="headerlink" href="#synchronization-api-actions" title="Permalink to this headline">ï</a></h2>
<p>One of the optimizations that comes with the allocator being part of the CUDA driver is integration with the synchronize APIs. When the user requests that the CUDA driver synchronize, the driver waits for asynchronous work to complete. Before returning, the driver will determine what frees the synchronization guaranteed to be completed. These allocations are made available for allocation regardless of specified stream or disabled allocation policies. The driver also checks <code class="docutils literal notranslate"><span class="pre">cudaMemPoolAttrReleaseThreshold</span></code> here and releases any excess physical memory that it can.</p>
</section>
<section id="addendums">
<span id="stream-ordered-addendums"></span><h2><span class="section-number">12.13. </span>Addendums<a class="headerlink" href="#addendums" title="Permalink to this headline">ï</a></h2>
<section id="cudamemcpyasync-current-context-device-sensitivity">
<span id="stream-ordered-cudamemcpyasync"></span><h3><span class="section-number">12.13.1. </span>cudaMemcpyAsync Current Context/Device Sensitivity<a class="headerlink" href="#cudamemcpyasync-current-context-device-sensitivity" title="Permalink to this headline">ï</a></h3>
<p>In the current CUDA driver, any async <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> involving memory from <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> should be done using the specified streamâs context as the calling threadâs current context. This is not necessary for <code class="docutils literal notranslate"><span class="pre">cudaMemcpyPeerAsync</span></code>, as the device primary contexts specified in the API are referenced instead of the current context.</p>
</section>
<section id="cupointergetattribute-query">
<span id="stream-ordered-cupointergetattribute"></span><h3><span class="section-number">12.13.2. </span>cuPointerGetAttribute Query<a class="headerlink" href="#cupointergetattribute-query" title="Permalink to this headline">ï</a></h3>
<p>Invoking <code class="docutils literal notranslate"><span class="pre">cuPointerGetAttribute</span></code> on an allocation after invoking <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code> on it results in undefined behavior. Specifically, it does not matter if an allocation is still accessible from a given stream: the behavior is still undefined.</p>
</section>
<section id="cugraphaddmemsetnode">
<span id="stream-ordered-cugraphaddmemsetnode"></span><h3><span class="section-number">12.13.3. </span>cuGraphAddMemsetNode<a class="headerlink" href="#cugraphaddmemsetnode" title="Permalink to this headline">ï</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">cuGraphAddMemsetNode</span></code> does not work with memory allocated via the stream ordered allocator. However, memsets of the allocations can be stream captured.</p>
</section>
<section id="pointer-attributes">
<span id="stream-ordered-pointer-attributes"></span><h3><span class="section-number">12.13.4. </span>Pointer Attributes<a class="headerlink" href="#pointer-attributes" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cuPointerGetAttributes</span></code> query works on stream ordered allocations. Since stream ordered allocations are not context associated, querying <code class="docutils literal notranslate"><span class="pre">CU_POINTER_ATTRIBUTE_CONTEXT</span></code> will succeed but return NULL in <code class="docutils literal notranslate"><span class="pre">*data</span></code>. The attribute <code class="docutils literal notranslate"><span class="pre">CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL</span></code> can be used to determine the location of the allocation: this can be useful when selecting a context for making p2h2p copies using <code class="docutils literal notranslate"><span class="pre">cudaMemcpyPeerAsync</span></code>. The attribute <code class="docutils literal notranslate"><span class="pre">CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE</span></code> was added in CUDA 11.3 and can be useful for debugging and for confirming which pool an allocation comes from before doing IPC.</p>
</section>
</section>
</section>
<section id="graph-memory-nodes">
<span id="id318"></span><h1><span class="section-number">13. </span>Graph Memory Nodes<a class="headerlink" href="#graph-memory-nodes" title="Permalink to this headline">ï</a></h1>
<section id="graph-memory-nodes-intro">
<span id="id319"></span><h2><span class="section-number">13.1. </span>Introduction<a class="headerlink" href="#graph-memory-nodes-intro" title="Permalink to this headline">ï</a></h2>
<p>Graph memory nodes allow graphs to create and own memory allocations. Graph memory nodes have GPU ordered lifetime semantics, which dictate when memory is allowed to be accessed on the device. These GPU ordered lifetime semantics enable driver-managed memory reuse, and match those of the stream ordered allocation APIs <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code>, which may be captured when creating a graph.</p>
<p>Graph allocations have fixed addresses over the life of a graph including repeated instantiations and launches. This allows the memory to be directly referenced by other operations within the graph without the need of a graph update, even when CUDA changes the backing physical memory. Within a graph, allocations whose graph ordered lifetimes do not overlap may use the same underlying physical memory.</p>
<p>CUDA may reuse the same physical memory for allocations across multiple graphs, aliasing virtual address mappings according to the GPU ordered lifetime semantics. For example when different graphs are launched into the same stream, CUDA may virtually alias the same physical memory to satisfy the needs of allocations which have single-graph lifetimes.</p>
</section>
<section id="support-and-compatibility">
<span id="graph-memory-nodes-support-and-compatibility"></span><h2><span class="section-number">13.2. </span>Support and Compatibility<a class="headerlink" href="#support-and-compatibility" title="Permalink to this headline">ï</a></h2>
<p>Graph memory nodes require an 11.4 capable CUDA driver and support for the stream ordered allocator on the GPU. The following snippet shows how to check for support on a given device.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">driverVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsMemoryPools</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">deviceSupportsMemoryNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverVersion</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">driverVersion</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">11020</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// avoid invalid value error in cudaDeviceGetAttribute</span>
<span class="w">    </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceSupportsMemoryPools</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrMemoryPoolsSupported</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">deviceSupportsMemoryNodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">driverVersion</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">11040</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">deviceSupportsMemoryPools</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Doing the attribute query inside the driver version check avoids an invalid value return code on 11.0 and 11.1 drivers. Be aware that the compute sanitizer emits warnings when it detects CUDA returning error codes, and a version check before reading the attribute will avoid this. Graph memory nodes are only supported on driver versions 11.4 and newer.</p>
</section>
<section id="api-fundamentals">
<span id="graph-memory-node-api-fundamentals"></span><h2><span class="section-number">13.3. </span>API Fundamentals<a class="headerlink" href="#api-fundamentals" title="Permalink to this headline">ï</a></h2>
<p>Graph memory nodes are graph nodes representing either memory allocation or free actions. As a shorthand, nodes that allocate memory are called allocation nodes. Likewise, nodes that free memory are called free nodes. Allocations created by allocation nodes are called graph allocations. CUDA assigns virtual addresses for the graph allocation at node creation time. While these virtual addresses are fixed for the lifetime of the allocation node, the allocation contents are not persistent past the freeing operation and may be overwritten by accesses referring to a different allocation.</p>
<p>Graph allocations are considered recreated every time a graph runs. A graph allocationâs lifetime, which differs from the nodeâs lifetime, begins when GPU execution reaches the allocating graph node and ends when one of the following occurs:</p>
<ul class="simple">
<li><p>GPU execution reaches the freeing graph node</p></li>
<li><p>GPU execution reaches the freeing <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync()</span></code> stream call</p></li>
<li><p>immediately upon the freeing call to <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Graph destruction does not automatically free any live graph-allocated memory, even though it ends the lifetime of the allocation node. The allocation must subsequently be freed in another graph, or using <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync()</span></code><code class="docutils literal notranslate"><span class="pre">/cudaFree()</span></code>.</p>
</div>
<p>Just like other <a class="reference internal" href="#graph-structure"><span class="std std-ref">Graph Structure</span></a>, graph memory nodes are ordered within a graph by dependency edges. A program must guarantee that operations accessing graph memory:</p>
<ul class="simple">
<li><p>are ordered after the allocation node</p></li>
<li><p>are ordered before the operation freeing the memory</p></li>
</ul>
<p>Graph allocation lifetimes begin and usually end according to GPU execution (as opposed to API invocation). GPU ordering is the order that work runs on the GPU as opposed to the order that the work is enqueued or described. Thus, graph allocations are considered âGPU ordered.â</p>
<section id="graph-node-apis">
<span id="id320"></span><h3><span class="section-number">13.3.1. </span>Graph Node APIs<a class="headerlink" href="#graph-node-apis" title="Permalink to this headline">ï</a></h3>
<p>Graph memory nodes may be explicitly created with the memory node creation APIs, <code class="docutils literal notranslate"><span class="pre">cudaGraphAddMemAllocNode</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGraphAddMemFreeNode</span></code>. The address allocated by <code class="docutils literal notranslate"><span class="pre">cudaGraphAddMemAllocNode</span></code> is returned to the user in the <code class="docutils literal notranslate"><span class="pre">dptr</span></code> field of the passed <code class="docutils literal notranslate"><span class="pre">CUDA_MEM_ALLOC_NODE_PARAMS</span></code> structure. All operations using graph allocations inside the allocating graph must be ordered after the allocating node. Similarly, any free nodes must be ordered after all uses of the allocation within the graph. <code class="docutils literal notranslate"><span class="pre">cudaGraphAddMemFreeNode</span></code> creates free nodes.</p>
<p>In the following figure, there is an example graph with an alloc and a free node. Kernel nodes <strong>a</strong>, <strong>b</strong>, and <strong>c</strong> are ordered after the allocation node and before the free node such that the kernels can access the allocation. Kernel node <strong>e</strong> is not ordered after the alloc node and therefore cannot safely access the memory. Kernel node <strong>d</strong> is not ordered before the free node, therefore it cannot safely access the memory.</p>
<figure class="align-default" id="id473">
<img alt="Kernel Nodes" src="_images/kernel-nodes.png" />
<figcaption>
<p><span class="caption-number">Figure 31 </span><span class="caption-text">Kernel Nodes</span><a class="headerlink" href="#id473" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>The following code snippet establishes the graph in this figure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Create the graph - it starts out empty
cudaGraphCreate(&amp;graph, 0);

// parameters for a basic allocation
cudaMemAllocNodeParams params = {};
params.poolProps.allocType = cudaMemAllocationTypePinned;
params.poolProps.location.type = cudaMemLocationTypeDevice;
// specify device 0 as the resident device
params.poolProps.location.id = 0;
params.bytesize = size;

cudaGraphAddMemAllocNode(&amp;allocNode, graph, NULL, 0, &amp;params);
nodeParams-&gt;kernelParams[0] = params.dptr;
cudaGraphAddKernelNode(&amp;a, graph, &amp;allocNode, 1, &amp;nodeParams);
cudaGraphAddKernelNode(&amp;b, graph, &amp;a, 1, &amp;nodeParams);
cudaGraphAddKernelNode(&amp;c, graph, &amp;a, 1, &amp;nodeParams);
cudaGraphNode_t dependencies[2];
// kernel nodes b and c are using the graph allocation, so the freeing node must depend on them.  Since the dependency of node b on node a establishes an indirect dependency, the free node does not need to explicitly depend on node a.
dependencies[0] = b;
dependencies[1] = c;
cudaGraphAddMemFreeNode(&amp;freeNode, graph, dependencies, 2, params.dptr);
// free node does not depend on kernel node d, so it must not access the freed graph allocation.
cudaGraphAddKernelNode(&amp;d, graph, &amp;c, 1, &amp;nodeParams);

// node e does not depend on the allocation node, so it must not access the allocation.  This would be true even if the freeNode depended on kernel node e.
cudaGraphAddKernelNode(&amp;e, graph, NULL, 0, &amp;nodeParams);
</pre></div>
</div>
</section>
<section id="stream-capture">
<span id="graph-memory-nodes-stream-capture"></span><h3><span class="section-number">13.3.2. </span>Stream Capture<a class="headerlink" href="#stream-capture" title="Permalink to this headline">ï</a></h3>
<p>Graph memory nodes can be created by capturing the corresponding stream ordered allocation and free calls <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code>. In this case, the virtual addresses returned by the captured allocation API can be used by other operations inside the graph. Since the stream ordered dependencies will be captured into the graph, the ordering requirements of the stream ordered allocation APIs guarantee that the graph memory nodes will be properly ordered with respect to the captured stream operations (for correctly written stream code).</p>
<p>Ignoring kernel nodes <strong>d</strong> and <strong>e</strong>, for clarity, the following code snippet shows how to use stream capture to create the graph from the previous figure:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cudaMallocAsync(&amp;dptr, size, stream1);
kernel_A&lt;&lt;&lt; ..., stream1 &gt;&gt;&gt;(dptr, ...);

// Fork into stream2
cudaEventRecord(event1, stream1);
cudaStreamWaitEvent(stream2, event1);

kernel_B&lt;&lt;&lt; ..., stream1 &gt;&gt;&gt;(dptr, ...);
// event dependencies translated into graph dependencies, so the kernel node created by the capture of kernel C will depend on the allocation node created by capturing the cudaMallocAsync call.
kernel_C&lt;&lt;&lt; ..., stream2 &gt;&gt;&gt;(dptr, ...);

// Join stream2 back to origin stream (stream1)
cudaEventRecord(event2, stream2);
cudaStreamWaitEvent(stream1, event2);

// Free depends on all work accessing the memory.
cudaFreeAsync(dptr, stream1);

// End capture in the origin stream
cudaStreamEndCapture(stream1, &amp;graph);
</pre></div>
</div>
</section>
<section id="accessing-and-freeing-graph-memory-outside-of-the-allocating-graph">
<span id="graph-memory-accessing-and-freeing"></span><h3><span class="section-number">13.3.3. </span>Accessing and Freeing Graph Memory Outside of the Allocating Graph<a class="headerlink" href="#accessing-and-freeing-graph-memory-outside-of-the-allocating-graph" title="Permalink to this headline">ï</a></h3>
<p>Graph allocations do not have to be freed by the allocating graph. When a graph does not free an allocation, that allocation persists beyond the execution of the graph and can be accessed by subsequent CUDA operations. These allocations may be accessed in another graph or directly using a stream operation as long as the accessing operation is ordered after the allocation through CUDA events and other stream ordering mechanisms. An allocation may subsequently be freed by regular calls to <code class="docutils literal notranslate"><span class="pre">cudaFree</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaFreeAsync</span></code>, or by the launch of another graph with a corresponding free node, or a subsequent launch of the allocating graph (if it was instantiated with the <a class="reference internal" href="#graph-memory-nodes-cudagraphinstantiateflagautofreeonlaunch"><span class="std std-ref">cudaGraphInstantiateFlagAutoFreeOnLaunch</span></a> flag). It is illegal to access memory after it has been freed - the free operation must be ordered after all operations accessing the memory using graph dependencies, CUDA events, and other stream ordering mechanisms.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because graph allocations may share underlying physical memory with each other, the <a class="reference internal" href="#virtual-aliasing-support"><span class="std std-ref">Virtual Aliasing Support</span></a> rules relating to consistency and coherency must be considered. Simply put, the free operation must be ordered after the full device operation (for example, compute kernel / memcpy) completes. Specifically, out of band synchronization - for example a handshake through memory as part of a compute kernel that accesses the graph-allocated memory - is not sufficient for providing ordering guarantees between the memory writes to graph memory and the free operation of that graph memory.</p>
</div>
<p>The following code snippets demonstrate accessing graph allocations outside of the allocating graph with ordering properly established by: using a single stream, using events between streams, and using events baked into the allocating and freeing graph.</p>
<p><strong>Ordering established by using a single stream:</strong></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>void *dptr;
cudaGraphAddMemAllocNode(&amp;allocNode, allocGraph, NULL, 0, &amp;params);
dptr = params.dptr;

cudaGraphInstantiate(&amp;allocGraphExec, allocGraph, NULL, NULL, 0);

cudaGraphLaunch(allocGraphExec, stream);
kernel&lt;&lt;&lt; â¦, stream &gt;&gt;&gt;(dptr, â¦);
cudaFreeAsync(dptr, stream);
</pre></div>
</div>
<p><strong>Ordering established by recording and waiting on CUDA events:</strong></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>void *dptr;

// Contents of allocating graph
cudaGraphAddMemAllocNode(&amp;allocNode, allocGraph, NULL, 0, &amp;params);
dptr = params.dptr;

// contents of consuming/freeing graph
nodeParams-&gt;kernelParams[0] = params.dptr;
cudaGraphAddKernelNode(&amp;a, graph, NULL, 0, &amp;nodeParams);
cudaGraphAddMemFreeNode(&amp;freeNode, freeGraph, &amp;a, 1, dptr);

cudaGraphInstantiate(&amp;allocGraphExec, allocGraph, NULL, NULL, 0);
cudaGraphInstantiate(&amp;freeGraphExec, freeGraph, NULL, NULL, 0);

cudaGraphLaunch(allocGraphExec, allocStream);

// establish the dependency of stream2 on the allocation node
// note: the dependency could also have been established with a stream synchronize operation
cudaEventRecord(allocEvent, allocStream)
cudaStreamWaitEvent(stream2, allocEvent);

kernel&lt;&lt;&lt; â¦, stream2 &gt;&gt;&gt; (dptr, â¦);

// establish the dependency between the stream 3 and the allocation use
cudaStreamRecordEvent(streamUseDoneEvent, stream2);
cudaStreamWaitEvent(stream3, streamUseDoneEvent);

// it is now safe to launch the freeing graph, which may also access the memory
cudaGraphLaunch(freeGraphExec, stream3);
</pre></div>
</div>
<p><strong>Ordering established by using graph external event nodes:</strong></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>void *dptr;
cudaEvent_t allocEvent; // event indicating when the allocation will be ready for use.
cudaEvent_t streamUseDoneEvent; // event indicating when the stream operations are done with the allocation.

// Contents of allocating graph with event record node
cudaGraphAddMemAllocNode(&amp;allocNode, allocGraph, NULL, 0, &amp;params);
dptr = params.dptr;
// note: this event record node depends on the alloc node
cudaGraphAddEventRecordNode(&amp;recordNode, allocGraph, &amp;allocNode, 1, allocEvent);
cudaGraphInstantiate(&amp;allocGraphExec, allocGraph, NULL, NULL, 0);

// contents of consuming/freeing graph with event wait nodes
cudaGraphAddEventWaitNode(&amp;streamUseDoneEventNode, waitAndFreeGraph, NULL, 0, streamUseDoneEvent);
cudaGraphAddEventWaitNode(&amp;allocReadyEventNode, waitAndFreeGraph, NULL, 0, allocEvent);
nodeParams-&gt;kernelParams[0] = params.dptr;

// The allocReadyEventNode provides ordering with the alloc node for use in a consuming graph.
cudaGraphAddKernelNode(&amp;kernelNode, waitAndFreeGraph, &amp;allocReadyEventNode, 1, &amp;nodeParams);

// The free node has to be ordered after both external and internal users.
// Thus the node must depend on both the kernelNode and the
// streamUseDoneEventNode.
dependencies[0] = kernelNode;
dependencies[1] = streamUseDoneEventNode;
cudaGraphAddMemFreeNode(&amp;freeNode, waitAndFreeGraph, &amp;dependencies, 2, dptr);
cudaGraphInstantiate(&amp;waitAndFreeGraphExec, waitAndFreeGraph, NULL, NULL, 0);

cudaGraphLaunch(allocGraphExec, allocStream);

// establish the dependency of stream2 on the event node satisfies the ordering requirement
cudaStreamWaitEvent(stream2, allocEvent);
kernel&lt;&lt;&lt; â¦, stream2 &gt;&gt;&gt; (dptr, â¦);
cudaStreamRecordEvent(streamUseDoneEvent, stream2);

// the event wait node in the waitAndFreeGraphExec establishes the dependency on the âreadyForFreeEventâ that is needed to prevent the kernel running in stream two from accessing the allocation after the free node in execution order.
cudaGraphLaunch(waitAndFreeGraphExec, stream3);
</pre></div>
</div>
</section>
<section id="cudagraphinstantiateflagautofreeonlaunch">
<span id="graph-memory-nodes-cudagraphinstantiateflagautofreeonlaunch"></span><h3><span class="section-number">13.3.4. </span>cudaGraphInstantiateFlagAutoFreeOnLaunch<a class="headerlink" href="#cudagraphinstantiateflagautofreeonlaunch" title="Permalink to this headline">ï</a></h3>
<p>Under normal circumstances, CUDA will prevent a graph from being relaunched if it has unfreed memory allocations because multiple allocations at the same address will leak memory. Instantiating a graph with the <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiateFlagAutoFreeOnLaunch</span></code> flag allows the graph to be relaunched while it still has unfreed allocations. In this case, the launch automatically inserts an asynchronous free of the unfreed allocations.</p>
<p>Auto free on launch is useful for single-producer multiple-consumer algorithms. At each iteration, a producer graph creates several allocations, and, depending on runtime conditions, a varying set of consumers accesses those allocations. This type of variable execution sequence means that consumers cannot free the allocations because a subsequent consumer may require access. Auto free on launch means that the launch loop does not need to track the producerâs allocations - instead, that information remains isolated to the producerâs creation and destruction logic. In general, auto free on launch simplifies an algorithm which would otherwise need to free all the allocations owned by a graph before each relaunch.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiateFlagAutoFreeOnLaunch</span></code> flag does not change the behavior of graph destruction. The application must explicitly free the unfreed memory in order to avoid memory leaks, even for graphs instantiated with the flag.
The following code shows the use of <code class="docutils literal notranslate"><span class="pre">cudaGraphInstantiateFlagAutoFreeOnLaunch</span></code> to simplify a single-producer / multiple-consumer algorithm:</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create producer graph which allocates memory and populates it with data</span>
<span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data2</span><span class="p">,</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="p">);</span><span class="w"></span>
<span class="n">produce</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">data2</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphInstantiateWithFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">producer</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">graph</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">cudaGraphInstantiateFlagAutoFreeOnLaunch</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create first consumer graph by capturing an asynchronous library call</span>
<span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="n">consumerFromLibrary</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphInstantiateWithFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consumer1</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">//regular instantiation</span>
<span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Create second consumer graph</span>
<span class="n">cudaStreamBeginCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamCaptureModeGlobal</span><span class="p">);</span><span class="w"></span>
<span class="n">consume2</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStreamPerThread</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">cudaStreamEndCapture</span><span class="p">(</span><span class="n">cudaStreamPerThread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphInstantiateWithFlags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consumer2</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphDestroy</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Launch in a loop</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">launchConsumer2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">producer</span><span class="p">,</span><span class="w"> </span><span class="n">myStream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">consumer1</span><span class="p">,</span><span class="w"> </span><span class="n">myStream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">launchConsumer2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaGraphLaunch</span><span class="p">(</span><span class="n">consumer2</span><span class="p">,</span><span class="w"> </span><span class="n">myStream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">determineAction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">launchConsumer2</span><span class="p">));</span><span class="w"></span>

<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">myStream</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaFreeAsync</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span><span class="w"> </span><span class="n">myStream</span><span class="p">);</span><span class="w"></span>

<span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">consumer1</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaGraphExecDestroy</span><span class="p">(</span><span class="n">consumer2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="optimized-memory-reuse">
<span id="graph-memory-nodes-optimized-memory-reuse"></span><h2><span class="section-number">13.4. </span>Optimized Memory Reuse<a class="headerlink" href="#optimized-memory-reuse" title="Permalink to this headline">ï</a></h2>
<p>CUDA reuses memory in two ways:</p>
<ul class="simple">
<li><p>Virtual and physical memory reuse within a graph is based on virtual address assignment, like in the stream ordered allocator.</p></li>
<li><p>Physical memory reuse between graphs is done with virtual aliasing: different graphs can map the same physical memory to their unique virtual addresses.</p></li>
</ul>
<section id="address-reuse-within-a-graph">
<span id="graph-memory-nodes-address-reuse-within-a-graph"></span><h3><span class="section-number">13.4.1. </span>Address Reuse within a Graph<a class="headerlink" href="#address-reuse-within-a-graph" title="Permalink to this headline">ï</a></h3>
<p>CUDA may reuse memory within a graph by assigning the same virtual address ranges to different allocations whose lifetimes do not overlap. Since virtual addresses may be reused, pointers to different allocations with disjoint lifetimes are not guaranteed to be unique.</p>
<p>The following figure shows adding a new allocation node (2) that can reuse the address freed by a dependent node (1).</p>
<figure class="align-default" id="id474">
<img alt="Adding New Alloc Node 2" src="_images/new-alloc-node.png" />
<figcaption>
<p><span class="caption-number">Figure 32 </span><span class="caption-text">Adding New Alloc Node 2</span><a class="headerlink" href="#id474" title="Permalink to this image">ï</a></p>
<div class="legend">
<p>The following figure shows adding a new alloc node (4). The new alloc node is not dependent on the free node (2) so cannot reuse the address from the associated alloc node (2). If the alloc node (2) used the address freed by free node (1), the new alloc node 3 would need a new address.</p>
</div>
</figcaption>
</figure>
<figure class="align-default" id="id475">
<img alt="Adding New Alloc Node 3" src="_images/adding-new-alloc-nodes.png" />
<figcaption>
<p><span class="caption-number">Figure 33 </span><span class="caption-text">Adding New Alloc Node 3</span><a class="headerlink" href="#id475" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="physical-memory-management-and-sharing">
<span id="graph-memory-nodes-physical-memory-mgmt"></span><h3><span class="section-number">13.4.2. </span>Physical Memory Management and Sharing<a class="headerlink" href="#physical-memory-management-and-sharing" title="Permalink to this headline">ï</a></h3>
<p>CUDA is responsible for mapping physical memory to the virtual address before the allocating node is reached in GPU order. As an optimization for memory footprint and mapping overhead, multiple graphs may use the same physical memory for distinct allocations if they will not run simultaneously; however, physical pages cannot be reused if they are bound to more than one executing graph at the same time, or to a graph allocation which remains unfreed.</p>
<p>CUDA may update physical memory mappings at any time during graph instantiation, launch, or execution. CUDA may also introduce synchronization between future graph launches in order to prevent live graph allocations from referring to the same physical memory. As for any allocate-free-allocate pattern, if a program accesses a pointer outside of an allocationâs lifetime, the erroneous access may silently read or write live data owned by another allocation (even if the virtual address of the allocation is unique). Use of compute sanitizer tools can catch this error.</p>
<p>The following figure shows graphs sequentially launched in the same stream. In this example, each graph frees all the memory it allocates. Since the graphs in the same stream never run concurrently, CUDA can and should use the same physical memory to satisfy all the allocations.</p>
<figure class="align-default" id="id476">
<img alt="Sequentially Launched Graphs" src="_images/sequentially-launched-graphs.png" />
<figcaption>
<p><span class="caption-number">Figure 34 </span><span class="caption-text">Sequentially Launched Graphs</span><a class="headerlink" href="#id476" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="performance-considerations">
<span id="graph-memory-nodes-performance-considerations"></span><h2><span class="section-number">13.5. </span>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Permalink to this headline">ï</a></h2>
<p>When multiple graphs are launched into the same stream, CUDA attempts to allocate the same physical memory to them because the execution of these graphs cannot overlap. Physical mappings for a graph are retained between launches as an optimization to avoid the cost of remapping. If, at a later time, one of the graphs is launched such that its execution may overlap with the others (for example if it is launched into a different stream) then CUDA must perform some remapping because concurrent graphs require distinct memory to avoid data corruption.</p>
<p>In general, remapping of graph memory in CUDA is likely caused by these operations:</p>
<ul class="simple">
<li><p>Changing the stream into which a graph is launched</p></li>
<li><p>A trim operation on the graph memory pool, which explicitly frees unused memory (discussed in <a class="reference internal" href="#graph-memory-nodes-physical-memory-footprint"><span class="std std-ref">Physical Memory Footprint</span></a>)</p></li>
<li><p>Relaunching a graph while an unfreed allocation from another graph is mapped to the same memory will cause a remap of memory before relaunch</p></li>
</ul>
<p>Remapping must happen in execution order, but after any previous execution of that graph is complete (otherwise memory that is still in use could be unmapped). Due to this ordering dependency, as well as because mapping operations are OS calls, mapping operations can be relatively expensive. Applications can avoid this cost by launching graphs containing allocation memory nodes consistently into the same stream.</p>
<section id="first-launch-cudagraphupload">
<span id="graph-memory-nodes-first-launch"></span><h3><span class="section-number">13.5.1. </span>First Launch / cudaGraphUpload<a class="headerlink" href="#first-launch-cudagraphupload" title="Permalink to this headline">ï</a></h3>
<p>Physical memory cannot be allocated or mapped during graph instantiation because the stream in which the graph will execute is unknown. Mapping is done instead during graph launch. Calling <code class="docutils literal notranslate"><span class="pre">cudaGraphUpload</span></code> can separate out the cost of allocation from the launch by performing all mappings for that graph immediately and associating the graph with the upload stream. If the graph is then launched into the same stream, it will launch without any additional remapping.</p>
<p>Using different streams for graph upload and graph launch behaves similarly to switching streams, likely resulting in remap operations. In addition, unrelated memory pool management is permitted to pull memory from an idle stream, which could negate the impact of the uploads.</p>
</section>
</section>
<section id="physical-memory-footprint">
<span id="graph-memory-nodes-physical-memory-footprint"></span><h2><span class="section-number">13.6. </span>Physical Memory Footprint<a class="headerlink" href="#physical-memory-footprint" title="Permalink to this headline">ï</a></h2>
<p>The pool-management behavior of asynchronous allocation means that destroying a graph which contains memory nodes (even if their allocations are free) will not immediately return physical memory to the OS for use by other processes. To explicitly release memory back to the OS, an application should use the <code class="docutils literal notranslate"><span class="pre">cudaDeviceGraphMemTrim</span></code> API.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaDeviceGraphMemTrim</span></code> will unmap and release any physical memory reserved by graph memory nodes that is not actively in use. Allocations that have not been freed and graphs that are scheduled or running are considered to be actively using the physical memory and will not be impacted. Use of the trim API will make physical memory available to other allocation APIs and other applications or processes, but will cause CUDA to reallocate and remap memory when the trimmed graphs are next launched. Note that <code class="docutils literal notranslate"><span class="pre">cudaDeviceGraphMemTrim</span></code> operates on a different pool from <code class="docutils literal notranslate"><span class="pre">cudaMemPoolTrimTo()</span></code>. The graph memory pool is not exposed to the steam ordered memory allocator. CUDA allows applications to query their graph memory footprint through the <code class="docutils literal notranslate"><span class="pre">cudaDeviceGetGraphMemAttribute</span></code> API. Querying the attribute <code class="docutils literal notranslate"><span class="pre">cudaGraphMemAttrReservedMemCurrent</span></code> returns the amount of physical memory reserved by the driver for graph allocations in the current process. Querying <code class="docutils literal notranslate"><span class="pre">cudaGraphMemAttrUsedMemCurrent</span></code> returns the amount of physical memory currently mapped by at least one graph. Either of these attributes can be used to track when new physical memory is acquired by CUDA for the sake of an allocating graph. Both of these attributes are useful for examining how much memory is saved by the sharing mechanism.</p>
</section>
<section id="peer-access">
<span id="graph-memory-nodes-peer-access"></span><h2><span class="section-number">13.7. </span>Peer Access<a class="headerlink" href="#peer-access" title="Permalink to this headline">ï</a></h2>
<p>Graph allocations can be configured for access from multiple GPUs, in which case CUDA will map the allocations onto the peer GPUs as required. CUDA allows graph allocations requiring different mappings to reuse the same virtual address. When this occurs, the address range is mapped onto all GPUs required by the different allocations. This means an allocation may sometimes allow more peer access than was requested during its creation; however, relying on these extra mappings is still an error.</p>
<section id="peer-access-with-graph-node-apis">
<span id="graph-memory-nodes-peer-access-with-graph-node-apis"></span><h3><span class="section-number">13.7.1. </span>Peer Access with Graph Node APIs<a class="headerlink" href="#peer-access-with-graph-node-apis" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaGraphAddMemAllocNode</span></code> API accepts mapping requests in the <code class="docutils literal notranslate"><span class="pre">accessDescs</span></code> array field of the node parameters structures. The <code class="docutils literal notranslate"><span class="pre">poolProps.location</span></code> embedded structure specifies the resident device for the allocation. Access from the allocating GPU is assumed to be needed, thus the application does not need to specify an entry for the resident device in the <code class="docutils literal notranslate"><span class="pre">accessDescs</span></code> array.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>cudaMemAllocNodeParams params = {};
params.poolProps.allocType = cudaMemAllocationTypePinned;
params.poolProps.location.type = cudaMemLocationTypeDevice;
// specify device 1 as the resident device
params.poolProps.location.id = 1;
params.bytesize = size;

// allocate an allocation resident on device 1 accessible from device 1
cudaGraphAddMemAllocNode(&amp;allocNode, graph, NULL, 0, &amp;params);

accessDescs[2];
// boilerplate for the access descs (only ReadWrite and Device access supported by the add node api)
accessDescs[0].flags = cudaMemAccessFlagsProtReadWrite;
accessDescs[0].location.type = cudaMemLocationTypeDevice;
accessDescs[1].flags = cudaMemAccessFlagsProtReadWrite;
accessDescs[1].location.type = cudaMemLocationTypeDevice;

// access being requested for device 0 &amp; 2.  Device 1 access requirement left implicit.
accessDescs[0].location.id = 0;
accessDescs[1].location.id = 2;

// access request array has 2 entries.
params.accessDescCount = 2;
params.accessDescs = accessDescs;

// allocate an allocation resident on device 1 accessible from devices 0, 1 and 2. (0 &amp; 2 from the descriptors, 1 from it being the resident device).
cudaGraphAddMemAllocNode(&amp;allocNode, graph, NULL, 0, &amp;params);
</pre></div>
</div>
</section>
<section id="peer-access-with-stream-capture">
<span id="graph-memory-nodes-peer-access-with-stream-capture"></span><h3><span class="section-number">13.7.2. </span>Peer Access with Stream Capture<a class="headerlink" href="#peer-access-with-stream-capture" title="Permalink to this headline">ï</a></h3>
<p>For stream capture, the allocation node records the peer accessibility of the allocating pool at the time of the capture. Altering the peer accessibility of the allocating pool after a <code class="docutils literal notranslate"><span class="pre">cudaMallocFromPoolAsync</span></code> call is captured does not affect the mappings that the graph will make for the allocation.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// boilerplate for the access descs (only ReadWrite and Device access supported by the add node api)
accessDesc.flags = cudaMemAccessFlagsProtReadWrite;
accessDesc.location.type = cudaMemLocationTypeDevice;
accessDesc.location.id = 1;

// let memPool be resident and accessible on device 0

cudaStreamBeginCapture(stream);
cudaMallocAsync(&amp;dptr1, size, memPool, stream);
cudaStreamEndCapture(stream, &amp;graph1);

cudaMemPoolSetAccess(memPool, &amp;accessDesc, 1);

cudaStreamBeginCapture(stream);
cudaMallocAsync(&amp;dptr2, size, memPool, stream);
cudaStreamEndCapture(stream, &amp;graph2);

//The graph node allocating dptr1 would only have the device 0 accessibility even though memPool now has device 1 accessibility.
//The graph node allocating dptr2 will have device 0 and device 1 accessibility, since that was the pool accessibility at the time of the cudaMallocAsync call.
</pre></div>
</div>
</section>
</section>
<section id="memory-nodes-in-child-graphs">
<span id="graph-memory-nodes-memory-nodes-in-child-graphs"></span><h2><span class="section-number">13.8. </span>Memory Nodes in Child Graphs<a class="headerlink" href="#memory-nodes-in-child-graphs" title="Permalink to this headline">ï</a></h2>
<p>CUDA 12.9 introduces the ability to move child graph ownership to a parent graph. Child graphs which are moved to the parent are allowed to contain memory allocation and free nodes. This allows a child graph containing allocation or free nodes to be independently constructed prior to its addition in a parent graph.</p>
<p>The following restrictions apply to child graphs after they have been moved:</p>
<ul class="simple">
<li><p>Cannot be independently instantiated or destroyed.</p></li>
<li><p>Cannot be added as a child graph of a separate parent graph.</p></li>
<li><p>Cannot be used as an argument to cuGraphExecUpdate.</p></li>
<li><p>Cannot have additional memory allocation or free nodes added.</p></li>
</ul>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>// Create the child graph
cudaGraphCreate(&amp;child, 0);

// parameters for a basic allocation
cudaMemAllocNodeParams params = {};
params.poolProps.allocType = cudaMemAllocationTypePinned;
params.poolProps.location.type = cudaMemLocationTypeDevice;
// specify device 0 as the resident device
params.poolProps.location.id = 0;
params.bytesize = size;

cudaGraphAddMemAllocNode(&amp;allocNode, graph, NULL, 0, &amp;params);
// Additional nodes using the allocation could be added here
cudaGraphAddMemFreeNode(&amp;freeNode, graph, &amp;allocNode, 1, params.dptr);

// Create the parent graph
cudaGraphCreate(&amp;parent, 0);

// Move the child graph to the parent graph
cudaGraphNodeParams childNodeParams = { cudaGraphNodeTypeGraph };
childNodeParams.graph.graph = child;
childNodeParams.graph.ownership = cudaGraphChildGraphOwnershipMove;
cudaGraphAddNode_v2(&amp;parentNode, parent, NULL, NULL, 0, &amp;childNodeParams);
</pre></div>
</div>
</section>
</section>
<section id="mathematical-functions-appendix">
<span id="id321"></span><h1><span class="section-number">14. </span>Mathematical Functions<a class="headerlink" href="#mathematical-functions-appendix" title="Permalink to this headline">ï</a></h1>
<p>The reference manual lists, along with their description, all the functions of the C/C++ standard library mathematical functions that are supported in device code, as well as all intrinsic functions (that are only supported in device code).</p>
<p>This section provides accuracy information for some of these functions when applicable. It uses ULP for quantification. For further information on the definition of the Unit in the Last Place (ULP), please see Jean-Michel Mullerâs paper <em>On the definition of ulp(x)</em>, RR-5504, LIP RR-2005-09, INRIA, LIP. 2005, pp.16 at <a class="reference external" href="https://hal.inria.fr/inria-00070503/document">https://hal.inria.fr/inria-00070503/document</a>.</p>
<p>Mathematical functions supported in device code do not set the global <code class="docutils literal notranslate"><span class="pre">errno</span></code> variable, nor report any floating-point exceptions to indicate errors; thus, if error diagnostic mechanisms are required, the user should implement additional screening for inputs and outputs of the functions. The user is responsible for the validity of pointer arguments. The user must not pass uninitialized parameters to the Mathematical functions as this may result in undefined behavior: functions are inlined in the user program and thus are subject to compiler optimizations.</p>
<section id="standard-functions">
<span id="mathematical-functions-appendix-standard-functions"></span><h2><span class="section-number">14.1. </span>Standard Functions<a class="headerlink" href="#standard-functions" title="Permalink to this headline">ï</a></h2>
<p>The functions from this section can be used in both host and device code.</p>
<p>This section specifies the error bounds of each function when executed on the device and also when executed on the host in the case where the host does not supply the function.</p>
<p>The error bounds are generated from extensive but not exhaustive tests, so they are not guaranteed bounds.</p>
<p><strong>Single-Precision Floating-Point Functions</strong></p>
<p>Addition and multiplication are IEEE-compliant, so have a maximum error of 0.5 ulp.</p>
<p>The recommended way to round a single-precision floating-point operand to an integer, with the result being a single-precision floating-point number is <code class="docutils literal notranslate"><span class="pre">rintf()</span></code>, not <code class="docutils literal notranslate"><span class="pre">roundf()</span></code>. The reason is that <code class="docutils literal notranslate"><span class="pre">roundf()</span></code> maps to a 4-instruction sequence on the device, whereas <code class="docutils literal notranslate"><span class="pre">rintf()</span></code> maps to a single instruction. <code class="docutils literal notranslate"><span class="pre">truncf()</span></code>, <code class="docutils literal notranslate"><span class="pre">ceilf()</span></code>, and <code class="docutils literal notranslate"><span class="pre">floorf()</span></code> each map to a single instruction as well.</p>
<table class="table-no-stripes docutils align-default" id="id477">
<caption><span class="caption-number">Table 18 </span><span class="caption-text">Single-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded single-precision result obtained according to the round-to-nearest ties-to-even rounding mode.</span><a class="headerlink" href="#id477" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Maximum ulp error</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x+y</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x*y</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x/y</span></code></p></td>
<td><p>0 for compute capability <span class="math notranslate nohighlight">\(\ge 2\)</span> when compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code></p>
<p>2 (full range), otherwise</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1/x</span></code></p></td>
<td><p>0 for compute capability <span class="math notranslate nohighlight">\(\ge 2\)</span> when compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code></p>
<p>1 (full range), otherwise</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">rsqrtf(x)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">1/sqrtf(x)</span></code></p>
</td>
<td><p>2 (full range)</p>
<p>Applies to <code class="docutils literal notranslate"><span class="pre">1/sqrtf(x)</span></code> only when it is converted to <code class="docutils literal notranslate"><span class="pre">rsqrtf(x)</span></code> by the compiler.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sqrtf(x)</span></code></p></td>
<td><p>0 when compiled with <code class="docutils literal notranslate"><span class="pre">-prec-sqrt=true</span></code></p>
<p>Otherwise 1 for compute capability <span class="math notranslate nohighlight">\(\ge 5.2\)</span></p>
<p>and 3 for older architectures</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cbrtf(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rcbrtf(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">hypotf(x,y)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rhypotf(x,y)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm3df(x,y,z)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnorm3df(x,y,z)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm4df(x,y,z,t)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnorm4df(x,y,z,t)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">normf(dim,arr)</span></code></p></td>
<td><p>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off. .</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnormf(dim,arr)</span></code></p></td>
<td><p>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off. .</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">expf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">exp2f(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exp10f(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">expm1f(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">logf(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">log2f(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log10f(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">log1pf(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sinf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cosf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tanf(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sincosf(x,sptr,cptr)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sinpif(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cospif(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sincospif(x,sptr,cptr)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">asinf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">acosf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">atanf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">atan2f(y,x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sinhf(x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">coshf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tanhf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">asinhf(x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">acoshf(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">atanhf(x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">powf(x,y)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erff(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">erfcf(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erfinvf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">erfcinvf(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erfcxf(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">normcdff(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">normcdfinvf(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lgammaf(x)</span></code></p></td>
<td><p>6 (outside interval -10.001 â¦ -2.264; larger inside)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tgammaf(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">fmaf(x,y,z)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">frexpf(x,exp)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ldexpf(x,exp)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scalbnf(x,n)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">scalblnf(x,l)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">logbf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ilogbf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">j0f(x)</span></code></p></td>
<td><p>9 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 2.2 x 10<sup>-6</sup></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">j1f(x)</span></code></p></td>
<td><p>9 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 2.2 x 10<sup>-6</sup></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">jnf(n,x)</span></code></p></td>
<td><p>For n = 128, the maximum absolute error is 2.2 x 10<sup>-6</sup></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">y0f(x)</span></code></p></td>
<td><p>9 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 2.2 x 10<sup>-6</sup></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">y1f(x)</span></code></p></td>
<td><p>9 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 2.2 x 10<sup>-6</sup></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ynf(n,x)</span></code></p></td>
<td><p>ceil(2 + 2.5n) for |x| &lt; n</p>
<p>otherwise, the maximum absolute error is 2.2 x 10<sup>-6</sup></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cyl_bessel_i0f(x)</span></code></p></td>
<td><p>6 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cyl_bessel_i1f(x)</span></code></p></td>
<td><p>6 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fmodf(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">remainderf(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">remquof(x,y,iptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">modff(x,iptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fdimf(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">truncf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">roundf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rintf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nearbyintf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ceilf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">floorf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lrintf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lroundf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llrintf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llroundf(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
</tbody>
</table>
<p><strong>Double-Precision Floating-Point Functions</strong></p>
<p>The recommended way to round a double-precision floating-point operand to an integer, with the result being a double-precision floating-point number is <code class="docutils literal notranslate"><span class="pre">rint()</span></code>, not <code class="docutils literal notranslate"><span class="pre">round()</span></code>. The reason is that <code class="docutils literal notranslate"><span class="pre">round()</span></code> maps to a 5-instruction sequence on the device, whereas <code class="docutils literal notranslate"><span class="pre">rint()</span></code> maps to a single instruction. <code class="docutils literal notranslate"><span class="pre">trunc()</span></code>, <code class="docutils literal notranslate"><span class="pre">ceil()</span></code>, and <code class="docutils literal notranslate"><span class="pre">floor()</span></code> each map to a single instruction as well.</p>
<table class="table-no-stripes docutils align-default" id="id478">
<caption><span class="caption-number">Table 19 </span><span class="caption-text">Double-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded double-precision result obtained according to the round-to-nearest ties-to-even rounding mode.</span><a class="headerlink" href="#id478" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Maximum ulp error</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x+y</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x*y</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x/y</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">1/x</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sqrt(x)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rsqrt(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cbrt(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rcbrt(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">hypot(x,y)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rhypot(x,y)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm3d(x,y,z)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnorm3d(x,y,z)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm4d(x,y,z,t)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnorm4d(x,y,z,t)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">norm(dim,arr)</span></code></p></td>
<td><p>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rnorm(dim,arr)</span></code></p></td>
<td><p>An error bound cannot be provided because a fast algorithm is used with accuracy loss due to round-off.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exp(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">exp2(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">exp10(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">expm1(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">log2(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log10(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">log1p(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sin(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cos(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tan(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sincos(x,sptr,cptr)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sinpi(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cospi(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sincospi(x,sptr,cptr)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">asin(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">acos(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">atan(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">atan2(y,x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sinh(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cosh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tanh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">asinh(x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">acosh(x)</span></code></p></td>
<td><p>3 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">atanh(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pow(x,y)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erf(x)</span></code></p></td>
<td><p>2 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">erfc(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erfinv(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">erfcinv(x)</span></code></p></td>
<td><p>6 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">erfcx(x)</span></code></p></td>
<td><p>4 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">normcdf(x)</span></code></p></td>
<td><p>5 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">normcdfinv(x)</span></code></p></td>
<td><p>8 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lgamma(x)</span></code></p></td>
<td><p>4 (outside interval -23.0001 â¦ -2.2637; larger inside)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">tgamma(x)</span></code></p></td>
<td><p>10 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">fma(x,y,z)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">frexp(x,exp)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ldexp(x,exp)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scalbn(x,n)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">scalbln(x,l)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">logb(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ilogb(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">j0(x)</span></code></p></td>
<td><p>7 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 5 x 10<sup>-12</sup></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">j1(x)</span></code></p></td>
<td><p>7 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 5 x 10<sup>-12</sup></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">jn(n,x)</span></code></p></td>
<td><p>For n = 128, the maximum absolute error is 5 x 10<sup>-12</sup></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">y0(x)</span></code></p></td>
<td><p>7 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 5 x 10<sup>-12</sup></p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">y1(x)</span></code></p></td>
<td><p>7 for |x| &lt; 8</p>
<p>otherwise, the maximum absolute error is 5 x 10<sup>-12</sup></p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">yn(n,x)</span></code></p></td>
<td><p>For |x| &gt; 1.5n, the maximum absolute error is 5 x 10<sup>-12</sup></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cyl_bessel_i0(x)</span></code></p></td>
<td><p>6 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cyl_bessel_i1(x)</span></code></p></td>
<td><p>6 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fmod(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">remainder(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">remquo(x,y,iptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">modf(x,iptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fdim(x,y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">trunc(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">round(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">rint(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">nearbyint(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ceil(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">floor(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lrint(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lround(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">llrint(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">llround(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
</tbody>
</table>
<p><strong>Quad-Precision Floating-Point Functions</strong></p>
<p>Note that the quad-precision mathematical functions are currently only available to devices with compute capability 10.0 and later.
Due to the specifics of implementation, the support of <code class="docutils literal notranslate"><span class="pre">__float128</span></code> and <code class="docutils literal notranslate"><span class="pre">_Float128</span></code> types in device code is also limited to select combinations of host platforms, see also <a class="reference internal" href="#host-compiler-extensions"><span class="std std-ref">Host Compiler Extensions</span></a>.</p>
<table class="table-no-stripes docutils align-default" id="id479">
<caption><span class="caption-number">Table 20 </span><span class="caption-text">Quad-Precision Mathematical Standard Library Functions with Maximum ULP Error. The maximum error is stated as the absolute value of the difference in ulps between the result returned by the CUDA library function and a correctly rounded quad-precision result obtained according to the round-to-nearest ties-to-even rounding mode.</span><a class="headerlink" href="#id479" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Maximum ulp error</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x+y</span></code>
<code class="docutils literal notranslate"><span class="pre">__nv_fp128_add(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x-y</span></code>
<code class="docutils literal notranslate"><span class="pre">__nv_fp128_sub(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x*y</span></code>
<code class="docutils literal notranslate"><span class="pre">__nv_fp128_mul(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">x/y</span></code>
<code class="docutils literal notranslate"><span class="pre">__nv_fp128_div(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_sqrt(x)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fma(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p></td>
<td><p>0 (IEEE-754 round-to-nearest-even)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_sin(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_cos(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_tan(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_asin(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_acos(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_atan(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_exp(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_exp2(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_exp10(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_expm1(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_log(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_log2(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_log10(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_log1p(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_pow(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_sinh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_cosh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_tanh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_asinh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_acosh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_atanh(x)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_hypot(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>1 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_ceil(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_trunc(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_floor(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_round(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_rint(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fabs(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_copysign(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fmax(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fmin(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fdim(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_fmod(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_remainder(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_frexp(x,</span> <span class="pre">nptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_modf(x,</span> <span class="pre">iptr)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_ldexp(x,</span> <span class="pre">exp)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__nv_fp128_ilogb(x)</span></code></p></td>
<td><p>0 (full range)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="intrinsic-functions">
<span id="mathematical-functions-appendix-intrinsic-functions"></span><h2><span class="section-number">14.2. </span>Intrinsic Functions<a class="headerlink" href="#intrinsic-functions" title="Permalink to this headline">ï</a></h2>
<p>The functions from this section can only be used in device code.</p>
<p>Among these functions are the less accurate, but faster versions of some of the functions of <a class="reference internal" href="#mathematical-functions-appendix-standard-functions"><span class="std std-ref">Standard Functions</span></a>.
They have the same name prefixed with <code class="docutils literal notranslate"><span class="pre">__</span></code> (such as <code class="docutils literal notranslate"><span class="pre">__sinf(x)</span></code>).
They are faster as they map to fewer native instructions.
The compiler has an option (<code class="docutils literal notranslate"><span class="pre">-use_fast_math</span></code>) that forces each function in <a class="reference internal" href="#intrinsic-functions-functions-affected-use-fast-math"><span class="std std-numref">Table 21</span></a>
to compile to its intrinsic counterpart. In addition to reducing the accuracy of the affected functions,
it may also cause some differences in special case handling. A more robust approach is to selectively replace
mathematical function calls by calls to intrinsic functions only where it is merited by the performance gains
and where changed properties such as reduced accuracy and different special case handling can be tolerated.</p>
<table class="table-no-stripes docutils align-default" id="intrinsic-functions-functions-affected-use-fast-math">
<caption><span class="caption-number">Table 21 </span><span class="caption-text">Functions Affected by -use_fast_math</span><a class="headerlink" href="#intrinsic-functions-functions-affected-use-fast-math" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 48%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operator/Function</p></th>
<th class="head"><p>Device Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x/y</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__fdividef(x,y)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sinf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__sinf(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cosf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__cosf(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tanf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__tanf(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sincosf(x,sptr,cptr)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__sincosf(x,sptr,cptr)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">logf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__logf(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">log2f(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__log2f(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">log10f(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__log10f(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">expf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__expf(x)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">exp10f(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__exp10f(x)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">powf(x,y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__powf(x,y)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">tanhf(x)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">__tanhf(x)</span></code></p></td>
</tr>
</tbody>
</table>
<p><strong>Single-Precision Floating-Point Functions</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__fadd_[rn,rz,ru,rd]()</span></code> and <code class="docutils literal notranslate"><span class="pre">__fmul_[rn,rz,ru,rd]()</span></code> map to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the â*â and â+â operators will frequently be combined into FMADs.</p>
<p>Functions suffixed with <code class="docutils literal notranslate"><span class="pre">_rn</span></code> operate using the round to nearest even rounding mode.</p>
<p>Functions suffixed with <code class="docutils literal notranslate"><span class="pre">_rz</span></code> operate using the round towards zero rounding mode.</p>
<p>Functions suffixed with <code class="docutils literal notranslate"><span class="pre">_ru</span></code> operate using the round up (to positive infinity) rounding mode.</p>
<p>Functions suffixed with <code class="docutils literal notranslate"><span class="pre">_rd</span></code> operate using the round down (to negative infinity) rounding mode.</p>
<p>The accuracy of floating-point division varies depending on whether the code is compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=false</span></code>
or <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code>. When the code is compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=false</span></code>, both the regular division <code class="docutils literal notranslate"><span class="pre">/</span></code>
operator and <code class="docutils literal notranslate"><span class="pre">__fdividef(x,y)</span></code> have the same accuracy, but for 2<sup>126</sup> &lt; <code class="docutils literal notranslate"><span class="pre">|y|</span></code> &lt; 2<sup>128</sup>,
<code class="docutils literal notranslate"><span class="pre">__fdividef(x,y)</span></code> delivers a result of zero, whereas the <code class="docutils literal notranslate"><span class="pre">/</span></code> operator delivers the correct result to
within the accuracy stated in <a class="reference internal" href="#intrinsic-functions-single-precision-floating-point-intrinsic-functions-supported-by-cuda-runtime-library"><span class="std std-numref">Table 22</span></a>.
Also, for 2<sup>126</sup> &lt; <code class="docutils literal notranslate"><span class="pre">|y|</span></code> &lt; 2<sup>128</sup>, if <code class="docutils literal notranslate"><span class="pre">x</span></code> is infinity, <code class="docutils literal notranslate"><span class="pre">__fdividef(x,y)</span></code> delivers
a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> (as a result of multiplying infinity by zero), while the <code class="docutils literal notranslate"><span class="pre">/</span></code> operator returns infinity.
On the other hand, the <code class="docutils literal notranslate"><span class="pre">/</span></code> operator is IEEE-compliant when the code is compiled with <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code>
or without any <code class="docutils literal notranslate"><span class="pre">-prec-div</span></code> option at all since its default value is true.</p>
<table class="table-no-stripes docutils align-default" id="intrinsic-functions-single-precision-floating-point-intrinsic-functions-supported-by-cuda-runtime-library">
<caption><span class="caption-number">Table 22 </span><span class="caption-text">Single-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)</span><a class="headerlink" href="#intrinsic-functions-single-precision-floating-point-intrinsic-functions-supported-by-cuda-runtime-library" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Error bounds</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__fadd_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__fsub_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__fmul_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__fmaf_[rn,rz,ru,rd](x,y,z)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__frcp_[rn,rz,ru,rd](x)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__fsqrt_[rn,rz,ru,rd](x)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__frsqrt_rn(x)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__fdiv_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__fdividef(x,y)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">|y|</span></code> in [<span class="math notranslate nohighlight">\(2^{-126}, 2^{126}\)</span>], the maximum ulp error is 2.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__expf(x)</span></code></p></td>
<td><p>The maximum ulp error is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">floor(abs(1.173</span> <span class="pre">*</span> <span class="pre">x))</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__exp10f(x)</span></code></p></td>
<td><p>The maximum ulp error is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">floor(abs(2.97</span> <span class="pre">*</span> <span class="pre">x))</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__logf(x)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0.5, 2], the maximum absolute error is <span class="math notranslate nohighlight">\(2^{-21.41}\)</span>, otherwise, the maximum ulp error is 3.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__log2f(x)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0.5, 2], the maximum absolute error is <span class="math notranslate nohighlight">\(2^{-22}\)</span>, otherwise, the maximum ulp error is 2.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__log10f(x)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">x</span></code> in [0.5, 2], the maximum absolute error is <span class="math notranslate nohighlight">\(2^{-24}\)</span>, otherwise, the maximum ulp error is 3.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__sinf(x)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">x</span></code> in [<span class="math notranslate nohighlight">\(-\pi, \pi\)</span>], the maximum absolute error is <span class="math notranslate nohighlight">\(2^{-21.41}\)</span>, and larger otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__cosf(x)</span></code></p></td>
<td><p>For <code class="docutils literal notranslate"><span class="pre">x</span></code> in [<span class="math notranslate nohighlight">\(-\pi, \pi\)</span>], the maximum absolute error is <span class="math notranslate nohighlight">\(2^{-21.19}\)</span>, and larger otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__sincosf(x,sptr,cptr)</span></code></p></td>
<td><p>Same as <code class="docutils literal notranslate"><span class="pre">__sinf(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">__cosf(x)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__tanf(x)</span></code></p></td>
<td><p>Derived from its implementation as <code class="docutils literal notranslate"><span class="pre">__sinf(x)</span> <span class="pre">*</span> <span class="pre">(1/__cosf(x))</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__powf(x,</span> <span class="pre">y)</span></code></p></td>
<td><p>Derived from its implementation as <code class="docutils literal notranslate"><span class="pre">exp2f(y</span> <span class="pre">*</span> <span class="pre">__log2f(x))</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__tanhf(x)</span></code></p></td>
<td><p>The maximum relative error of the current implementation is <span class="math notranslate nohighlight">\(2^{-11}\)</span>.
Subnormal results of this fast intrinsic are not flushed to zero even under <code class="docutils literal notranslate"><span class="pre">-ftz=true</span></code> compiler setting.
Available for devices with compute capability of at least 7.5;
and defaults to regular <code class="docutils literal notranslate"><span class="pre">tanhf()</span></code> function behavior on other devices.</p></td>
</tr>
</tbody>
</table>
<p><strong>Double-Precision Floating-Point Functions</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">__dadd_rn()</span></code> and <code class="docutils literal notranslate"><span class="pre">__dmul_rn()</span></code> map to addition and multiplication operations that the compiler never merges into FMADs. By contrast, additions and multiplications generated from the â*â and â+â operators will frequently be combined into FMADs.</p>
<table class="table-no-stripes docutils align-default" id="id480">
<caption><span class="caption-number">Table 23 </span><span class="caption-text">Double-Precision Floating-Point Intrinsic Functions. (Supported by the CUDA Runtime Library with Respective Error Bounds)</span><a class="headerlink" href="#id480" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Error bounds</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__dadd_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__dsub_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__dmul_[rn,rz,ru,rd](x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__fma_[rn,rz,ru,rd](x,y,z)</span></code></p></td>
<td><p>IEEE-compliant.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__ddiv_[rn,rz,ru,rd](x,y)(x,y)</span></code></p></td>
<td><p>IEEE-compliant.</p>
<p>Requires compute capability <em>&gt;</em> 2.</p>
</td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__drcp_[rn,rz,ru,rd](x)</span></code></p></td>
<td><p>IEEE-compliant.</p>
<p>Requires compute capability <em>&gt;</em> 2.</p>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__dsqrt_[rn,rz,ru,rd](x)</span></code></p></td>
<td><p>IEEE-compliant.</p>
<p>Requires compute capability <em>&gt;</em> 2.</p>
</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="c-language-support">
<span id="c-cplusplus-language-support"></span><h1><span class="section-number">15. </span>C++ Language Support<a class="headerlink" href="#c-language-support" title="Permalink to this headline">ï</a></h1>
<p>As described in <a class="reference internal" href="#compilation-with-nvcc"><span class="std std-ref">Compilation with NVCC</span></a>, CUDA source files compiled with <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> can include a mix of host code and device code. The CUDA front-end compiler aims to emulate the host compiler behavior with respect to C++ input code. The input source code is processed according to the C++ ISO/IEC 14882:2003, C++ ISO/IEC 14882:2011, C++ ISO/IEC 14882:2014 or C++ ISO/IEC 14882:2017 specifications, and the CUDA front-end compiler aims to emulate any host compiler divergences from the ISO specification. In addition, the supported language is extended with CUDA-specific constructs described in this document <a class="footnote-reference brackets" href="#fn13" id="id322">13</a>, and is subject to the restrictions described below.</p>
<p><a class="reference internal" href="#cpp11-language-features"><span class="std std-ref">C++11 Language Features</span></a>, <a class="reference internal" href="#cpp14-language-features"><span class="std std-ref">C++14 Language Features</span></a> and <a class="reference internal" href="#cpp17-language-features"><span class="std std-ref">C++17 Language Features</span></a> provide support matrices for the C++11, C++14, C++17 and C++20 features, respectively. <a class="reference internal" href="#language-restrictions"><span class="std std-ref">Restrictions</span></a> lists the language restrictions. <a class="reference internal" href="#polymorphic-function-wrappers"><span class="std std-ref">Polymorphic Function Wrappers</span></a> and <a class="reference internal" href="#extended-lambda"><span class="std std-ref">Extended Lambdas</span></a> describe additional features. <a class="reference internal" href="#code-samples"><span class="std std-ref">Code Samples</span></a> gives code samples.</p>
<section id="c-11-language-features">
<span id="cpp11-language-features"></span><h2><span class="section-number">15.1. </span>C++11 Language Features<a class="headerlink" href="#c-11-language-features" title="Permalink to this headline">ï</a></h2>
<p>The following table lists new language features that have been accepted into the C++11 standard. The âProposalâ column provides a link to the ISO C++ committee proposal that describes the feature, while the âAvailable in nvcc (device code)â column indicates the first version of nvcc that contains an implementation of this feature (if it has been implemented) for device code.</p>
<table class="table-no-stripes colwidths-given docutils align-default" id="id481">
<caption><span class="caption-number">Table 24 </span><span class="caption-text">C++11 Language Features</span><a class="headerlink" href="#id481" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 60%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Feature</p></th>
<th class="head"><p>C++11 Proposal</p></th>
<th class="head"><p>Available in nvcc (device code)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Rvalue references</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html">N2118</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Â  Rvalue references for <code class="docutils literal notranslate"><span class="pre">*this</span></code></p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm">N2439</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Initialization of class objects by rvalues</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1610.html">N1610</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Non-static data member initializers</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2756.htm">N2756</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Variadic templates</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf">N2242</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Â  Extending variadic template template parameters</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2555.pdf">N2555</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Initializer lists</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm">N2672</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Static assertions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">N1720</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">auto</span></code>-typed variables</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">N1984</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Â  Â  Â  Â  Multi-declarator <code class="docutils literal notranslate"><span class="pre">auto</span></code></p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1737.pdf">N1737</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Â  Â  Â  Â  Removal of auto as a storage-class specifier</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2546.htm">N2546</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Â  Â  Â  Â  New function declarator syntax</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm">N2541</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Lambda expressions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2927.pdf">N2927</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Declared type of an expression</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">N2343</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Â  Â  Â  Â  Incomplete return types</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf">N3276</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Right angle brackets</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">N1757</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Default template arguments for function templates</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#226">DR226</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Solving the SFINAE problem for expressions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html">DR339</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Alias templates</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">N2258</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Extern templates</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1987.htm">N1987</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Null pointer constant</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">N2431</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Strongly-typed enums</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Forward declarations for enums</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2764.pdf">N2764</a>
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1206">DR1206</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Standardized attribute syntax</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf">N2761</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Generalized constant expressions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">N2235</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Alignment support</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2341.pdf">N2341</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Conditionally-support behavior</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1627.pdf">N1627</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Changing undefined behavior into diagnosable errors</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1727.pdf">N1727</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Delegating constructors</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">N1986</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Inheriting constructors</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm">N2540</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Explicit conversion operators</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2437.pdf">N2437</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>New character types</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2249.html">N2249</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Unicode string literals</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Raw string literals</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">N2442</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Universal character names in literals</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2170.html">N2170</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>User-defined literals</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf">N2765</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Standard Layout Types</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2342.htm">N2342</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Defaulted functions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Deleted functions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2346.htm">N2346</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Extended friend declarations</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1791.pdf">N1791</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Extending <code class="docutils literal notranslate"><span class="pre">sizeof</span></code></p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2253.html">N2253</a>
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#850">DR850</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Inline namespaces</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm">N2535</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Unrestricted unions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">N2544</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Local and unnamed types as template arguments</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm">N2657</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Range-based for</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2930.html">N2930</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p>Explicit virtual overrides</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2928.htm">N2928</a>
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm">N3206</a>
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm">N3272</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Minimal support for garbage collection and reachability-based leak detection</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm">N2670</a></p></td>
<td><p>N/A (see <a class="reference internal" href="#language-restrictions"><span class="std std-ref">Restrictions</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><p>Allowing move constructors to throw [noexcept]</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">N3050</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Defining move special member functions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html">N3053</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td colspan="3"><p><strong>Concurrency</strong></p></td>
</tr>
<tr class="row-even"><td><p>Sequence points</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2239.html">N2239</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Atomic operations</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2427.html">N2427</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Strong Compare and Exchange</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html">N2748</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Bidirectional Fences</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2752.htm">N2752</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Memory model</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2429.htm">N2429</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Data-dependency ordering: atomics and memory model</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2664.htm">N2664</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Propagating exceptions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2179.html">N2179</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Allow atomics use in signal handlers</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2547.htm">N2547</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>Thread-local storage</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">N2659</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Dynamic initialization and destruction with concurrency</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">N2660</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td colspan="3"><p><strong>C99 Features in C++11</strong></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__func__</span></code> predefined identifier</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2340.htm">N2340</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>C99 preprocessor</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1653.htm">N1653</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code></p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf">N1811</a></p></td>
<td><p>7.0</p></td>
</tr>
<tr class="row-even"><td><p>Extended integral types</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1988.pdf">N1988</a></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="c-14-language-features">
<span id="cpp14-language-features"></span><h2><span class="section-number">15.2. </span>C++14 Language Features<a class="headerlink" href="#c-14-language-features" title="Permalink to this headline">ï</a></h2>
<p>The following table lists new language features that have been accepted into the C++14 standard.</p>
<table class="docutils align-default" id="id482">
<caption><span class="caption-number">Table 25 </span><span class="caption-text">C++14 Language Features</span><a class="headerlink" href="#id482" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 50%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Language Feature</p></th>
<th class="head"><p>C++14 Proposal</p></th>
<th class="head"><p>Available in nvcc (device code)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Tweak to certain C++ contextual conversions</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf">N3323</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-odd"><td><p>Binary literals</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3472.pdf">N3472</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-even"><td><p>Functions with deduced return type</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/N3638.html">N3638</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-odd"><td><p>Generalized lambda capture (init-capture)</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/N3648.html">N3648</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-even"><td><p>Generic (polymorphic) lambda expressions</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/N3649.html">N3649</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-odd"><td><p>Variable templates</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/N3651.pdf">N3651</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-even"><td><p>Relaxing requirements on constexpr functions</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/N3652.html">N3652</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-odd"><td><p>Member initializers and aggregates</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3653.html">N3653</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-even"><td><p>Clarifying memory allocation</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html">N3664</a></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>Sized deallocation</p></td>
<td><p><a class="reference external" href="https://isocpp.org/files/papers/n3778.html">N3778</a></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">[[deprecated]]</span></code> attribute</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3760.html">N3760</a></p></td>
<td><p>9.0</p></td>
</tr>
<tr class="row-odd"><td><p>Single-quotation-mark as a digit separator</p></td>
<td><p><a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3781.pdf">N3781</a></p></td>
<td><p>9.0</p></td>
</tr>
</tbody>
</table>
</section>
<section id="c-17-language-features">
<span id="cpp17-language-features"></span><h2><span class="section-number">15.3. </span>C++17 Language Features<a class="headerlink" href="#c-17-language-features" title="Permalink to this headline">ï</a></h2>
<p>All C++17 language features are supported in nvcc version 11.0 and later, subject to restrictions described <a class="reference internal" href="#cpp17"><span class="std std-ref">here</span></a>.</p>
</section>
<section id="c-20-language-features">
<span id="cpp20-language-features"></span><h2><span class="section-number">15.4. </span>C++20 Language Features<a class="headerlink" href="#c-20-language-features" title="Permalink to this headline">ï</a></h2>
<p>All C++20 language features are supported in nvcc version 12.0 and later, subject to restrictions described <a class="reference internal" href="#cpp20"><span class="std std-ref">here</span></a>.</p>
</section>
<section id="language-restrictions">
<span id="id323"></span><h2><span class="section-number">15.5. </span>Restrictions<a class="headerlink" href="#language-restrictions" title="Permalink to this headline">ï</a></h2>
<section id="host-compiler-extensions">
<span id="id324"></span><h3><span class="section-number">15.5.1. </span>Host Compiler Extensions<a class="headerlink" href="#host-compiler-extensions" title="Permalink to this headline">ï</a></h3>
<p>Host compiler specific language extensions are not supported in device code.</p>
<p><code class="docutils literal notranslate"><span class="pre">__Complex</span></code> types are only supported in host code.</p>
<p><code class="docutils literal notranslate"><span class="pre">__int128</span></code> type is supported in device code when compiled in conjunction with a host compiler that supports it.</p>
<p><code class="docutils literal notranslate"><span class="pre">__float128</span></code> type is supported for devices with compute capability 10.0 and later, when compiled in conjunction with a host compiler that supports the type. A constant expression of <code class="docutils literal notranslate"><span class="pre">__float128</span></code> type may be processed by the compiler in a floating point representation with lower precision.</p>
</section>
<section id="preprocessor-symbols">
<span id="id325"></span><h3><span class="section-number">15.5.2. </span>Preprocessor Symbols<a class="headerlink" href="#preprocessor-symbols" title="Permalink to this headline">ï</a></h3>
<section id="cuda-arch">
<span id="cuda-arch-macro"></span><h4><span class="section-number">15.5.2.1. </span>__CUDA_ARCH__<a class="headerlink" href="#cuda-arch" title="Permalink to this headline">ï</a></h4>
<ol class="arabic">
<li><p>The type signature of the following entities shall not depend on whether <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined or not, or on a particular value of <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions and function templates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__device__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables</p></li>
<li><p>textures and surfaces</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if !defined(__CUDA_ARCH__)</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mytype</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">mytype</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="n">__device__</span><span class="w"> </span><span class="n">mytype</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w">         </span><span class="c1">// error: xxx&#39;s type depends on __CUDA_ARCH__</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">mytype</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="c1">// error: foo&#39;s type depends on __CUDA_ARCH__</span>
<span class="w">                    </span><span class="n">mytype</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>If a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template is instantiated and launched from the host, then the function template must be instantiated with the same template arguments irrespective of whether <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined and regardless of the value of <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#if !defined(__CUDA_ARCH__)</span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">      </span><span class="c1">// error: &quot;kern&lt;int&gt;&quot; instantiation only</span>
<span class="w">                         </span><span class="c1">// when __CUDA_ARCH__ is undefined!</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>In separate compilation mode, the presence or absence of a definition of a function or variable with external linkage shall not depend on whether <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined or on a particular value of <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code><a class="footnote-reference brackets" href="#fn14" id="id326">14</a>.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if !defined(__CUDA_ARCH__)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">                  </span><span class="c1">// error: The definition of foo()</span>
<span class="w">                                    </span><span class="c1">// is only present when __CUDA_ARCH__</span>
<span class="w">                                    </span><span class="c1">// is undefined</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</li>
<li><p>In separate compilation, <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> must not be used in headers such that different objects could contain different behavior. Or, it must be guaranteed that all objects will compile for the same compute_arch. If a weak function or template function is defined in a header and its behavior depends on <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>, then the instances of that function in the objects could conflict if the objects are compiled for different compute arch.</p>
<p>For example, if an a.h contains:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">getptr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="cp">#if __CUDA_ARCH__ == 700</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="cm">/* no address */</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">  </span><span class="n">__shared__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Then if <code class="docutils literal notranslate"><span class="pre">a.cu</span></code> and <code class="docutils literal notranslate"><span class="pre">b.cu</span></code> both include <code class="docutils literal notranslate"><span class="pre">a.h</span></code> and instantiate <code class="docutils literal notranslate"><span class="pre">getptr</span></code> for the same type, and <code class="docutils literal notranslate"><span class="pre">b.cu</span></code> expects a non-NULL address, and compile with:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>nvcc âarch=compute_70 âdc a.cu
nvcc âarch=compute_80 âdc b.cu
nvcc âarch=sm_80 a.o b.o
</pre></div>
</div>
<p>At link time only one version of the <code class="docutils literal notranslate"><span class="pre">getptr</span></code> is used, so the behavior would depend on which version is chosen. To avoid this, either <code class="docutils literal notranslate"><span class="pre">a.cu</span></code> and <code class="docutils literal notranslate"><span class="pre">b.cu</span></code> must be compiled for the same compute arch, or <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> should not be used in the shared header function.</p>
</li>
</ol>
<p>The compiler does not guarantee that a diagnostic will be generated for the unsupported uses of <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> described above.</p>
</section>
</section>
<section id="qualifiers">
<span id="id327"></span><h3><span class="section-number">15.5.3. </span>Qualifiers<a class="headerlink" href="#qualifiers" title="Permalink to this headline">ï</a></h3>
<section id="device-memory-space-specifiers">
<span id="device-memory-specifiers"></span><h4><span class="section-number">15.5.3.1. </span>Device Memory Space Specifiers<a class="headerlink" href="#device-memory-space-specifiers" title="Permalink to this headline">ï</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code>, <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> memory space specifiers are not allowed on:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">struct</span></code>, and <code class="docutils literal notranslate"><span class="pre">union</span></code> data members,</p></li>
<li><p>formal parameters,</p></li>
<li><p>non-extern variable declarations within a function that executes on the host.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> and <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> memory space specifiers are not allowed on variable declarations that are neither extern nor static within a function that executes on the device.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__constant__</span></code>, <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> or <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variable definition cannot have a class type with a non-empty constructor or a non-empty destructor. A constructor for a class type is considered empty at a point in the translation unit, if it is either a trivial constructor or it satisfies all of the following conditions:</p>
<ul class="simple">
<li><p>The constructor function has been defined.</p></li>
<li><p>The constructor function has no parameters, the initializer list is empty and the function body is an empty compound statement.</p></li>
<li><p>Its class has no virtual functions, no virtual base classes and no non-static data member initializers.</p></li>
<li><p>The default constructors of all base classes of its class can be considered empty.</p></li>
<li><p>For all the nonstatic data members of its class that are of class type (or array thereof), the default constructors can be considered empty.</p></li>
</ul>
<p>A destructor for a class is considered empty at a point in the translation unit, if it is either a trivial destructor or it satisfies all of the following conditions:</p>
<ul class="simple">
<li><p>The destructor function has been defined.</p></li>
<li><p>The destructor function body is an empty compound statement.</p></li>
<li><p>Its class has no virtual functions and no virtual base classes.</p></li>
<li><p>The destructors of all base classes of its class can be considered empty.</p></li>
<li><p>For all the nonstatic data members of its class that are of class type (or array thereof), the destructor can be considered empty.</p></li>
</ul>
<p>When compiling in the whole program compilation mode (see the nvcc user manual for a description of this mode), <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code>, <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables cannot be defined as external using the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword. The only exception is for dynamically allocated <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variables as described in <a class="reference internal" href="#shared"><span class="std std-ref">__shared__</span></a>.</p>
<p>When compiling in the separate compilation mode (see the nvcc user manual for a description of this mode), <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code>, <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables can be defined as external using the <code class="docutils literal notranslate"><span class="pre">extern</span></code> keyword. <code class="docutils literal notranslate"><span class="pre">nvlink</span></code> will generate an error when it cannot find a definition for an external variable (unless it is a dynamically allocated <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variable).</p>
</section>
<section id="managed-memory-space-specifier">
<span id="managed-specifier"></span><h4><span class="section-number">15.5.3.2. </span>__managed__ Memory Space Specifier<a class="headerlink" href="#managed-memory-space-specifier" title="Permalink to this headline">ï</a></h4>
<p>Variables marked with the <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> memory space specifier (âmanagedâ variables) have the following restrictions:</p>
<ul class="simple">
<li><p>The address of a managed variable is not a constant expression.</p></li>
<li><p>A managed variable shall not have a const qualified type.</p></li>
<li><p>A managed variable shall not have a reference type.</p></li>
<li><p>The address or value of a managed variable shall not be used when the CUDA runtime may not be in a valid state, including the following cases:</p>
<ul>
<li><p>In static/dynamic initialization or destruction of an object with static or thread local storage duration.</p></li>
<li><p>In code that executes after exit() has been called (for example, a function marked with gccâs â<code class="docutils literal notranslate"><span class="pre">__attribute__((destructor))</span></code>â).</p></li>
<li><p>In code that executes when CUDA runtime may not be initialized (for example, a function marked with gccâs â<code class="docutils literal notranslate"><span class="pre">__attribute__((constructor))</span></code>â).</p></li>
</ul>
</li>
<li><p>A managed variable cannot be used as an unparenthesized id-expression argument to a <code class="docutils literal notranslate"><span class="pre">decltype()</span></code> expression.</p></li>
<li><p>Managed variables have the same coherence and consistency behavior as specified for dynamically allocated managed memory.</p></li>
<li><p>When a CUDA program containing managed variables is run on an execution platform with multiple GPUs, the variables are allocated only once, and not per GPU.</p></li>
<li><p>A managed variable declaration without the extern linkage is not allowed within a function that executes on the host.</p></li>
<li><p>A managed variable declaration without the extern or static linkage is not allowed within a function that executes on the device.</p></li>
</ul>
<p>Here are examples of legal and illegal uses of managed variables:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">         </span><span class="c1">// OK</span>

<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xxx</span><span class="p">;</span><span class="w">                             </span><span class="c1">// error: use of managed variable</span>
<span class="w">                                             </span><span class="c1">// (xxx) in static initialization</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">field</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">S1_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">field</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S2_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">~</span><span class="n">S2_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">S1_t</span><span class="w"> </span><span class="n">temp1</span><span class="p">;</span><span class="w">                                 </span><span class="c1">// error: use of managed variable</span>
<span class="w">                                            </span><span class="c1">// (xxx) in dynamic initialization</span>

<span class="n">S2_t</span><span class="w"> </span><span class="n">temp2</span><span class="p">;</span><span class="w">                                 </span><span class="c1">// error: use of managed variable</span>
<span class="w">                                            </span><span class="c1">// (xxx) in the destructor of</span>
<span class="w">                                            </span><span class="c1">// object with static storage</span>
<span class="w">                                            </span><span class="c1">// duration</span>

<span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">  </span><span class="c1">// error: const qualified type</span>

<span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zzz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w">      </span><span class="c1">// error: reference type</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S3_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">S3_t</span><span class="o">&lt;&amp;</span><span class="n">xxx</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">                            </span><span class="c1">// error: address of managed</span>
<span class="w">                                            </span><span class="c1">// variable(xxx) not a</span>
<span class="w">                                            </span><span class="c1">// constant expression</span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xxx</span><span class="p">);</span><span class="w">                      </span><span class="c1">// OK</span>
<span class="w">  </span><span class="n">xxx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">                                 </span><span class="c1">// OK</span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xxx</span><span class="p">;</span><span class="w">                          </span><span class="c1">// OK</span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">xxx</span><span class="o">++</span><span class="p">;</span><span class="w">                                    </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">decltype</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="w"> </span><span class="n">qqq</span><span class="p">;</span><span class="w">                        </span><span class="c1">// error: managed variable(xxx) used</span>
<span class="w">                                            </span><span class="c1">// as unparenthized argument to</span>
<span class="w">                                            </span><span class="c1">// decltype</span>

<span class="w">  </span><span class="k">decltype</span><span class="p">((</span><span class="n">xxx</span><span class="p">))</span><span class="w"> </span><span class="n">zzz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w">                </span><span class="c1">// OK</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="volatile-qualifier">
<span id="id328"></span><h4><span class="section-number">15.5.3.3. </span>Volatile Qualifier<a class="headerlink" href="#volatile-qualifier" title="Permalink to this headline">ï</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">volatile</span></code> keyword is supported to maintain compatibility with ISO C++; however, few if any of its <a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.html#prop">remaining non-deprecated uses</a> apply to GPUs.</p>
</div>
<p>Reads and writes to volatile qualified objects are not atomic, and are compiled to one or more <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#volatile-operation">.volatile instructions</a> which do NOT guarantee:</p>
<ul class="simple">
<li><p>ordering of memory operations, or</p></li>
<li><p>that the number of memory operations performed by the HW matches the number of PTX instructions.</p></li>
</ul>
<p>That is, CUDA C++ volatile is not suitable for:</p>
<ul>
<li><p><strong>Inter-Thread Synchronization</strong>: use atomic operations via <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/synchronization_primitives/atomic_ref.html">cuda::atomic_ref</a>, <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/synchronization_primitives/atomic.html">cuda::atomic</a>, or <a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a> instead.
Atomic memory operations provide inter-thread synchronization guarantees and deliver much better performance than volatile operations.
CUDA C++ volatile operations do not provide any inter-thread synchronization guarantees and are therefore not correct for inter-thread synchronization.
The following example shows how to pass a message across two threads using atomic operations.</p>
<blockquote>
<div><div class="sd-tab-set docutils">
<input checked="checked" id="5b249230-61bb-40e8-ad29-755f2b33133e" name="4d50f473-69aa-4f96-a62e-0c91aeec855d" type="radio">
</input><label class="sd-tab-label" for="5b249230-61bb-40e8-ad29-755f2b33133e">
cuda::atomic_ref</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-cuda-atomic-ref">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_device</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">{</span><span class="o">*</span><span class="n">flag</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Consumer: blocks until flag is set by producer, then reads data</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">__trap</span><span class="p">();</span><span class="w"> </span><span class="c1">// Errors if wrong data read</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Producer: writes data then sets flag</span>
<span class="w">    </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<input id="b1832b0a-23ad-443c-b3d6-1a8eff844718" name="4d50f473-69aa-4f96-a62e-0c91aeec855d" type="radio">
</input><label class="sd-tab-label" for="b1832b0a-23ad-443c-b3d6-1a8eff844718">
cuda::atomic</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-cuda-atomic">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">thread_scope_device</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Consumer: blocks until flag is set by producer, then reads data</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">flag</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">__trap</span><span class="p">();</span><span class="w"> </span><span class="c1">// Errors if wrong data read</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Producer: writes data then sets flag</span>
<span class="w">    </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">flag</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cuda</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<input id="b54ec4b3-a8d1-46c9-9a8a-72a70b191759" name="4d50f473-69aa-4f96-a62e-0c91aeec855d" type="radio">
</input><label class="sd-tab-label" for="b54ec4b3-a8d1-46c9-9a8a-72a70b191759">
Atomic Functions (<code class="docutils literal notranslate"><span class="pre">atomicAdd</span></code> and <code class="docutils literal notranslate"><span class="pre">atomicExch</span></code>)</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-atomic-functions">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Consumer: blocks until flag is set by producer, then reads data</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">atomicAdd</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Load with Relaxed Read-Modify-Write</span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">                </span><span class="c1">// SequentiallyConsistent fence</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">__trap</span><span class="p">();</span><span class="w">      </span><span class="c1">// Errors if wrong data read</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Producer: writes data then sets flag</span>
<span class="w">    </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="nf">__threadfence</span><span class="p">();</span><span class="w">     </span><span class="c1">// SequentiallyConsistent fence</span>
<span class="w">    </span><span class="n">atomicExch</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Store with Relaxed Read-Modify-Write</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div></blockquote>
</li>
<li><p><strong>Memory Mapped IO</strong> (MMIO): use <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#mmio-operation">PTX MMIO operations</a> via inline PTX instead.
PTX MMIO operations strictly preserve the number of memory accesses performed.
CUDA C++ <code class="docutils literal notranslate"><span class="pre">volatile</span></code> operations do not preserve the number of memory accesses performed, and may perform more or less accesses than requested in a non-deterministic way, making them incorrect for MMIO.
The following example shows how to read and write from a register using PTX mmio operations.</p>
<blockquote>
<div><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">mmio_reg0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">mmio_reg1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Write to MMIO register:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;st.relaxed.mmio.sys.u32 [%0], %1;&quot;</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">(</span><span class="n">mmio_reg0</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Read MMIO register:</span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;ld.relaxed.mmio.sys.u32 %0, [%1];&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">(</span><span class="n">mmio_reg1</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="n">__trap</span><span class="p">();</span><span class="w"> </span><span class="c1">// Errors if wrong data read</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="pointers">
<span id="id329"></span><h3><span class="section-number">15.5.4. </span>Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline">ï</a></h3>
<p>Dereferencing a pointer either to global or shared memory in code that is executed on the host, or to host memory in code that is executed on the device results in an undefined behavior, most often in a segmentation fault and application termination.</p>
<p>The address obtained by taking the address of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> or <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable can only be used in device code. The address of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variable obtained through <code class="docutils literal notranslate"><span class="pre">cudaGetSymbolAddress()</span></code> as described in <a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a> can only be used in host code.</p>
</section>
<section id="operators">
<span id="id330"></span><h3><span class="section-number">15.5.5. </span>Operators<a class="headerlink" href="#operators" title="Permalink to this headline">ï</a></h3>
<section id="assignment-operator">
<span id="id331"></span><h4><span class="section-number">15.5.5.1. </span>Assignment Operator<a class="headerlink" href="#assignment-operator" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables can only be assigned from the host code through runtime functions (<a class="reference internal" href="#device-memory"><span class="std std-ref">Device Memory</span></a>); they cannot be assigned from the device code.</p>
<p><code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variables cannot have an initialization as part of their declaration.</p>
<p>It is not allowed to assign values to any of the built-in variables defined in <a class="reference internal" href="#built-in-variables"><span class="std std-ref">Built-in Variables</span></a>.</p>
</section>
<section id="address-operator">
<span id="id332"></span><h4><span class="section-number">15.5.5.2. </span>Address Operator<a class="headerlink" href="#address-operator" title="Permalink to this headline">ï</a></h4>
<p>It is not allowed to take the address of any of the built-in variables defined in <a class="reference internal" href="#built-in-variables"><span class="std std-ref">Built-in Variables</span></a>.</p>
</section>
</section>
<section id="run-time-type-information-rtti">
<span id="rtti"></span><h3><span class="section-number">15.5.6. </span>Run Time Type Information (RTTI)<a class="headerlink" href="#run-time-type-information-rtti" title="Permalink to this headline">ï</a></h3>
<p>The following RTTI-related features are supported in host code, but not in device code.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">typeid</span></code> operator</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">std::type_info</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> operator</p></li>
</ul>
</section>
<section id="exception-handling">
<span id="id333"></span><h3><span class="section-number">15.5.7. </span>Exception Handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline">ï</a></h3>
<p>Exception handling is only supported in host code, but not in device code.</p>
<p>Exception specification is not supported for <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions.</p>
</section>
<section id="standard-library">
<span id="id334"></span><h3><span class="section-number">15.5.8. </span>Standard Library<a class="headerlink" href="#standard-library" title="Permalink to this headline">ï</a></h3>
<p>Standard libraries are only supported in host code, but not in device code, unless specified otherwise.</p>
</section>
<section id="namespace-reservations">
<h3><span class="section-number">15.5.9. </span>Namespace Reservations<a class="headerlink" href="#namespace-reservations" title="Permalink to this headline">ï</a></h3>
<p>Unless an exception is otherwise noted, it is undefined behavior to add any declarations or definitions to <code class="docutils literal notranslate"><span class="pre">cuda::</span></code>, <code class="docutils literal notranslate"><span class="pre">nv::</span></code>, <code class="docutils literal notranslate"><span class="pre">cooperative_groups::</span></code> or any namespace nested within.</p>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">cuda</span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Bad: class declaration added to namespace cuda</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="p">{};</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Bad: function definition added to namespace cuda</span>
<span class="w">   </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="nf">make_stream</span><span class="p">(){</span><span class="w"></span>
<span class="w">      </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace cuda</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">cuda</span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utils</span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Bad: function definition added to namespace nested within cuda</span>
<span class="w">      </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="nf">make_stream</span><span class="p">(){</span><span class="w"></span>
<span class="w">          </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="c1">// namespace utils</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace cuda</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">utils</span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cuda</span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="c1">// Okay: namespace cuda may be used nested within a non-reserved namespace</span>
<span class="w">     </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="nf">make_stream</span><span class="p">(){</span><span class="w"></span>
<span class="w">          </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="c1">// namespace cuda</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace utils</span>

<span class="c1">// Bad: Equivalent to adding symbols to namespace cuda at global scope</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utils</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="functions">
<span id="id335"></span><h3><span class="section-number">15.5.10. </span>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">ï</a></h3>
<section id="external-linkage">
<span id="id336"></span><h4><span class="section-number">15.5.10.1. </span>External Linkage<a class="headerlink" href="#external-linkage" title="Permalink to this headline">ï</a></h4>
<p>A call within some device code of a function declared with the extern qualifier is only allowed if the function is defined within the same compilation unit as the device code, i.e., a single file or several files linked together with relocatable device code and nvlink.</p>
</section>
<section id="implicitly-declared-and-explicitly-defaulted-functions">
<span id="compiler-generated-functions"></span><h4><span class="section-number">15.5.10.2. </span>Implicitly-declared and explicitly-defaulted functions<a class="headerlink" href="#implicitly-declared-and-explicitly-defaulted-functions" title="Permalink to this headline">ï</a></h4>
<p>Let <code class="docutils literal notranslate"><span class="pre">F</span></code> denote a function that is either implicitly-declared or is explicitly-defaulted on its first declaration The execution space specifiers (<code class="docutils literal notranslate"><span class="pre">__host__</span></code>, <code class="docutils literal notranslate"><span class="pre">__device__</span></code>) for <code class="docutils literal notranslate"><span class="pre">F</span></code> are the union of the execution space specifiers of all the functions that invoke it (note that a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> caller will be treated as a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> caller for this analysis). For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">Base</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Other</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Derived</span><span class="w"> </span><span class="n">D1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Other</span><span class="w"> </span><span class="n">D2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Other</span><span class="w"> </span><span class="n">D3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the implicitly-declared constructor function âDerived::Derivedâ will be treated as a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function, since it is invoked only from the <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function âfooâ. The implicitly-declared constructor function âOther::Otherâ will be treated as a <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function, since it is invoked both from a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function âfooâ and a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function âbarâ.</p>
<p>In addition, if <code class="docutils literal notranslate"><span class="pre">F</span></code> is a virtual destructor, then the execution spaces of each virtual destructor <code class="docutils literal notranslate"><span class="pre">D</span></code> overridden by <code class="docutils literal notranslate"><span class="pre">F</span></code> are added to the set of execution spaces for <code class="docutils literal notranslate"><span class="pre">F</span></code>, if <code class="docutils literal notranslate"><span class="pre">D</span></code> is either not implicitly defined or is explicitly defaulted on a declaration other than its first declaration.</p>
<p>For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Base1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="o">~</span><span class="n">Base1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Derived1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Base1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// implicitly-declared virtual destructor</span>
<span class="w">                             </span><span class="c1">// ~Derived1 has __host__ __device__</span>
<span class="w">                             </span><span class="c1">// execution space specifiers</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Base2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="o">~</span><span class="n">Base2</span><span class="p">();</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="n">Base2</span><span class="o">::~</span><span class="n">Base2</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Derived2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Base2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// implicitly-declared virtual destructor</span>
<span class="w">                             </span><span class="c1">// ~Derived2 has __device__ execution</span>
<span class="w">                             </span><span class="c1">// space specifiers</span>
</pre></div>
</div>
</section>
<section id="function-parameters">
<span id="id337"></span><h4><span class="section-number">15.5.10.3. </span>Function Parameters<a class="headerlink" href="#function-parameters" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> function parameters are passed to the device via constant memory and are limited to 32,764 bytes starting with Volta, and 4 KB on older architectures.</p>
<p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions cannot have a variable number of arguments.</p>
<p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> function parameters cannot be pass-by-reference.</p>
<p>In separate compilation mode, if a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function is ODR-used in a particular translation unit, then the parameter and return types of the function must be complete in that translation unit.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//first.cu:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="p">;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"> </span><span class="c1">// error: type &#39;S&#39; is incomplete</span>
<span class="n">__device__</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="c1">//second.cu:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//compiler invocation
$nvcc -std=c++14 -rdc=true first.cu second.cu -o first
nvlink error   : Prototype doesn&#39;t match for &#39;_Z3foo1S&#39; in &#39;/tmp/tmpxft_00005c8c_00000000-18_second.o&#39;, first defined in &#39;/tmp/tmpxft_00005c8c_00000000-18_second.o&#39;
nvlink fatal   : merge_elf failed
</pre></div>
</div>
<section id="global-function-argument-processing">
<span id="id338"></span><h5><span class="section-number">15.5.10.3.1. </span><code class="docutils literal notranslate"><span class="pre">__global__</span></code> Function Argument Processing<a class="headerlink" href="#global-function-argument-processing" title="Permalink to this headline">ï</a></h5>
<p>When a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function is launched from device code, each argument must be trivially copyable and trivially destructible.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function is launched from host code, each argument type is allowed to be non-trivially copyable or non-trivially-destructible, but the processing for such types does not follow the standard C++ model, as described below. User code must ensure that this workflow does not affect program correctness. The workflow diverges from standard C++ in two areas:</p>
<ol class="arabic">
<li><p><strong>Memcpy instead of copy constructor invocation</strong></p>
<p>When lowering a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function launch from host code, the compiler generates stub functions that copy the parameters one or more times by value, before eventually using <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> to copy the arguments to the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functionâs parameter memory on the device. This occurs even if an argument was non-trivially-copyable, and therefore may break programs where the copy constructor has side effects.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="c1">// this assert may fail, because the compiler</span>
<span class="w"> </span><span class="c1">// generated code will memcpy the contents of &quot;in&quot;</span>
<span class="w"> </span><span class="c1">// from host to kernel parameter memory, so the</span>
<span class="w"> </span><span class="c1">// &quot;in.ptr&quot; is not initialized to &quot;&amp;in.x&quot; because</span>
<span class="w"> </span><span class="c1">// the copy constructor is skipped.</span>
<span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in</span><span class="p">.</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">S</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>

<span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="n">S1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">S1</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">++</span><span class="n">counter</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="cm">/* this assertion may fail, because</span>
<span class="cm">   the compiler generates stub</span>
<span class="cm">   functions on the host for a kernel</span>
<span class="cm">   launch, and they may copy the</span>
<span class="cm">   argument by value more than once.</span>
<span class="cm">*/</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="n">S1</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"></span>
<span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p><strong>Destructor may be invoked before the ``__global__`` function has finished</strong></p>
<p>Kernel launches are asynchronous with host execution. As a result, if a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function argument has a non-trivial destructor, the destructor may execute in host code even before the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function has finished execution. This may break programs where the destructor has side effects.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ptr</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="o">~</span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="c1">//error: This store may write to memory that has already been</span>
<span class="w">  </span><span class="c1">//       freed (see below).</span>
<span class="w">  </span><span class="o">*</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"></span>

<span class="w"> </span><span class="cm">/* The object &#39;V&#39; is first copied by value to a compiler-generated</span>
<span class="cm">  * stub function that does the kernel launch, and the stub function</span>
<span class="cm">  * bitwise copies the contents of the argument to kernel parameter</span>
<span class="cm">  * memory.</span>
<span class="cm">  * However, GPU kernel execution is asynchronous with host</span>
<span class="cm">  * execution.</span>
<span class="cm">  * As a result, S::~S() will execute when the stub function   returns, releasing allocated memory, even though the kernel may not have finished execution.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w"> </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">V</span><span class="p">);</span><span class="w"></span>
<span class="w"> </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
</section>
<section id="toolkit-and-driver-compatibility">
<h5><span class="section-number">15.5.10.3.2. </span>Toolkit and Driver Compatibility<a class="headerlink" href="#toolkit-and-driver-compatibility" title="Permalink to this headline">ï</a></h5>
<p>Developers must use the 12.1 Toolkit and r530 driver or higher to compile, launch, and debug kernels that accept parameters larger than 4KB. If such kernels are launched on older drivers, CUDA will issue the error <code class="docutils literal notranslate"><span class="pre">CUDA_ERROR_NOT_SUPPORTED</span></code>.</p>
</section>
<section id="link-compatibility-across-toolkit-revisions">
<h5><span class="section-number">15.5.10.3.3. </span>Link Compatibility across Toolkit Revisions<a class="headerlink" href="#link-compatibility-across-toolkit-revisions" title="Permalink to this headline">ï</a></h5>
<p>When linking device objects, if at least one device object contains a kernel with a parameter larger than 4KB, the developer must recompile all objects from their respective device sources with the 12.1 toolkit or higher before linking them together. Failure to do so will result in a linker error.</p>
</section>
</section>
<section id="static-variables-within-function">
<span id="static-variables-function"></span><h4><span class="section-number">15.5.10.4. </span>Static Variables within Function<a class="headerlink" href="#static-variables-within-function" title="Permalink to this headline">ï</a></h4>
<p>Variable memory space specifiers are allowed in the declaration of a static variable <code class="docutils literal notranslate"><span class="pre">V</span></code> within the immediate or nested block scope of a function <code class="docutils literal notranslate"><span class="pre">F</span></code> where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> or <code class="docutils literal notranslate"><span class="pre">__device__</span></code>-only function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> is a <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function and <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined <a class="footnote-reference brackets" href="#fn17" id="id339">18</a>.</p></li>
</ul>
<p>If no explicit memory space specifier is present in the declaration of <code class="docutils literal notranslate"><span class="pre">V</span></code>, an implicit <code class="docutils literal notranslate"><span class="pre">__device__</span></code> specifier is assumed during device compilation.</p>
<p><code class="docutils literal notranslate"><span class="pre">V</span></code> has the same initialization restrictions as a variable with the same memory space specifiers declared in namespace scope for example a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> variable cannot have a ânon-emptyâ constructor (see <a class="reference internal" href="#device-memory-specifiers"><span class="std std-ref">Device Memory Space Specifiers</span></a>).</p>
<p>Examples of legal and illegal uses of function-scope static variables are shown below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S2_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">S2_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S3_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="nf">S3_t</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w">              </span><span class="c1">// OK, implicit __device__ memory space specifier</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w">         </span><span class="c1">// OK, implicit __device__ memory space specifier</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m1</span><span class="p">;</span><span class="w">  </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span><span class="w">   </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__constant__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c1</span><span class="p">;</span><span class="w"> </span><span class="c1">// OK</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">S1_t</span><span class="w"> </span><span class="n">i3</span><span class="p">;</span><span class="w">             </span><span class="c1">// OK, implicit __device__ memory space specifier</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">S1_t</span><span class="w"> </span><span class="n">i4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">22</span><span class="p">};</span><span class="w">      </span><span class="c1">// OK, implicit __device__ memory space specifier</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i5</span><span class="p">;</span><span class="w">   </span><span class="c1">// OK</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">33</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">          </span><span class="c1">// error: dynamic initialization is not allowed</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">S1_t</span><span class="w"> </span><span class="n">i7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">};</span><span class="w">       </span><span class="c1">// error: dynamic initialization is not allowed</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">S2_t</span><span class="w"> </span><span class="n">i8</span><span class="p">;</span><span class="w">             </span><span class="c1">// error: dynamic initialization is not allowed</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">S3_t</span><span class="w"> </span><span class="nf">i9</span><span class="p">(</span><span class="mi">44</span><span class="p">);</span><span class="w">         </span><span class="c1">// error: dynamic initialization is not allowed</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i1</span><span class="p">;</span><span class="w">              </span><span class="c1">// OK, implicit __device__ memory space specifier</span>
<span class="w">                              </span><span class="c1">// during device compilation.</span>
<span class="cp">#ifdef __CUDA_ARCH__</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span><span class="w">   </span><span class="c1">// OK, declaration is only visible during device</span>
<span class="w">                              </span><span class="c1">// compilation  (__CUDA_ARCH__ is defined)</span>
<span class="cp">#else</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d0</span><span class="p">;</span><span class="w">              </span><span class="c1">// OK, declaration is only visible during host</span>
<span class="w">                              </span><span class="c1">// compilation (__CUDA_ARCH__ is not defined)</span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d2</span><span class="p">;</span><span class="w">   </span><span class="c1">// error: __device__ variable inside</span>
<span class="w">                              </span><span class="c1">// a host function during host compilation</span>
<span class="w">                              </span><span class="c1">// i.e. when __CUDA_ARCH__ is not defined</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i2</span><span class="p">;</span><span class="w">  </span><span class="c1">// error: __shared__ variable inside</span>
<span class="w">                             </span><span class="c1">// a host function during host compilation</span>
<span class="w">                             </span><span class="c1">// i.e. when __CUDA_ARCH__ is not defined</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="function-pointers">
<span id="id340"></span><h4><span class="section-number">15.5.10.5. </span>Function Pointers<a class="headerlink" href="#function-pointers" title="Permalink to this headline">ï</a></h4>
<p>The address of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function taken in host code cannot be used in device code (e.g. to launch the kernel). Similarly, the address of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function taken in device code cannot be used in host code.</p>
<p>It is not allowed to take the address of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function in host code.</p>
</section>
<section id="function-recursion">
<span id="id341"></span><h4><span class="section-number">15.5.10.6. </span>Function Recursion<a class="headerlink" href="#function-recursion" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions do not support recursion.</p>
</section>
<section id="friend-functions">
<span id="friend-function"></span><h4><span class="section-number">15.5.10.7. </span>Friend Functions<a class="headerlink" href="#friend-functions" title="Permalink to this headline">ï</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or function template cannot be defined in a friend declaration.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="n">__global__</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w">  </span><span class="c1">// OK: not a definition</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="n">__global__</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK: not a definition</span>

<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="n">__global__</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// error: definition in friend declaration</span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="n">__global__</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// error: definition in friend declaration</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="operator-function">
<span id="id342"></span><h4><span class="section-number">15.5.10.8. </span>Operator Function<a class="headerlink" href="#operator-function" title="Permalink to this headline">ï</a></h4>
<p>An operator function cannot be a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function.</p>
</section>
<section id="allocation-and-deallocation-functions">
<h4><span class="section-number">15.5.10.9. </span>Allocation and Deallocation Functions<a class="headerlink" href="#allocation-and-deallocation-functions" title="Permalink to this headline">ï</a></h4>
<p>A user-defined <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">new[]</span></code>, <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete</span></code>, or <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">delete[]</span></code> cannot be used to replace the corresponding <code class="docutils literal notranslate"><span class="pre">__host__</span></code> or <code class="docutils literal notranslate"><span class="pre">__device__</span></code> builtins provided by the compiler.</p>
</section>
</section>
<section id="classes">
<span id="id343"></span><h3><span class="section-number">15.5.11. </span>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">ï</a></h3>
<section id="data-members">
<span id="id344"></span><h4><span class="section-number">15.5.11.1. </span>Data Members<a class="headerlink" href="#data-members" title="Permalink to this headline">ï</a></h4>
<p>Static data members are not supported except for those that are also const-qualified (see <a class="reference internal" href="#const-variables"><span class="std std-ref">Const-qualified variables</span></a>).</p>
</section>
<section id="function-members">
<span id="id345"></span><h4><span class="section-number">15.5.11.2. </span>Function Members<a class="headerlink" href="#function-members" title="Permalink to this headline">ï</a></h4>
<p>Static member functions cannot be <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions.</p>
</section>
<section id="virtual-functions">
<span id="id346"></span><h4><span class="section-number">15.5.11.3. </span>Virtual Functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">ï</a></h4>
<p>When a function in a derived class overrides a virtual function in a base class, the execution space specifiers (i.e., <code class="docutils literal notranslate"><span class="pre">__host__</span></code>, <code class="docutils literal notranslate"><span class="pre">__device__</span></code>) on the overridden and overriding functions must match.</p>
<p>It is not allowed to pass as an argument to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function an object of a class with virtual functions.</p>
<p>If an object is created in host code, invoking a virtual function for that object in device code has undefined behavior.</p>
<p>If an object is created in device code, invoking a virtual function for that object in host code has undefined behavior.</p>
<p>See <a class="reference internal" href="#windows-specific"><span class="std std-ref">Windows-Specific</span></a> for additional constraints when using the Microsoft host compiler.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="n">__managed__</span><span class="w"> </span><span class="n">S1</span><span class="w"> </span><span class="o">*</span><span class="n">ptr1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr2</span><span class="p">;</span><span class="w"></span>

<span class="n">__managed__</span><span class="w"> </span><span class="nf">__align__</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">buf1</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr1</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span><span class="w">     </span><span class="c1">// error: virtual function call on a object</span>
<span class="w">                   </span><span class="c1">//        created in host code.</span>
<span class="w">  </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="n">buf1</span><span class="p">)</span><span class="w"> </span><span class="n">S1</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">S1</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemAttachGlobal</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="n">S1</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr2</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span><span class="w">  </span><span class="c1">// error: virtual function call on an object</span>
<span class="w">                </span><span class="c1">//        created in device code.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="virtual-base-classes">
<span id="id347"></span><h4><span class="section-number">15.5.11.4. </span>Virtual Base Classes<a class="headerlink" href="#virtual-base-classes" title="Permalink to this headline">ï</a></h4>
<p>It is not allowed to pass as an argument to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function an object of a class derived from virtual base classes.</p>
<p>See <a class="reference internal" href="#windows-specific"><span class="std std-ref">Windows-Specific</span></a> for additional constraints when using the Microsoft host compiler.</p>
</section>
<section id="anonymous-unions">
<span id="anon-union"></span><h4><span class="section-number">15.5.11.5. </span>Anonymous Unions<a class="headerlink" href="#anonymous-unions" title="Permalink to this headline">ï</a></h4>
<p>Member variables of a namespace scope anonymous union cannot be referenced in a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> or <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function.</p>
</section>
<section id="windows-specific">
<span id="id348"></span><h4><span class="section-number">15.5.11.6. </span>Windows-Specific<a class="headerlink" href="#windows-specific" title="Permalink to this headline">ï</a></h4>
<p>The CUDA compiler follows the IA64 ABI for class layout, while the Microsoft host compiler does not. Let <code class="docutils literal notranslate"><span class="pre">T</span></code> denote a pointer to member type, or a class type that satisfies any of the following conditions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> has virtual functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> has a virtual base class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> has multiple inheritance with more than one direct or indirect empty base class.</p></li>
<li><p>All direct and indirect base classes <code class="docutils literal notranslate"><span class="pre">B</span></code> of <code class="docutils literal notranslate"><span class="pre">T</span></code> are empty and the type of the first field <code class="docutils literal notranslate"><span class="pre">F</span></code> of <code class="docutils literal notranslate"><span class="pre">T</span></code> uses <code class="docutils literal notranslate"><span class="pre">B</span></code> in its definition, such that <code class="docutils literal notranslate"><span class="pre">B</span></code> is laid out at offset 0 in the definition of <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p></li>
</ul>
<p>Let <code class="docutils literal notranslate"><span class="pre">C</span></code> denote <code class="docutils literal notranslate"><span class="pre">T</span></code> or a class type that has <code class="docutils literal notranslate"><span class="pre">T</span></code> as a field type or as a base class type. The CUDA compiler may compute the class layout and size differently than the Microsoft host compiler for the type <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>As long as the type <code class="docutils literal notranslate"><span class="pre">C</span></code> is used exclusively in host or device code, the program should work correctly.</p>
<p>Passing an object of type <code class="docutils literal notranslate"><span class="pre">C</span></code> between host and device code has undefined behavior, for example, as an argument to a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or through <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> calls.</p>
<p>Accessing an object of type <code class="docutils literal notranslate"><span class="pre">C</span></code> or any subobject in device code, or invoking a member function in device code, has undefined behavior if the object is created in host code.</p>
<p>Accessing an object of type <code class="docutils literal notranslate"><span class="pre">C</span></code> or any subobject in host code, or invoking a member function in host code, has undefined behavior if the object is created in device code <a class="footnote-reference brackets" href="#fn19" id="id349">19</a>.</p>
</section>
</section>
<section id="templates">
<span id="id350"></span><h3><span class="section-number">15.5.12. </span>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">ï</a></h3>
<p>A type or template cannot be used in the type, non-type or template template argument of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiation or a <code class="docutils literal notranslate"><span class="pre">__device__/__constant__</span></code> variable instantiation if either:</p>
<ul class="simple">
<li><p>The type or template is defined within a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code>.</p></li>
<li><p>The type or template is a class member with <code class="docutils literal notranslate"><span class="pre">private</span></code> or <code class="docutils literal notranslate"><span class="pre">protected</span></code> access and its parent class is not defined within a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function.</p></li>
<li><p>The type is unnamed.</p></li>
<li><p>The type is compounded from any of the types above.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">myKernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">myClass</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inner_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// error: inner_t is used in template argument</span>
<span class="w">       </span><span class="c1">// but it is private</span>
<span class="w">       </span><span class="n">myKernel</span><span class="o">&lt;</span><span class="n">inner_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// C++14 only</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">d1</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="n">d2</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error (C++14 only): S1_t is local to the function fn</span>
<span class="w">  </span><span class="n">d1</span><span class="o">&lt;</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error (C++14 only): a closure type cannot be used for</span>
<span class="w">  </span><span class="c1">// instantiating a variable template</span>
<span class="w">  </span><span class="n">d2</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="trigraphs-and-digraphs">
<span id="trigraph-digraph"></span><h3><span class="section-number">15.5.13. </span>Trigraphs and Digraphs<a class="headerlink" href="#trigraphs-and-digraphs" title="Permalink to this headline">ï</a></h3>
<p>Trigraphs are not supported on any platform. Digraphs are not supported on Windows.</p>
</section>
<section id="const-qualified-variables">
<span id="const-variables"></span><h3><span class="section-number">15.5.14. </span>Const-qualified variables<a class="headerlink" href="#const-qualified-variables" title="Permalink to this headline">ï</a></h3>
<p>Let âVâ denote a namespace scope variable or a class static member variable that has const qualified type and does not have execution space annotations (for example, <code class="docutils literal notranslate"><span class="pre">__device__,</span> <span class="pre">__constant__,</span> <span class="pre">__shared__</span></code>). V is considered to be a host code variable.</p>
<p>The value of V may be directly used in device code, if</p>
<ul class="simple">
<li><p>V has been initialized with a constant expression before the point of use,</p></li>
<li><p>the type of V is not volatile-qualified, and</p></li>
<li><p>it has one of the following types:</p>
<ul>
<li><p>built-in floating point type except when the Microsoft compiler is used as the host compiler,</p></li>
<li><p>built-in integral type.</p></li>
</ul>
</li>
</ul>
<p>Device source code cannot contain a reference to V or take the address of V.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">extern</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zzz</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">www</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">local1</span><span class="p">[</span><span class="n">xxx</span><span class="p">];</span><span class="w">          </span><span class="c1">// OK</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">local2</span><span class="p">[</span><span class="n">S1_t</span><span class="o">::</span><span class="n">yyy</span><span class="p">];</span><span class="w">    </span><span class="c1">// OK</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w">           </span><span class="c1">// OK</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S1_t</span><span class="o">::</span><span class="n">yyy</span><span class="p">;</span><span class="w">     </span><span class="c1">// OK</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zzz</span><span class="p">;</span><span class="w">           </span><span class="c1">// error: zzz not initialized with constant</span>
<span class="w">                            </span><span class="c1">// expression at the point of use.</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w">    </span><span class="c1">// error: reference to host variable</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">val4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xxx</span><span class="p">;</span><span class="w">   </span><span class="c1">// error: address of host variable</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">val5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">www</span><span class="p">;</span><span class="w">   </span><span class="c1">// OK except when the Microsoft compiler is used as</span>
<span class="w">                            </span><span class="c1">// the host compiler.</span>
<span class="p">}</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zzz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="long-double">
<span id="id351"></span><h3><span class="section-number">15.5.15. </span>Long Double<a class="headerlink" href="#long-double" title="Permalink to this headline">ï</a></h3>
<p>The use of <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> type is not supported in device code.</p>
</section>
<section id="deprecation-annotation">
<span id="id352"></span><h3><span class="section-number">15.5.16. </span>Deprecation Annotation<a class="headerlink" href="#deprecation-annotation" title="Permalink to this headline">ï</a></h3>
<p>nvcc supports the use of <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> attribute when using <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">clang</span></code>, <code class="docutils literal notranslate"><span class="pre">xlC</span></code>, <code class="docutils literal notranslate"><span class="pre">icc</span></code> or <code class="docutils literal notranslate"><span class="pre">pgcc</span></code> host compilers, and the use of <code class="docutils literal notranslate"><span class="pre">deprecated</span></code> declspec when using the <code class="docutils literal notranslate"><span class="pre">cl.exe</span></code> host compiler. It also supports the <code class="docutils literal notranslate"><span class="pre">[[deprecated]]</span></code> standard attribute when the C++14 dialect has been enabled. The CUDA frontend compiler will generate a deprecation diagnostic for a reference to a deprecated entity from within the body of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__global__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is defined (i.e., during device compilation phase). Other references to deprecated entities will be handled by the host compiler, e.g., a reference from within a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function.</p>
<p>The CUDA frontend compiler does not support the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">gcc</span> <span class="pre">diagnostic</span></code> or <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">warning</span></code> mechanisms supported by various host compilers. Therefore, deprecation diagnostics generated by the CUDA frontend compiler are not affected by these pragmas, but diagnostics generated by the host compiler will be affected. To suppress the warning for device-code, user can use NVIDIA specific pragma <a class="reference internal" href="#nv-diagnostic-pragmas"><span class="std std-ref">#pragma nv_diag_suppress</span></a>. The <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> flag <code class="docutils literal notranslate"><span class="pre">-Wno-deprecated-declarations</span></code> can be used to suppress all deprecation warnings, and the flag <code class="docutils literal notranslate"><span class="pre">-Werror=deprecated-declarations</span></code> can be used to turn deprecation warnings into errors.</p>
</section>
<section id="noreturn-annotation">
<span id="id353"></span><h3><span class="section-number">15.5.17. </span>Noreturn Annotation<a class="headerlink" href="#noreturn-annotation" title="Permalink to this headline">ï</a></h3>
<p>nvcc supports the use of <code class="docutils literal notranslate"><span class="pre">noreturn</span></code> attribute when using <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">clang</span></code>, <code class="docutils literal notranslate"><span class="pre">xlC</span></code>, <code class="docutils literal notranslate"><span class="pre">icc</span></code> or <code class="docutils literal notranslate"><span class="pre">pgcc</span></code> host compilers, and the use of <code class="docutils literal notranslate"><span class="pre">noreturn</span></code> declspec when using the <code class="docutils literal notranslate"><span class="pre">cl.exe</span></code> host compiler. It also supports the <code class="docutils literal notranslate"><span class="pre">[[noreturn]]</span></code> standard attribute when the C++11 dialect has been enabled.</p>
<p>The attribute/declspec can be used in both host and device code.</p>
</section>
<section id="likely-unlikely-standard-attributes">
<span id="likely-unlikely-attribute"></span><h3><span class="section-number">15.5.18. </span>[[likely]] / [[unlikely]] Standard Attributes<a class="headerlink" href="#likely-unlikely-standard-attributes" title="Permalink to this headline">ï</a></h3>
<p>These attributes are accepted in all configurations that support the C++ standard attribute syntax. The attributes can be used to hint to the device compiler optimizer whether a statement is more or less likely to be executed compared to any alternative path that does not include the statement.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="n">likely</span><span class="p">]]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// the &#39;if&#39; block will likely be entered</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="p">[[</span><span class="n">unlikely</span><span class="p">]]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// the &#39;if&#39; block will not likely be entered</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>If these attributes are used in host code when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is undefined, then they will be present in the code parsed by the host compiler, which may generate a warning if the attributes are not supported. For example, <code class="docutils literal notranslate"><span class="pre">clang</span></code>11 host compiler will generate an âunknown attributeâ warning.</p>
</section>
<section id="const-and-pure-gnu-attributes">
<span id="const-pure-attribute"></span><h3><span class="section-number">15.5.19. </span>const and pure GNU Attributes<a class="headerlink" href="#const-and-pure-gnu-attributes" title="Permalink to this headline">ï</a></h3>
<p>These attributes are supported for both host and device functions, when using a language dialect and host compiler that also supports these attributes e.g. with g++ host compiler.</p>
<p>For a device function annotated with the <code class="docutils literal notranslate"><span class="pre">pure</span></code> attribute, the device code optimizer assumes that the function does not change any mutable state visible to caller functions (e.g. memory).</p>
<p>For a device function annotated with the <code class="docutils literal notranslate"><span class="pre">const</span></code> attribute, the device code optimizer assumes that the function does not access or change any mutable state visible to caller functions (e.g. memory).</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="k">const</span><span class="p">))</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">//because &#39;get&#39; is marked with &#39;const&#39; attribute</span>
<span class="c1">//device code optimizer can recognize that the</span>
<span class="c1">//second call to get() can be commoned out.</span>
<span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">in</span><span class="p">);</span><span class="w"></span>
<span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">in</span><span class="p">);</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="nv-pure-attribute">
<span id="id354"></span><h3><span class="section-number">15.5.20. </span>__nv_pure__ Attribute<a class="headerlink" href="#nv-pure-attribute" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__nv_pure__</span></code> attributed is supported for both host and device functions. For host functions, when using a language dialect that supports the <code class="docutils literal notranslate"><span class="pre">pure</span></code> GNU attribute, the <code class="docutils literal notranslate"><span class="pre">__nv_pure__</span></code> attribute is translated to the <code class="docutils literal notranslate"><span class="pre">pure</span></code> GNU attribute. Similarly when using MSVC as the host compiler, the attribute is translated to the MSVC <code class="docutils literal notranslate"><span class="pre">noalias</span></code> attribute.</p>
<p>When a device function is annotated with the <code class="docutils literal notranslate"><span class="pre">__nv_pure__</span></code> attribute, the device code optimizer assumes that the function does not change any mutable state visible to caller functions (e.g. memory).</p>
</section>
<section id="intel-host-compiler-specific">
<span id="intel-compiler-specific"></span><h3><span class="section-number">15.5.21. </span>Intel Host Compiler Specific<a class="headerlink" href="#intel-host-compiler-specific" title="Permalink to this headline">ï</a></h3>
<p>The CUDA frontend compiler parser does not recognize some of the intrinsic functions supported by the Intel compiler (e.g. <code class="docutils literal notranslate"><span class="pre">icc</span></code>). When using the Intel compiler as a host compiler, <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> will therefore enable the macro <code class="docutils literal notranslate"><span class="pre">__INTEL_COMPILER_USE_INTRINSIC_PROTOTYPES</span></code> during preprocessing. This macro enables explicit declarations of the Intel compiler intrinsic functions in the associated header files, allowing <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> to support use of such functions in host code<a class="footnote-reference brackets" href="#fn20" id="id355">20</a>.</p>
</section>
<section id="c-11-features">
<span id="cpp11"></span><h3><span class="section-number">15.5.22. </span>C++11 Features<a class="headerlink" href="#c-11-features" title="Permalink to this headline">ï</a></h3>
<p>C++11 features that are enabled by default by the host compiler are also supported by nvcc, subject to the restrictions described in this document. In addition, invoking nvcc with <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code> flag turns on all C++11 features and also invokes the host preprocessor, compiler and linker with the corresponding C++11 dialect option <a class="footnote-reference brackets" href="#fn21" id="id356">21</a>.</p>
<section id="lambda-expressions">
<span id="id357"></span><h4><span class="section-number">15.5.22.1. </span>Lambda Expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this headline">ï</a></h4>
<p>The execution space specifiers for all member functions<a class="footnote-reference brackets" href="#fn22" id="id358">22</a> of the closure class associated with a lambda expression are derived by the compiler as follows. As described in the C++11 standard, the compiler creates a closure type in the smallest block scope, class scope or namespace scope that contains the lambda expression. The innermost function scope enclosing the closure type is computed, and the corresponding functionâs execution space specifiers are assigned to the closure class member functions. If there is no enclosing function scope, the execution space specifier is <code class="docutils literal notranslate"><span class="pre">__host__</span></code>.</p>
<p>Examples of lambda expressions and computed execution space specifiers are shown below (in comments).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">globalVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// __host__</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// __host__</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// __device__</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">l3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// __host__ __device__</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f4</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cm">/* __host__ */</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f5</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">l5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w">      </span><span class="c1">// __device__</span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">f6</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">helper</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cm">/* __device__ */</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The closure type of a lambda expression cannot be used in the type or non-type argument of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiation, unless the lambda is defined within a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">temp1</span><span class="p">);</span><span class="w">                    </span><span class="c1">// error: lambda closure type used in</span>
<span class="w">                                          </span><span class="c1">// template type argument</span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">S1_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">temp1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">());</span><span class="w"> </span><span class="c1">// error: lambda closure type used in</span>
<span class="w">                                          </span><span class="c1">// template type argument</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="std-initializer-list">
<span id="initializer-list"></span><h4><span class="section-number">15.5.22.2. </span>std::initializer_list<a class="headerlink" href="#std-initializer-list" title="Permalink to this headline">ï</a></h4>
<p>By default, the CUDA compiler will implicitly consider the member functions of <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> to have <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> execution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag <code class="docutils literal notranslate"><span class="pre">--no-host-device-initializer-list</span></code> will disable this behavior; member functions of <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> will then be considered as <code class="docutils literal notranslate"><span class="pre">__host__</span></code> functions and will not be directly invokable from device code.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in</span><span class="p">);</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">});</span><span class="w">   </span><span class="c1">// (a) initializer list containing only</span>
<span class="w">                    </span><span class="c1">// constant expressions.</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">});</span><span class="w">   </span><span class="c1">// (b) initializer list with at least one</span>
<span class="w">                    </span><span class="c1">// non-constant element.</span>
<span class="w">                    </span><span class="c1">// This form may have better performance than (a).</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="rvalue-references">
<span id="id359"></span><h4><span class="section-number">15.5.22.3. </span>Rvalue references<a class="headerlink" href="#rvalue-references" title="Permalink to this headline">ï</a></h4>
<p>By default, the CUDA compiler will implicitly consider <code class="docutils literal notranslate"><span class="pre">std::move</span></code> and <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> function templates to have <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> execution space specifiers, and therefore they can be invoked directly from device code. The nvcc flag <code class="docutils literal notranslate"><span class="pre">--no-host-device-move-forward</span></code> will disable this behavior; <code class="docutils literal notranslate"><span class="pre">std::move</span></code> and <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> will then be considered as <code class="docutils literal notranslate"><span class="pre">__host__</span></code> functions and will not be directly invokable from device code.</p>
</section>
<section id="constexpr-functions-and-function-templates">
<span id="constexpr-functions"></span><h4><span class="section-number">15.5.22.4. </span>Constexpr functions and function templates<a class="headerlink" href="#constexpr-functions-and-function-templates" title="Permalink to this headline">ï</a></h4>
<p>By default, a constexpr function cannot be called from a function with incompatible execution space <a class="footnote-reference brackets" href="#fn23" id="id360">23</a>. The experimental nvcc flag <code class="docutils literal notranslate"><span class="pre">--expt-relaxed-constexpr</span></code> removes this restriction <a class="footnote-reference brackets" href="#fn24" id="id361">24</a>. When this flag is specified, host code can invoke a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> constexpr function and device code can invoke a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> constexpr function. nvcc will define the macro <code class="docutils literal notranslate"><span class="pre">__CUDACC_RELAXED_CONSTEXPR__</span></code> when <code class="docutils literal notranslate"><span class="pre">--expt-relaxed-constexpr</span></code> has been specified. Note that a function template instantiation may not be a constexpr function even if the corresponding template is marked with the keyword <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> (C++11 Standard Section <code class="docutils literal notranslate"><span class="pre">[dcl.constexpr.p6]</span></code>).</p>
</section>
<section id="constexpr-variables">
<span id="id362"></span><h4><span class="section-number">15.5.22.5. </span>Constexpr variables<a class="headerlink" href="#constexpr-variables" title="Permalink to this headline">ï</a></h4>
<p>Let âVâ denote a namespace scope variable or a class static member variable that has been marked constexpr and that does not have execution space annotations (e.g., <code class="docutils literal notranslate"><span class="pre">__device__,</span> <span class="pre">__constant__,</span> <span class="pre">__shared__</span></code>). V is considered to be a host code variable.</p>
<p>If V is of scalar type <a class="footnote-reference brackets" href="#fn25" id="id363">25</a> other than <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">double</span></code> and the type is not volatile-qualified, the value of V can be directly used in device code. In addition, if V is of a non-scalar type then scalar elements of V can be used inside a constexpr <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function, if the call to the function is a constant expression <a class="footnote-reference brackets" href="#fn26" id="id364">26</a>. Device source code cannot contain a reference to V or take the address of V.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">qqq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">host_arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">host_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">yyy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">S1_t</span><span class="o">::</span><span class="n">qqq</span><span class="p">;</span><span class="w">  </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w">             </span><span class="c1">// error: reference to host constexpr</span>
<span class="w">                                   </span><span class="c1">// variable</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xxx</span><span class="p">;</span><span class="w">            </span><span class="c1">// error: address of host constexpr</span>
<span class="w">                                   </span><span class="c1">// variable</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S1_t</span><span class="o">::</span><span class="n">qqq</span><span class="p">;</span><span class="w">       </span><span class="c1">// error: reference to host constexpr</span>
<span class="w">                                   </span><span class="c1">// variable</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">v5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">S1_t</span><span class="o">::</span><span class="n">qqq</span><span class="p">;</span><span class="w">      </span><span class="c1">// error: address of host constexpr</span>
<span class="w">                                   </span><span class="c1">// variable</span>

<span class="w">  </span><span class="n">v1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">                    </span><span class="c1">// OK: &#39;get(2)&#39; is a constant</span>
<span class="w">                                   </span><span class="c1">// expression.</span>
<span class="w">  </span><span class="n">v1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span><span class="w">                  </span><span class="c1">// error: &#39;get(idx)&#39; is not a constant</span>
<span class="w">                                   </span><span class="c1">// expression</span>
<span class="w">  </span><span class="n">v1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">host_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">               </span><span class="c1">// error: &#39;host_arr&#39; does not have</span>
<span class="w">                                   </span><span class="c1">// scalar type.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">v1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="inline-namespaces">
<span id="id365"></span><h4><span class="section-number">15.5.22.6. </span>Inline namespaces<a class="headerlink" href="#inline-namespaces" title="Permalink to this headline">ï</a></h4>
<p>For an input CUDA translation unit, the CUDA compiler may invoke the host compiler for compiling the host code within the translation unit. In the code passed to the host compiler, the CUDA compiler will inject additional compiler generated code, if the input CUDA translation unit contained a definition of any of the following entities:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or function template instantiation</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__constant__</span></code></p></li>
<li><p>variables with surface or texture type</p></li>
</ul>
<p>The compiler generated code contains a reference to the defined entity. If the entity is defined within an inline namespace and another entity of the same name and type signature is defined in an enclosing namespace, this reference may be considered ambiguous by the host compiler and host compilation will fail.</p>
<p>This limitation can be avoided by using unique names for such entities defined within an inline namespace.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Gvar</span><span class="p">;</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">N1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Gvar</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// &lt;-- CUDA compiler inserts a reference to &quot;Gvar&quot; at this point in the</span>
<span class="c1">// translation unit. This reference will be considered ambiguous by the</span>
<span class="c1">// host compiler and compilation will fail.</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">N1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">N2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Gvar</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">N2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Gvar</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// &lt;-- CUDA compiler inserts reference to &quot;::N2::Gvar&quot; at this point in</span>
<span class="c1">// the translation unit. This reference will be considered ambiguous by</span>
<span class="c1">// the host compiler and compilation will fail.</span>
</pre></div>
</div>
<section id="inline-unnamed-namespaces">
<span id="id366"></span><h5><span class="section-number">15.5.22.6.1. </span>Inline unnamed namespaces<a class="headerlink" href="#inline-unnamed-namespaces" title="Permalink to this headline">ï</a></h5>
<p>The following entities cannot be declared in namespace scope within an inline unnamed namespace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__managed__</span></code>, <code class="docutils literal notranslate"><span class="pre">__device__</span></code>, <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> and <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> variables</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__global__</span></code> function and function templates</p></li>
<li><p>variables with surface or texture type</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">N2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w">            </span><span class="c1">// error</span>

<span class="w">    </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">         </span><span class="c1">// error</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w">    </span><span class="c1">// error</span>

<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x1b</span><span class="p">;</span><span class="w">                   </span><span class="c1">// error</span>
<span class="w">    </span><span class="n">__constant__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x2b</span><span class="p">;</span><span class="w">                 </span><span class="c1">// error</span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x3b</span><span class="p">;</span><span class="w">                   </span><span class="c1">// error</span>

<span class="w">    </span><span class="n">texture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q2</span><span class="p">;</span><span class="w">                      </span><span class="c1">// error</span>
<span class="w">    </span><span class="n">surface</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w">                      </span><span class="c1">// error</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="thread-local">
<span id="id367"></span><h4><span class="section-number">15.5.22.7. </span>thread_local<a class="headerlink" href="#thread-local" title="Permalink to this headline">ï</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">thread_local</span></code> storage specifier is not allowed in device code.</p>
</section>
<section id="global-functions-and-function-templates">
<span id="cpp11-global"></span><h4><span class="section-number">15.5.22.8. </span>__global__ functions and function templates<a class="headerlink" href="#global-functions-and-function-templates" title="Permalink to this headline">ï</a></h4>
<p>If the closure type associated with a lambda expression is used in a template argument of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiation, the lambda expression must either be defined in the immediate or nested block scope of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function, or must be an <a class="reference internal" href="#extended-lambda"><span class="std std-ref">extended lambda</span></a>.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// All kernel instantiations in this function</span>
<span class="w">  </span><span class="c1">// are valid, since the lambdas are defined inside</span>
<span class="w">  </span><span class="c1">// a __device__ function.</span>

<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo_host</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// OK: instantiated with closure type of an extended __device__ lambda</span>
<span class="w">   </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// OK: instantiated with closure type of an extended __host__ __device__</span>
<span class="w">   </span><span class="c1">// lambda</span>
<span class="w">   </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// error: unsupported: instantiated with closure type of a lambda</span>
<span class="w">   </span><span class="c1">// that is not an extended lambda</span>
<span class="w">   </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="p">[]</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// error: unsupported: instantiated with closure type of a lambda</span>
<span class="w">   </span><span class="c1">// that is not an extended lambda</span>
<span class="w">   </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// error: unsupported: instantiated with closure type of a lambda</span>
<span class="w">   </span><span class="c1">// that is not an extended lambda</span>
<span class="w">   </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">lam2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or function template cannot be declared as <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function or function template cannot have a parameter of type <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> or <code class="docutils literal notranslate"><span class="pre">va_list</span></code>.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function cannot have a parameter of rvalue reference type.</p>
<p>A variadic <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template has the following restrictions:</p>
<ul class="simple">
<li><p>Only a single pack parameter is allowed.</p></li>
<li><p>The pack parameter must be listed last in the template parameter list.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// ok</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Wrapper</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Pack</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo1</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Pack</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// error: pack parameter is not last in parameter list</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Pack</span><span class="p">,</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Wrapper</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo2</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Pack</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>

<span class="c1">// error: multiple parameter packs</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Pack1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">...</span><span class="n">Pack2</span><span class="p">,</span><span class="w"> </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Wrapper1</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Wrapper2</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo3</span><span class="p">(</span><span class="n">Wrapper1</span><span class="o">&lt;</span><span class="n">Pack1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Wrapper2</span><span class="o">&lt;</span><span class="n">Pack2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="managed-and-shared-variables">
<span id="cpp11-device-variable"></span><h4><span class="section-number">15.5.22.9. </span>__managed__ and __shared__ variables<a class="headerlink" href="#managed-and-shared-variables" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">`__managed__</span></code> and <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> variables cannot be marked with the keyword <code class="docutils literal notranslate"><span class="pre">constexpr</span></code>.</p>
</section>
<section id="defaulted-functions">
<span id="cpp11-defaulted-function"></span><h4><span class="section-number">15.5.22.10. </span>Defaulted functions<a class="headerlink" href="#defaulted-functions" title="Permalink to this headline">ï</a></h4>
<p>Execution space specifiers on a function that is explicitly-defaulted on its first declaration are ignored by the CUDA compiler. Instead, the CUDA compiler will infer the execution space specifiers as described in <a class="reference internal" href="#compiler-generated-functions"><span class="std std-ref">Implicitly-declared and explicitly-defaulted functions</span></a>.</p>
<p>Execution space specifiers are not ignored if the function is explicitly-defaulted, but not on its first declaration.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// warning: __host__ annotation is ignored on a function that</span>
<span class="w">  </span><span class="c1">//          is explicitly-defaulted on its first declaration</span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="nf">S1</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">//note: __device__ execution space is derived for S1::S1</span>
<span class="w">  </span><span class="c1">//       based on implicit call from within __device__ function</span>
<span class="w">  </span><span class="c1">//       foo1</span>
<span class="w">  </span><span class="n">S1</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="nf">S2</span><span class="p">();</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">//note: S2::S2 is not defaulted on its first declaration, and</span>
<span class="c1">//      its execution space is fixed to __host__  based on its</span>
<span class="c1">//      first declaration.</span>
<span class="n">S2</span><span class="o">::</span><span class="n">S2</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// error: call from __device__ function &#39;foo2&#39; to</span>
<span class="w">   </span><span class="c1">//        __host__ function &#39;S2::S2&#39;</span>
<span class="w">   </span><span class="n">S2</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="c-14-features">
<span id="cpp14"></span><h3><span class="section-number">15.5.23. </span>C++14 Features<a class="headerlink" href="#c-14-features" title="Permalink to this headline">ï</a></h3>
<p>C++14 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc <code class="docutils literal notranslate"><span class="pre">-std=c++14</span></code> flag turns on all C++14 features and also invokes the host preprocessor, compiler and linker with the corresponding C++14 dialect option <a class="footnote-reference brackets" href="#fn27" id="id368">27</a>. This section describes the restrictions on the supported C++14 features.</p>
<section id="functions-with-deduced-return-type">
<span id="return-type-deduction"></span><h4><span class="section-number">15.5.23.1. </span>Functions with deduced return type<a class="headerlink" href="#functions-with-deduced-return-type" title="Permalink to this headline">ï</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function cannot have a deduced return type.</p>
<p>If a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function has deduced return type, the CUDA frontend compiler will change the function declaration to have a <code class="docutils literal notranslate"><span class="pre">void</span></code> return type, before invoking the host compiler. This may cause issues for introspecting the deduced return type of the <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function in host code. Thus, the CUDA compiler will issue compile-time errors for referencing such deduced return type outside device function bodies, except if the reference is absent when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> is undefined.</p>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">fn1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">fn2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">device_fn1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// OK</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// error: referenced outside device function bodies</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">fn1</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="n">g1</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">host_fn1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error: referenced outside device function bodies</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S_local_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error: referenced outside device function bodies</span>
<span class="w">    </span><span class="k">decltype</span><span class="p">(</span><span class="n">fn2</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="w"> </span><span class="n">m1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">S_local_t</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m1</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// error: referenced outside device function bodies</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">fn2</span><span class="p">)</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">host_fn2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// error: referenced outside device function bodies</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S1_derived_t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">S1_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">fn1</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="variable-templates">
<span id="id369"></span><h4><span class="section-number">15.5.23.2. </span>Variable templates<a class="headerlink" href="#variable-templates" title="Permalink to this headline">ï</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">__device__/__constant__</span></code> variable template cannot have a const qualified type when using the Microsoft host compiler.</p>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// error: a __device__ variable template cannot</span>
<span class="c1">// have a const qualified type on Windows</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">d1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="c1">// error: a __device__ variable template cannot</span>
<span class="c1">// have a const qualified type on Windows</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">d2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>

<span class="c1">// OK</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">d3</span><span class="p">;</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d1</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d2</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="c-17-features">
<span id="cpp17"></span><h3><span class="section-number">15.5.24. </span>C++17 Features<a class="headerlink" href="#c-17-features" title="Permalink to this headline">ï</a></h3>
<p>C++17 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc <code class="docutils literal notranslate"><span class="pre">-std=c++17</span></code> flag turns on all C++17 features and also invokes the host preprocessor, compiler and linker with the corresponding C++17 dialect option <a class="footnote-reference brackets" href="#fn28" id="id370">28</a>. This section describes the restrictions on the supported C++17 features.</p>
<section id="inline-variable">
<span id="id371"></span><h4><span class="section-number">15.5.24.1. </span>Inline Variable<a class="headerlink" href="#inline-variable" title="Permalink to this headline">ï</a></h4>
<ul>
<li><p>A namespace scope inline variable declared with <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> or <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> memory space specifier must have internal linkage, if the code is compiled with nvcc in whole program compilation mode.</p>
<p>Examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="c1">//error when compiled with nvcc in</span>
<span class="w">                           </span><span class="c1">//whole program compilation mode.</span>
<span class="w">                           </span><span class="c1">//ok when compiled with nvcc in</span>
<span class="w">                           </span><span class="c1">//separate compilation mode.</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy0</span><span class="p">;</span><span class="w"> </span><span class="c1">// ok.</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w"> </span><span class="c1">// ok: internal linkage</span>
<span class="k">namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="kr">inline</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">zzz</span><span class="p">;</span><span class="w"> </span><span class="c1">// ok: internal linkage</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>When using g++ host compiler, an inline variable declared with <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> memory space specifier may not be visible to the debugger.</p></li>
</ul>
</section>
<section id="structured-binding">
<span id="id372"></span><h4><span class="section-number">15.5.24.2. </span>Structured Binding<a class="headerlink" href="#structured-binding" title="Permalink to this headline">ï</a></h4>
<p>A structured binding cannot be declared with a variable memory space specifier.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">b1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="w"> </span><span class="c1">// error</span>
</pre></div>
</div>
</section>
</section>
<section id="c-20-features">
<span id="cpp20"></span><h3><span class="section-number">15.5.25. </span>C++20 Features<a class="headerlink" href="#c-20-features" title="Permalink to this headline">ï</a></h3>
<p>C++20 features enabled by default by the host compiler are also supported by nvcc. Passing nvcc <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> flag turns on all C++20 features and also invokes the host preprocessor, compiler and linker with the corresponding C++20 dialect option <a class="footnote-reference brackets" href="#fn29" id="id373">29</a>. This section describes the restrictions on the supported C++20 features.</p>
<section id="module-support">
<span id="cpp20-module"></span><h4><span class="section-number">15.5.25.1. </span>Module support<a class="headerlink" href="#module-support" title="Permalink to this headline">ï</a></h4>
<p>Modules are not supported in CUDA C++, in either host or device code. Uses of the <code class="docutils literal notranslate"><span class="pre">module</span></code>, <code class="docutils literal notranslate"><span class="pre">export</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span></code> keywords are diagnosed as errors.</p>
</section>
<section id="coroutine-support">
<span id="cpp20-coroutine"></span><h4><span class="section-number">15.5.25.2. </span>Coroutine support<a class="headerlink" href="#coroutine-support" title="Permalink to this headline">ï</a></h4>
<p>Coroutines are not supported in device code. Uses of the <code class="docutils literal notranslate"><span class="pre">co_await</span></code>, <code class="docutils literal notranslate"><span class="pre">co_yield</span></code> and <code class="docutils literal notranslate"><span class="pre">co_return</span></code> keywords in the scope of a device function are diagnosed as error during device compilation.</p>
</section>
<section id="three-way-comparison-operator">
<span id="cpp20-spaceship"></span><h4><span class="section-number">15.5.25.3. </span>Three-way comparison operator<a class="headerlink" href="#three-way-comparison-operator" title="Permalink to this headline">ï</a></h4>
<p>The three-way comparison operator is supported in both host and device code, but some uses implicitly rely on functionality from the Standard Template Library provided by the host implementation. Uses of those operators may require specifying the flag <code class="docutils literal notranslate"><span class="pre">--expt-relaxed-constexpr</span></code> to silence warnings and the functionality requires that the host implementation satisfies the requirements of device code.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="cpf">&lt;compare&gt;</span><span class="cp"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">// ok, calls a user-defined host-device overload</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// call to an implicitly-declared function and requires</span>
<span class="w">                </span><span class="c1">// a device-compatible std::strong_ordering implementation</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="consteval-functions">
<span id="cpp20-consteval"></span><h4><span class="section-number">15.5.25.4. </span>Consteval functions<a class="headerlink" href="#consteval-functions" title="Permalink to this headline">ï</a></h4>
<p>Ordinarily, cross execution space calls are not allowed, and cause a compiler diagnostic (warning or error). This restriction does not apply when the called function is declared with the <code class="docutils literal notranslate"><span class="pre">consteval</span></code> specifier. Thus, a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function can call a <code class="docutils literal notranslate"><span class="pre">__host__</span></code><code class="docutils literal notranslate"><span class="pre">consteval</span></code> function, and a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function can call a <code class="docutils literal notranslate"><span class="pre">__device__</span> <span class="pre">consteval</span></code> function.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">N1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">//consteval host function</span>
<span class="k">consteval</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">hcallee</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">hcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">hcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hdfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">hcallee</span><span class="p">();</span><span class="w">  </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">hfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">hcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace N1</span>


<span class="k">namespace</span><span class="w"> </span><span class="nn">N2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="c1">//consteval device function</span>
<span class="k">consteval</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dcallee</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">gfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">dcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">hdfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dcallee</span><span class="p">();</span><span class="w">  </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">hfunc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dcallee</span><span class="p">();</span><span class="w"> </span><span class="cm">/* OK */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="polymorphic-function-wrappers">
<span id="id374"></span><h2><span class="section-number">15.6. </span>Polymorphic Function Wrappers<a class="headerlink" href="#polymorphic-function-wrappers" title="Permalink to this headline">ï</a></h2>
<p>A polymorphic function wrapper class template <code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> is provided in the <code class="docutils literal notranslate"><span class="pre">nvfunctional</span></code> header. Instances of this class template can be used to store, copy and invoke any callable target, e.g., lambda expressions. <code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> can be used in both host and device code.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvfunctional&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_d</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_hd</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_h</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_hd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn3</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fn2</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fn3</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">hostdevice_func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_hd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fn2</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">host_func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_h</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_hd</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn3</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn1</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fn2</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fn3</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Instances of <code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> in host code cannot be initialized with the address of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function or with a functor whose <code class="docutils literal notranslate"><span class="pre">operator()</span></code> is a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function. Instances of <code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> in device code cannot be initialized with the address of a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function or with a functor whose <code class="docutils literal notranslate"><span class="pre">operator()</span></code> is a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function.</p>
<p><code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> instances cannot be passed from host code to device code (and vice versa) at run time. <code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> cannot be used in the parameter type of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function, if the <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function is launched from host code.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nvfunctional&gt;</span><span class="cp"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_d</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__host__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_h</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">lam_h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">k</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error: initialized with address of __host__ function</span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_h</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// error: initialized with address of functor with</span>
<span class="w">  </span><span class="c1">// __host__ operator() function</span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lam_h</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error: initialized with address of __device__ function</span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo_d</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// error: initialized with address of functor with</span>
<span class="w">  </span><span class="c1">// __device__ operator() function</span>
<span class="w">  </span><span class="n">nvstd</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fn2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lam_d</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// error: passing nvstd::function from host to device</span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">fn2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nvstd::function</span></code> is defined in the <code class="docutils literal notranslate"><span class="pre">nvfunctional</span></code> header as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">nvstd</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_RetType</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">function</span><span class="o">&lt;</span><span class="n">_RetType</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="c1">// constructors</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="n">function</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_F</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="p">(</span><span class="n">_F</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// destructor</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="o">~</span><span class="n">function</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// assignment operators</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">function</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="n">function</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">_F</span><span class="o">&amp;&amp;</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// swap</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">function</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// function capacity</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="kt">bool</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// function invocation</span>
<span class="w">      </span><span class="n">__device__</span><span class="w"> </span><span class="n">_RetType</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// null pointer comparisons</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">nullptr_t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">nullptr_t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="n">nullptr_t</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// specialized algorithms</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">_R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">_ArgTypes</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">function</span><span class="o">&lt;</span><span class="n">_R</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;&amp;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="extended-lambdas">
<span id="extended-lambda"></span><h2><span class="section-number">15.7. </span>Extended Lambdas<a class="headerlink" href="#extended-lambdas" title="Permalink to this headline">ï</a></h2>
<p>The nvcc flag <code class="docutils literal notranslate"><span class="pre">'--extended-lambda'</span></code> allows explicit execution space annotations in a lambda expression <a class="footnote-reference brackets" href="#fn30" id="id375">30</a>. The execution space annotations should be present after the âlambda-introducerâ and before the optional âlambda-declaratorâ. nvcc will define the macro <code class="docutils literal notranslate"><span class="pre">__CUDACC_EXTENDED_LAMBDA__</span></code> when the <code class="docutils literal notranslate"><span class="pre">'--extended-lambda'</span></code> flag has been specified.</p>
<p>An âextended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambdaâ is a lambda expression that is annotated explicitly with â<code class="docutils literal notranslate"><span class="pre">__device__</span></code>â, and is defined within the immediate or nested block scope of a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function.</p>
<p>An âextended <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambdaâ is a lambda expression that is annotated explicitly with both â<code class="docutils literal notranslate"><span class="pre">__host__</span></code>â and â<code class="docutils literal notranslate"><span class="pre">__device__</span></code>â, and is defined within the immediate or nested block scope of a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function.</p>
<p>An âextended lambdaâ denotes either an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambda or an extended <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda. Extended lambdas can be used in the type arguments of <a class="reference internal" href="#cpp11-global"><span class="std std-ref">__global__ function template instantiation</span></a>.</p>
<p>If the execution space annotations are not explicitly specified, they are computed based on the scopes enclosing the closure class associated with the lambda, as described in the section on C++11 support. The execution space annotations are applied to all methods of the closure class associated with the lambda.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo_host</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// not an extended lambda: no explicit execution space annotations</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// extended __device__ lambda</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// extended __host__ __device__ lambda</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// not an extended lambda: explicitly annotated with only &#39;__host__&#39;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo_host_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// not an extended lambda: no explicit execution space annotations</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// extended __device__ lambda</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// extended __host__ __device__ lambda</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// not an extended lambda: explicitly annotated with only &#39;__host__&#39;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo_device</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// none of the lambdas within this function are extended lambdas,</span>
<span class="w">  </span><span class="c1">// because the enclosing function is not a __host__ or __host__ __device__</span>
<span class="w">  </span><span class="c1">// function.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// lam1 and lam2 are not extended lambdas because they are not defined</span>
<span class="c1">// within a __host__ or __host__ __device__ function.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<section id="extended-lambda-type-traits">
<span id="extended-lambda-traits"></span><h3><span class="section-number">15.7.1. </span>Extended Lambda Type Traits<a class="headerlink" href="#extended-lambda-type-traits" title="Permalink to this headline">ï</a></h3>
<p>The compiler provides type traits to detect closure types for extended lambdas at compile time:</p>
<p><code class="docutils literal notranslate"><span class="pre">__nv_is_extended_device_lambda_closure_type(type)</span></code>: If âtypeâ is the closure class created for an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambda, then the trait is true, otherwise it is false.</p>
<p><code class="docutils literal notranslate"><span class="pre">__nv_is_extended_device_lambda_with_preserved_return_type(type)</span></code>: If âtypeâ is the closure class created for an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambda and the lambda is defined with trailing return type (with restriction), then the trait is true, otherwise it is false. If the trailing return type definition refers to any lambda parameter name, the return type is not preserved.</p>
<p><code class="docutils literal notranslate"><span class="pre">__nv_is_extended_host_device_lambda_closure_type(type)</span></code>: If âtypeâ is the closure class created for an extended <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda, then the trait is true, otherwise it is false.</p>
<p>These traits can be used in all compilation modes, irrespective of whether lambdas or extended lambdas are enabled<a class="footnote-reference brackets" href="#fn31" id="id376">31</a>.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define IS_D_LAMBDA(X) __nv_is_extended_device_lambda_closure_type(X)</span>
<span class="cp">#define IS_DPRT_LAMBDA(X) __nv_is_extended_device_lambda_with_preserved_return_type(X)</span>
<span class="cp">#define IS_HD_LAMBDA(X) __nv_is_extended_host_device_lambda_closure_type(X)</span>

<span class="k">auto</span><span class="w"> </span><span class="n">lam0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam0 is not an extended lambda (since defined outside function scope)</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam0</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam0</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam0</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam1 is not an extended lambda (since no execution space annotations)</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam2 is an extended __device__ lambda</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam2</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam2</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam2</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam3 is an extended __host__ __device__ lambda</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam3</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam3</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam3</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam4 is an extended __device__ lambda with preserved return type</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam4</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam4</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam4</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// lam5 is not an extended __device__ lambda with preserved return type</span>
<span class="w">  </span><span class="c1">// because it references the operator()&#39;s parameter types in the trailing return type.</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="n">IS_D_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam5</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_DPRT_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam5</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">IS_HD_LAMBDA</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam5</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="extended-lambda-restrictions">
<span id="id377"></span><h3><span class="section-number">15.7.2. </span>Extended Lambda Restrictions<a class="headerlink" href="#extended-lambda-restrictions" title="Permalink to this headline">ï</a></h3>
<p>The CUDA compiler will replace an extended lambda expression with an instance of a placeholder type defined in namespace scope, before invoking the host compiler. The template argument of the placeholder type requires taking the address of a function enclosing the original extended lambda expression. This is required for the correct execution of any <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template whose template argument involves the closure type of an extended lambda. The <em>enclosing function</em> is computed as follows.</p>
<p>By definition, the extended lambda is present within the immediate or nested block scope of a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function. If this function is not the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> of a lambda expression, then it is considered the enclosing function for the extended lambda. Otherwise, the extended lambda is defined within the immediate or nested block scope of the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> of one or more enclosing lambda expressions. If the outermost such lambda expression is defined in the immediate or nested block scope of a function <code class="docutils literal notranslate"><span class="pre">F</span></code>, then <code class="docutils literal notranslate"><span class="pre">F</span></code> is the computed enclosing function, else the enclosing function does not exist.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// enclosing function for lam1 is &quot;foo&quot;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// enclosing function for lam4 is &quot;foo&quot;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">     </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">lam6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// enclosing function for lam7 does not exist</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>Here are the restrictions on extended lambdas:</p>
<ol class="arabic">
<li><p>An extended lambda cannot be defined inside another extended lambda expression.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error: extended lambda defined within another extended lambda</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>An extended lambda cannot be defined inside a generic lambda expression.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// error: extended lambda defined within a generic lambda</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>If an extended lambda is defined within the immediate or nested block scope of one or more nested lambda expression, the outermost such lambda expression must be defined inside the immediate or nested block scope of a function.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// error: outer enclosing lambda is not defined within a</span>
<span class="w">  </span><span class="c1">// non-lambda-operator() function.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The enclosing function for the extended lambda must be named and its address can be taken. If the enclosing function is a class member, then the following conditions must be satisfied:</p>
<ul class="simple">
<li><p>All classes enclosing the member function must have a name.</p></li>
<li><p>The member function must not have private or protected access within its parent class.</p></li>
<li><p>All enclosing classes must not have private or protected access within their respective parent classes.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="c1">// OK</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">S1_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Error: cannot take address of enclosing function</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">C0_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Error: enclosing function has private access in parent class</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S2_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Error: enclosing class S2_t has private access in its</span>
<span class="w">      </span><span class="c1">// parent class</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>It must be possible to take the address of the enclosing routine unambiguously, at the point where the extended lambda has been defined. This may not be feasible in some cases e.g. when a class typedef shadows a template type argument of the same name.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Bar</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">();</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Bar</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">A</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;::</span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* In code sent to host compiler, nvcc will inject an</span>
<span class="cm">     address expression here, of the form:</span>
<span class="cm">     (void (A&lt; Bar&gt; ::*)(void))(&amp;A::test))</span>

<span class="cm">     However, the class typedef &#39;Bar&#39; (to void) shadows the</span>
<span class="cm">     template argument &#39;Bar&#39;, causing the address</span>
<span class="cm">     expression in A&lt;int&gt;::test to actually refer to:</span>
<span class="cm">     (void (A&lt; void&gt; ::*)(void))(&amp;A::test))</span>

<span class="cm">     ..which doesn&#39;t take the address of the enclosing</span>
<span class="cm">     routine &#39;A&lt;int&gt;::test&#39; correctly.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">xxx</span><span class="p">.</span><span class="n">test</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>An extended lambda cannot be defined in a class that is local to a function.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Error: bar is member of a class that is local to a function.</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>The enclosing function for an extended lambda cannot have deduced return type.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: the return type of foo is deduced.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>__host__ __device__ extended lambdas cannot be generic lambdas.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: __host__ __device__ extended lambdas cannot be</span>
<span class="w">  </span><span class="c1">// generic lambdas.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: __host__ __device__ extended lambdas cannot be</span>
<span class="w">  </span><span class="c1">// generic lambdas.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">...</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">               </span><span class="k">return</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">              </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>If the enclosing function is an instantiation of a function template or a member function template, and/or the function is a member of a class template, the template(s) must satisfy the following constraints:</p>
<ul class="simple">
<li><p>The template must have at most one variadic parameter, and it must be listed last in the template parameter list.</p></li>
<li><p>The template parameters must be named.</p></li>
<li><p>The template instantiation argument types cannot involve types that are either local to a function (except for closure types for extended lambdas), or are private or protected class members.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">in</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">foo</span><span class="w"> </span><span class="p">{};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">P1</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">P2</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">bar1</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&lt;</span><span class="n">P1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&lt;</span><span class="n">P2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: enclosing function has multiple parameter packs</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">P1</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">bar2</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&lt;</span><span class="n">P1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: for enclosing function, the</span>
<span class="w">  </span><span class="c1">// parameter pack is not last in the template parameter list.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">bar3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: for enclosing function, the second template</span>
<span class="w">  </span><span class="c1">// parameter is not named.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">foo</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">bar1</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">bar2</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">bar3</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">in</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">bar4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">C1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="k">friend</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: enclosing function for device lambda in bar4</span>
<span class="w">  </span><span class="c1">// is instantiated with a type local to main.</span>
<span class="w">  </span><span class="n">bar4</span><span class="o">&lt;</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: enclosing function for device lambda in bar4</span>
<span class="w">  </span><span class="c1">// is instantiated with a type that is a private member</span>
<span class="w">  </span><span class="c1">// of a class.</span>
<span class="w">  </span><span class="n">bar4</span><span class="o">&lt;</span><span class="n">C1_t</span><span class="o">::</span><span class="n">S1_t</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>With Visual Studio host compilers, the enclosing function must have external linkage. The restriction is present because this host compiler does not support using the address of non-extern linkage functions as template arguments, which is needed by the CUDA compiler transformations to support extended lambdas.</p></li>
<li><p>With Visual Studio host compilers, an extended lambda shall not be defined within the body of an âif-constexprâ block.</p></li>
<li><p>An extended lambda has the following restrictions on captured variables:</p>
<ul class="simple">
<li><p>In the code sent to the host compiler, the variable may be passed by value to a sequence of helper functions before being used to direct-initialize the field of the class type used to represent the closure type for the extended lambda<a class="footnote-reference brackets" href="#fn32" id="id378">32</a>.</p></li>
<li><p>A variable can only be captured by value.</p></li>
<li><p>A variable of array type cannot be captured if the number of array dimensions is greater than 7.</p></li>
<li><p>For a variable of array type, in the code sent to the host compiler, the closure typeâs array field is first default-initialized, and then each element of the array field is copy-assigned from the corresponding element of the captured array variable. Therefore, the array element type must be default-constructible and copy-assignable in host code.</p></li>
<li><p>A function parameter that is an element of a variadic argument pack cannot be captured.</p></li>
<li><p>The type of the captured variable cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.</p></li>
<li><p>For a __host__ __device__ extended lambda, the types used in the return or parameter types of the lambda expressionâs <code class="docutils literal notranslate"><span class="pre">operator()</span></code> cannot involve types that are either local to a function (except for closure types of extended lambdas), or are private or protected class members.</p></li>
<li><p>Init-capture is not supported for __host__ __device__ extended lambdas. Init-capture is supported for __device__ extended lambdas, except when the init-capture is of array type or of type <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>.</p></li>
<li><p>The function call operator for an extended lambda is not constexpr. The closure type for an extended lambda is not a literal type. The constexpr and consteval specifier cannot be used in the declaration of an extended lambda.</p></li>
<li><p>A variable cannot be implicitly captured inside an if-constexpr block lexically nested inside an extended lambda, unless it has already been implicitly captured earlier outside the if-constexpr block or appears in the explicit capture list for the extended lambda (see example below).</p></li>
</ul>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// OK: an init-capture is allowed for an</span>
<span class="w">  </span><span class="c1">// extended __device__ lambda.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: an init-capture is not allowed for</span>
<span class="w">  </span><span class="c1">// an extended __host__ __device__ lambda.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: an extended __device__ lambda cannot capture</span>
<span class="w">  </span><span class="c1">// variables by reference.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: by-reference capture is not allowed</span>
<span class="w">  </span><span class="c1">// for an extended __device__ lambda.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">S1_t</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: a type local to a function cannot be used in the type</span>
<span class="w">  </span><span class="c1">// of a captured variable.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: an init-capture cannot be of type std::initializer_list.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">11</span><span class="p">}]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">33</span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: an init-capture cannot be of type std::initializer_list.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error scenario (lam9) and supported scenarios (lam10, lam11)</span>
<span class="w">  </span><span class="c1">// for capture within &#39;if-constexpr&#39; block</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">yyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">//Error: An extended __device__ lambda cannot first-capture</span>
<span class="w">      </span><span class="c1">//      &#39;yyy&#39; in constexpr-if context</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">yyy</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">//OK: &#39;yyy&#39; already listed in explicit capture list for the extended lambda</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">//OK: &#39;yyy&#39; already implicit captured outside the &#39;if-constexpr&#39; block</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">yyy</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>When parsing a function, the CUDA compiler assigns a counter value to each extended lambda within that function. This counter value is used in the substituted named type passed to the host compiler. Hence, whether or not an extended lambda is defined within a function should not depend on a particular value of <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code>, or on <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> being undefined.</p>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">in</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Error: the number and relative declaration</span>
<span class="w">  </span><span class="c1">// order of extended lambdas depends on</span>
<span class="w">  </span><span class="c1">// __CUDA_ARCH__</span>
<span class="cp">#if defined(__CUDA_ARCH__)</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host___</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>As described above, the CUDA compiler replaces a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> extended lambda defined in a host function with a placeholder type defined in namespace scope. Unless the trait <code class="docutils literal notranslate"><span class="pre">__nv_is_extended_device_lambda_with_preserved_return_type()</span></code> returns true for the closure type of the extended lambda, the placeholder type does not define a <code class="docutils literal notranslate"><span class="pre">operator()</span></code> function equivalent to the original lambda declaration. An attempt to determine the return type or parameter types of the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> function of such a lambda may therefore work incorrectly in host code, as the code processed by the host compiler will be semantically different than the input code processed by the CUDA compiler. However, it is OK to introspect the return type or parameter types of the <code class="docutils literal notranslate"><span class="pre">operator()</span></code> function within device code. Note that this restriction does not apply to <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> extended lambdas, or to <code class="docutils literal notranslate"><span class="pre">__device__</span></code> extended lambdas for which the trait <code class="docutils literal notranslate"><span class="pre">__nv_is_extended_device_lambda_with_preserved_return_type()</span></code> returns true.</p>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">getRef</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;10&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: attempt to extract the return type</span>
<span class="w">  </span><span class="c1">// of a __device__ lambda in host code</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)()</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">xx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">;</span><span class="w"></span>


<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;10&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// OK : lam2 represents a __host__ __device__ extended lambda</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam2</span><span class="p">)()</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">xx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;10&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// OK : lam3 represents a __device__ extended lambda with preserved return type</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam3</span><span class="p">)()</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">xx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;abc&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam3</span><span class="p">)()</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">getRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="c1">// lam4&#39;s return type is not preserved because it references the operator()&#39;s</span>
<span class="w">  </span><span class="c1">// parameter types in the trailing return type.</span>
<span class="w">  </span><span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">__nv_is_extended_device_lambda_with_preserved_return_type</span><span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam4</span><span class="p">)),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>For an extended device lambda:
-  Introspecting the parameter type of operator() is only supported in device code.
-  Introspecting the return type of operator() is supported only in device code, unless the trait function __nv_is_extended_device_lambda_with_preserved_return_type() returns true.</p></li>
<li><p>If the functor object represented by an extended lambda is passed from host to device code (e.g., as the argument of a <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function), then any expression in the body of the lambda expression that captures variables must be remain unchanged irrespective of whether the <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro is defined, and whether the macro has a particular value. This restriction arises because the lambdaâs closure class layout depends on the order in which captured variables are encountered when the compiler processes the lambda expression; the program may execute incorrectly if the closure class layout differs in device and host compilation.</p>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Error: &quot;x1&quot; is only captured when __CUDA_ARCH__ is defined.</span>
<span class="cp">#ifdef __CUDA_ARCH__</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>As described previously, the CUDA compiler replaces an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type does not define a pointer-to-function conversion operator in host code, however the conversion operator is provided in device code. Note that this restriction does not apply to <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> extended lambdas.</p>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kern</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// OK: conversion in device code is supported</span>
<span class="w">  </span><span class="n">fp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="c1">// OK: conversion in device code is supported</span>
<span class="w">  </span><span class="n">fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lam1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">fp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam_hd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam_d</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">kern</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam_hd</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// OK : conversion for __host__ __device__ lambda is supported</span>
<span class="w">  </span><span class="c1">// in host code</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lam_hd</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Error: conversion for __device__ lambda is not supported in</span>
<span class="w">  </span><span class="c1">// host code.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fp2</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lam_d</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>As described previously, the CUDA compiler replaces an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda expression with an instance of a placeholder type in the code sent to the host compiler. This placeholder type may define C++ special member functions (e.g. constructor, destructor). As a result, some standard C++ type traits may return different results for the closure type of the extended lambda, in the CUDA frontend compiler versus the host compiler. The following type traits are affected: <code class="docutils literal notranslate"><span class="pre">std::is_trivially_copyable</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_trivially_constructible</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_trivially_copy_constructible</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_trivially_move_constructible</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_trivially_destructible</span></code>.</p>
<p>Care must be taken that the results of these type traits are not used in <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function template instantiation or in <code class="docutils literal notranslate"><span class="pre">__device__</span> <span class="pre">/</span> <span class="pre">__constant__</span> <span class="pre">/</span> <span class="pre">__managed__</span></code> variable template instantiation.</p>
<p>Example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">__global__</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">dolaunch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="c1">// ERROR: this kernel launch may fail, because CUDA frontend compiler</span>
<span class="c1">// and host compiler may disagree on the result of</span>
<span class="c1">// std::is_trivially_copyable() trait on the closure type of the</span>
<span class="c1">// extended lambda</span>
<span class="n">foo</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copyable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">dolaunch</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">lam1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</li>
</ol>
<p>The CUDA compiler will generate compiler diagnostics for a subset of cases described in 1-12; no diagnostic will be generated for cases 13-17, but the host compiler may fail to compile the generated code.</p>
</section>
<section id="notes-on-host-device-lambdas">
<span id="host-device-lambda-notes"></span><h3><span class="section-number">15.7.3. </span>Notes on __host__ __device__ lambdas<a class="headerlink" href="#notes-on-host-device-lambdas" title="Permalink to this headline">ï</a></h3>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambdas, <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambdas can be called from host code. As described earlier, the CUDA compiler replaces an extended lambda expression defined in host code with an instance of a named placeholder type. The placeholder type for an extended <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda invokes the original lambdaâs <code class="docutils literal notranslate"><span class="pre">operator()</span></code> with an indirect function call <a class="footnote-reference brackets" href="#fn31" id="id379">31</a>.</p>
<p>The presence of the indirect function call may cause an extended <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda to be less optimized by the host compiler than lambdas that are implicitly or explicitly <code class="docutils literal notranslate"><span class="pre">__host__</span></code> only. In the latter case, the host compiler can easily inline the body of the lambda into the calling context. But in case of an extended <code class="docutils literal notranslate"><span class="pre">__host__</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">__device__</span></code> lambda, the host compiler encounters the indirect function call and may not be able to easily inline the original <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> lambda body.</p>
</section>
<section id="this-capture-by-value">
<span id="star-this-capture"></span><h3><span class="section-number">15.7.4. </span>*this Capture By Value<a class="headerlink" href="#this-capture-by-value" title="Permalink to this headline">ï</a></h3>
<p>When a lambda is defined within a non-static class member function, and the body of the lambda refers to a class member variable, C++11/C++14 rules require that the <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer of the class is captured by value, instead of the referenced member variable. If the lambda is an extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__host__</span></code><code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambda defined in a host function, and the lambda is executed on the GPU, accessing the referenced member variable on the GPU will cause a run time error if the <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer points to host memory.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> value = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">());</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">S1_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">xxx</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">       </span><span class="c1">// reference to &quot;xxx&quot; causes</span>
<span class="w">       </span><span class="c1">// the &#39;this&#39; pointer (S1_t*) to be captured by value</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Kernel launch fails at run time because &#39;this-&gt;xxx&#39;</span>
<span class="w">    </span><span class="c1">// is not accessible from the GPU</span>
<span class="w">    </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">S1_t</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">s1</span><span class="p">.</span><span class="n">doit</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>C++17 solves this problem by adding a new â*thisâ capture mode. In this mode, the compiler makes a copy of the object denoted by â*thisâ instead of capturing the pointer <code class="docutils literal notranslate"><span class="pre">this</span></code> by value. The â*thisâ capture mode is described in more detail here: <code class="docutils literal notranslate"><span class="pre">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0018r3.html</span></code> .</p>
<p>The CUDA compiler supports the â*thisâ capture mode for lambdas defined within <code class="docutils literal notranslate"><span class="pre">__device__</span></code> and <code class="docutils literal notranslate"><span class="pre">__global__</span></code> functions and for extended <code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambdas defined in host code, when the <code class="docutils literal notranslate"><span class="pre">--extended-lambda</span></code> nvcc flag is used.</p>
<p>Hereâs the above example modified to use â*thisâ capture mode:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> value = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">());</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">S1_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">xxx</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// note the &quot;*this&quot; capture specification</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">       </span><span class="c1">// reference to &quot;xxx&quot; causes</span>
<span class="w">       </span><span class="c1">// the object denoted by &#39;*this&#39; to be captured by</span>
<span class="w">       </span><span class="c1">// value, and the GPU code will access copy_of_star_this-&gt;xxx</span>
<span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Kernel launch succeeds</span>
<span class="w">    </span><span class="n">foo</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">S1_t</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">s1</span><span class="p">.</span><span class="n">doit</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>â*thisâ capture mode is not allowed for unannotated lambdas defined in host code, or for extended <code class="docutils literal notranslate"><span class="pre">__host__</span></code><code class="docutils literal notranslate"><span class="pre">__device__</span></code> lambdas, unless â*thisâ capture is enabled by the selected language dialect. Examples of supported and unsupported usage:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="n">S1_t</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">xxx</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">host_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// OK: use in an extended __device__ lambda</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use in an extended __host__ __device__ lambda</span>
<span class="w">    </span><span class="c1">// Error if *this capture not enabled by language dialect</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use in an unannotated lambda in host function</span>
<span class="w">    </span><span class="c1">// Error if *this capture not enabled by language dialect</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">device_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// OK: use in a lambda defined in a __device__ function</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// OK: use in a lambda defined in a __device__ function</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// OK: use in a lambda defined in a __device__ function</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">host_device_func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="c1">// OK: use in an extended __device__ lambda</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use in an extended __host__ __device__ lambda</span>
<span class="w">    </span><span class="c1">// Error if *this capture not enabled by language dialect</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Use in an unannotated lambda in a __host__ __device__ function</span>
<span class="w">    </span><span class="c1">// Error if *this capture not enabled by language dialect</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">lam3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">]</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">xxx</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="additional-notes">
<span id="extended-lambda-notes"></span><h3><span class="section-number">15.7.5. </span>Additional Notes<a class="headerlink" href="#additional-notes" title="Permalink to this headline">ï</a></h3>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">ADL</span> <span class="pre">Lookup</span></code>: As described earlier, the CUDA compiler will replace an extended lambda expression with an instance of a placeholder type, before invoking the host compiler. One template argument of the placeholder type uses the address of the function enclosing the original lambda expression. This may cause additional namespaces to participate in argument dependent lookup (ADL), for any host function call whose argument types involve the closure type of the extended lambda expression. This may cause an incorrect function to be selected by the host compiler.</p>
<p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">N1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S1_t</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">N2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">doit</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">     </span><span class="n">foo</span><span class="p">(</span><span class="n">in</span><span class="p">);</span><span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">N1</span><span class="o">::</span><span class="n">S1_t</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* extended __device__ lambda. In the code sent to the host compiler, this</span>
<span class="cm">     is replaced with the placeholder type instantiation expression</span>
<span class="cm">     &#39; __nv_dl_wrapper_t&lt; __nv_dl_tag&lt;void (*)(N1::S1_t in),(&amp;bar),1&gt; &gt; { }&#39;</span>

<span class="cm">     As a result, the namespace &#39;N1&#39; participates in ADL lookup of the</span>
<span class="cm">     call to &quot;foo&quot; in the body of N2::doit, causing ambiguity.</span>
<span class="cm">  */</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">lam1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">  </span><span class="n">N2</span><span class="o">::</span><span class="n">doit</span><span class="p">(</span><span class="n">lam1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the example above, the CUDA compiler replaced the extended lambda with a placeholder type that involves the <code class="docutils literal notranslate"><span class="pre">N1</span></code> namespace. As a result, the namespace <code class="docutils literal notranslate"><span class="pre">N1</span></code> participates in the ADL lookup for <code class="docutils literal notranslate"><span class="pre">foo(in)</span></code> in the body of <code class="docutils literal notranslate"><span class="pre">N2::doit</span></code>, and host compilation fails because multiple overload candidates <code class="docutils literal notranslate"><span class="pre">N1::foo</span></code> and <code class="docutils literal notranslate"><span class="pre">N2::foo</span></code> are found.</p>
</li>
</ol>
</section>
</section>
<section id="relaxed-constexpr-expt-relaxed-constexpr">
<span id="relaxed-constexpr"></span><h2><span class="section-number">15.8. </span>Relaxed Constexpr (-expt-relaxed-constexpr)<a class="headerlink" href="#relaxed-constexpr-expt-relaxed-constexpr" title="Permalink to this headline">ï</a></h2>
<p>By default, the following cross-execution space calls are not supported:</p>
<ol class="arabic">
<li><p>Calling a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>-only <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> function from a <code class="docutils literal notranslate"><span class="pre">__host__</span></code> function during host code generation phase (i.e, when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro is undefined). Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">D</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">();</span><span class="w">  </span><span class="c1">//ERROR: calling a __device__-only constexpr function from host code</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Calling a <code class="docutils literal notranslate"><span class="pre">__host__</span></code>-only <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> function from a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> or <code class="docutils literal notranslate"><span class="pre">__global__</span></code> function, during device code generation phase (i.e. when <code class="docutils literal notranslate"><span class="pre">__CUDA_ARCH__</span></code> macro is defined). Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">H</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">dmain</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">();</span><span class="w">  </span><span class="c1">//ERROR: calling a __host__-only constexpr function from device code</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
<p>The experimental flag <code class="docutils literal notranslate"><span class="pre">-expt-relaxed-constexpr</span></code> can be used to relax this constraint. When this flag is specified, the compiler will support cross execution space calls described above, as follows:</p>
<ol class="arabic">
<li><p>A cross-execution space call to a constexpr function is supported if it occurs in a context that requires constant evaluation, e.g., in the initializer of a constexpr variable. Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">doit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK: call is in a context that</span>
<span class="w">                          </span><span class="c1">// requires constant evaluation.</span>
<span class="p">}</span><span class="w"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK: call is in a context that</span>
<span class="w">                          </span><span class="c1">// requires constant evaluation.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Otherwise:</p>
<blockquote>
<div><ol class="loweralpha">
<li><p>During device code generation, device code is generated for the body of a  <code class="docutils literal notranslate"><span class="pre">__host__</span></code>-only constexpr function <code class="docutils literal notranslate"><span class="pre">H</span></code>, unless <code class="docutils literal notranslate"><span class="pre">H</span></code> is not used or is only called in a constexpr context. Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// NOTE: &quot;H&quot; is emitted in generated device code because it is</span>
<span class="c1">// called from device code in a non-constexpr context</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="n">in</span><span class="p">);</span><span class="w">  </span><span class="c1">// OK, even though argument is not a constant expression</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">in</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>All code restrictions applicable to a ``__device__``  function are also applicable to the ``constexpr host``-only function ``H`` that is called from device code. However, compiler may not emit any build time diagnostics for ``H`` for these restrictions</strong> <a class="footnote-reference brackets" href="#frelaxedconstexpr1" id="id380">15</a> .</p>
<blockquote>
<div><p>For example, the following code patterns are unsupported in the body of <code class="docutils literal notranslate"><span class="pre">H</span></code> (as with any <code class="docutils literal notranslate"><span class="pre">__device__</span></code> function), but no compiler diagnostic may be generated:</p>
<blockquote>
<div><ul>
<li><p>ODR-use of a host variable or <code class="docutils literal notranslate"><span class="pre">__host__</span></code>-only non-constexpr function. Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">qqq</span><span class="p">,</span><span class="w"> </span><span class="n">www</span><span class="p">;</span><span class="w"></span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">__host__</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qqq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">www</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">doit</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span><span class="w"> </span><span class="c1">// ERROR: H() attempts to refer to host variables &#39;qqq&#39; and &#39;www&#39;.</span>
<span class="w">                 </span><span class="c1">// code will compile, but will NOT execute correctly.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Use of exceptions (<code class="docutils literal notranslate"><span class="pre">throw/catch</span></code>) and RTTI (<code class="docutils literal notranslate"><span class="pre">typeid,</span> <span class="pre">dynamic_cast</span></code>). Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// NOTE: &quot;H&quot; is emitted in generated device code</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">H</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">Derived</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// ERROR: use of typeid in code executing on the GPU</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">};</span><span class="w"> </span><span class="c1">// ERROR: use of throw in code executing on the GPU</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">doit</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">Derived</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span><span class="w"> </span><span class="c1">//ERROR: H() attempts use typeid and throw(), which are not allowed in code that executes on the GPU</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</li>
<li><p>During host code generation, the body of a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>-only constexpr function <code class="docutils literal notranslate"><span class="pre">D</span></code> is preserved in the code sent to the host compiler. If the body of <code class="docutils literal notranslate"><span class="pre">D</span></code> attempts to ODR-use a namespace scope device variable or a <code class="docutils literal notranslate"><span class="pre">__device__</span></code>-only non-constexpr function, then the call to <code class="docutils literal notranslate"><span class="pre">D</span></code> from host code is not supported (code may build without compiler diagnostics, but may behave incorrectly at run time). Example:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">qqq</span><span class="p">,</span><span class="w"> </span><span class="n">www</span><span class="p">;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qqq</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="n">www</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">doit</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">(</span><span class="n">flag</span><span class="p">);</span><span class="w"> </span><span class="c1">// ERROR: D() attempts to refer to device variables &#39;qqq&#39; and &#39;www&#39;</span>
<span class="w">                 </span><span class="c1">// code will compile, but will NOT execute correctly.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Note: Given above restrictions and lack of compiler diagnostics for incorrect usage, be careful when calling a constexpr __host__ function in the standard C++ headers from device code</strong>, since the implementation of the function will vary depending on the host platform, e.g., based on the <code class="docutils literal notranslate"><span class="pre">libstdc++</span></code> version for gcc host compiler. Such code may break silently when being ported to a different platform or host compiler version (if the target C++ library implementation odr-uses a host code variable or function, as described earlier).</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="n">in</span><span class="p">);</span><span class="w"> </span><span class="c1">// &quot;std::foo&quot; is constexpr function defined in the host compiler&#39;s standard library header</span>
<span class="w">                         </span><span class="c1">// WARNING: if std::foo implementation ODR-uses host variables or functions,</span>
<span class="w">                         </span><span class="c1">// code will not work correctly</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div></blockquote>
</li>
</ol>
<dl class="footnote brackets">
<dt class="label" id="frelaxedconstexpr1"><span class="brackets"><a class="fn-backref" href="#id380">15</a></span></dt>
<dd><p>Diagnostics are usually generated during parsing, but the host-only function <code class="docutils literal notranslate"><span class="pre">H</span></code> may already have been parsed before the call to <code class="docutils literal notranslate"><span class="pre">H</span></code> from device code is encountered later in the translation unit.</p>
</dd>
</dl>
</section>
<section id="code-samples">
<span id="id381"></span><h2><span class="section-number">15.9. </span>Code Samples<a class="headerlink" href="#code-samples" title="Permalink to this headline">ï</a></h2>
<section id="data-aggregation-class">
<span id="id382"></span><h3><span class="section-number">15.9.1. </span>Data Aggregation Class<a class="headerlink" href="#data-aggregation-class" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PixelRGBA</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="n">r_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">g_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">b_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">a_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">                         </span><span class="n">r_</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">g_</span><span class="p">(</span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="n">b_</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">a_</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">r_</span><span class="p">,</span><span class="w"> </span><span class="n">g_</span><span class="p">,</span><span class="w"> </span><span class="n">b_</span><span class="p">,</span><span class="w"> </span><span class="n">a_</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">__device__</span><span class="w"></span>
<span class="n">PixelRGBA</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p2</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PixelRGBA</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">r_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">r_</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">g_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">g_</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="n">p1</span><span class="p">.</span><span class="n">b_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">b_</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">a_</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">a_</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">PixelRGBA</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...      // Initialization of p1 and p2 here</span>
<span class="w">    </span><span class="n">PixelRGBA</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="derived-class">
<span id="id383"></span><h3><span class="section-number">15.9.2. </span>Derived Class<a class="headerlink" href="#derived-class" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryPool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryPool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">Shape</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">putThis</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Draw</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">         </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">put</span><span class="p">(</span><span class="s">&quot;Shapeless&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Shape</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ix</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iy</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">iy</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">PutCoord</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Draw</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="o">~</span><span class="n">Point</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">GetPointObj</span><span class="p">(</span><span class="n">MemoryPool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pool</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">-20</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="n">rand</span><span class="p">(</span><span class="mi">-100</span><span class="p">,</span><span class="mi">-20</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="class-template">
<span id="id384"></span><h3><span class="section-number">15.9.3. </span>Class Template<a class="headerlink" href="#class-template" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">myValues</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="n">MAX_VALUES</span><span class="p">];</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="n">myValues</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">clear</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">setValue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Idx</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">putToMemory</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">valueLocation</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">__global__</span><span class="w"> </span><span class="n">useValues</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">memoryBuffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">myValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">myLocation</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__device__</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">useValues</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="function-template">
<span id="id385"></span><h3><span class="section-number">15.9.4. </span>Function Template<a class="headerlink" href="#function-template" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="p">(...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="n">__device__</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// Specialization</span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Explicit argument specification</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Implicit argument deduction</span>
<span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="kt">bool</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="functor-class">
<span id="id386"></span><h3><span class="section-number">15.9.5. </span>Functor Class<a class="headerlink" href="#functor-class" title="Permalink to this headline">ï</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Add</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">__device__</span><span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="k">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Device code</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">O</span><span class="o">&gt;</span><span class="w"> </span><span class="n">__global__</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">VectorOperation</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">O</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iElement</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">iElement</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">iElement</span><span class="p">],</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">iElement</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="n">VectorOperation</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">Add</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="fn15"><span class="brackets">16</span></dt>
<dd><p>e.g., the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code> syntax for launching kernels.</p>
</dd>
<dt class="label" id="fn16"><span class="brackets">17</span></dt>
<dd><p>This does not apply to entities that may be defined in more than one translation unit, such as compiler generated template instantiations.</p>
</dd>
<dt class="label" id="fn17"><span class="brackets"><a class="fn-backref" href="#id339">18</a></span></dt>
<dd><p>The intent is to allow variable memory space specifiers for static variables in a <code class="docutils literal notranslate"><span class="pre">__host__</span> <span class="pre">__device__</span></code> function during device compilation, but disallow it during host compilation</p>
</dd>
<dt class="label" id="fn19"><span class="brackets"><a class="fn-backref" href="#id349">19</a></span></dt>
<dd><p>One way to debug suspected layout mismatch of a type <code class="docutils literal notranslate"><span class="pre">C</span></code> is to use <code class="docutils literal notranslate"><span class="pre">printf</span></code> to output the values of <code class="docutils literal notranslate"><span class="pre">sizeof(C)</span></code> and <code class="docutils literal notranslate"><span class="pre">offsetof(C,</span> <span class="pre">field)</span></code> in host and device code.</p>
</dd>
<dt class="label" id="fn20"><span class="brackets"><a class="fn-backref" href="#id355">20</a></span></dt>
<dd><p>Note that this may negatively impact compile time due to presence of extra declarations.</p>
</dd>
<dt class="label" id="fn21"><span class="brackets"><a class="fn-backref" href="#id356">21</a></span></dt>
<dd><p>At present, the <code class="docutils literal notranslate"><span class="pre">-std=c++11</span></code> flag is supported only for the following host compilers : gcc version &gt;= 4.7, clang, icc &gt;= 15, and xlc &gt;= 13.1</p>
</dd>
<dt class="label" id="fn22"><span class="brackets"><a class="fn-backref" href="#id358">22</a></span></dt>
<dd><p>including <code class="docutils literal notranslate"><span class="pre">operator()</span></code></p>
</dd>
<dt class="label" id="fn23"><span class="brackets"><a class="fn-backref" href="#id360">23</a></span></dt>
<dd><p>The restrictions are the same as with a non-constexpr callee function.</p>
</dd>
<dt class="label" id="fn24"><span class="brackets"><a class="fn-backref" href="#id361">24</a></span></dt>
<dd><p>Note that the behavior of experimental flags may change in future compiler releases.</p>
</dd>
<dt class="label" id="fn25"><span class="brackets"><a class="fn-backref" href="#id363">25</a></span></dt>
<dd><p>C++ Standard Section <code class="docutils literal notranslate"><span class="pre">[basic.types]</span></code></p>
</dd>
<dt class="label" id="fn26"><span class="brackets"><a class="fn-backref" href="#id364">26</a></span></dt>
<dd><p>C++ Standard Section <code class="docutils literal notranslate"><span class="pre">[expr.const]</span></code></p>
</dd>
<dt class="label" id="fn27"><span class="brackets"><a class="fn-backref" href="#id368">27</a></span></dt>
<dd><p>At present, the <code class="docutils literal notranslate"><span class="pre">-std=c++14</span></code> flag is supported only for the following host compilers : gcc version &gt;= 5.1, clang version &gt;= 3.7 and icc version &gt;= 17</p>
</dd>
<dt class="label" id="fn28"><span class="brackets"><a class="fn-backref" href="#id370">28</a></span></dt>
<dd><p>At present, the <code class="docutils literal notranslate"><span class="pre">-std=c++17</span></code> flag is supported only for the following host compilers : gcc version &gt;= 7.0, clang version &gt;= 8.0, Visual Studio version &gt;= 2017, pgi compiler version &gt;= 19.0, icc compiler version &gt;= 19.0</p>
</dd>
<dt class="label" id="fn29"><span class="brackets"><a class="fn-backref" href="#id373">29</a></span></dt>
<dd><p>At present, the <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> flag is supported only for the following host compilers : gcc version &gt;= 10.0,  clang version &gt;= 10.0, Visual Studio Version &gt;= 2022 and nvc++ version &gt;= 20.7.</p>
</dd>
<dt class="label" id="fn30"><span class="brackets"><a class="fn-backref" href="#id375">30</a></span></dt>
<dd><p>When using the icc host compiler, this flag is only supported for icc &gt;= 1800.</p>
</dd>
<dt class="label" id="fn31"><span class="brackets">31</span><span class="fn-backref">(<a href="#id376">1</a>,<a href="#id379">2</a>)</span></dt>
<dd><p>The traits will always return false if extended lambda mode is not active.</p>
</dd>
<dt class="label" id="fn32"><span class="brackets"><a class="fn-backref" href="#id378">32</a></span></dt>
<dd><p>In contrast, the C++ standard specifies that the captured variable is used to direct-initialize the field of the closure type.</p>
</dd>
</dl>
</section>
</section>
</section>
<section id="texture-fetching">
<span id="id387"></span><h1><span class="section-number">16. </span>Texture Fetching<a class="headerlink" href="#texture-fetching" title="Permalink to this headline">ï</a></h1>
<p>This section gives the formula used to compute the value returned by the texture functions of <a class="reference internal" href="#texture-functions"><span class="std std-ref">Texture Functions</span></a> depending on the various attributes of the texture object (see <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>).</p>
<p>The texture bound to the texture object is represented as an array <em>T</em> of</p>
<ul class="simple">
<li><p><em>N</em> texels for a one-dimensional texture,</p></li>
<li><p><em>N x M</em> texels for a two-dimensional texture,</p></li>
<li><p><em>N x M x L</em> texels for a three-dimensional texture.</p></li>
</ul>
<p>It is fetched using non-normalized texture coordinates <em>x</em>, <em>y</em>, and <em>z</em>, or the normalized texture coordinates <em>x/N</em>, <em>y/M</em>, and <em>z/L</em> as described in <a class="reference internal" href="#texture-memory"><span class="std std-ref">Texture Memory</span></a>. In this section, the coordinates are assumed to be in the valid range. <a class="reference internal" href="#texture-memory"><span class="std std-ref">Texture Memory</span></a> explained how out-of-range coordinates are remapped to the valid range based on the addressing mode.</p>
<section id="nearest-point-sampling">
<span id="id388"></span><h2><span class="section-number">16.1. </span>Nearest-Point Sampling<a class="headerlink" href="#nearest-point-sampling" title="Permalink to this headline">ï</a></h2>
<p>In this filtering mode, the value returned by the texture fetch is</p>
<ul class="simple">
<li><p><em>tex(x)=T[i]</em> for a one-dimensional texture,</p></li>
<li><p><em>tex(x,y)=T[i,j]</em> for a two-dimensional texture,</p></li>
<li><p><em>tex(x,y,z)=T[i,j,k]</em> for a three-dimensional texture,</p></li>
</ul>
<p>where <em>i=floor(x)</em>, <em>j=floor(y)</em>, and <em>k=floor(z)</em>.</p>
<p><a class="reference internal" href="#nearest-point-sampling-nearest-point-sampling-fig"><span class="std std-ref">Figure 32</span></a> illustrates nearest-point sampling for a one-dimensional texture with <em>N=4</em>.</p>
<figure class="align-default" id="nearest-point-sampling-nearest-point-sampling-fig">
<img alt="_images/nearest-point-sampling-of-1-d-texture-of-4-texels.png" src="_images/nearest-point-sampling-of-1-d-texture-of-4-texels.png" />
<figcaption>
<p><span class="caption-number">Figure 35 </span><span class="caption-text">Nearest-Point Sampling Filtering Mode</span><a class="headerlink" href="#nearest-point-sampling-nearest-point-sampling-fig" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
<p>For integer textures, the value returned by the texture fetch can be optionally remapped to [0.0, 1.0] (see <a class="reference internal" href="#texture-memory"><span class="std std-ref">Texture Memory</span></a>).</p>
</section>
<section id="linear-filtering">
<span id="id389"></span><h2><span class="section-number">16.2. </span>Linear Filtering<a class="headerlink" href="#linear-filtering" title="Permalink to this headline">ï</a></h2>
<p>In this filtering mode, which is only available for floating-point textures, the value returned by the texture fetch is</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(tex(x)=(1-\alpha)T[i]+{\alpha}T[i+1]\)</span> for a one-dimensional texture,</p></li>
<li><p><span class="math notranslate nohighlight">\(tex(x)=(1-\alpha)T[i]+{\alpha}T[i+1]\)</span> for a one-dimensional texture,</p></li>
<li><p><span class="math notranslate nohighlight">\(tex(x,y)=(1-\alpha)(1-\beta)T[i,j]+\alpha(1-\beta)T[i+1,j]+(1-\alpha){\beta}T[i,j+1]+\alpha{\beta}T[i+1,j+1]\)</span> for a two-dimensional texture,</p></li>
<li><p><span class="math notranslate nohighlight">\(tex(x,y,z)\)</span> =</p>
<p><span class="math notranslate nohighlight">\((1-\alpha)(1-\beta)(1-\gamma)T[i,j,k]+\alpha(1-\beta)(1-\gamma)T[i+1,j,k]+\)</span></p>
<p><span class="math notranslate nohighlight">\((1-\alpha)\beta(1-\gamma)T[i,j+1,k]+\alpha\beta(1-\gamma)T[i+1,j+1,k]+\)</span></p>
<p><span class="math notranslate nohighlight">\((1-\alpha)(1-\beta){\gamma}T[i,j,k+1]+\alpha(1-\beta){\gamma}T[i+1,j,k+1]+\)</span></p>
<p><span class="math notranslate nohighlight">\((1-\alpha)\beta{\gamma}T[i,j+1,k+1]+\alpha\beta{\gamma}T[i+1,j+1,k+1]\)</span></p>
<p>for a three-dimensional texture,</p>
</li>
</ul>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(i=floor(x\ B)*, \alpha=frac(x\ B)*, *x\ B\ =x-0.5,\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(j=floor(y\ B)*, \beta=frac(y\ B)*, *y\ B\ =y-0.5,\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(k=floor(z\ B)*, \gamma=frac(z\ B)*, *z\ B\ = z-0.5,\)</span></p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, and <span class="math notranslate nohighlight">\(\gamma\)</span> are stored in 9-bit fixed point format with 8 bits of fractional value (so 1.0 is exactly represented).</p>
<p><a class="reference internal" href="#linear-filtering-of-1-d-texture-of-4-texels"><span class="std std-ref">Figure 33</span></a> illustrates linear filtering of a one-dimensional texture with <em>N=4</em>.</p>
<figure class="align-default" id="linear-filtering-of-1-d-texture-of-4-texels">
<img alt="_images/linear-filtering-of-1-d-texture-of-4-texels.png" src="_images/linear-filtering-of-1-d-texture-of-4-texels.png" />
<figcaption>
<p><span class="caption-number">Figure 36 </span><span class="caption-text">Linear Filtering Mode</span><a class="headerlink" href="#linear-filtering-of-1-d-texture-of-4-texels" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="table-lookup">
<h2><span class="section-number">16.3. </span>Table Lookup<a class="headerlink" href="#table-lookup" title="Permalink to this headline">ï</a></h2>
<p>A table lookup <em>TL(x)</em> where <em>x</em> spans the interval <em>[0,R]</em> can be implemented as <em>TL(x)=tex((N-1)/R)x+0.5)</em> in order to ensure that <em>TL(0)=T[0]</em> and <em>TL(R)=T[N-1]</em>.</p>
<p><a class="reference internal" href="#table-lookup-1-d-table-lookup-using-linear-filtering"><span class="std std-ref">Figure 34</span></a> illustrates the use of texture filtering to implement a table lookup with <em>R=4</em> or <em>R=1</em> from a one-dimensional texture with <em>N=4</em>.</p>
<figure class="align-default" id="table-lookup-1-d-table-lookup-using-linear-filtering">
<img alt="_images/1-d-table-lookup-using-linear-filtering.png" src="_images/1-d-table-lookup-using-linear-filtering.png" />
<figcaption>
<p><span class="caption-number">Figure 37 </span><span class="caption-text">One-Dimensional Table Lookup Using Linear Filtering</span><a class="headerlink" href="#table-lookup-1-d-table-lookup-using-linear-filtering" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="compute-capabilities">
<span id="id390"></span><h1><span class="section-number">17. </span>Compute Capabilities<a class="headerlink" href="#compute-capabilities" title="Permalink to this headline">ï</a></h1>
<p>The general specifications and features of a compute device depend on its compute capability (see <a class="reference internal" href="#compute-capability"><span class="std std-ref">Compute Capability</span></a>).</p>
<p><a class="reference internal" href="#features-and-technical-specifications-feature-support-per-compute-capability"><span class="std std-numref">Table 27</span></a> and
<a class="reference internal" href="#features-and-technical-specifications-technical-specifications-per-compute-capability"><span class="std std-numref">Table 28</span></a> show the features and technical specifications associated with each compute capability that is currently supported.</p>
<p>Section <a class="reference internal" href="#floating-point-standard"><span class="std std-ref">Floating-Point Standard</span></a> reviews compliance with the IEEE floating-point standard.</p>
<p>Sections <a class="reference internal" href="#compute-capability-5-x"><span class="std std-ref">Compute Capability 5.x</span></a>, <a class="reference internal" href="#compute-capability-6-x"><span class="std std-ref">Compute Capability 6.x</span></a>, <a class="reference internal" href="#compute-capability-7-x"><span class="std std-ref">Compute Capability 7.x</span></a>, <a class="reference internal" href="#compute-capability-8-x"><span class="std std-ref">Compute Capability 8.x</span></a>, <a class="reference internal" href="#compute-capability-9-0"><span class="std std-ref">Compute Capability 9.0</span></a>, <a class="reference internal" href="#compute-capability-10-x"><span class="std std-ref">Compute Capability 10.x</span></a>, and <a class="reference internal" href="#compute-capability-12-x"><span class="std std-ref">Compute Capability 12.0</span></a> give more details on the architecture of devices with these respective compute capabilities.</p>
<section id="feature-availability">
<span id="id391"></span><h2><span class="section-number">17.1. </span>Feature Availability<a class="headerlink" href="#feature-availability" title="Permalink to this headline">ï</a></h2>
<p>Most compute features introduced with a compute architecture are intended to be available on all subsequent architectures. This is shown in <a class="reference internal" href="#features-and-technical-specifications-feature-support-per-compute-capability"><span class="std std-numref">Table 27</span></a> by the âyesâ for availability of a feature on compute capabilities subsequent to its introduction.</p>
<section id="architecture-specific-features">
<span id="id392"></span><h3><span class="section-number">17.1.1. </span>Architecture-Specific Features<a class="headerlink" href="#architecture-specific-features" title="Permalink to this headline">ï</a></h3>
<p>Beginning with devices of Compute Capability 9.0, specialized compute features that are introduced with an architecture may not be guaranteed to be available on all subsequent compute capabilities. These features are called <em>architecture-specific</em> features and target acceleration of specialized operations, such as Tensor Core operations, which are not intended for all classes of compute capabilities or may significantly change on future generations.  Code must be compiled with an architecture-specific compiler target (see <a class="reference internal" href="#feature-set-compiler-targets"><span class="std std-ref">Feature Set Compiler Targets</span></a>) to enable architecture-specific features. Code compiled with an architecture-specific compiler target can only be run on the exact compute capability it was compiled for.</p>
</section>
<section id="family-specific-features">
<span id="id393"></span><h3><span class="section-number">17.1.2. </span>Family-Specific Features<a class="headerlink" href="#family-specific-features" title="Permalink to this headline">ï</a></h3>
<p>Beginning with devices of Compute Capability 10.0, some architecture-specific features are common to devices of more than one compute capability.  The devices that contain these features are part of the same family and these features can also be called <em>family-specific</em> features.  Family-specific features are guaranteed to be available on all devices in the same family. A family-specific compiler target is required to enable family-specific features. See <a class="reference internal" href="#feature-set-compiler-targets"><span class="std std-numref">Section 17.1.3</span></a>. Code compiled for a family-specific target can only be run on GPUs which are members of that family.</p>
</section>
<section id="feature-set-compiler-targets">
<span id="id394"></span><h3><span class="section-number">17.1.3. </span>Feature Set Compiler Targets<a class="headerlink" href="#feature-set-compiler-targets" title="Permalink to this headline">ï</a></h3>
<p>There are three sets of compute features which the compiler can target:</p>
<p><strong>Baseline Feature Set</strong>: The predominant set of compute features that are introduced with the intent to be available for subsequent compute architectures.  These features and their availability are summarized in <a class="reference internal" href="#features-and-technical-specifications-feature-support-per-compute-capability"><span class="std std-numref">Table 27</span></a>.</p>
<p><strong>Architecture-Specific Feature Set</strong>: A small and highly specialized set of features called architecture-specific, that are introduced to accelerate specialized operations, which are not guaranteed to be available or might change significantly on subsequent compute architectures.  These features are summarized in the respective âCompute Capability #.#â subsections.  The architecture-specific feature set is a superset of the family-specific feature set.  Architecture-specific compiler targets were introduced with Compute Capability 9.0 devices and are selected by using an <strong>a</strong> suffix in the compilation target, for example by specifying <code class="docutils literal notranslate"><span class="pre">compute_100a</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_120a</span></code> as the compute target.</p>
<p><strong>Family-Specific Feature Set</strong>: Some architecture-specific features are common to GPUs of more than one compute capability. These features are summarized in the respective âCompute Capability #.#â subsections. With a few exceptions, later generation devices with the same major compute capability are in the same family. <a class="reference internal" href="#family-specific-compatibility"><span class="std std-numref">Table 26</span></a> indicates the compatibility of family-specific targets with device compute capability, including exceptions. The family-specific feature set is a superset of the baseline feature set.  Family-specific compiler targets were introduced with Compute Capability 10.0 devices and are selected by using a <strong>f</strong> suffix in the compilation target, for example by specifying <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code> or <code class="docutils literal notranslate"><span class="pre">compute_120f</span></code> as the compute target.</p>
<p>All devices starting from compute capability 9.0 have a set of features that are architecture-specific. To utilize the complete set of these features on a specific GPU, the architecture-specific compiler target with the suffix <strong>a</strong> must be used. Additionally, starting from compute capability 10.0, there are sets of features that appear in multiple devices with different minor compute capability. These sets of instructions are called family-specific features, and the devices which share these features are said to be part of the same family. The family-specific features are a subset of the architecture-specific features that are shared by all members of that GPU family. The family-specific compiler target with the suffix <strong>f</strong> allows the compiler to generate code which uses this common subset of architecture-specific features.</p>
<p>For example:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">compute_100</span></code> compilation target does not allow use of architecture-specific features.  This target will be compatible with all devices of compute capability 10.0 and later.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code> <em>family-specific</em> compilation target allows the use of the subset of architecture-specific features that are common across the GPU family. This target will only be compatible with devices that are part of the GPU family. In this example it is compatible with devices of Compute Capability 10.0 and Compute Capability 10.3. The features available in the family-specific <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code> target is a superset of the features available in the baseline <code class="docutils literal notranslate"><span class="pre">compute_100</span></code> target.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">compute_100a</span></code> <em>architecture-specific</em> compilation target allows use of the complete set of architecture-specific features in Compute Capability 10.0 devices. This target will only be compatible with devices of Compute Capability 10.0 and no others. The features available in the <code class="docutils literal notranslate"><span class="pre">compute_100a</span></code> target form a superset of the features available in the <code class="docutils literal notranslate"><span class="pre">compute_100f</span></code> target.</p></li>
</ul>
<table class="table-no-stripes docutils align-default" id="family-specific-compatibility">
<caption><span class="caption-number">Table 26 </span><span class="caption-text">Family-Specific Compatibility</span><a class="headerlink" href="#family-specific-compatibility" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 36%" />
<col style="width: 31%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Compilation Target</p></th>
<th class="head" colspan="2"><p>Compatible with Compute Capability</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">compute_100f</span></code></p></td>
<td><p>10.0</p></td>
<td><p>10.3</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">compute_101f</span></code></p></td>
<td colspan="2"><p>10.1 <a class="footnote-reference brackets" href="#family1" id="id395">33</a></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">compute_103f</span></code></p></td>
<td colspan="2"><p>10.3 <a class="footnote-reference brackets" href="#family2" id="id396">34</a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">compute_120f</span></code></p></td>
<td><p>12.0</p></td>
<td><p>12.1</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">compute_121f</span></code></p></td>
<td colspan="2"><p>12.1 <a class="footnote-reference brackets" href="#family2" id="id397">34</a></p></td>
</tr>
</tbody>
</table>
<dl class="footnote brackets">
<dt class="label" id="family1"><span class="brackets"><a class="fn-backref" href="#id395">33</a></span></dt>
<dd><p>Compute Capability 10.1 is a special case and is not is not part of any other family.</p>
</dd>
<dt class="label" id="family2"><span class="brackets">34</span><span class="fn-backref">(<a href="#id396">1</a>,<a href="#id397">2</a>)</span></dt>
<dd><p>Some families only contain a single member when they are created. They may be expanded in the future to include more devices.</p>
</dd>
</dl>
</section>
</section>
<section id="features-and-technical-specifications">
<span id="id398"></span><h2><span class="section-number">17.2. </span>Features and Technical Specifications<a class="headerlink" href="#features-and-technical-specifications" title="Permalink to this headline">ï</a></h2>
<table class="small table-no-stripes longtable docutils align-default" id="features-and-technical-specifications-feature-support-per-compute-capability">
<caption><span class="caption-number">Table 27 </span><span class="caption-text">Feature Support per Compute Capability</span><a class="headerlink" href="#features-and-technical-specifications-feature-support-per-compute-capability" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 74%" />
<col style="width: 5%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p class="centered">
<strong>Feature Support</strong></p></th>
<th class="head" colspan="8"><p class="centered">
<strong>Compute Capability</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>(Unlisted features are supported for all compute capabilities)</p></td>
<td><p>5.0, 5.2</p></td>
<td><p>5.3</p></td>
<td><p>6.x</p></td>
<td><p>7.x</p></td>
<td><p>8.x</p></td>
<td><p>9.0</p></td>
<td><p>10.x</p></td>
<td><p>12.0</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic functions operating on 32-bit integer values in global memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Atomic functions operating on 32-bit integer values in shared memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic functions operating on 64-bit integer values in global memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Atomic functions operating on 64-bit integer values in shared memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic functions operating on 128-bit integer values in global memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Atomic functions operating on 128-bit integer values in shared memory (<a class="reference internal" href="#atomic-functions"><span class="std std-ref">Atomic Functions</span></a>)</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic addition operating on 32-bit floating point values in global and shared memory (<a class="reference internal" href="#atomicadd"><span class="std std-ref">atomicAdd()</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Atomic addition operating on 64-bit floating point values in global memory and shared memory (<a class="reference internal" href="#atomicadd"><span class="std std-ref">atomicAdd()</span></a>)</p></td>
<td colspan="2"><p>No</p></td>
<td colspan="6"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Atomic addition operating on float2 and float4 floating point vectors in global memory (<a class="reference internal" href="#atomicadd"><span class="std std-ref">atomicAdd()</span></a>)</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Warp vote functions (<a class="reference internal" href="#warp-vote-functions"><span class="std std-ref">Warp Vote Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Memory fence functions (<a class="reference internal" href="#memory-fence-functions"><span class="std std-ref">Memory Fence Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Synchronization functions (<a class="reference internal" href="#synchronization-functions"><span class="std std-ref">Synchronization Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Surface functions (<a class="reference internal" href="#surface-functions"><span class="std std-ref">Surface Functions</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Unified Memory Programming (<a class="reference internal" href="#um-unified-memory-programming-hd"><span class="std std-ref">Unified Memory Programming</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Dynamic Parallelism (<a class="reference internal" href="#cuda-dynamic-parallelism"><span class="std std-ref">CUDA Dynamic Parallelism</span></a>)</p></td>
<td colspan="8"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Half-precision floating-point operations: addition, subtraction, multiplication, comparison, warp shuffle functions, conversion</p></td>
<td><p>No</p></td>
<td colspan="7"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Bfloat16-precision floating-point operations: addition, subtraction, multiplication, comparison, warp shuffle functions, conversion</p></td>
<td colspan="4"><p>No</p></td>
<td colspan="4"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Tensor Cores</p></td>
<td colspan="3"><p>No</p></td>
<td colspan="5"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Mixed Precision Warp-Matrix Functions (<a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a>)</p></td>
<td colspan="3"><p>No</p></td>
<td colspan="5"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Hardware-accelerated <code class="docutils literal notranslate"><span class="pre">memcpy_async</span></code> (<a class="reference internal" href="#memcpy-async-pipeline"><span class="std std-ref">Asynchronous Data Copies using cuda::pipeline</span></a>)</p></td>
<td colspan="4"><p>No</p></td>
<td colspan="4"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Hardware-accelerated Split Arrive/Wait Barrier (<a class="reference internal" href="#aw-barrier"><span class="std std-ref">Asynchronous Barrier</span></a>)</p></td>
<td colspan="4"><p>No</p></td>
<td colspan="4"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>L2 Cache Residency Management (<a class="reference internal" href="#l2-access-intro"><span class="std std-ref">Device Memory L2 Access Management</span></a>)</p></td>
<td colspan="4"><p>No</p></td>
<td colspan="4"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>DPX Instructions for Accelerated Dynamic Programming</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Distributed Shared Memory</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Thread Block Cluster</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Tensor Memory Accelerator (TMA) unit</p></td>
<td colspan="5"><p>No</p></td>
<td colspan="3"><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>Note that the KB and K units used in the following table correspond to 1024 bytes (i.e., a KiB) and 1024 respectively.</p>
<table class="small table-no-stripes longtable colwidths-given docutils align-default" id="features-and-technical-specifications-technical-specifications-per-compute-capability">
<caption><span class="caption-number">Table 28 </span><span class="caption-text">Technical Specifications per Compute Capability</span><a class="headerlink" href="#features-and-technical-specifications-technical-specifications-per-compute-capability" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 31%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="16"><p class="centered">
<strong>Compute Capability</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Technical Specifications</p></td>
<td><p>5.0</p></td>
<td><p>5.2</p></td>
<td><p>5.3</p></td>
<td><p>6.0</p></td>
<td><p>6.1</p></td>
<td><p>6.2</p></td>
<td><p>7.0</p></td>
<td><p>7.2</p></td>
<td><p>7.5</p></td>
<td><p>8.0</p></td>
<td><p>8.6</p></td>
<td><p>8.7</p></td>
<td><p>8.9</p></td>
<td><p>9.0</p></td>
<td><p>10.x</p></td>
<td><p>12.0</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum number of
resident grids per device
(Concurrent Kernel
Execution)</p></td>
<td colspan="2"><p>32</p></td>
<td><p>16</p></td>
<td><p>128</p></td>
<td><p>32</p></td>
<td><p>16</p></td>
<td><p>128</p></td>
<td><p>16</p></td>
<td colspan="8"><p>128</p></td>
</tr>
<tr class="row-even"><td><p>Maximum dimensionality of
grid of thread blocks</p></td>
<td colspan="16"><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum x -dimension of a
grid of thread blocks
[thread blocks]</p></td>
<td colspan="16"><p>2<sup>31</sup>-1</p></td>
</tr>
<tr class="row-even"><td><p>Maximum y- or z-dimension
of a grid of thread
blocks</p></td>
<td colspan="16"><p>65535</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum dimensionality of
thread block</p></td>
<td colspan="16"><p>3</p></td>
</tr>
<tr class="row-even"><td><p>Maximum x- or
y-dimensionality of a
block</p></td>
<td colspan="16"><p>1024</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum z-dimension
of a block</p></td>
<td colspan="16"><p>64</p></td>
</tr>
<tr class="row-even"><td><p>Maximum number of
threads per block</p></td>
<td colspan="16"><p>1024</p></td>
</tr>
<tr class="row-odd"><td><p>Warp size</p></td>
<td colspan="16"><p>32</p></td>
</tr>
<tr class="row-even"><td><p>Maximum number of
resident blocks per SM</p></td>
<td colspan="8"><p>32</p></td>
<td><p>16</p></td>
<td><p>32</p></td>
<td colspan="2"><p>16</p></td>
<td><p>24</p></td>
<td colspan="3"><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum number of
resident warps per SM</p></td>
<td colspan="8"><p>64</p></td>
<td><p>32</p></td>
<td><p>64</p></td>
<td colspan="3"><p>48</p></td>
<td colspan="2"><p>64</p></td>
<td><p>48</p></td>
</tr>
<tr class="row-even"><td><p>Maximum number of
resident threads per SM</p></td>
<td colspan="8"><p>2048</p></td>
<td><p>1024</p></td>
<td><p>2048</p></td>
<td colspan="3"><p>1536</p></td>
<td colspan="2"><p>2048</p></td>
<td><p>1536</p></td>
</tr>
<tr class="row-odd"><td><p>Number of 32-bit
registers per SM</p></td>
<td colspan="16"><p>64 K</p></td>
</tr>
<tr class="row-even"><td><p>Maximum number of 32-bit
registers per thread
block</p></td>
<td colspan="2"><p>64 K</p></td>
<td><p>32 K</p></td>
<td colspan="2"><p>64 K</p></td>
<td><p>32 K</p></td>
<td colspan="10"><p>64 K</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum number of 32-bit
registers per thread</p></td>
<td colspan="16"><p>255</p></td>
</tr>
<tr class="row-even"><td><p>Maximum amount of shared
memory per SM</p></td>
<td><p>64 KB</p></td>
<td><p>96 KB</p></td>
<td colspan="2"><p>64 KB</p></td>
<td><p>96 KB</p></td>
<td><p>64 KB</p></td>
<td colspan="2"><p>96 KB</p></td>
<td><p>64 KB</p></td>
<td><p>164
KB</p></td>
<td><p>100
KB</p></td>
<td><p>164
KB</p></td>
<td><p>100
KB</p></td>
<td colspan="2"><p>228
KB</p></td>
<td><p>100
KB</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum amount of shared
memory per thread block
<a class="footnote-reference brackets" href="#fn33" id="id399">35</a></p></td>
<td colspan="6"><p>48 KB</p></td>
<td><p>96 KB</p></td>
<td><p>96 KB</p></td>
<td><p>64 KB</p></td>
<td><p>163
KB</p></td>
<td><p>99 KB</p></td>
<td><p>163
KB</p></td>
<td><p>99 KB</p></td>
<td colspan="2"><p>227
KB</p></td>
<td><p>99 KB</p></td>
</tr>
<tr class="row-even"><td><p>Number of shared
memory banks</p></td>
<td colspan="16"><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum amount of local
memory per thread</p></td>
<td colspan="16"><p>512 KB</p></td>
</tr>
<tr class="row-even"><td><p>Constant memory size</p></td>
<td colspan="16"><p>64 KB</p></td>
</tr>
<tr class="row-odd"><td><p>Cache working set per SM
for constant memory</p></td>
<td colspan="3"><p>8 KB</p></td>
<td><p>4 KB</p></td>
<td colspan="12"><p>8 KB</p></td>
</tr>
<tr class="row-even"><td><p>Cache  working set per SM
for texture memory</p></td>
<td colspan="3"><p>Between 12 KB and 48 KB</p></td>
<td colspan="3"><p>Between 24 KB and 48 KB</p></td>
<td colspan="2"><p>32 ~ 128 KB</p></td>
<td><p>32 or
64 KB</p></td>
<td><p>28 KB
~ 192
KB</p></td>
<td><p>28 KB
~ 128
KB</p></td>
<td><p>28 KB
~ 192
KB</p></td>
<td><p>28 KB
~ 128
KB</p></td>
<td colspan="2"><p>28 KB
~ 256
KB</p></td>
<td><p>28 KB
~ 128
KB</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width for a 1D
texture object using
a CUDA array</p></td>
<td colspan="3"><p>65536</p></td>
<td colspan="13"><p>131072</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width for a 1D
texture object using
linear memory</p></td>
<td colspan="3"><p>2<sup>27</sup></p></td>
<td><p>2<sup>28</sup></p></td>
<td colspan="2"><p>2<sup>27</sup></p></td>
<td><p>2<sup>28</sup></p></td>
<td><p>2<sup>27</sup></p></td>
<td colspan="8"><p>2<sup>28</sup></p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width and number
of layers for a 1D
layered texture object</p></td>
<td colspan="3"><p>16384
x
2048</p></td>
<td colspan="13"><p>32768
x
2048</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width and height
for a 2D texture
object using a CUDA
array</p></td>
<td colspan="3"><p>65536
x
65536</p></td>
<td colspan="13"><p>131072
x
65536</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width and height
for a 2D texture
object using
linear memory</p></td>
<td colspan="3"><p>65536
x
65536</p></td>
<td colspan="13"><p>131072
x
65000</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width and height
for a 2D texture
object using a CUDA
array supporting texture
gather</p></td>
<td colspan="3"><p>16384
x
16384</p></td>
<td colspan="13"><p>32768
x
32768</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width, height,
and number of layers for
a 2D layered texture
object</p></td>
<td colspan="3"><p>16384 x 16384 x 2048</p></td>
<td colspan="13"><p>32768 x 32768 x 2048</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width, height,
and depth for a 3D
texture object using
to a CUDA array</p></td>
<td colspan="3"><p>4096 x 4096 x 4096</p></td>
<td colspan="13"><p>16384 x 16384 x 16384</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width (and
height) for a cubemap
texture object</p></td>
<td colspan="3"><p>16384</p></td>
<td colspan="13"><p>32768</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width (and
height) and number of
layers for a cubemap
layered texture object</p></td>
<td colspan="3"><p>16384
x
2046</p></td>
<td colspan="13"><p>32768
x
2046</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum number of
textures that can be
bound to a kernel</p></td>
<td colspan="16"><p>256</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width for a 1D
surface object using
a CUDA array</p></td>
<td colspan="3"><p>16384</p></td>
<td colspan="13"><p>32768</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width and number
of layers for a 1D
layered surface object</p></td>
<td colspan="3"><p>16384
x
2048</p></td>
<td colspan="13"><p>32768
x
2048</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width and height
for a 2D surface
object using a
CUDA array</p></td>
<td colspan="3"><p>65536
x
65536</p></td>
<td colspan="13"><p>1
31072
x
65536</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width, height,
and number of layers for
a 2D layered surface
object</p></td>
<td colspan="3"><p>16384
x
16384 x 2048</p></td>
<td colspan="13"><p>32768
x
32768 x 1048</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width, height,
and depth for a 3D
surface object using
a CUDA array</p></td>
<td colspan="3"><p>4096
x
4096 x 4096</p></td>
<td colspan="13"><p>16384
x
16384 x 16384</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum width (and
height) for a cubemap
surface object using
a CUDA array</p></td>
<td colspan="3"><p>16384</p></td>
<td colspan="13"><p>32768</p></td>
</tr>
<tr class="row-even"><td><p>Maximum width (and
height) and number of
layers for a cubemap
layered surface object</p></td>
<td colspan="3"><p>16384
x
2046</p></td>
<td colspan="13"><p>32768
x
2046</p></td>
</tr>
<tr class="row-odd"><td><p>Maximum number of
surfaces that can use
a kernel</p></td>
<td colspan="6"><p>16</p></td>
<td colspan="10"><p>32</p></td>
</tr>
</tbody>
</table>
</section>
<section id="floating-point-standard">
<span id="id400"></span><h2><span class="section-number">17.3. </span>Floating-Point Standard<a class="headerlink" href="#floating-point-standard" title="Permalink to this headline">ï</a></h2>
<p>All compute devices follow the IEEE 754-2008 standard for binary floating-point arithmetic with the following deviations:</p>
<ul class="simple">
<li><p>There is no dynamically configurable rounding mode; however, most of the operations support multiple IEEE rounding modes, exposed via device intrinsics.</p></li>
<li><p>There is no mechanism for detecting that a floating-point exception has occurred and all operations behave as if the IEEE-754 exceptions are always masked, and deliver the masked response as defined by IEEE-754 if there is an exceptional event. For the same reason, while SNaN encodings are supported, they are not signaling and are handled as quiet.</p></li>
<li><p>The result of a single-precision floating-point operation involving one or more input NaNs is the quiet NaN of bit pattern 0x7fffffff.</p></li>
<li><p>Double-precision floating-point absolute value and negation are not compliant with IEEE-754 with respect to NaNs; these are passed through unchanged.</p></li>
</ul>
<p>Code must be compiled with <code class="docutils literal notranslate"><span class="pre">-ftz=false</span></code>, <code class="docutils literal notranslate"><span class="pre">-prec-div=true</span></code>, and <code class="docutils literal notranslate"><span class="pre">-prec-sqrt=true</span></code> to ensure IEEE compliance (this is the default setting; see the <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> user manual for description of these compilation flags).</p>
<p>Regardless of the setting of the compiler flag <code class="docutils literal notranslate"><span class="pre">-ftz</span></code>,</p>
<ul class="simple">
<li><p>atomic single-precision floating-point adds on global memory always operate in flush-to-zero mode, i.e., behave equivalent to <code class="docutils literal notranslate"><span class="pre">FADD.F32.FTZ.RN</span></code>,</p></li>
<li><p>atomic single-precision floating-point adds on shared memory always operate with denormal support, i.e., behave equivalent to <code class="docutils literal notranslate"><span class="pre">FADD.F32.RN</span></code>.</p></li>
</ul>
<p>In accordance to the IEEE-754R standard, if one of the input parameters to <code class="docutils literal notranslate"><span class="pre">fminf()</span></code>, <code class="docutils literal notranslate"><span class="pre">fmin()</span></code>, <code class="docutils literal notranslate"><span class="pre">fmaxf()</span></code>, or <code class="docutils literal notranslate"><span class="pre">fmax()</span></code> is NaN, but not the other, the result is the non-NaN parameter.</p>
<p>The conversion of a floating-point value to an integer value in the case where the floating-point value falls outside the range of the integer format is left undefined by IEEE-754. For compute devices, the behavior is to clamp to the end of the supported range. This is unlike the x86 architecture behavior.</p>
<p>The behavior of integer division by zero and integer overflow is left undefined by IEEE-754. For compute devices, there is no mechanism for detecting that such integer operation exceptions have occurred. Integer division by zero yields an unspecified, machine-specific value.</p>
<p><a class="reference external" href="https://developer.nvidia.com/content/precision-performance-floating-point-and-ieee-754-compliance-nvidia-gpus">https://developer.nvidia.com/content/precision-performance-floating-point-and-ieee-754-compliance-nvidia-gpus</a> includes more information on the floating point accuracy and compliance of NVIDIA GPUs.</p>
</section>
<section id="compute-capability-5-x">
<span id="id401"></span><h2><span class="section-number">17.4. </span>Compute Capability 5.x<a class="headerlink" href="#compute-capability-5-x" title="Permalink to this headline">ï</a></h2>
<section id="architecture">
<span id="architecture-5-x"></span><h3><span class="section-number">17.4.1. </span>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline">ï</a></h3>
<p>An SM consists of:</p>
<ul class="simple">
<li><p>128 CUDA cores for arithmetic operations (see <a class="reference internal" href="#arithmetic-instructions"><span class="std std-ref">Arithmetic Instructions</span></a> for throughputs of arithmetic operations),</p></li>
<li><p>32 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>When an SM is given warps to execute, it first distributes them among the four schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified L1/texture cache of 24 KB used to cache reads from global memory,</p></li>
<li><p>64 KB of shared memory for devices of compute capability 5.0 or 96 KB of shared memory for devices of compute capability 5.2.</p></li>
</ul>
<p>The unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
<p>There is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the <code class="docutils literal notranslate"><span class="pre">l2CacheSize</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>).</p>
<p>The cache behavior (e.g., whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.</p>
</section>
<section id="global-memory-5-x">
<span id="id402"></span><h3><span class="section-number">17.4.2. </span>Global Memory<a class="headerlink" href="#global-memory-5-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory accesses are always cached in L2.</p>
<p>Data that is read-only for the entire lifetime of the kernel can also be cached in the unified L1/texture cache described in the previous section by reading it using the <code class="docutils literal notranslate"><span class="pre">__ldg()</span></code> function (see <a class="reference internal" href="#ldg-function"><span class="std std-ref">Read-Only Data Cache Load Function</span></a>). When the compiler detects that the read-only condition is satisfied for some data, it will use <code class="docutils literal notranslate"><span class="pre">__ldg()</span></code> to read it. The compiler might not always be able to detect that the read-only condition is satisfied for some data. Marking pointers used for loading such data with both the <code class="docutils literal notranslate"><span class="pre">const</span></code> and <code class="docutils literal notranslate"><span class="pre">__restrict__</span></code> qualifiers increases the likelihood that the compiler will detect the read-only condition.</p>
<p>Data that is not read-only for the entire lifetime of the kernel cannot be cached in the unified L1/texture cache for devices of compute capability 5.0. For devices of compute capability 5.2, it is, by default, not cached in the unified L1/texture cache, but caching may be enabled using the following mechanisms:</p>
<ul class="simple">
<li><p>Perform the read using inline assembly with the appropriate modifier as described in the PTX reference manual;</p></li>
<li><p>Compile with the <code class="docutils literal notranslate"><span class="pre">-Xptxas</span> <span class="pre">-dlcm=ca</span></code> compilation flag, in which case all reads are cached, except reads that are performed using inline assembly with a modifier that disables caching;</p></li>
<li><p>Compile with the <code class="docutils literal notranslate"><span class="pre">-Xptxas</span> <span class="pre">-fscm=ca</span></code> compilation flag, in which case all reads are cached, including reads that are performed using inline assembly regardless of the modifier used.</p></li>
</ul>
<p>When caching is enabled using one of the three mechanisms listed above, devices of compute capability 5.2 will cache global memory reads in the unified L1/texture cache for all kernel launches except for the kernel launches for which thread blocks consume too much of the SMâs register file. These exceptions are reported by the profiler.</p>
</section>
<section id="shared-memory-5-x">
<span id="id403"></span><h3><span class="section-number">17.4.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-5-x" title="Permalink to this headline">ï</a></h3>
<p>Shared memory has 32 banks that are organized such that successive 32-bit words map to successive banks. Each bank has a bandwidth of 32 bits per clock cycle.</p>
<p>A shared memory request for a warp does not generate a bank conflict between two threads that access any address within the same 32-bit word (even though the two addresses fall in the same bank). In that case, for read accesses, the word is broadcast to the requesting threads and for write accesses, each address is written by only one of the threads (which thread performs the write is undefined).</p>
<p><a class="reference internal" href="#shared-memory-5-x-examples-of-strided-shared-memory-accesses"><span class="std std-ref">Figure 22</span></a> shows some examples of strided access.</p>
<p><a class="reference internal" href="#shared-memory-5-x-examples-of-irregular-shared-memory-accesses"><span class="std std-ref">Figure 23</span></a> shows some examples of memory read accesses that involve the broadcast mechanism.</p>
<figure class="align-center" id="shared-memory-5-x-examples-of-strided-shared-memory-accesses">
<img alt="Strided Shared Memory Accesses in 32 bit bank size mode." src="_images/examples-of-strided-shared-memory-accesses.png" />
<figcaption>
<p><span class="caption-number">Figure 38 </span><span class="caption-text">Strided Shared Memory Accesses in 32 bit bank size mode.</span><a class="headerlink" href="#shared-memory-5-x-examples-of-strided-shared-memory-accesses" title="Permalink to this image">ï</a></p>
<div class="legend">
<dl class="simple">
<dt>Left</dt><dd><p>Linear addressing with a stride of one 32-bit word (no bank conflict).</p>
</dd>
<dt>Middle</dt><dd><p>Linear addressing with a stride of two 32-bit words (two-way bank conflict).</p>
</dd>
<dt>Right</dt><dd><p>Linear addressing with a stride of three 32-bit words (no bank conflict).</p>
</dd>
</dl>
</div>
</figcaption>
</figure>
<figure class="align-center" id="shared-memory-5-x-examples-of-irregular-shared-memory-accesses">
<img alt="Irregular Shared Memory Accesses." src="_images/examples-of-irregular-shared-memory-accesses.png" />
<figcaption>
<p><span class="caption-number">Figure 39 </span><span class="caption-text">Irregular Shared Memory Accesses.</span><a class="headerlink" href="#shared-memory-5-x-examples-of-irregular-shared-memory-accesses" title="Permalink to this image">ï</a></p>
<div class="legend">
<dl class="simple">
<dt>Left</dt><dd><p>Conflict-free access via random permutation.</p>
</dd>
<dt>Middle</dt><dd><p>Conflict-free access since threads 3, 4, 6, 7, and 9 access the same word within bank 5.</p>
</dd>
<dt>Right</dt><dd><p>Conflict-free broadcast access (threads access the same word within a bank).</p>
</dd>
</dl>
</div>
</figcaption>
</figure>
</section>
</section>
<section id="compute-capability-6-x">
<span id="id404"></span><h2><span class="section-number">17.5. </span>Compute Capability 6.x<a class="headerlink" href="#compute-capability-6-x" title="Permalink to this headline">ï</a></h2>
<section id="architecture-6-x">
<span id="id405"></span><h3><span class="section-number">17.5.1. </span>Architecture<a class="headerlink" href="#architecture-6-x" title="Permalink to this headline">ï</a></h3>
<p>An SM consists of:</p>
<ul class="simple">
<li><p>64 (compute capability 6.0) or 128 (6.1 and 6.2) CUDA cores for arithmetic operations,</p></li>
<li><p>16 (6.0) or 32 (6.1 and 6.2) special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>2 (6.0) or 4 (6.1 and 6.2) warp schedulers.</p></li>
</ul>
<p>When an SM is given warps to execute, it first distributes them among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified L1/texture cache for reads from global memory of size 24 KB (6.0 and 6.2) or 48 KB (6.1),</p></li>
<li><p>a shared memory of size 64 KB (6.0 and 6.2) or 96 KB (6.1).</p></li>
</ul>
<p>The unified L1/texture cache is also used by the texture unit that implements the various addressing modes and data filtering mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
<p>There is also an L2 cache shared by all SMs that is used to cache accesses to local or global memory, including temporary register spills. Applications may query the L2 cache size by checking the <code class="docutils literal notranslate"><span class="pre">l2CacheSize</span></code> device property (see <a class="reference internal" href="#device-enumeration"><span class="std std-ref">Device Enumeration</span></a>).</p>
<p>The cache behavior (for example, whether reads are cached in both the unified L1/texture cache and L2 or in L2 only) can be partially configured on a per-access basis using modifiers to the load instruction.</p>
</section>
<section id="global-memory-6-x">
<span id="id406"></span><h3><span class="section-number">17.5.2. </span>Global Memory<a class="headerlink" href="#global-memory-6-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as in devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-6-x">
<span id="id407"></span><h3><span class="section-number">17.5.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-6-x" title="Permalink to this headline">ï</a></h3>
<p>Shared memory behaves the same way as in devices of compute capability 5.x (See <a class="reference internal" href="#shared-memory-5-x"><span class="std std-ref">Shared Memory</span></a>).</p>
</section>
</section>
<section id="compute-capability-7-x">
<span id="id408"></span><h2><span class="section-number">17.6. </span>Compute Capability 7.x<a class="headerlink" href="#compute-capability-7-x" title="Permalink to this headline">ï</a></h2>
<section id="architecture-7-x">
<span id="id409"></span><h3><span class="section-number">17.6.1. </span>Architecture<a class="headerlink" href="#architecture-7-x" title="Permalink to this headline">ï</a></h3>
<p>An SM consists of:</p>
<ul class="simple">
<li><p>64 FP32 cores for single-precision arithmetic operations,</p></li>
<li><p>32 FP64 cores for double-precision arithmetic operations,<a class="footnote-reference brackets" href="#fn35" id="id410">36</a></p></li>
<li><p>64 INT32 cores for integer math,</p></li>
<li><p>8 mixed-precision Tensor Cores for deep learning matrix arithmetic</p></li>
<li><p>16 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified data cache and shared memory with a total size of 128 KB (<em>Volta</em>) or 96 KB (<em>Turing</em>).</p></li>
</ul>
<p>Shared memory is partitioned out of unified data cache, and can be configured to various sizes (See <a class="reference internal" href="#shared-memory-7-x"><span class="std std-ref">Shared Memory</span></a>.) The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
</section>
<section id="independent-thread-scheduling">
<span id="independent-thread-scheduling-7-x"></span><h3><span class="section-number">17.6.2. </span>Independent Thread Scheduling<a class="headerlink" href="#independent-thread-scheduling" title="Permalink to this headline">ï</a></h3>
<p>The <strong>NVIDIA Volta GPU Architecture</strong> introduces <em>Independent Thread Scheduling</em> among threads in a warp, enabling intra-warp synchronization patterns previously unavailable and simplifying code changes when porting CPU code. However, this can lead to a rather different set of threads participating in the executed code than intended if the developer made assumptions about warp-synchronicity of previous hardware architectures.</p>
<p>Below are code patterns of concern and suggested corrective actions for Volta-safe code.</p>
<ol class="arabic simple">
<li><p>For applications using warp intrinsics (<code class="docutils literal notranslate"><span class="pre">__shfl*</span></code>, <code class="docutils literal notranslate"><span class="pre">__any</span></code>, <code class="docutils literal notranslate"><span class="pre">__all</span></code>, <code class="docutils literal notranslate"><span class="pre">__ballot</span></code>), it is necessary that developers port their code to the new, safe, synchronizing counterpart, with the <code class="docutils literal notranslate"><span class="pre">*_sync</span></code> suffix. The new warp intrinsics take in a mask of threads that explicitly define which lanes (threads of a warp) must participate in the warp intrinsic. See <a class="reference internal" href="#warp-vote-functions"><span class="std std-ref">Warp Vote Functions</span></a> and <a class="reference internal" href="#warp-shuffle-functions"><span class="std std-ref">Warp Shuffle Functions</span></a> for details.</p></li>
</ol>
<p>Since the intrinsics are available with CUDA 9.0+, (if necessary) code can be executed conditionally with the following preprocessor macro:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if defined(CUDART_VERSION) &amp;&amp; CUDART_VERSION &gt;= 9000</span>
<span class="c1">// *_sync intrinsic</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>These intrinsics are available on all architectures, not just <strong>NVIDIA Volta GPU Architecture</strong> or <strong>NVIDIA Turing GPU Architecture</strong>, and in most cases a single code-base will suffice for all architectures. Note, however, that for <em>Pascal</em> and earlier architectures, all threads in mask must execute the same warp intrinsic instruction in convergence, and the union of all values in mask must be equal to the warpâs active mask. The following code pattern is valid on <strong>NVIDIA Volta GPU Architecture</strong>, but not on <em>Pascal</em> or earlier architectures.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">warpSize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">swapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_xor_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">swapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__shfl_xor_sync</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>The replacement for <code class="docutils literal notranslate"><span class="pre">__ballot(1)</span></code> is <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code>. Note that threads within a warp can diverge even within a single code path. As a result, <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code> and <code class="docutils literal notranslate"><span class="pre">__ballot(1)</span></code> may return only a subset of the threads on the current code path. The following invalid code example sets bit <code class="docutils literal notranslate"><span class="pre">i</span></code> of <code class="docutils literal notranslate"><span class="pre">output</span></code> to 1 when <code class="docutils literal notranslate"><span class="pre">data[i]</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">threshold</span></code>. <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code> is used in an attempt to enable cases where <code class="docutils literal notranslate"><span class="pre">dataLen</span></code> is not a multiple of 32.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sets bit in output[] to 1 if the correspond element in data[i]</span>
<span class="c1">// is greater than &#39;threshold&#39;, using 32 threads in a warp.</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">warpLane</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dataLen</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">warpSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__activemask</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitPack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ballot_sync</span><span class="p">(</span><span class="n">active</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">warpLane</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitPack</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p>This code is invalid because CUDA does not guarantee that the warp will diverge ONLY at the loop condition. When divergence happens for other reasons, conflicting results will be computed for the same 32-bit output element by different subsets of threads in the warp. A correct code might use a non-divergent loop condition together with <code class="docutils literal notranslate"><span class="pre">__ballot_sync()</span></code> to safely enumerate the set of threads in the warp participating in the threshold calculation as follows.</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">warpLane</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">warpLane</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dataLen</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">warpSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ballot_sync</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dataLen</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dataLen</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">bitPack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ballot_sync</span><span class="p">(</span><span class="n">active</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">warpLane</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitPack</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference internal" href="#discovery-pattern-cg"><span class="std std-ref">Discovery Pattern</span></a> demonstrates a valid use case for <code class="docutils literal notranslate"><span class="pre">__activemask()</span></code>.</p>
<ol class="arabic">
<li><p>If applications have warp-synchronous codes, they will need to insert the new <code class="docutils literal notranslate"><span class="pre">__syncwarp()</span></code> warp-wide barrier synchronization instruction between any steps where data is exchanged between threads via global or shared memory. Assumptions that code is executed in lockstep or that reads/writes from separate threads are visible across a warp without synchronization are invalid.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w"></span>
<span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>

<span class="c1">// Inter-warp reduction</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="o">+</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Intra-warp reduction</span>
<span class="c1">// Butterfly reduction simplifies syncwarp mask</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">16</span><span class="p">];</span><span class="w"> </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">     </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w">  </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">     </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">  </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">     </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w">  </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">s_buff</span><span class="p">[</span><span class="n">tid</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span><span class="w">     </span><span class="n">__syncwarp</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s_buff</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">__syncthreads</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>Although <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> has been consistently documented as synchronizing all threads in the thread block, <em>Pascal</em> and prior architectures could only enforce synchronization at the warp level. In certain cases, this allowed a barrier to succeed without being executed by every thread as long as at least some thread in every warp reached the barrier. Starting with <strong>NVIDIA Volta GPU Architecture</strong>, the CUDA built-in <code class="docutils literal notranslate"><span class="pre">__syncthreads()</span></code> and PTX instruction <code class="docutils literal notranslate"><span class="pre">bar.sync</span></code> (and their derivatives) are enforced per thread and thus will not succeed until reached by all non-exited threads in the block. Code exploiting the previous behavior will likely deadlock and must be modified to ensure that all non-exited threads reach the barrier.</p></li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">racecheck</span></code> and <code class="docutils literal notranslate"><span class="pre">synccheck</span></code> tools provided by <code class="docutils literal notranslate"><span class="pre">compute-saniter</span></code> can help with locating violations.</p>
<p>To aid migration while implementing the above-mentioned corrective actions, developers can opt-in to the Pascal scheduling model that does not support independent thread scheduling. See <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a> for details.</p>
</section>
<section id="global-memory-7-x">
<span id="id411"></span><h3><span class="section-number">17.6.3. </span>Global Memory<a class="headerlink" href="#global-memory-7-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as in devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-7-x">
<span id="id412"></span><h3><span class="section-number">17.6.4. </span>Shared Memory<a class="headerlink" href="#shared-memory-7-x" title="Permalink to this headline">ï</a></h3>
<p>The amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the <em>Volta</em> architecture (compute capability 7.0), the unified data cache has a size of 128 KB, and the shared memory capacity can be set to 0, 8, 16, 32, 64 or 96 KB. For the <em>Turing</em> architecture (compute capability 7.5), the unified data cache has a size of 96 KB, and the shared memory capacity can be set to either 32 KB or 64 KB. Unlike Kepler, the driver automatically configures the shared memory capacity for each kernel to avoid shared memory occupancy bottlenecks while also allowing concurrent execution with already launched kernels where possible. In most cases, the driverâs default behavior should provide optimal performance.</p>
<p>Because the driver is not always aware of the full workload, it is sometimes useful for applications to provide additional hints regarding the desired shared memory configuration. For example, a kernel with little or no shared memory use may request a larger carveout in order to encourage concurrent execution with later kernels that require more shared memory. The new <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> API allows applications to set a preferred shared memory capacity, or <code class="docutils literal notranslate"><span class="pre">carveout</span></code>, as a percentage of the maximum supported shared memory capacity (96 KB for <em>Volta</em>, and 64 KB for <em>Turing</em>).</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> relaxes enforcement of the preferred shared capacity compared to the legacy <code class="docutils literal notranslate"><span class="pre">cudaFuncSetCacheConfig()</span></code> API introduced with Kepler. The legacy API treated shared memory capacities as hard requirements for kernel launch. As a result, interleaving kernels with different shared memory configurations would needlessly serialize launches behind shared memory reconfigurations. With the new API, the carveout is treated as a hint. The driver may choose a different configuration if required to execute the function or to avoid thrashing.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="n">BLOCK_DIM</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">carveout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span><span class="w"> </span><span class="c1">// prefer shared memory capacity 50% of maximum</span>
<span class="c1">// Named Carveout Values:</span>
<span class="c1">// carveout = cudaSharedmemCarveoutDefault;   //  (-1)</span>
<span class="c1">// carveout = cudaSharedmemCarveoutMaxL1;     //   (0)</span>
<span class="c1">// carveout = cudaSharedmemCarveoutMaxShared; // (100)</span>
<span class="n">cudaFuncSetAttribute</span><span class="p">(</span><span class="n">MyKernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributePreferredSharedMemoryCarveout</span><span class="p">,</span><span class="w"> </span><span class="n">carveout</span><span class="p">);</span><span class="w"></span>
<span class="n">MyKernel</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="n">gridDim</span><span class="p">,</span><span class="w"> </span><span class="n">BLOCK_DIM</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
<p>In addition to an integer percentage, several convenience enums are provided as listed in the code comments above. Where a chosen integer percentage does not map exactly to a supported capacity (SM 7.0 devices support shared capacities of 0, 8, 16, 32, 64, or 96 KB), the next larger capacity is used. For instance, in the example above, 50% of the 96 KB maximum is 48 KB, which is not a supported shared memory capacity. Thus, the preference is rounded up to 64 KB.</p>
<p>Compute capability 7.x devices allow a single thread block to address the full capacity of shared memory: 96 KB on <em>Volta</em>, 64 KB on <em>Turing</em>. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, as such they must use dynamic shared memory (rather than statically sized arrays) and require an explicit opt-in using <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Device code</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">MyKernel</span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">__shared__</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">buffer</span><span class="p">[];</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Host code</span>
<span class="kt">int</span><span class="w"> </span><span class="n">maxbytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">98304</span><span class="p">;</span><span class="w"> </span><span class="c1">// 96 KB</span>
<span class="n">cudaFuncSetAttribute</span><span class="p">(</span><span class="n">MyKernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributeMaxDynamicSharedMemorySize</span><span class="p">,</span><span class="w"> </span><span class="n">maxbytes</span><span class="p">);</span><span class="w"></span>
<span class="n">MyKernel</span><span class="w"> </span><span class="o">&lt;&lt;&lt;</span><span class="n">gridDim</span><span class="p">,</span><span class="w"> </span><span class="n">blockDim</span><span class="p">,</span><span class="w"> </span><span class="n">maxbytes</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span><span class="w"></span>
</pre></div>
</div>
<p>Otherwise, shared memory behaves the same way as for devices of compute capability 5.x (See <a class="reference internal" href="#shared-memory-5-x"><span class="std std-ref">Shared Memory</span></a>).</p>
</section>
</section>
<section id="compute-capability-8-x">
<span id="id413"></span><h2><span class="section-number">17.7. </span>Compute Capability 8.x<a class="headerlink" href="#compute-capability-8-x" title="Permalink to this headline">ï</a></h2>
<section id="architecture-8-x">
<span id="id414"></span><h3><span class="section-number">17.7.1. </span>Architecture<a class="headerlink" href="#architecture-8-x" title="Permalink to this headline">ï</a></h3>
<p>A Streaming Multiprocessor (SM) consists of:</p>
<ul class="simple">
<li><p>64 FP32 cores for single-precision arithmetic operations in devices of compute capability 8.0 and 128 FP32 cores in devices of compute capability 8.6, 8.7 and 8.9,</p></li>
<li><p>32 FP64 cores for double-precision arithmetic operations in devices of compute capability 8.0 and 2 FP64 cores in devices of compute capability 8.6, 8.7 and 8.9</p></li>
<li><p>64 INT32 cores for integer math,</p></li>
<li><p>4 mixed-precision Third-Generation Tensor Cores supporting half-precision (fp16), <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">tf32</span></code>, sub-byte and double precision (fp64) matrix arithmetic for compute capabilities 8.0, 8.6 and 8.7 (see <a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a> for details),</p></li>
<li><p>4 mixed-precision Fourth-Generation Tensor Cores supporting <code class="docutils literal notranslate"><span class="pre">fp8</span></code>, <code class="docutils literal notranslate"><span class="pre">fp16</span></code>, <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">tf32</span></code>, sub-byte and <code class="docutils literal notranslate"><span class="pre">fp64</span></code> for compute capability 8.9 (see <a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a> for details),</p></li>
<li><p>16 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified data cache and shared memory with a total size of 192 KB for devices of compute capability 8.0 and 8.7 (1.5x <em>Volta</em>âs 128 KB capacity) and 128 KB for devices of compute capabilities 8.6 and 8.9.</p></li>
</ul>
<p>Shared memory is partitioned out of the unified data cache, and can be configured to various sizes (see <a class="reference internal" href="#shared-memory-8-x"><span class="std std-ref">Shared Memory</span></a>). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
</section>
<section id="global-memory-8-x">
<span id="id415"></span><h3><span class="section-number">17.7.2. </span>Global Memory<a class="headerlink" href="#global-memory-8-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as for devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-8-x">
<span id="id416"></span><h3><span class="section-number">17.7.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-8-x" title="Permalink to this headline">ï</a></h3>
<p>Similar to the <a class="reference internal" href="#architecture-7-x"><span class="std std-ref">Volta architecture</span></a>, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the <strong>NVIDIA Ampere GPU Architecture</strong>, the unified data cache has a size of 192 KB for devices of compute capability 8.0 and 8.7 and 128 KB for devices of compute capabilities 8.6 and 8.9. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132 or 164 KB for devices of compute capability 8.0 and 8.7, and to 0, 8, 16, 32, 64 or 100 KB for devices of compute capabilities 8.6 and 8.9.</p>
<p>An application can set the <code class="docutils literal notranslate"><span class="pre">carveout</span></code>, i.e., the preferred shared memory capacity, with the <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaFuncSetAttribute</span><span class="p">(</span><span class="n">kernel_name</span><span class="p">,</span><span class="w"> </span><span class="n">cudaFuncAttributePreferredSharedMemoryCarveout</span><span class="p">,</span><span class="w"> </span><span class="n">carveout</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The API can specify the carveout either as an integer percentage of the maximum supported shared memory capacity of 164 KB for devices of compute capability 8.0 and 8.7 and 100 KB for devices of compute capabilities 8.6 and 8.9 respectively, or as one of the following values: <code class="docutils literal notranslate"><span class="pre">{cudaSharedmemCarveoutDefault</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaSharedmemCarveoutMaxL1</span></code>, or <code class="docutils literal notranslate"><span class="pre">cudaSharedmemCarveoutMaxShared</span></code>. When using a percentage, the carveout is rounded up to the nearest supported shared memory capacity. For example, for devices of compute capability 8.0, 50% will map to a 100 KB carveout instead of an 82 KB one. Setting the <code class="docutils literal notranslate"><span class="pre">cudaFuncAttributePreferredSharedMemoryCarveout</span></code> is considered a hint by the driver; the driver may choose a different configuration, if needed.</p>
<p>Devices of compute capability 8.0 and 8.7 allow a single thread block to address up to 163 KB of shared memory, while devices of compute capabilities 8.6 and 8.9 allow up to 99 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> to set the <code class="docutils literal notranslate"><span class="pre">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>; see <a class="reference internal" href="#shared-memory-7-x"><span class="std std-ref">Shared Memory</span></a> for the <strong>NVIDIA Volta GPU Architecture</strong>.</p>
<p>Note that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.</p>
</section>
</section>
<section id="compute-capability-9-0">
<span id="id417"></span><h2><span class="section-number">17.8. </span>Compute Capability 9.0<a class="headerlink" href="#compute-capability-9-0" title="Permalink to this headline">ï</a></h2>
<section id="architecture-9-0">
<span id="id418"></span><h3><span class="section-number">17.8.1. </span>Architecture<a class="headerlink" href="#architecture-9-0" title="Permalink to this headline">ï</a></h3>
<p>A Streaming Multiprocessor (SM) consists of:</p>
<ul class="simple">
<li><p>128 FP32 cores for single-precision arithmetic operations,</p></li>
<li><p>64 FP64 cores for double-precision arithmetic operations,</p></li>
<li><p>64 INT32 cores for integer math,</p></li>
<li><p>4 mixed-precision fourth-generation Tensor Cores supporting the new <code class="docutils literal notranslate"><span class="pre">FP8</span></code> input type in either <code class="docutils literal notranslate"><span class="pre">E4M3</span></code> or <code class="docutils literal notranslate"><span class="pre">E5M2</span></code> for exponent (E) and mantissa (M), half-precision (fp16), <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">tf32</span></code>, INT8 and double precision (fp64) matrix arithmetic (see <a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a> for details) with sparsity support,</p></li>
<li><p>16 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified data cache and shared memory with a total size of 256 KB for devices of compute capability 9.0 (1.33x <strong>NVIDIA Ampere GPU Architectureâs</strong> 192 KB capacity).</p></li>
</ul>
<p>Shared memory is partitioned out of the unified data cache, and can be configured to various sizes (see <a class="reference internal" href="#shared-memory-9-0"><span class="std std-ref">Shared Memory</span></a>). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
</section>
<section id="global-memory-9-0">
<span id="id419"></span><h3><span class="section-number">17.8.2. </span>Global Memory<a class="headerlink" href="#global-memory-9-0" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as for devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-9-0">
<span id="id420"></span><h3><span class="section-number">17.8.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-9-0" title="Permalink to this headline">ï</a></h3>
<p>Similar to the <a class="reference internal" href="#architecture-8-x"><span class="std std-ref">NVIDIA Ampere GPU architecture</span></a>, the amount of the unified data cache reserved for shared memory is configurable on a per kernel basis. For the <em>NVIDIA H100 Tensor Core GPU architecture</em>, the unified data cache has a size of 256 KB for devices of compute capability 9.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132, 164, 196 or 228 KB.</p>
<p>As with the <a class="reference internal" href="#shared-memory-8-x"><span class="std std-ref">NVIDIA Ampere GPU architecture</span></a>, an application can configure its preferred shared memory capacity, i.e., the <code class="docutils literal notranslate"><span class="pre">carveout</span></code>. Devices of compute capability 9.0 allow a single thread block to address up to 227 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> to set the <code class="docutils literal notranslate"><span class="pre">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>; see <a class="reference internal" href="#shared-memory-7-x"><span class="std std-ref">Shared Memory</span></a> for the <strong>NVIDIA Volta GPU Architecture</strong>.</p>
<p>Note that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.</p>
</section>
<section id="features-accelerating-specialized-computations">
<span id="features-accelerating-specialized-computations-9-0"></span><h3><span class="section-number">17.8.4. </span>Features Accelerating Specialized Computations<a class="headerlink" href="#features-accelerating-specialized-computations" title="Permalink to this headline">ï</a></h3>
<p>The NVIDIA Hopper GPU architecture includes features to accelerate matrix multiply-accumulate (MMA) computations with:</p>
<ul class="simple">
<li><p>asynchronous execution of MMA instructions</p></li>
<li><p>MMA instructions acting on large matrices spanning a warp-group</p></li>
<li><p>dynamic reassignment of register capacity among warp-groups to support even larger matrices, and</p></li>
<li><p>operand matrices accessed directly from shared memory</p></li>
</ul>
<p>See the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#instruction-set">PTX ISA</a> for more details.</p>
<p>This feature set is only available within the CUDA compilation toolchain through inline PTX.</p>
<p>It is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.</p>
<p>It is strongly recommended that device kernels utilize this complex feature set through <a class="reference external" href="https://github.com/NVIDIA/cutlass">CUTLASS</a>, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.</p>
</section>
</section>
<section id="compute-capability-10-x">
<span id="id421"></span><h2><span class="section-number">17.9. </span>Compute Capability 10.x<a class="headerlink" href="#compute-capability-10-x" title="Permalink to this headline">ï</a></h2>
<section id="architecture-10-x">
<span id="id422"></span><h3><span class="section-number">17.9.1. </span>Architecture<a class="headerlink" href="#architecture-10-x" title="Permalink to this headline">ï</a></h3>
<p>A Streaming Multiprocessor (SM) consists of:</p>
<ul class="simple">
<li><p>128 FP32 cores for single-precision arithmetic operations,</p></li>
<li><p>64 FP64 cores for double-precision arithmetic operations,</p></li>
<li><p>64 INT32 cores for integer math,</p></li>
<li><p>4 mixed-precision fifth-generation Tensor Cores supporting <code class="docutils literal notranslate"><span class="pre">FP8</span></code> input type in either <code class="docutils literal notranslate"><span class="pre">E4M3</span></code> or <code class="docutils literal notranslate"><span class="pre">E5M2</span></code> for exponent (E) and mantissa (M), half-precision (fp16), <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">tf32</span></code>, INT8 and double precision (fp64) matrix arithmetic (see <a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a> for details) with sparsity support,</p></li>
<li><p>16 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified data cache and shared memory with a total size of 256 KB for devices of compute capability 10.0</p></li>
</ul>
<p>Shared memory is partitioned out of the unified data cache, and can be configured to various sizes (see <a class="reference internal" href="#shared-memory-10-x"><span class="std std-ref">Shared Memory</span></a>). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
</section>
<section id="global-memory-10-x">
<span id="id423"></span><h3><span class="section-number">17.9.2. </span>Global Memory<a class="headerlink" href="#global-memory-10-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as for devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-10-x">
<span id="id424"></span><h3><span class="section-number">17.9.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-10-x" title="Permalink to this headline">ï</a></h3>
<p>The amount of the unified data cache reserved for shared memory is configurable on a per kernel basis and is identical to <a class="reference internal" href="#shared-memory-9-0"><span class="std std-ref">compute capability 9.0</span></a>. The unified data cache has a size of 256 KB for devices of compute capability 10.x. The shared memory capacity can be set to 0, 8, 16, 32, 64, 100, 132, 164, 196 or 228 KB.</p>
<p>As with the <a class="reference internal" href="#shared-memory-8-x"><span class="std std-ref">NVIDIA Ampere GPU architecture</span></a>, an application can configure its preferred shared memory capacity, i.e., the <code class="docutils literal notranslate"><span class="pre">carveout</span></code>. Devices of compute capability 10.x allow a single thread block to address up to 227 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> to set the <code class="docutils literal notranslate"><span class="pre">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>; see <a class="reference internal" href="#shared-memory-7-x"><span class="std std-ref">Shared Memory</span></a> for the Volta architecture.</p>
<p>Note that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.</p>
</section>
<section id="features-accelerating-specialized-computations-10-x">
<span id="id425"></span><h3><span class="section-number">17.9.4. </span>Features Accelerating Specialized Computations<a class="headerlink" href="#features-accelerating-specialized-computations-10-x" title="Permalink to this headline">ï</a></h3>
<p>The NVIDIA Blackwell GPU architecture extends features to accelerate matrix multiply-accumulate (MMA) from the NVIDIA Hopper GPU architecture.</p>
<p>See the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#instruction-set">PTX ISA</a> for more details.</p>
<p>This feature set is only available within the CUDA compilation toolchain through inline PTX.</p>
<p>It is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.</p>
<p>It is strongly recommended that device kernels utilize this complex feature set through <a class="reference external" href="https://github.com/NVIDIA/cutlass">CUTLASS</a>, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.</p>
</section>
</section>
<section id="compute-capability-12-0">
<span id="compute-capability-12-x"></span><h2><span class="section-number">17.10. </span>Compute Capability 12.0<a class="headerlink" href="#compute-capability-12-0" title="Permalink to this headline">ï</a></h2>
<section id="architecture-12-x">
<span id="id426"></span><h3><span class="section-number">17.10.1. </span>Architecture<a class="headerlink" href="#architecture-12-x" title="Permalink to this headline">ï</a></h3>
<p>A Streaming Multiprocessor (SM) consists of:</p>
<ul class="simple">
<li><p>128 FP32 cores for single-precision arithmetic operations,</p></li>
<li><p>2 FP64 cores for double-precision arithmetic operations,</p></li>
<li><p>64 INT32 cores for integer math,</p></li>
<li><p>Mixed-precision fifth-generation Tensor Core(s) supporting <code class="docutils literal notranslate"><span class="pre">FP8</span></code> input type in either <code class="docutils literal notranslate"><span class="pre">E4M3</span></code> or <code class="docutils literal notranslate"><span class="pre">E5M2</span></code> for exponent (E) and mantissa (M), half-precision (fp16), <code class="docutils literal notranslate"><span class="pre">__nv_bfloat16</span></code>, <code class="docutils literal notranslate"><span class="pre">tf32</span></code>, INT8 and double precision (fp64) matrix arithmetic (see <a class="reference internal" href="#wmma"><span class="std std-ref">Warp Matrix Functions</span></a> for details) with sparsity support,</p></li>
<li><p>16 special function units for single-precision floating-point transcendental functions,</p></li>
<li><p>4 warp schedulers.</p></li>
</ul>
<p>An SM statically distributes its warps among its schedulers. Then, at every instruction issue time, each scheduler issues one instruction for one of its assigned warps that is ready to execute, if any.</p>
<p>An SM has:</p>
<ul class="simple">
<li><p>a read-only constant cache that is shared by all functional units and speeds up reads from the constant memory space, which resides in device memory,</p></li>
<li><p>a unified data cache and shared memory with a total size of 100 KB for devices of compute capability 12.0</p></li>
</ul>
<p>Shared memory is partitioned out of the unified data cache, and can be configured to various sizes (see <a class="reference internal" href="#shared-memory-9-0"><span class="std std-ref">Shared Memory</span></a>). The remaining data cache serves as an L1 cache and is also used by the texture unit that implements the various addressing and data filtering modes mentioned in <a class="reference internal" href="#texture-and-surface-memory"><span class="std std-ref">Texture and Surface Memory</span></a>.</p>
</section>
<section id="global-memory-12-x">
<span id="id427"></span><h3><span class="section-number">17.10.2. </span>Global Memory<a class="headerlink" href="#global-memory-12-x" title="Permalink to this headline">ï</a></h3>
<p>Global memory behaves the same way as for devices of compute capability 5.x (See <a class="reference internal" href="#global-memory-5-x"><span class="std std-ref">Global Memory</span></a>).</p>
</section>
<section id="shared-memory-12-x">
<span id="id428"></span><h3><span class="section-number">17.10.3. </span>Shared Memory<a class="headerlink" href="#shared-memory-12-x" title="Permalink to this headline">ï</a></h3>
<p>The amount of the unified data cache reserved for shared memory is configurable on a per kernel basis and is identical to <a class="reference internal" href="#shared-memory-9-0"><span class="std std-ref">compute capability 9.0</span></a>. The unified data cache has a size of 100 KB for devices of compute capability 12.0. The shared memory capacity can be set to 0, 8, 16, 32, 64, or 100 KB.</p>
<p>As with the <a class="reference internal" href="#shared-memory-8-x"><span class="std std-ref">NVIDIA Ampere GPU architecture</span></a>, an application can configure its preferred shared memory capacity, i.e., the <code class="docutils literal notranslate"><span class="pre">carveout</span></code>. Devices of compute capability 12.0 allow a single thread block to address up to 99 KB of shared memory. Kernels relying on shared memory allocations over 48 KB per block are architecture-specific, and must use dynamic shared memory rather than statically sized shared memory arrays. These kernels require an explicit opt-in by using <code class="docutils literal notranslate"><span class="pre">cudaFuncSetAttribute()</span></code> to set the <code class="docutils literal notranslate"><span class="pre">cudaFuncAttributeMaxDynamicSharedMemorySize</span></code>; see <a class="reference internal" href="#shared-memory-7-x"><span class="std std-ref">Shared Memory</span></a> for the Volta architecture.</p>
<p>Note that the maximum amount of shared memory per thread block is smaller than the maximum shared memory partition available per SM. The 1 KB of shared memory not made available to a thread block is reserved for system use.</p>
</section>
<section id="features-accelerating-specialized-computations-12-x">
<span id="id429"></span><h3><span class="section-number">17.10.4. </span>Features Accelerating Specialized Computations<a class="headerlink" href="#features-accelerating-specialized-computations-12-x" title="Permalink to this headline">ï</a></h3>
<p>The NVIDIA Blackwell GPU architecture extends features to accelerate matrix multiply-accumulate (MMA) from the NVIDIA Hopper GPU architecture.</p>
<p>See the <a class="reference external" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#instruction-set">PTX ISA</a> for more details.</p>
<p>This feature set is only available within the CUDA compilation toolchain through inline PTX.</p>
<p>It is strongly recommended that applications utilize this complex feature set through CUDA-X libraries such as cuBLAS, cuDNN, or cuFFT.</p>
<p>It is strongly recommended that device kernels utilize this complex feature set through <a class="reference external" href="https://github.com/NVIDIA/cutlass">CUTLASS</a>, a collection of CUDA C++ template abstractions for implementing high-performance matrix-multiplication (GEMM) and related computations at all levels and scales within CUDA.</p>
<dl class="footnote brackets">
<dt class="label" id="fn33"><span class="brackets"><a class="fn-backref" href="#id399">35</a></span></dt>
<dd><p>above 48 KB requires dynamic shared memory</p>
</dd>
<dt class="label" id="fn35"><span class="brackets"><a class="fn-backref" href="#id410">36</a></span></dt>
<dd><p>2 FP64 cores for double-precision arithmetic operations for devices of compute capabilities 7.5</p>
</dd>
</dl>
</section>
</section>
</section>
<section id="driver-api">
<span id="id430"></span><h1><span class="section-number">18. </span>Driver API<a class="headerlink" href="#driver-api" title="Permalink to this headline">ï</a></h1>
<p>This section assumes knowledge of the concepts described in <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a>.</p>
<p>The driver API is implemented in the <code class="docutils literal notranslate"><span class="pre">cuda</span></code> dynamic library (<code class="docutils literal notranslate"><span class="pre">cuda.dll</span></code> or <code class="docutils literal notranslate"><span class="pre">cuda.so</span></code>) which is copied on the system during the installation of the device driver. All its entry points are prefixed with cu.</p>
<p>It is a handle-based, imperative API: Most objects are referenced by opaque handles that may be specified to functions to manipulate the objects.</p>
<p>The objects available in the driver API are summarized in <a class="reference internal" href="#driver-api-objects-available-in-cuda-driver-api"><span class="std std-ref">Table 22</span></a>.</p>
<table class="table-no-stripes docutils align-default" id="driver-api-objects-available-in-cuda-driver-api">
<caption><span class="caption-number">Table 29 </span><span class="caption-text">Objects Available in the CUDA Driver API</span><a class="headerlink" href="#driver-api-objects-available-in-cuda-driver-api" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 13%" />
<col style="width: 9%" />
<col style="width: 79%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Object</p></th>
<th class="head"><p>Handle</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device</p></td>
<td><p>CUdevice</p></td>
<td><p>CUDA-enabled device</p></td>
</tr>
<tr class="row-odd"><td><p>Context</p></td>
<td><p>CUcontext</p></td>
<td><p>Roughly equivalent to a CPU process</p></td>
</tr>
<tr class="row-even"><td><p>Module</p></td>
<td><p>CUmodule</p></td>
<td><p>Roughly equivalent to a dynamic library</p></td>
</tr>
<tr class="row-odd"><td><p>Function</p></td>
<td><p>CUfunction</p></td>
<td><p>Kernel</p></td>
</tr>
<tr class="row-even"><td><p>Heap memory</p></td>
<td><p>CUdeviceptr</p></td>
<td><p>Pointer to device memory</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA array</p></td>
<td><p>CUarray</p></td>
<td><p>Opaque container for one-dimensional or two-dimensional data on the device, readable via texture or surface references</p></td>
</tr>
<tr class="row-even"><td><p>Texture object</p></td>
<td><p>CUtexref</p></td>
<td><p>Object that describes how to interpret texture memory data</p></td>
</tr>
<tr class="row-odd"><td><p>Surface reference</p></td>
<td><p>CUsurfref</p></td>
<td><p>Object that describes how to read or write CUDA arrays</p></td>
</tr>
<tr class="row-even"><td><p>Stream</p></td>
<td><p>CUstream</p></td>
<td><p>Object that describes a CUDA stream</p></td>
</tr>
<tr class="row-odd"><td><p>Event</p></td>
<td><p>CUevent</p></td>
<td><p>Object that describes a CUDA event</p></td>
</tr>
</tbody>
</table>
<p>The driver API must be initialized with <code class="docutils literal notranslate"><span class="pre">cuInit()</span></code> before any function from the driver API is called. A CUDA context must then be created that is attached to a specific device and made current to the calling host thread as detailed in <a class="reference internal" href="#context"><span class="std std-ref">Context</span></a>.</p>
<p>Within a CUDA context, kernels are explicitly loaded as PTX or binary objects by the host code as described in <a class="reference internal" href="#module"><span class="std std-ref">Module</span></a>. Kernels written in C++ must therefore be compiled separately into <em>PTX</em> or binary objects. Kernels are launched using API entry points as described in <a class="reference internal" href="#kernel-execution"><span class="std std-ref">Kernel Execution</span></a>.</p>
<p>Any application that wants to run on future device architectures must load <em>PTX</em>, not binary code. This is because binary code is architecture-specific and therefore incompatible with future architectures, whereas <em>PTX</em> code is compiled to binary code at load time by the device driver.</p>
<p>Here is the host code of the sample from <a class="reference internal" href="#kernels"><span class="std std-ref">Kernels</span></a> written using the driver API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate input vectors h_A and h_B in host memory</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">h_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">h_B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize input vectors</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Initialize</span>
<span class="w">    </span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get number of devices supporting CUDA</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">deviceCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuDeviceGetCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deviceCount</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">deviceCount</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;There is no device supporting CUDA.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">exit</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get handle for device 0</span>
<span class="w">    </span><span class="n">CUdevice</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuDevice</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create context</span>
<span class="w">    </span><span class="n">CUcontext</span><span class="w"> </span><span class="n">cuContext</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuCtxCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuContext</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cuDevice</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Create module from binary file</span>
<span class="w">    </span><span class="n">CUmodule</span><span class="w"> </span><span class="n">cuModule</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuModuleLoad</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;VecAdd.ptx&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate vectors in device memory</span>
<span class="w">    </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">d_A</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">d_B</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">d_C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Copy vectors from host memory to device memory</span>
<span class="w">    </span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">h_A</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cuMemcpyHtoD</span><span class="p">(</span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">h_B</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get function handle from module</span>
<span class="w">    </span><span class="n">CUfunction</span><span class="w"> </span><span class="n">vecAdd</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vecAdd</span><span class="p">,</span><span class="w"> </span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;VecAdd&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Invoke kernel</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">blocksPerGrid</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">N</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">vecAdd</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">                   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Full code can be found in the <code class="docutils literal notranslate"><span class="pre">vectorAddDrv</span></code> CUDA sample.</p>
<section id="context">
<span id="id431"></span><h2><span class="section-number">18.1. </span>Context<a class="headerlink" href="#context" title="Permalink to this headline">ï</a></h2>
<p>A CUDA context is analogous to a CPU process. All resources and actions performed within the driver API are encapsulated inside a CUDA context, and the system automatically cleans up these resources when the context is destroyed. Besides objects such as modules and texture or surface references, each context has its own distinct address space. As a result, <code class="docutils literal notranslate"><span class="pre">CUdeviceptr</span></code> values from different contexts reference different memory locations.</p>
<p>A host thread may have only one device context current at a time. When a context is created with <code class="docutils literal notranslate"><span class="pre">cuCtxCreate(</span></code>), it is made current to the calling host thread. CUDA functions that operate in a context (most functions that do not involve device enumeration or context management) will return <code class="docutils literal notranslate"><span class="pre">CUDA_ERROR_INVALID_CONTEXT</span></code> if a valid context is not current to the thread.</p>
<p>Each host thread has a stack of current contexts. <code class="docutils literal notranslate"><span class="pre">cuCtxCreate()</span></code> pushes the new context onto the top of the stack. <code class="docutils literal notranslate"><span class="pre">cuCtxPopCurrent()</span></code> may be called to detach the context from the host thread. The context is then âfloatingâ and may be pushed as the current context for any host thread. <code class="docutils literal notranslate"><span class="pre">cuCtxPopCurrent()</span></code> also restores the previous current context, if any.</p>
<p>A usage count is also maintained for each context. <code class="docutils literal notranslate"><span class="pre">cuCtxCreate()</span></code> creates a context with a usage count of 1. <code class="docutils literal notranslate"><span class="pre">cuCtxAttach()</span></code> increments the usage count and <code class="docutils literal notranslate"><span class="pre">cuCtxDetach()</span></code> decrements it. A context is destroyed when the usage count goes to 0 when calling <code class="docutils literal notranslate"><span class="pre">cuCtxDetach()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuCtxDestroy()</span></code>.</p>
<p>The driver API is interoperable with the runtime and it is possible to access the <em>primary context</em> (see <a class="reference internal" href="#initialization"><span class="std std-ref">Initialization</span></a>) managed by the runtime from the driver API via <code class="docutils literal notranslate"><span class="pre">cuDevicePrimaryCtxRetain()</span></code>.</p>
<p>Usage count facilitates interoperability between third party authored code operating in the same context. For example, if three libraries are loaded to use the same context, each library would call <code class="docutils literal notranslate"><span class="pre">cuCtxAttach()</span></code> to increment the usage count and <code class="docutils literal notranslate"><span class="pre">cuCtxDetach()</span></code> to decrement the usage count when the library is done using the context. For most libraries, it is expected that the application will have created a context before loading or initializing the library; that way, the application can create the context using its own heuristics, and the library simply operates on the context handed to it. Libraries that wish to create their own contexts - unbeknownst to their API clients who may or may not have created contexts of their own - would use <code class="docutils literal notranslate"><span class="pre">cuCtxPushCurrent()</span></code> and <code class="docutils literal notranslate"><span class="pre">cuCtxPopCurrent()</span></code> as illustrated in the following figure.</p>
<figure class="align-center" id="library-context-management">
<img alt="Library Context Management" src="_images/library-context-management.png" />
<figcaption>
<p><span class="caption-number">Figure 40 </span><span class="caption-text">Library Context Management</span><a class="headerlink" href="#library-context-management" title="Permalink to this image">ï</a></p>
</figcaption>
</figure>
</section>
<section id="module">
<span id="id432"></span><h2><span class="section-number">18.2. </span>Module<a class="headerlink" href="#module" title="Permalink to this headline">ï</a></h2>
<p>Modules are dynamically loadable packages of device code and data, akin to DLLs in Windows, that are output by nvcc (see <a class="reference internal" href="#compilation-with-nvcc"><span class="std std-ref">Compilation with NVCC</span></a>). The names for all symbols, including functions, global variables, and texture or surface references, are maintained at module scope so that modules written by independent third parties may interoperate in the same CUDA context.</p>
<p>This code sample loads a module and retrieves a handle to some kernel:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmodule</span><span class="w"> </span><span class="n">cuModule</span><span class="p">;</span><span class="w"></span>
<span class="n">cuModuleLoad</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myModule.ptx&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">CUfunction</span><span class="w"> </span><span class="n">myKernel</span><span class="p">;</span><span class="w"></span>
<span class="n">cuModuleGetFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myKernel</span><span class="p">,</span><span class="w"> </span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyKernel&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This code sample compiles and loads a new module from PTX code and parses compilation errors:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BUFFER_SIZE 8192</span>
<span class="n">CUmodule</span><span class="w"> </span><span class="n">cuModule</span><span class="p">;</span><span class="w"></span>
<span class="n">CUjit_option</span><span class="w"> </span><span class="n">options</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="w"></span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">PTXCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;some PTX code&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="n">error_log</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_ERROR_LOG_BUFFER</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">error_log</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_TARGET_FROM_CUCONTEXT</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuModuleLoadDataEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="n">PTXCode</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Link error:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">error_log</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This code sample compiles, links, and loads a new module from multiple PTX codes and parses link and compilation errors:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define BUFFER_SIZE 8192</span>
<span class="n">CUmodule</span><span class="w"> </span><span class="n">cuModule</span><span class="p">;</span><span class="w"></span>
<span class="n">CUjit_option</span><span class="w"> </span><span class="n">options</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">walltime</span><span class="p">;</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="n">error_log</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">],</span><span class="w"> </span><span class="n">info_log</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">PTXCode0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;some PTX code&quot;</span><span class="p">;</span><span class="w"></span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">PTXCode1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;some other PTX code&quot;</span><span class="p">;</span><span class="w"></span>
<span class="n">CUlinkState</span><span class="w"> </span><span class="n">linkState</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">cubin</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">cubinSize</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_WALL_TIME</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">walltime</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_INFO_LOG_BUFFER</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">info_log</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_ERROR_LOG_BUFFER</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">error_log</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">BUFFER_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_JIT_LOG_VERBOSE</span><span class="p">;</span><span class="w"></span>
<span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">cuLinkCreate</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">options</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linkState</span><span class="p">);</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuLinkAddData</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="n">CU_JIT_INPUT_PTX</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PTXCode0</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">PTXCode0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Link error:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">error_log</span><span class="p">);</span><span class="w"></span>
<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuLinkAddData</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="n">CU_JIT_INPUT_PTX</span><span class="p">,</span><span class="w"></span>
<span class="w">                    </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PTXCode1</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">PTXCode1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Link error:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">error_log</span><span class="p">);</span><span class="w"></span>
<span class="n">cuLinkComplete</span><span class="p">(</span><span class="n">linkState</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cubinSize</span><span class="p">);</span><span class="w"></span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Link completed in %fms. Linker Output:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">walltime</span><span class="p">,</span><span class="w"> </span><span class="n">info_log</span><span class="p">);</span><span class="w"></span>
<span class="n">cuModuleLoadData</span><span class="p">(</span><span class="n">cuModule</span><span class="p">,</span><span class="w"> </span><span class="n">cubin</span><span class="p">);</span><span class="w"></span>
<span class="n">cuLinkDestroy</span><span class="p">(</span><span class="n">linkState</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Full code can be found in the <code class="docutils literal notranslate"><span class="pre">ptxjit</span></code> CUDA sample.</p>
</section>
<section id="kernel-execution">
<span id="id433"></span><h2><span class="section-number">18.3. </span>Kernel Execution<a class="headerlink" href="#kernel-execution" title="Permalink to this headline">ï</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">cuLaunchKernel()</span></code> launches a kernel with a given execution configuration.</p>
<p>Parameters are passed either as an array of pointers (next to last parameter of <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel()</span></code>) where the nth pointer corresponds to the nth parameter and points to a region of memory from which the parameter is copied, or as one of the extra options (last parameter of <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel()</span></code>).</p>
<p>When parameters are passed as an extra option (the <code class="docutils literal notranslate"><span class="pre">CU_LAUNCH_PARAM_BUFFER_POINTER</span></code> option), they are passed as a pointer to a single buffer where parameters are assumed to be properly offset with respect to each other by matching the alignment requirement for each parameter type in device code.</p>
<p>Alignment requirements in device code for the built-in vector types are listed in <a class="reference internal" href="#vector-types-alignment-requirements-in-device-code"><span class="std std-ref">Table 5</span></a>. For all other basic types, the alignment requirement in device code matches the alignment requirement in host code and can therefore be obtained using <code class="docutils literal notranslate"><span class="pre">__alignof()</span></code>. The only exception is when the host compiler aligns <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> (and <code class="docutils literal notranslate"><span class="pre">long</span></code> on a 64-bit system) on a one-word boundary instead of a two-word boundary (for example, using <code class="docutils literal notranslate"><span class="pre">gcc</span></code>âs compilation flag <code class="docutils literal notranslate"><span class="pre">-mno-align-double</span></code>) since in device code these types are always aligned on a two-word boundary.</p>
<p><code class="docutils literal notranslate"><span class="pre">CUdeviceptr</span></code> is an integer, but represents a pointer, so its alignment requirement is <code class="docutils literal notranslate"><span class="pre">__alignof(void*)</span></code>.</p>
<p>The following code sample uses a macro (<code class="docutils literal notranslate"><span class="pre">ALIGN_UP()</span></code>) to adjust the offset of each parameter to meet its alignment requirement and another macro (<code class="docutils literal notranslate"><span class="pre">ADD_TO_PARAM_BUFFER()</span></code>) to add each parameter to the parameter buffer passed to the <code class="docutils literal notranslate"><span class="pre">CU_LAUNCH_PARAM_BUFFER_POINTER</span></code> option.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ALIGN_UP(offset, alignment) \</span>
<span class="cp">      (offset) = ((offset) + (alignment) - 1) &amp; ~((alignment) - 1)</span>

<span class="kt">char</span><span class="w"> </span><span class="n">paramBuffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">paramBufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="cp">#define ADD_TO_PARAM_BUFFER(value, alignment)                   \</span>
<span class="cp">    do {                                                        \</span>
<span class="cp">        paramBufferSize = ALIGN_UP(paramBufferSize, alignment); \</span>
<span class="cp">        memcpy(paramBuffer + paramBufferSize,                   \</span>
<span class="cp">               &amp;(value), sizeof(value));                        \</span>
<span class="cp">        paramBufferSize += sizeof(value);                       \</span>
<span class="cp">    } while (0)</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">__alignof</span><span class="p">(</span><span class="n">i</span><span class="p">));</span><span class="w"></span>
<span class="n">float4</span><span class="w"> </span><span class="n">f4</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">f4</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w"> </span><span class="c1">// float4&#39;s alignment is 16</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">__alignof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">__alignof</span><span class="p">(</span><span class="n">f</span><span class="p">));</span><span class="w"></span>
<span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devPtr</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="n">__alignof</span><span class="p">(</span><span class="n">devPtr</span><span class="p">));</span><span class="w"></span>
<span class="n">float2</span><span class="w"> </span><span class="n">f2</span><span class="p">;</span><span class="w"></span>
<span class="n">ADD_TO_PARAM_BUFFER</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"> </span><span class="c1">// float2&#39;s alignment is 8</span>

<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">extra</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">CU_LAUNCH_PARAM_BUFFER_POINTER</span><span class="p">,</span><span class="w"> </span><span class="n">paramBuffer</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">CU_LAUNCH_PARAM_BUFFER_SIZE</span><span class="p">,</span><span class="w">    </span><span class="o">&amp;</span><span class="n">paramBufferSize</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">CU_LAUNCH_PARAM_END</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">cuLaunchKernel</span><span class="p">(</span><span class="n">cuFunction</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">blockWidth</span><span class="p">,</span><span class="w"> </span><span class="n">blockHeight</span><span class="p">,</span><span class="w"> </span><span class="n">blockDepth</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="n">gridWidth</span><span class="p">,</span><span class="w"> </span><span class="n">gridHeight</span><span class="p">,</span><span class="w"> </span><span class="n">gridDepth</span><span class="p">,</span><span class="w"></span>
<span class="w">               </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">extra</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The alignment requirement of a structure is equal to the maximum of the alignment requirements of its fields. The alignment requirement of a structure that contains built-in vector types, <code class="docutils literal notranslate"><span class="pre">CUdeviceptr</span></code>, or non-aligned <code class="docutils literal notranslate"><span class="pre">double</span></code> and <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code>, might therefore differ between device code and host code. Such a structure might also be padded differently. The following structure, for example, is not padded at all in host code, but it is padded in device code with 12 bytes after field <code class="docutils literal notranslate"><span class="pre">f</span></code> since the alignment requirement for field <code class="docutils literal notranslate"><span class="pre">f4</span></code> is 16.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w">  </span><span class="n">f</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">float4</span><span class="w"> </span><span class="n">f4</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="n">myStruct</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="interoperability-between-runtime-and-driver-apis">
<span id="id434"></span><h2><span class="section-number">18.4. </span>Interoperability between Runtime and Driver APIs<a class="headerlink" href="#interoperability-between-runtime-and-driver-apis" title="Permalink to this headline">ï</a></h2>
<p>An application can mix runtime API code with driver API code.</p>
<p>If a context is created and made current via the driver API, subsequent runtime calls will pick up this context instead of creating a new one.</p>
<p>If the runtime is initialized (implicitly as mentioned in <a class="reference internal" href="#cuda-c-runtime"><span class="std std-ref">CUDA Runtime</span></a>), <code class="docutils literal notranslate"><span class="pre">cuCtxGetCurrent()</span></code> can be used to retrieve the context created during initialization. This context can be used by subsequent driver API calls.</p>
<p>The implicitly created context from the runtime is called the <em>primary context</em> (see <a class="reference internal" href="#initialization"><span class="std std-ref">Initialization</span></a>). It can be managed from the driver API with the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__PRIMARY__CTX.html">Primary Context Management</a> functions.</p>
<p>Device memory can be allocated and freed using either API. <code class="docutils literal notranslate"><span class="pre">CUdeviceptr</span></code> can be cast to regular pointers and vice-versa:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">devPtr</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">d_data</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Allocation using driver API</span>
<span class="n">cuMemAlloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="n">d_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">devPtr</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Allocation using runtime API</span>
<span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_data</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
<span class="n">devPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CUdeviceptr</span><span class="p">)</span><span class="n">d_data</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>In particular, this means that applications written using the driver API can invoke libraries written using the runtime API (such as cuFFT, cuBLAS, â¦).</p>
<p>All functions from the device and version management sections of the reference manual can be used interchangeably.</p>
</section>
<section id="driver-entry-point-access">
<span id="id435"></span><h2><span class="section-number">18.5. </span>Driver Entry Point Access<a class="headerlink" href="#driver-entry-point-access" title="Permalink to this headline">ï</a></h2>
<section id="introduction-driver-entry-point-access">
<span id="id436"></span><h3><span class="section-number">18.5.1. </span>Introduction<a class="headerlink" href="#introduction-driver-entry-point-access" title="Permalink to this headline">ï</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Driver</span> <span class="pre">Entry</span> <span class="pre">Point</span> <span class="pre">Access</span> <span class="pre">APIs</span></code> provide a way to retrieve the address of a CUDA driver function. Starting from CUDA 11.3, users can call into available CUDA driver APIs using function pointers obtained from these APIs.</p>
<p>These APIs provide functionality similar to their counterparts, dlsym on POSIX platforms and GetProcAddress on Windows. The provided APIs will let users:</p>
<ul class="simple">
<li><p>Retrieve the address of a driver function using the <code class="docutils literal notranslate"><span class="pre">CUDA</span> <span class="pre">Driver</span> <span class="pre">API.</span></code></p></li>
<li><p>Retrieve the address of a driver function using the <code class="docutils literal notranslate"><span class="pre">CUDA</span> <span class="pre">Runtime</span> <span class="pre">API.</span></code></p></li>
<li><p>Request <em>per-thread default stream</em> version of a CUDA driver function. For more details, see <a class="reference internal" href="#retrieve-per-thread-default-stream-versions"><span class="std std-ref">Retrieve Per-thread Default Stream Versions</span></a>.</p></li>
<li><p>Access new CUDA features on older toolkits but with a newer driver.</p></li>
</ul>
</section>
<section id="driver-function-typedefs">
<span id="id437"></span><h3><span class="section-number">18.5.2. </span>Driver Function Typedefs<a class="headerlink" href="#driver-function-typedefs" title="Permalink to this headline">ï</a></h3>
<p>To help retrieve the CUDA Driver API entry points, the CUDA Toolkit provides access to headers containing the function pointer definitions for all CUDA driver APIs. These headers are installed with the CUDA Toolkit and are made available in the toolkitâs <code class="docutils literal notranslate"><span class="pre">include/</span></code> directory. The table below summarizes the header files containing the <code class="docutils literal notranslate"><span class="pre">typedefs</span></code> for each CUDA API header file.</p>
<table class="docutils align-default" id="id483">
<caption><span class="caption-number">Table 30 </span><span class="caption-text">Typedefs header files for CUDA driver APIs</span><a class="headerlink" href="#id483" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 41%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API header file</p></th>
<th class="head"><p>API Typedef header file</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cuda.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaTypedefs.h</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaGL.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaGLTypedefs.h</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaProfiler.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaProfilerTypedefs.h</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaVDPAU.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaVDPAUTypedefs.h</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaEGL.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaEGLTypedefs.h</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D9.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D9Typedefs.h</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D10.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D10Typedefs.h</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D11.h</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaD3D11Typedefs.h</span></code></p></td>
</tr>
</tbody>
</table>
<p>The above headers do not define actual function pointers themselves; they define the typedefs for function pointers. For example, <code class="docutils literal notranslate"><span class="pre">cudaTypedefs.h</span></code> has the below typedefs for the driver API <code class="docutils literal notranslate"><span class="pre">cuMemAlloc</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuMemAlloc_v3020</span><span class="p">)(</span><span class="n">CUdeviceptr_v2</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytesize</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuMemAlloc_v2000</span><span class="p">)(</span><span class="n">CUdeviceptr_v1</span><span class="w"> </span><span class="o">*</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bytesize</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>CUDA driver symbols have a version based naming scheme with a <code class="docutils literal notranslate"><span class="pre">_v*</span></code> extension in its name except for the first version. When the signature or the semantics of a specific CUDA driver API changes, we increment the version number of the corresponding driver symbol. In the case of the <code class="docutils literal notranslate"><span class="pre">cuMemAlloc</span></code> driver API, the first driver symbol name is <code class="docutils literal notranslate"><span class="pre">cuMemAlloc</span></code> and the next symbol name is <code class="docutils literal notranslate"><span class="pre">cuMemAlloc_v2</span></code>. The typedef for the first version which was introduced in CUDA 2.0 (2000) is <code class="docutils literal notranslate"><span class="pre">PFN_cuMemAlloc_v2000</span></code>. The typedef for the next version which was introduced in CUDA 3.2 (3020) is <code class="docutils literal notranslate"><span class="pre">PFN_cuMemAlloc_v3020</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">typedefs</span></code> can be used to more easily define a function pointer of the appropriate type in code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_cuMemAlloc_v3020</span><span class="w"> </span><span class="n">pfn_cuMemAlloc_v2</span><span class="p">;</span><span class="w"></span>
<span class="n">PFN_cuMemAlloc_v2000</span><span class="w"> </span><span class="n">pfn_cuMemAlloc_v1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>The above method is preferable if users are interested in a specific version of the API. Additionally, the headers have predefined macros for the latest version of all driver symbols that were available when the installed CUDA toolkit was released; these typedefs do not have a <code class="docutils literal notranslate"><span class="pre">_v*</span></code> suffix. For CUDA 11.3 toolkit, <code class="docutils literal notranslate"><span class="pre">cuMemAlloc_v2</span></code> was the latest version and so we can also define its function pointer as below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_cuMemAlloc</span><span class="w"> </span><span class="n">pfn_cuMemAlloc</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="driver-function-retrieval">
<span id="id438"></span><h3><span class="section-number">18.5.3. </span>Driver Function Retrieval<a class="headerlink" href="#driver-function-retrieval" title="Permalink to this headline">ï</a></h3>
<p>Using the Driver Entry Point Access APIs and the appropriate typedef, we can get the function pointer to any CUDA driver API.</p>
<section id="using-the-driver-api">
<span id="id439"></span><h4><span class="section-number">18.5.3.1. </span>Using the Driver API<a class="headerlink" href="#using-the-driver-api" title="Permalink to this headline">ï</a></h4>
<p>The driver API requires CUDA version as an argument to get the ABI compatible version for the requested driver symbol. CUDA Driver APIs have a per-function ABI denoted with a <code class="docutils literal notranslate"><span class="pre">_v*</span></code> extension. For example, consider the versions of <code class="docutils literal notranslate"><span class="pre">cuStreamBeginCapture</span></code> and their corresponding <code class="docutils literal notranslate"><span class="pre">typedefs</span></code> from <code class="docutils literal notranslate"><span class="pre">cudaTypedefs.h</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// cuda.h</span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">CUDAAPI</span><span class="w"> </span><span class="n">cuStreamBeginCapture</span><span class="p">(</span><span class="n">CUstream</span><span class="w"> </span><span class="n">hStream</span><span class="p">);</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">CUDAAPI</span><span class="w"> </span><span class="n">cuStreamBeginCapture_v2</span><span class="p">(</span><span class="n">CUstream</span><span class="w"> </span><span class="n">hStream</span><span class="p">,</span><span class="w"> </span><span class="n">CUstreamCaptureMode</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>

<span class="c1">// cudaTypedefs.h</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuStreamBeginCapture_v10000</span><span class="p">)(</span><span class="n">CUstream</span><span class="w"> </span><span class="n">hStream</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuStreamBeginCapture_v10010</span><span class="p">)(</span><span class="n">CUstream</span><span class="w"> </span><span class="n">hStream</span><span class="p">,</span><span class="w"> </span><span class="n">CUstreamCaptureMode</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>From the above <code class="docutils literal notranslate"><span class="pre">typedefs</span></code> in the code snippet, version suffixes <code class="docutils literal notranslate"><span class="pre">_v10000</span></code> and <code class="docutils literal notranslate"><span class="pre">_v10010</span></code> indicate that the above APIs were introduced in CUDA 10.0 and CUDA 10.1 respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="c1">// Declare the entry points for cuStreamBeginCapture</span>
<span class="n">PFN_cuStreamBeginCapture_v10000</span><span class="w"> </span><span class="n">pfn_cuStreamBeginCapture_v1</span><span class="p">;</span><span class="w"></span>
<span class="n">PFN_cuStreamBeginCapture_v10010</span><span class="w"> </span><span class="n">pfn_cuStreamBeginCapture_v2</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Get the function pointer to the cuStreamBeginCapture driver symbol</span>
<span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuStreamBeginCapture&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuStreamBeginCapture_v1</span><span class="p">,</span><span class="w"> </span><span class="mi">10000</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Get the function pointer to the cuStreamBeginCapture_v2 driver symbol</span>
<span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuStreamBeginCapture&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuStreamBeginCapture_v2</span><span class="p">,</span><span class="w"> </span><span class="mi">10010</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Referring to the code snippet above, to retrieve the address to the <code class="docutils literal notranslate"><span class="pre">_v1</span></code> version of the driver API <code class="docutils literal notranslate"><span class="pre">cuStreamBeginCapture</span></code>, the CUDA version argument should be exactly 10.0 (10000). Similarly, the CUDA version for retrieving the address to the <code class="docutils literal notranslate"><span class="pre">_v2</span></code> version of the API should be 10.1 (10010). Specifying a higher CUDA version for retrieving a specific version of a driver API might not always be portable. For example, using 11030 here would still return the <code class="docutils literal notranslate"><span class="pre">_v2</span></code> symbol, but if a hypothetical <code class="docutils literal notranslate"><span class="pre">_v3</span></code> version is released in CUDA 11.3, the <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> API would start returning the newer <code class="docutils literal notranslate"><span class="pre">_v3</span></code> symbol instead when paired with a CUDA 11.3 driver. Since the ABI and function signatures of the <code class="docutils literal notranslate"><span class="pre">_v2</span></code> and <code class="docutils literal notranslate"><span class="pre">_v3</span></code> symbols might differ, calling the <code class="docutils literal notranslate"><span class="pre">_v3</span></code> function using the <code class="docutils literal notranslate"><span class="pre">_v10010</span></code> typedef intended for the <code class="docutils literal notranslate"><span class="pre">_v2</span></code> symbol would exhibit undefined behavior.</p>
<p>To retrieve the latest version of a driver API for a given CUDA Toolkit, we can also specify CUDA_VERSION as the <code class="docutils literal notranslate"><span class="pre">version</span></code> argument and use the unversioned typedef to define the function pointer. Since <code class="docutils literal notranslate"><span class="pre">_v2</span></code> is the latest version of the driver API <code class="docutils literal notranslate"><span class="pre">cuStreamBeginCapture</span></code> in CUDA 11.3, the below code snippet shows a different method to retrieve it.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assuming we are using CUDA 11.3 Toolkit</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="c1">// Declare the entry point</span>
<span class="n">PFN_cuStreamBeginCapture</span><span class="w"> </span><span class="n">pfn_cuStreamBeginCapture_latest</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Intialize the entry point. Specifying CUDA_VERSION will give the function pointer to the</span>
<span class="c1">// cuStreamBeginCapture_v2 symbol since it is latest version on CUDA 11.3.</span>
<span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuStreamBeginCapture&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuStreamBeginCapture_latest</span><span class="p">,</span><span class="w"> </span><span class="n">CUDA_VERSION</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Note that requesting a driver API with an invalid CUDA version will return an error <code class="docutils literal notranslate"><span class="pre">CUDA_ERROR_NOT_FOUND</span></code>. In the above code examples, passing in a version less than 10000 (CUDA 10.0) would be invalid.</p>
</section>
<section id="using-the-runtime-api">
<span id="id440"></span><h4><span class="section-number">18.5.3.2. </span>Using the Runtime API<a class="headerlink" href="#using-the-runtime-api" title="Permalink to this headline">ï</a></h4>
<p>The runtime API <code class="docutils literal notranslate"><span class="pre">cudaGetDriverEntryPoint</span></code> uses the CUDA runtime version to get the ABI compatible version for the requested driver symbol. In the below code snippet, the minimum CUDA runtime version required would be CUDA 11.2 as <code class="docutils literal notranslate"><span class="pre">cuMemAllocAsync</span></code> was introduced then.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="c1">// Declare the entry point</span>
<span class="n">PFN_cuMemAllocAsync</span><span class="w"> </span><span class="n">pfn_cuMemAllocAsync</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Intialize the entry point. Assuming CUDA runtime version &gt;= 11.2</span>
<span class="n">cudaGetDriverEntryPoint</span><span class="p">(</span><span class="s">&quot;cuMemAllocAsync&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuMemAllocAsync</span><span class="p">,</span><span class="w"> </span><span class="n">cudaEnableDefault</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Call the entry point</span>
<span class="k">if</span><span class="p">(</span><span class="n">driverStatus</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaDriverEntryPointSuccess</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuMemAllocAsync</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pfn_cuMemAllocAsync</span><span class="p">(...);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The runtime API <code class="docutils literal notranslate"><span class="pre">cudaGetDriverEntryPointByVersion</span></code> uses the user provided CUDA version to get the ABI compatible version for the requested driver symbol. This allows more specific control over the requested ABI version.</p>
</section>
<section id="retrieve-per-thread-default-stream-versions">
<span id="id441"></span><h4><span class="section-number">18.5.3.3. </span>Retrieve Per-thread Default Stream Versions<a class="headerlink" href="#retrieve-per-thread-default-stream-versions" title="Permalink to this headline">ï</a></h4>
<p>Some CUDA driver APIs can be configured to have <em>default stream</em> or <em>per-thread default stream</em> semantics. Driver APIs having <em>per-thread default stream</em> semantics are suffixed with <em>_ptsz</em> or <em>_ptds</em> in their name. For example, <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel</span></code> has a <em>per-thread default stream</em> variant named <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel_ptsz</span></code>. With the Driver Entry Point Access APIs, users can request for the <em>per-thread default stream</em> version of the driver API <code class="docutils literal notranslate"><span class="pre">cuLaunchKernel</span></code> instead of the <em>default stream</em> version. Configuring the CUDA driver APIs for <em>default stream</em> or <em>per-thread default stream</em> semantics affects the synchronization behavior. More details can be found <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/stream-sync-behavior.html#stream-sync-behavior__default-stream">here</a>.</p>
<p>The <em>default stream</em> or <em>per-thread default stream</em> versions of a driver API can be obtained by one of the following ways:</p>
<ul class="simple">
<li><p>Use the compilation flag <code class="docutils literal notranslate"><span class="pre">--default-stream</span> <span class="pre">per-thread</span></code> or define the macro <code class="docutils literal notranslate"><span class="pre">CUDA_API_PER_THREAD_DEFAULT_STREAM</span></code> to get <em>per-thread default stream</em> behavior.</p></li>
<li><p>Force <em>default stream</em> or <em>per-thread default stream</em> behavior using the flags <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_LEGACY_STREAM/cudaEnableLegacyStream</span></code> or <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM/cudaEnablePerThreadDefaultStream</span></code> respectively.</p></li>
</ul>
</section>
<section id="access-new-cuda-features">
<span id="id442"></span><h4><span class="section-number">18.5.3.4. </span>Access New CUDA features<a class="headerlink" href="#access-new-cuda-features" title="Permalink to this headline">ï</a></h4>
<p>It is always recommended to install the latest CUDA toolkit to access new CUDA driver features, but if for some reason, a user does not want to update or does not have access to the latest toolkit, the API can be used to access new CUDA features with only an updated CUDA driver. For discussion, let us assume the user is on CUDA 11.3 and wants to use a new driver API <code class="docutils literal notranslate"><span class="pre">cuFoo</span></code> available in the CUDA 12.0 driver. The below code snippet illustrates this use-case:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Assuming we have CUDA 12.0 driver installed.</span>

<span class="w">    </span><span class="c1">// Manually define the prototype as cudaTypedefs.h in CUDA 11.3 does not have the cuFoo typedef</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuFoo</span><span class="p">)(...);</span><span class="w"></span>
<span class="w">    </span><span class="n">PFN_cuFoo</span><span class="w"> </span><span class="n">pfn_cuFoo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Get the address for cuFoo API using cuGetProcAddress. Specify CUDA version as</span>
<span class="w">    </span><span class="c1">// 12000 since cuFoo was introduced then or get the driver version dynamically</span>
<span class="w">    </span><span class="c1">// using cuDriverGetVersion</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">driverVersion</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cuDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverVersion</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuFoo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuFoo</span><span class="p">,</span><span class="w"> </span><span class="n">driverVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuFoo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">pfn_cuFoo</span><span class="p">(...);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot retrieve the address to cuFoo - driverStatus = %d. Check if the latest driver for CUDA 12.0 is installed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// rest of code here</span>

<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="potential-implications-with-cugetprocaddress">
<span id="implications-with-cugetprocaddress"></span><h3><span class="section-number">18.5.4. </span>Potential Implications with cuGetProcAddress<a class="headerlink" href="#potential-implications-with-cugetprocaddress" title="Permalink to this headline">ï</a></h3>
<p>Below is a set of concrete and theoretical examples of potential issues with <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaGetDriverEntryPoint</span></code>.</p>
<section id="implications-with-cugetprocaddress-vs-implicit-linking">
<span id="implications-with-native-compilation"></span><h4><span class="section-number">18.5.4.1. </span>Implications with cuGetProcAddress vs Implicit Linking<a class="headerlink" href="#implications-with-cugetprocaddress-vs-implicit-linking" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code> was introduced in CUDA 9.2. This API has a newer revision (<code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid_v2</span></code>) introduced in CUDA 11.4. To preserve minor version compatibility, <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code> will not be version bumped to <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid_v2</span></code> in cuda.h until CUDA 12.0. This means that calling it by obtaining a function pointer to it via <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> might have different behavior. Example using the API directly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>

<span class="n">CUuuid</span><span class="w"> </span><span class="n">uuid</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdevice</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get device 0</span>
<span class="c1">// handle status</span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGetUuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uuid</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">)</span><span class="w"> </span><span class="c1">// Get uuid of device 0</span>
</pre></div>
</div>
<p>In this example, assume the user is compiling with CUDA 11.4. Note that this will perform the behavior of <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code>, not _v2 version. Now an example of using <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="n">CUuuid</span><span class="w"> </span><span class="n">uuid</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdevice</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get device 0</span>
<span class="c1">// handle status</span>

<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">;</span><span class="w"></span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">,</span><span class="w"> </span><span class="n">CUDA_VERSION</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuid points to ???</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, assume the user is compiling with CUDA 11.4. This will get the function pointer of <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid_v2</span></code>. Calling the function pointer will then invoke the new _v2 function, not the same <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code> as shown in the previous example.</p>
</section>
<section id="compile-time-vs-runtime-version-usage-in-cugetprocaddress">
<span id="implications-compile-vs-runtime-version"></span><h4><span class="section-number">18.5.4.2. </span>Compile Time vs Runtime Version Usage in cuGetProcAddress<a class="headerlink" href="#compile-time-vs-runtime-version-usage-in-cugetprocaddress" title="Permalink to this headline">ï</a></h4>
<p>Letâs take the same issue and make one small tweak. The last example used the compile time constant of CUDA_VERSION to determine which function pointer to obtain. More complications arise if the user queries the driver version dynamically using <code class="docutils literal notranslate"><span class="pre">cuDriverGetVersion</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaDriverGetVersion</span></code> to pass to <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code>. Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="n">CUuuid</span><span class="w"> </span><span class="n">uuid</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdevice</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDeviceGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Get device 0</span>
<span class="c1">// handle status</span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaVersion</span><span class="p">);</span><span class="w"></span>
<span class="c1">// handle status</span>

<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">;</span><span class="w"></span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">,</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuid points to ???</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, assume the user is compiling with CUDA 11.3. The user would debug, test, and deploy this application with the known behavior of getting <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code> (not the _v2 version). Since CUDA has guaranteed ABI compatibility between minor versions, this same application is expected to run after the driver is upgraded to CUDA 11.4 (without updating the toolkit and runtime) without requiring recompilation. This will have undefined behavior though, because now the typedef for <code class="docutils literal notranslate"><span class="pre">PFN_cuDeviceGetUuid</span></code> will still be of the signature for the original version, but since <code class="docutils literal notranslate"><span class="pre">cudaVersion</span></code> would now be 11040 (CUDA 11.4), <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> would return the function pointer to the _v2 version, meaning calling it might have undefined behavior.</p>
<p>Note in this case the original (not the _v2 version) typedef looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuDeviceGetUuid_v9020</span><span class="p">)(</span><span class="n">CUuuid</span><span class="w"> </span><span class="o">*</span><span class="n">uuid</span><span class="p">,</span><span class="w"> </span><span class="n">CUdevice_v1</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>But the _v2 version typedef looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuDeviceGetUuid_v11040</span><span class="p">)(</span><span class="n">CUuuid</span><span class="w"> </span><span class="o">*</span><span class="n">uuid</span><span class="p">,</span><span class="w"> </span><span class="n">CUdevice_v1</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>So in this case, the API/ABI is going to be the same and the runtime API call will likely not cause issuesâonly the potential for unknown uuid return. In <a class="reference internal" href="#implications-to-api-abi"><span class="std std-ref">Implications to API/ABI</span></a>, we discuss a more problematic case of API/ABI compatibility.</p>
</section>
<section id="api-version-bumps-with-explicit-version-checks">
<span id="implications-runtime-version-bumps"></span><h4><span class="section-number">18.5.4.3. </span>API Version Bumps with Explicit Version Checks<a class="headerlink" href="#api-version-bumps-with-explicit-version-checks" title="Permalink to this headline">ï</a></h4>
<p>Above, was a specific concrete example. Now for instance letâs use a theoretical example that still has issues with compatibility across driver versions. Example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUresult</span><span class="w"> </span><span class="nf">cuFoo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"> </span><span class="c1">// Introduced in CUDA 11.4</span>
<span class="n">CUresult</span><span class="w"> </span><span class="nf">cuFoo_v2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"> </span><span class="c1">// Introduced in CUDA 11.5</span>
<span class="n">CUresult</span><span class="w"> </span><span class="nf">cuFoo_v3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">jazz</span><span class="p">);</span><span class="w"> </span><span class="c1">// Introduced in CUDA 11.6</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuFoo_v11040</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuFoo_v11050</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">);</span><span class="w"></span>
<span class="k">typedef</span><span class="w"> </span><span class="n">CUresult</span><span class="w"> </span><span class="p">(</span><span class="n">CUDAAPI</span><span class="w"> </span><span class="o">*</span><span class="n">PFN_cuFoo_v11060</span><span class="p">)(</span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">jazz</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Notice that the API has been modified twice since original creation in CUDA 11.4 and the latest in CUDA 11.6 also modified the API/ABI interface to the function. The usage in user code compiled against CUDA 11.5 is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>

<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cudaVersion</span><span class="p">);</span><span class="w"></span>
<span class="c1">// handle status</span>

<span class="n">PFN_cuFoo_v11040</span><span class="w"> </span><span class="n">pfn_cuFoo_v11040</span><span class="p">;</span><span class="w"></span>
<span class="n">PFN_cuFoo_v11050</span><span class="w"> </span><span class="n">pfn_cuFoo_v11050</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">cudaVersion</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">11050</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// We know to get the CUDA 11.4 version</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuFoo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuFoo_v11040</span><span class="p">,</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Handle status and validating pfn_cuFoo_v11040</span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Assume &gt;= CUDA 11.5 version we can use the second version</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuFoo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuFoo_v11050</span><span class="p">,</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Handle status and validating pfn_cuFoo_v11050</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, without updates for the new typedef in CUDA 11.6 and recompiling the application with those new typedefs and case handling, the application will get the cuFoo_v3 function pointer returned and any usage of that function would then cause undefined behavior. The point of this example was to illustrate that even explicit version checks for <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> may not safely cover the minor version bumps within a CUDA major release.</p>
</section>
<section id="issues-with-runtime-api-usage">
<span id="implications-issues-with-runtime-api"></span><h4><span class="section-number">18.5.4.4. </span>Issues with Runtime API Usage<a class="headerlink" href="#issues-with-runtime-api-usage" title="Permalink to this headline">ï</a></h4>
<p>The above examples were focused on the issues with the Driver API usage for obtaining the function pointers to driver APIs. Now we will discuss the potential issues with the Runtime API usage for <code class="docutils literal notranslate"><span class="pre">cudaApiGetDriverEntryPoint</span></code>.</p>
<p>We will start by using the Runtime APIs similar to the above.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp"></span>

<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">driverVersion</span><span class="p">,</span><span class="w"> </span><span class="n">runtimeVersion</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Ask the runtime for the function</span>
<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">;</span><span class="w"></span>
<span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGetDriverEntryPoint</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">,</span><span class="w"> </span><span class="n">cudaEnableDefault</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuid points to ???</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The function pointer in this example is even more complicated than the driver only examples above because there is no control over which version of the function to obtain; it will always get the API for the current CUDA Runtime version. See the following table for more information:</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 26%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="2"><p>Static Runtime Version Linkage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Driver Version Installed</p></td>
<td><p><strong>V11.3</strong></p></td>
<td><p><strong>V11.4</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>V11.3</strong></p></td>
<td><p>v1</p></td>
<td><p>v1x</p></td>
</tr>
<tr class="row-even"><td><p><strong>V11.4</strong></p></td>
<td><p>v1</p></td>
<td><p>v2</p></td>
</tr>
</tbody>
</table>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>V11.3 =&gt; 11.3 CUDA Runtime and Toolkit (includes header files cuda.h and cudaTypedefs.h)
V11.4 =&gt; 11.4 CUDA Runtime and Toolkit (includes header files cuda.h and cudaTypedefs.h)
v1 =&gt; cuDeviceGetUuid
v2 =&gt; cuDeviceGetUuid_v2

x =&gt; Implies the typedef function pointer won&#39;t match the returned
     function pointer.  In these cases, the typedef at compile time
     using a CUDA 11.4 runtime, would match the _v2 version, but the
     returned function pointer would be the original (non _v2) function.
</pre></div>
</div>
<p>The problem in the table comes in with a newer CUDA 11.4 Runtime and Toolkit and older driver (CUDA 11.3) combination, labeled as v1x in the above. This combination would have the driver returning the pointer to the older function (non _v2), but the typedef used in the application would be for the new function pointer.</p>
</section>
<section id="issues-with-runtime-api-and-dynamic-versioning">
<span id="implications-with-runtime-api-and-dynamic-version"></span><h4><span class="section-number">18.5.4.5. </span>Issues with Runtime API and Dynamic Versioning<a class="headerlink" href="#issues-with-runtime-api-and-dynamic-versioning" title="Permalink to this headline">ï</a></h4>
<p>More complications arise when we consider different combinations of the CUDA version with which an application is compiled, CUDA runtime version, and CUDA driver version that an application dynamically links against.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cudaTypedefs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp"></span>

<span class="n">CUresult</span><span class="w"> </span><span class="n">status</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaError_t</span><span class="w"> </span><span class="n">error</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">driverVersion</span><span class="p">,</span><span class="w"> </span><span class="n">runtimeVersion</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>
<span class="k">enum</span><span class="w"> </span><span class="nc">cudaDriverEntryPointQueryResult</span><span class="w"> </span><span class="n">runtimeStatus</span><span class="p">;</span><span class="w"></span>

<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidDriver</span><span class="p">;</span><span class="w"></span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuidDriver</span><span class="p">,</span><span class="w"> </span><span class="n">CUDA_VERSION</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidDriver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuidDriver points to ???</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Ask the runtime for the function</span>
<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">;</span><span class="w"></span>
<span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaGetDriverEntryPoint</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">,</span><span class="w"> </span><span class="n">cudaEnableDefault</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">runtimeStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">cudaSuccess</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidRuntime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuidRuntime points to ???</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Ask the driver for the function based on the driver version (obtained via runtime)</span>
<span class="n">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaDriverGetVersion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverVersion</span><span class="p">);</span><span class="w"></span>
<span class="n">PFN_cuDeviceGetUuid</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidDriverDriverVer</span><span class="p">;</span><span class="w"></span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;cuDeviceGetUuid&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn_cuDeviceGetUuidDriverDriverVer</span><span class="p">,</span><span class="w"> </span><span class="n">driverVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn_cuDeviceGetUuidDriverDriverVer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// pfn_cuDeviceGetUuidDriverDriverVer points to ???</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following matrix of function pointers is expected:</p>
<table class="table-no-stripes docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<tbody>
<tr class="row-odd"><td rowspan="3"><p><strong>Function Pointer</strong></p></td>
<td colspan="8"><p><strong>Application Compiled/Runtime Dynamic Linked Version/Driver Version</strong></p></td>
</tr>
<tr class="row-even"><td colspan="8"><p><strong>(3 =&gt; CUDA 11.3 and 4 =&gt; CUDA 11.4)</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>3/3/3</strong></p></td>
<td><p><strong>3/3/4</strong></p></td>
<td><p><strong>3/4/3</strong></p></td>
<td><p><strong>3/4/4</strong></p></td>
<td><p><strong>4/3/3</strong></p></td>
<td><p><strong>4/3/4</strong></p></td>
<td><p><strong>4/4/3</strong></p></td>
<td><p><strong>4/4/4</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pfn_cuDeviceGetUuidDriver</span></code></p></td>
<td><p>t1/v1</p></td>
<td><p>t1/v1</p></td>
<td><p>t1/v1</p></td>
<td><p>t1/v1</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
<td><p><strong>t2/v1</strong></p></td>
<td><p>t2/v2</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pfn_cuDeviceGetUuidRuntime</span></code></p></td>
<td><p>t1/v1</p></td>
<td><p>t1/v1</p></td>
<td><p>t1/v1</p></td>
<td><p><strong>t1/v2</strong></p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
<td><p><strong>t2/v1</strong></p></td>
<td><p>t2/v2</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pfn_cuDeviceGetUuidDriverDriverVer</span></code></p></td>
<td><p>t1/v1</p></td>
<td><p><strong>t1/v2</strong></p></td>
<td><p>t1/v1</p></td>
<td><p><strong>t1/v2</strong></p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
<td><p><strong>t2/v1</strong></p></td>
<td><p>t2/v2</p></td>
</tr>
</tbody>
</table>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>tX -&gt; Typedef version used at compile time
vX -&gt; Version returned/used at runtime
</pre></div>
</div>
<p>If the application is compiled against CUDA Version 11.3, it would have the typedef for the original function, but if compiled against CUDA Version 11.4, it would have the typedef for the _v2 function. Because of that, notice the number of cases where the typedef does not match the actual version returned/used.</p>
</section>
<section id="issues-with-runtime-api-allowing-cuda-version">
<span id="implications-with-runtime-api-by-version"></span><h4><span class="section-number">18.5.4.6. </span>Issues with Runtime API allowing CUDA Version<a class="headerlink" href="#issues-with-runtime-api-allowing-cuda-version" title="Permalink to this headline">ï</a></h4>
<p>Unless specified otherwise, the CUDA runtime API <code class="docutils literal notranslate"><span class="pre">cudaGetDriverEntryPointByVersion</span></code> will have similar implications as the driver entry point <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> since it allows for the user to request a specific CUDA driver version.</p>
</section>
<section id="implications-to-api-abi">
<span id="id443"></span><h4><span class="section-number">18.5.4.7. </span>Implications to API/ABI<a class="headerlink" href="#implications-to-api-abi" title="Permalink to this headline">ï</a></h4>
<p>In the above examples using <code class="docutils literal notranslate"><span class="pre">cuDeviceGetUuid</span></code>, the implications of the mismatched API are minimal, and may not be entirely noticeable to many users as the _v2 was added to support Multi-Instance GPU (MIG) mode. So, on a system without MIG, the user might not even realize they are getting a different API.</p>
<p>More problematic is an API which changes its application signature (and hence ABI) such as <code class="docutils literal notranslate"><span class="pre">cuCtxCreate</span></code>. The _v2 version, introduced in CUDA 3.2 is currently used as the default <code class="docutils literal notranslate"><span class="pre">cuCtxCreate</span></code> when using <code class="docutils literal notranslate"><span class="pre">cuda.h</span></code> but now has a newer version introduced in CUDA 11.4 (<code class="docutils literal notranslate"><span class="pre">cuCtxCreate_v3</span></code>). The API signature has been modified as well, and now takes extra arguments. So, in some of the cases above, where the typedef to the function pointer doesnât match the returned function pointer, there is a chance for non-obvious ABI incompatibility which would lead to undefined behavior.</p>
<p>For example, assume the following code compiled against a CUDA 11.3 toolkit with a CUDA 11.4 driver installed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">PFN_cuCtxCreate</span><span class="w"> </span><span class="n">cuUnknown</span><span class="p">;</span><span class="w"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuCtxCreate&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cuUnknown</span><span class="p">,</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">,</span><span class="w"> </span><span class="n">CU_GET_PROC_ADDRESS_DEFAULT</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">cuUnknown</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuUnknown</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Running this code where <code class="docutils literal notranslate"><span class="pre">cudaVersion</span></code> is set to anything &gt;=11040 (indicating CUDA 11.4) could have undefined behavior due to not having adequately supplied all the parameters required for the _v3 version of the <code class="docutils literal notranslate"><span class="pre">cuCtxCreate_v3</span></code> API.</p>
</section>
</section>
<section id="determining-cugetprocaddress-failure-reasons">
<span id="determining-cugetprocaddress-failure-reason"></span><h3><span class="section-number">18.5.5. </span>Determining cuGetProcAddress Failure Reasons<a class="headerlink" href="#determining-cugetprocaddress-failure-reasons" title="Permalink to this headline">ï</a></h3>
<p>There are two types of errors with cuGetProcAddress. Those are (1) API/usage errors and (2) inability to find the driver API requested. The first error type will return error codes from the API via the CUresult return value. Things like passing NULL as the <code class="docutils literal notranslate"><span class="pre">pfn</span></code> variable or passing invalid <code class="docutils literal notranslate"><span class="pre">flags</span></code>.</p>
<p>The second error type encodes in the <code class="docutils literal notranslate"><span class="pre">CUdriverProcAddressQueryResult</span> <span class="pre">*symbolStatus</span></code> and can be used to help distinguish potential issues with the driver not being able to find the symbol requested. Take the following example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// cuDeviceGetExecAffinitySupport was introduced in release CUDA 11.4</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="n">CUdriverProcAddressQueryResult</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cuGetProcAddress</span><span class="p">(</span><span class="s">&quot;cuDeviceGetExecAffinitySupport&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pfn</span><span class="p">,</span><span class="w"> </span><span class="n">cudaVersion</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">driverStatus</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;We can use the new feature when you upgrade cudaVersion to 11.4, but CUDA driver is good to go!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Indicating cudaVersion was &lt; 11.4 but run against a CUDA driver &gt;= 11.4</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">driverStatus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Please update both CUDA driver and cudaVersion to at least 11.4 to use the new feature!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Indicating driver is &lt; 11.4 since string not found, doesn&#39;t matter what cudaVersion was</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CU_GET_PROC_ADDRESS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">driverStatus</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pfn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;You&#39;re using cudaVersion and CUDA driver &gt;= 11.4, using new feature!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">pfn</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The first case with the return code <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">symbol</span></code> was found when searching in the CUDA driver but it was added later than the <code class="docutils literal notranslate"><span class="pre">cudaVersion</span></code> supplied. In the example, specifying <code class="docutils literal notranslate"><span class="pre">cudaVersion</span></code> as anything 11030 or less and when running against a CUDA driver &gt;= CUDA 11.4 would give this result of <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT</span></code>. This is because <code class="docutils literal notranslate"><span class="pre">cuDeviceGetExecAffinitySupport</span></code> was added in CUDA 11.4 (11040).</p>
<p>The second case with the return code <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND</span></code> indicates that the <code class="docutils literal notranslate"><span class="pre">symbol</span></code> was not found when searching in the CUDA driver. This can be due to a few reasons such as unsupported CUDA function due to older driver as well as just having a typo. In the latter, similar to the last example if the user had put <code class="docutils literal notranslate"><span class="pre">symbol</span></code> as CUDeviceGetExecAffinitySupport - notice the capital CU to start the string - <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code> would not be able to find the API because the string doesnât match. In the former case an example might be the user developing an application against a CUDA driver supporting the new API, and deploying the application against an older CUDA driver. Using the last example, if the developer developed against CUDA 11.4 or later but was deployed against a CUDA 11.3 driver, during their development they may have had a succesful <code class="docutils literal notranslate"><span class="pre">cuGetProcAddress</span></code>, but when deploying an application running against a CUDA 11.3 driver the call would no longer work with the <code class="docutils literal notranslate"><span class="pre">CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND</span></code> returned in <code class="docutils literal notranslate"><span class="pre">driverStatus</span></code>.</p>
</section>
</section>
</section>
<section id="cuda-environment-variables">
<span id="env-vars"></span><h1><span class="section-number">19. </span>CUDA Environment Variables<a class="headerlink" href="#cuda-environment-variables" title="Permalink to this headline">ï</a></h1>
<p>The following table lists the CUDA environment variables. Environment variables related to the Multi-Process Service are documented in the Multi-Process Service section of the GPU Deployment and Management guide.</p>
<table class="small table-no-stripes longtable docutils align-default" id="id484">
<caption><span class="caption-number">Table 31 </span><span class="caption-text">CUDA Environment Variables</span><a class="headerlink" href="#id484" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 19%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Variable</p></th>
<th class="head"><p>Values</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Device Enumeration and Properties</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_VISIBLE_DEVICES</p></td>
<td><p>A comma-separated sequence of GPU identifiers
MIG support: <code class="docutils literal notranslate"><span class="pre">MIG-&lt;GPU-UUID&gt;/&lt;GPU</span> <span class="pre">instance</span> <span class="pre">ID&gt;/&lt;compute</span> <span class="pre">instance</span> <span class="pre">ID&gt;</span></code></p></td>
<td><p>GPU identifiers are given as integer indices or as UUID strings. GPU UUID strings should follow the same format as given by <em>nvidia-smi</em>, such as GPU-8932f937-d72c-4106-c12f-20bd9faed9f6. However, for convenience, abbreviated forms are allowed; simply specify enough digits from the beginning of the GPU UUID to uniquely identify that GPU in the target system. For example, CUDA_VISIBLE_DEVICES=GPU-8932f937 may be a valid way to refer to the above GPU UUID, assuming no other GPU in the system shares this prefix.
Only the devices whose index is present in the sequence are visible to CUDA applications and they are enumerated in the order of the sequence. If one of the indices is invalid, only the devices whose index precedes the invalid index are visible to CUDA applications. For example, setting CUDA_VISIBLE_DEVICES to 2,1 causes device 0 to be invisible and device 2 to be enumerated before device 1. Setting CUDA_VISIBLE_DEVICES to 0,2,-1,1 causes devices 0 and 2 to be visible and device 1 to be invisible.
MIG format starts with MIG keyword and GPU UUID should follow the same format as given by <em>nvidia-smi</em>. For example, MIG-GPU-8932f937-d72c-4106-c12f-20bd9faed9f6/1/2. Only single MIG instance enumeration is supported.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_MANAGED_FORCE_DEVICE_ALLOC</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>Forces the driver to place all managed allocations in device memory.</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DEVICE_ORDER</p></td>
<td><p>FASTEST_FIRST, PCI_BUS_ID, (default is FASTEST_FIRST)</p></td>
<td><p>FASTEST_FIRST causes CUDA to enumerate the available devices in fastest to slowest order using a simple heuristic. PCI_BUS_ID orders devices by PCI bus ID in ascending order.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Compilation</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_CACHE_DISABLE</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>Disables caching (when set to 1) or enables caching (when set to 0) for just-in-time-compilation. When disabled, no binary code is added to or retrieved from the cache.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_CACHE_PATH</p></td>
<td><p>filepath</p></td>
<td><p>Specifies the folder where the just-in-time compiler caches binary codes; the default values are:</p>
<ul class="simple">
<li><p>on Windows, <code class="docutils literal notranslate"><span class="pre">%APPDATA%\NVIDIA\ComputeCache</span></code></p></li>
<li><p>on Linux, <code class="docutils literal notranslate"><span class="pre">~/.nv/ComputeCache</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>CUDA_CACHE_MAXSIZE</p></td>
<td><p>integer (default is 1073741824 (1 GiB) for desktop/server platforms and 268435456 (256 MiB) for embedded platforms and the maximum is 4294967296 (4 GiB))</p></td>
<td><p>Specifies the size in bytes of the cache used by the just-in-time compiler. Binary codes whose size exceeds the cache size are not cached. Older binary codes are evicted from the cache to make room for newer binary codes if needed.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_FORCE_PTX_JIT</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, forces the device driver to ignore any binary code embedded in an application (see <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>) and to just-in-time compile embedded PTX code instead. If a kernel does not have embedded PTX code, it will fail to load. This environment variable can be used to validate that PTX code is embedded in an application and that its just-in-time compilation works as expected to guarantee application forward compatibility with future architectures (see <a class="reference internal" href="#just-in-time-compilation"><span class="std std-ref">Just-in-Time Compilation</span></a>).</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DISABLE_PTX_JIT</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, disables the just-in-time compilation of embedded PTX code and use the compatible binary code embedded in an application (see <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>). If a kernel does not have embedded binary code or the embedded binary was compiled for an incompatible architecture, then it will fail to load. This environment variable can be used to validate that an application has the compatible <em>SASS</em> code generated for each kernel.(see <a class="reference internal" href="#binary-compatibility"><span class="std std-ref">Binary Compatibility</span></a>).</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_FORCE_JIT</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, forces the device driver to ignore any binary code embedded in an application (see <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>) and to just-in-time compile embedded PTX code instead. If a kernel does not have embedded PTX code, it will fail to load. This environment variable can be used to validate that PTX code is embedded in an application and that its just-in-time compilation works as expected to guarantee application forward compatibility with future architectures (see <a class="reference internal" href="#just-in-time-compilation"><span class="std std-ref">Just-in-Time Compilation</span></a>). The behavior can be overridden for embedded PTX by setting <code class="docutils literal notranslate"><span class="pre">CUDA_FORCE_PTX_JIT=0</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DISABLE_JIT</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, disables the just-in-time compilation of embedded PTX code and use the compatible binary code embedded in an application (see <a class="reference internal" href="#application-compatibility"><span class="std std-ref">Application Compatibility</span></a>). If a kernel does not have embedded binary code or the embedded binary was compiled for an incompatible architecture, then it will fail to load. This environment variable can be used to validate that an application has the compatible SASS code generated for each kernel.(see <a class="reference internal" href="#binary-compatibility"><span class="std std-ref">Binary Compatibility</span></a>). The behavior can be overridden for embedded PTX by setting <code class="docutils literal notranslate"><span class="pre">CUDA_DISABLE_PTX_JIT=0</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Execution</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_LAUNCH_BLOCKING</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>Disables (when set to 1) or enables (when set to 0) asynchronous kernel launches.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_DEVICE_MAX_CONNECTIONS</p></td>
<td><p>1 to 32 (default is 8)</p></td>
<td><p>Sets the number of compute and copy engine concurrent connections (work queues) from the host to each device of compute capability 3.5 and above.</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DEVICE_MAX_COPY_CONNECTIONS</p></td>
<td><p>1 to 32 (default is 8)</p></td>
<td><p>Sets the number of copy engine concurrent connections (work queues) per async copy engine from the host to each device of compute capability 8.0 and above. When both CUDA_DEVICE_MAX_CONNECTIONS and CUDA_DEVICE_MAX_COPY_CONNECTIONS are set,  only the number of copy connections set by CUDA_DEVICE_MAX_CONNECTIONS will be overwritten.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_AUTO_BOOST</p></td>
<td><p>0 or 1</p></td>
<td><p>Overrides the autoboost behavior set by the âauto-boost-default option of nvidia-smi. If an application requests via this environment variable a behavior that is different from nvidia-smiâs, its request is honored if there is no other application currently running on the same GPU that successfully requested a different behavior, otherwise it is ignored.</p></td>
</tr>
<tr class="row-odd"><td><p>CUDA_SCALE_LAUNCH_QUEUES</p></td>
<td><p>â0.25xâ, â0.5xâ, â2xâ or â4xâ</p></td>
<td><p>Scales the size of the queues available for launching work by a fixed multiplier.</p></td>
</tr>
<tr class="row-even"><td><p><strong>cuda-gdb (on Linux platform)</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DEVICE_WAITS_ON_EXCEPTION</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, a CUDA application will halt when a device exception occurs, allowing a debugger to be attached for further debugging.</p></td>
</tr>
<tr class="row-even"><td><p><strong>MPS service (on Linux platform)</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_DEVICE_DEFAULT_PERSISTING_L2_CACHE_PERCENTAGE_LIMIT</p></td>
<td><p>Percentage value (between 0 - 100, default is 0)</p></td>
<td><p>Devices of compute capability 8.x allow, a portion of L2 cache to be set-aside for persisting data accesses to global memory. When using CUDA MPS service, the set-aside size can only be controlled using this environment variable, before starting CUDA MPS control daemon. I.e., the environment variable should be set before running the command <code class="docutils literal notranslate"><span class="pre">nvidia-cuda-mps-control</span> <span class="pre">-d</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><strong>Module loading</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>CUDA_MODULE_LOADING</p></td>
<td><p>DEFAULT, LAZY, EAGER (default is LAZY)</p></td>
<td><p>Specifies the module loading mode for the application. When set to EAGER, all kernels and data from a cubin, fatbin or a PTX file are fully loaded upon corresponding <code class="docutils literal notranslate"><span class="pre">cuModuleLoad*</span></code> and <code class="docutils literal notranslate"><span class="pre">cuLibraryLoad*</span></code> API call. When set to LAZY, loading of specific kernels is delayed to the point a CUfunc handle is extracted with <code class="docutils literal notranslate"><span class="pre">cuModuleGetFunction</span></code> or <code class="docutils literal notranslate"><span class="pre">cuKernelGetFunction</span></code> API calls and data from the cubin is loaded at load of first kernel in the cubin or at first access of variables in the cubin. Default behavior may change in future CUDA releases.</p></td>
</tr>
<tr class="row-even"><td><p>CUDA_MODULE_DATA_LOADING</p></td>
<td><p>DEFAULT, LAZY, EAGER (default is LAZY)</p></td>
<td><p>Specifies the data loading mode for the application. When set to EAGER, all data from a cubin, fatbin or a PTX file are fully loaded to memory upon corresponding <code class="docutils literal notranslate"><span class="pre">cuLibraryLoad*</span></code>. This doesnât affect the LAZY or EAGER loading of kernels. When set to LAZY, loading of data is delayed to the point at which a handle is required. Default behavior may change in future CUDA releases. Data loading behavior is inherited from <code class="docutils literal notranslate"><span class="pre">CUDA_MODULE_LOADING</span></code> if this environment variable is not set.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Pre-loading dependent libraries</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>CUDA_FORCE_PRELOAD_LIBRARIES</p></td>
<td><p>0 or 1 (default is 0)</p></td>
<td><p>When set to 1, forces the driver to preload the libraries required for NVVM and PTX just-in-time compilation during driver initialization. This will increase the memory footprint and the time taken for CUDA driver initialization. This environment variable needs to be set to avoid certain deadlock situations involving multiple CUDA threads.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>CUDA Graphs</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>CUDA_GRAPHS_USE_NODE_PRIORITY</p></td>
<td><p>0 or 1</p></td>
<td><p>Overrides the cudaGraphInstantiateFlagUseNodePriority flag on graph instantiation. When set to 1, the flag will be set for all graphs and when set to 0, the flag will be cleared for all graphs.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>CUDA Error Log Management</strong></p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>CUDA_LOG_FILE</p></td>
<td><p>stdout, stderr, or valid file path</p></td>
<td><p>Provides a location for printing error logs as they occur. See the <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">Log</span> <span class="pre">Management</span></code> section for more details.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="error-log-management">
<span id="id444"></span><h1><span class="section-number">20. </span>Error Log Management<a class="headerlink" href="#error-log-management" title="Permalink to this headline">ï</a></h1>
<p>The <em>Error Log Management</em> mechanism allows for CUDA API errors to be reported
to developers in a plain-English format that describes the cause of the issue.</p>
<section id="id445">
<h2><span class="section-number">20.1. </span>Background<a class="headerlink" href="#id445" title="Permalink to this headline">ï</a></h2>
<p>Traditionally, the only indication of a failed CUDA API call is the return of a non-zero code.
As of CUDA Toolkit 12.9, the CUDA Runtime defines over 100 different return codes
for error conditions, but many of them are generic and give the developer no assistance with debugging the cause.</p>
</section>
<section id="activation">
<h2><span class="section-number">20.2. </span>Activation<a class="headerlink" href="#activation" title="Permalink to this headline">ï</a></h2>
<p>Set the <em>CUDA_LOG_FILE</em> environment variable. Acceptable values are <em>stdout</em>, <em>stderr</em>, or a valid path on the system to write a file.
The log buffer can be dumped via API even if <em>CUDA_LOG_FILE</em> was not set before program execution.
NOTE: An error-free execution may not print any logs.</p>
</section>
<section id="output">
<h2><span class="section-number">20.3. </span>Output<a class="headerlink" href="#output" title="Permalink to this headline">ï</a></h2>
<p>Logs are output in the following format:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Time</span><span class="p">][</span><span class="n">TID</span><span class="p">][</span><span class="n">Source</span><span class="p">][</span><span class="n">Severity</span><span class="p">][</span><span class="n">API</span><span class="w"> </span><span class="n">Entry</span><span class="w"> </span><span class="n">Point</span><span class="p">]</span><span class="w"> </span><span class="n">Message</span><span class="w"></span>
</pre></div>
</div>
<p>The following line is an actual error message that is generated if the developer tries to dump the Error Log Management logs to an unallocated buffer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">22</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">32.099</span><span class="p">][</span><span class="mi">25642</span><span class="p">][</span><span class="n">CUDA</span><span class="p">][</span><span class="n">E</span><span class="p">][</span><span class="n">cuLogsDumpToMemory</span><span class="p">]</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="nb">NULL</span><span class="w"></span>
</pre></div>
</div>
<p>Where before, all the developer would have gotten is <em>CUDA_ERROR_INVALID_VALUE</em> in the return code and possibly âinvalid argumentâ if <em>cuGetErrorString</em> is called.</p>
</section>
<section id="id446">
<h2><span class="section-number">20.4. </span>API Description<a class="headerlink" href="#id446" title="Permalink to this headline">ï</a></h2>
<p>The CUDA Driver provides APIs in two categories for interacting with the Error Log Management feature.</p>
<p>This feature allows developers to register callback functions to be used whenever an error log is generated, where the callback signature is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">callbackFunc</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">CUlogLevel</span><span class="w"> </span><span class="n">logLevel</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Callbacks are registered with this API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUresult</span><span class="w"> </span><span class="n">cuLogsRegisterCallback</span><span class="p">(</span><span class="n">CUlogsCallback</span><span class="w"> </span><span class="n">callbackFunc</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">userData</span><span class="p">,</span><span class="w"> </span><span class="n">CUlogsCallbackHandle</span><span class="w"> </span><span class="o">*</span><span class="n">callback_out</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Where <em>userData</em> is passed to the callback function without modifications. <em>callback_out</em> should be stored by the caller for use in <em>cuLogsUnregisterCallback</em>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUresult</span><span class="w"> </span><span class="n">cuLogsUnregisterCallback</span><span class="p">(</span><span class="n">CUlogsCallbackHandle</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The other set of API functions are for managing the output of logs. An important concept is the log iterator, which points to the current end of the buffer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUresult</span><span class="w"> </span><span class="n">cuLogsCurrent</span><span class="p">(</span><span class="n">CUlogIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iterator_out</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>The iterator position can be kept by the calling software in situations where a dump of the entire log buffer is not desired. Currently, the flags parameter must be 0, with additional options reserved for future CUDA releases.</p>
<p>At any time, the error log buffer can be dumped to either a file or memory with these functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUresult</span><span class="w"> </span><span class="n">cuLogsDumpToFile</span><span class="p">(</span><span class="n">CUlogIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iterator</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pathToFile</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"></span>
<span class="n">CUresult</span><span class="w"> </span><span class="n">cuLogsDumpToMemory</span><span class="p">(</span><span class="n">CUlogIterator</span><span class="w"> </span><span class="o">*</span><span class="n">iterator</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>If <em>iterator</em> is NULL, the entire buffer will be dumped, up to the maximum of 100 entries. If <em>iterator</em> is not NULL, logs will be dumped starting from that entry and the value of <em>iterator</em> will be updated to the current end of the logs, as if <em>cuLogsCurrent</em> had been called. If there have been more than 100 log entries into the buffer, a note will be added at the start of the dump noting this.</p>
<p>The flags parameter must be 0, with additional options reserved for future CUDA releases.</p>
<p>The <em>cuLogsDumpToMemory</em> function has additional considerations:</p>
<ol class="arabic simple">
<li><p>The buffer itself will be null-terminated, but each individual log entry will only be separated by a newline (n) character.</p></li>
<li><p>The maximum size of the buffer is 25600 bytes.</p></li>
<li><p>If the value provided in <em>size</em> is not sufficient to store all desired logs, a note will be added as the first entry and the oldest entries that do not fit will not be dumped.</p></li>
<li><p>After returning, <em>size</em> will contain the actual number of bytes written to the provided buffer.</p></li>
</ol>
</section>
<section id="limitations-and-known-issues">
<h2><span class="section-number">20.5. </span>Limitations and Known Issues<a class="headerlink" href="#limitations-and-known-issues" title="Permalink to this headline">ï</a></h2>
<ol class="arabic simple">
<li><p>The log buffer is limited to 100 entries. After this limit is reached, the oldest entries will be replaced and log dumps will contain a line noting the rollover.</p></li>
<li><p>Not all CUDA APIs are covered yet. This is an ongoing project to provide better usage error reporting for all APIs.</p></li>
<li><p>The Error Log Management log location (if given) will not be tested for validity until/unless a log is generated.</p></li>
<li><p>The Error Log Management APIs are currently only available via the CUDA Driver. Equivalent APIs will be added to the CUDA Runtime in a future release.</p></li>
<li><p>The log messages are not localized to any language and all provided logs are in US English.</p></li>
</ol>
</section>
</section>
<section id="unified-memory-programming">
<span id="um-unified-memory-programming-hd"></span><h1><span class="section-number">21. </span>Unified Memory Programming<a class="headerlink" href="#unified-memory-programming" title="Permalink to this headline">ï</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This chapter applies to devices with compute capability 5.0 or higher unless stated otherwise.
For devices with compute capability lower than 5.0, refer to the CUDA toolkit documentation for CUDA 11.8.</p>
</div>
<p>This documentation on Unified Memory is divided into 3 parts:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#um-introduction"><span class="std std-ref">General description of unified memory</span></a></p></li>
<li><p><a class="reference internal" href="#um-pageable-systems"><span class="std std-ref">Unified Memory on devices with full CUDA Unified Memory support</span></a></p></li>
<li><p><a class="reference internal" href="#um-no-pageable-systems"><span class="std std-ref">Unified Memory on devices without full CUDA Unified Memory support</span></a></p></li>
</ul>
<span class="target" id="um-coherency-new"><span id="um-multi-gpu"></span><span id="um-data-migration"></span></span><section id="unified-memory-introduction">
<span id="um-introduction"></span><h2><span class="section-number">21.1. </span>Unified Memory Introduction<a class="headerlink" href="#unified-memory-introduction" title="Permalink to this headline">ï</a></h2>
<p>CUDA Unified Memory provides all processors with:</p>
<ul class="simple">
<li><p>A single <em>unified</em> memory pool, that is,
a single pointer value enables all processors in the system
(all CPUs, all GPUs, etc.)
to access this memory with all of their native memory operations
(pointer dereferences, atomics, etc.).</p></li>
<li><p>Concurrent access to the unified memory pool from all processors in the system.</p></li>
</ul>
<p>Unified Memory improves GPU programming in several ways:</p>
<ul class="simple">
<li><p><strong>Productivity</strong>: GPU programs may access Unified Memory from GPU and CPU threads
concurrently without needing to create separate allocations (<code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>) and
copy memory manually back and forth (<code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code>).</p></li>
<li><p><strong>Performance</strong>:</p>
<ul>
<li><p>Data access speed may be maximized by migrating data towards processors that access it most frequently.
Applications can trigger manual migration of data and may use hints to control migration heuristics.</p></li>
<li><p>Total system memory usage may be reduced by avoiding duplicating memory on both CPUs and GPUs.</p></li>
</ul>
</li>
<li><p><strong>Functionality</strong>: It enables GPU programs to work on data that exceeds the GPU memoryâs capacity.</p></li>
</ul>
<p>With CUDA Unified Memory, data movement still takes place, and hints may improve performance.
These hints are not required for correctness or functionality, that is, programmers may focus on parallelizing
their applications across GPUs and CPUs first, and worry about data-movement later in the development cycle as a performance optimization.
Note that the physical location of data is invisible to a program and may be changed at any time,
but accesses to the dataâs virtual address will remain valid and coherent from any processor regardless of locality.</p>
<p>There are two main ways to obtain CUDA Unified Memory:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#um-implicit-allocation"><span class="std std-ref">System-Allocated Memory</span></a>: memory allocated on the host with system APIs:
stack variables, global-/file-scope variables, <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> / <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>
(see <a class="reference internal" href="#um-system-allocator"><span class="std std-ref">System-Allocated Memory: in-depth examples</span></a> for in-depth examples), thread locals, etc.</p></li>
<li><p><a class="reference internal" href="#um-explicit-allocation"><span class="std std-ref">CUDA APIs that explicitly allocate Unified Memory</span></a>: memory allocated with, for example, <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>,
are available on more systems and may perform better than System-Allocated Memory.</p></li>
</ul>
<section id="system-requirements-for-unified-memory">
<span id="um-device-properties"></span><span id="um-requirements"></span><h3><span class="section-number">21.1.1. </span>System Requirements for Unified Memory<a class="headerlink" href="#system-requirements-for-unified-memory" title="Permalink to this headline">ï</a></h3>
<p>The following table shows the different levels of support for CUDA Unified Memory,
the device properties required to detect these levels of support
and links to the documentation specific to each level of support:</p>
<table class="docutils align-default" id="table-unified-memory-levels">
<caption><span class="caption-number">Table 32 </span><span class="caption-text">Overview of levels of unified memory support</span><a class="headerlink" href="#table-unified-memory-levels" title="Permalink to this table">ï</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Unified Memory Support Level</p></th>
<th class="head"><p>System device properties</p></th>
<th class="head"><p>Further documentation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Full CUDA Unified Memory: all memory has full support. This includes System-Allocated and CUDA Managed Memory.</p></td>
<td><div class="line-block">
<div class="line">Set to 1: <code class="docutils literal notranslate"><span class="pre">pageableMemoryAccess</span></code></div>
<div class="line"><a class="reference internal" href="#um-system-allocator"><span class="std std-ref">Systems with hardware acceleration</span></a> also have the following properties set to 1:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">hostNativeAtomicSupported</span></code>, <code class="docutils literal notranslate"><span class="pre">pageableMemoryAccessUsesHostPageTables</span></code>, <code class="docutils literal notranslate"><span class="pre">directManagedMemAccessFromHost</span></code></div>
</div>
</td>
<td><p><a class="reference internal" href="#um-pageable-systems"><span class="std std-ref">Unified Memory on devices with full CUDA Unified Memory support</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>Only CUDA Managed Memory has full support.</p></td>
<td><div class="line-block">
<div class="line">Set to 1: <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code></div>
<div class="line">Set to 0: <code class="docutils literal notranslate"><span class="pre">pageableMemoryAccess</span></code></div>
</div>
</td>
<td><p><a class="reference internal" href="#um-cc60"><span class="std std-ref">Unified Memory on devices with only CUDA Managed Memory support</span></a></p></td>
</tr>
<tr class="row-even"><td><p>CUDA Managed Memory without full support: unified addressing but no concurrent access.</p></td>
<td><div class="line-block">
<div class="line">Set to 1: <code class="docutils literal notranslate"><span class="pre">managedMemory</span></code></div>
<div class="line">Set to 0: <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><a class="reference internal" href="#um-legacy-devices"><span class="std std-ref">Unified Memory on Windows or devices with compute capability 5.x</span></a></div>
<div class="line"><a class="reference external" href="https://docs.nvidia.com/cuda/cuda-for-tegra-appnote/index.html#memory-management">CUDA for Tegra Memory Management</a></div>
<div class="line"><a class="reference external" href="https://docs.nvidia.com/cuda/cuda-for-tegra-appnote/index.html#effective-usage-of-unified-memory-on-tegra">Unified Memory on Tegra</a></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>No Unified Memory support.</p></td>
<td><p>Set to 0: <code class="docutils literal notranslate"><span class="pre">managedMemory</span></code></p></td>
<td><p><a class="reference external" href="https://docs.nvidia.com/cuda/cuda-for-tegra-appnote/index.html#memory-management">CUDA for Tegra Memory Management</a></p></td>
</tr>
</tbody>
</table>
<p>The behavior of an application that attempts to use Unified Memory on a system that does not support it is undefined.
The following properties enable CUDA applications to check the level of system support for Unified Memory, and
to be portable between systems with different levels of support:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pageableMemoryAccess</span></code>: This property is set to 1 on systems with CUDA Unified Memory support where
all threads may access System-Allocated Memory and CUDA Managed Memory.
These systems include NVIDIA Grace Hopper, IBM Power9 + Volta, and modern Linux systems with HMM enabled (see next bullet), among others.</p>
<ul>
<li><p>Linux HMM requires Linux kernel version 6.1.24+, 6.2.11+ or 6.3+,
devices with compute capability 7.5 or higher and
a CUDA driver version 535+ installed with
<a class="reference external" href="http://download.nvidia.com/XFree86/Linux-x86_64/515.43.04/README/kernel_open.html">Open Kernel Modules</a>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code>: This property is set to 1 on systems with full CUDA Managed Memory support.
When this property is set to 0, there is only partial support for Unified Memory in CUDA Managed Memory.
For Tegra support of Unified Memory, see
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-for-tegra-appnote/index.html#memory-management">CUDA for Tegra Memory Management</a>.</p></li>
</ul>
<p>A program may query the level of GPU support for CUDA Unified Memory, by querying the attributes in
Table <a class="reference internal" href="#table-unified-memory-levels"><span class="std std-ref">Overview of levels of unified memory support</span></a> above using  <code class="docutils literal notranslate"><span class="pre">cudaGetDeviceProperties()</span></code>.</p>
</section>
<section id="um-opt-in">
<span id="um-querying-um-hd"></span><span id="um-simplifying"></span><span id="um-programming-model"></span><span id="id447"></span><h3><span class="section-number">21.1.2. </span>Programming Model<a class="headerlink" href="#um-opt-in" title="Permalink to this headline">ï</a></h3>
<p>With CUDA Unified Memory, separate allocations between host and device, and explicit memory transfers between them, are no longer required.
Programs may allocate Unified Memory in the following ways:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#um-implicit-allocation"><span class="std std-ref">System-Allocation APIs</span></a>: on <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a> via
any system allocation of the host process (Câs <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, C++âs <code class="docutils literal notranslate"><span class="pre">new</span></code> operator, POSIXâs <code class="docutils literal notranslate"><span class="pre">mmap</span></code> and so on).</p></li>
<li><p><a class="reference internal" href="#um-explicit-allocation"><span class="std std-ref">CUDA Managed Memory Allocation APIs</span></a>: via the <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> API which is syntactically similar to <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>.</p></li>
<li><p><a class="reference internal" href="#um-language-integration"><span class="std std-ref">CUDA Managed Variables</span></a>: variables declared with <code class="docutils literal notranslate"><span class="pre">__managed__</span></code>, which are semantically similar to a <code class="docutils literal notranslate"><span class="pre">__device__</span></code> variable.</p></li>
</ul>
<p>Most examples in this chapter provide at least two versions, one using CUDA Managed Memory and one using System-Allocated Memory.
Tabs allow you to choose between them. The following samples illustrate how Unified Memory simplifies CUDA programs:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="8acf29db-a1fd-4912-9247-fd8b4ff29558" name="097530e8-b881-4c4e-ba02-9e6012db0c77" type="radio">
</input><label class="sd-tab-label" for="8acf29db-a1fd-4912-9247-fd8b4ff29558">
System (<code class="docutils literal notranslate"><span class="pre">malloc()</span></code>)</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-basic-sam">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Does not require any unified memory support</span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">h_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Copy memory back to the host and synchronize</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h_value</span><span class="p">,</span><span class="w"> </span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaMemcpyDefault</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">h_value</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Requires System-Allocated Memory support</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<input id="4fdff301-88ce-4f5d-8f6b-1d667d681be1" name="097530e8-b881-4c4e-ba02-9e6012db0c77" type="radio">
</input><label class="sd-tab-label" for="4fdff301-88ce-4f5d-8f6b-1d667d681be1">
System (Stack)</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-basic-system-stack">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Does not require any unified memory support</span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">h_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Copy memory back to the host and synchronize</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h_value</span><span class="p">,</span><span class="w"> </span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaMemcpyDefault</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">h_value</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Requires System-Allocated Memory support</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<input id="16461374-2850-4a11-afad-840fc79a0b14" name="097530e8-b881-4c4e-ba02-9e6012db0c77" type="radio">
</input><label class="sd-tab-label" for="16461374-2850-4a11-afad-840fc79a0b14">
Managed (<code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>)</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-basic-managed">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Does not require any unified memory support</span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">h_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Copy memory back to the host and synchronize</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h_value</span><span class="p">,</span><span class="w"> </span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaMemcpyDefault</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">h_value</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Requires CUDA Managed Memory support</span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<input id="9df13c60-9483-4348-aa41-1338d3bc0974" name="097530e8-b881-4c4e-ba02-9e6012db0c77" type="radio">
</input><label class="sd-tab-label" for="9df13c60-9483-4348-aa41-1338d3bc0974">
Managed (<code class="docutils literal notranslate"><span class="pre">__managed__</span></code>)</label><div class="sd-tab-content docutils">
<table class="docutils align-default" id="table-basic-managed-var">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">d_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Does not require any unified memory support</span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">h_value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Copy memory back to the host and synchronize</span>
<span class="w">  </span><span class="n">cudaMemcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h_value</span><span class="p">,</span><span class="w"> </span><span class="n">d_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"></span>
<span class="w">             </span><span class="n">cudaMemcpyDefault</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">h_value</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">d_ptr</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
<td><div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Requires CUDA Managed Memory support</span>
<span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>In the example above, the device writes a value which is then read by the host:</p>
<ul class="simple">
<li><p><strong>Without Unified Memory</strong>: both host- and device-side storage for the written value is required (<code class="docutils literal notranslate"><span class="pre">h_value</span></code> and <code class="docutils literal notranslate"><span class="pre">d_ptr</span></code> in the example),
as is an explicit copy between the two using <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code>.</p></li>
<li><p><strong>With Unified Memory</strong>: device accesses data directly from the host. <code class="docutils literal notranslate"><span class="pre">ptr</span></code> / <code class="docutils literal notranslate"><span class="pre">value</span></code> may be used without a separate <code class="docutils literal notranslate"><span class="pre">h_value</span></code> / <code class="docutils literal notranslate"><span class="pre">d_ptr</span></code>
allocation and no copy routine is required, greatly simplifying and reducing the size of the program. With:</p>
<ul>
<li><p><strong>System Allocated</strong>: no other changes required.</p></li>
<li><p><strong>Managed Memory</strong>: data allocation changed to use <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>, which returns a pointer valid from both host and device code.</p></li>
</ul>
</li>
</ul>
<section id="allocation-apis-for-system-allocated-memory">
<span id="um-implicit-allocation"></span><h4><span class="section-number">21.1.2.1. </span>Allocation APIs for System-Allocated Memory<a class="headerlink" href="#allocation-apis-for-system-allocated-memory" title="Permalink to this headline">ï</a></h4>
<p>On <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a>, all memory is unified memory.
This includes memory allocated with system allocation APIs, such as <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>, C++ <code class="docutils literal notranslate"><span class="pre">new()</span></code> operator,
and also automatic variables on CPU thread stacks, thread locals, global variables, and so on.</p>
<p>System-Allocated Memory may be populated on first touch, depending on the API and system settings used.
First touch means that:</p>
<ul class="simple">
<li><p>The allocation APIs allocate virtual memory and return immediately, and</p></li>
<li><p>physical memory is populated when a thread accesses the memory for the first time.</p></li>
</ul>
<p>Usually, the physical memory will be chosen âcloseâ to the processor that thread is running on. For example,</p>
<ul class="simple">
<li><p>GPU thread accesses it first: physical GPU memory of GPU that thread runs on is chosen.</p></li>
<li><p>CPU thread accesses it first: physical CPU memory in the memory NUMA node of the CPU core that thread runs on is chosen.</p></li>
</ul>
<p>CUDA Unified Memory Hint and Prefetch APIs,  <code class="docutils literal notranslate"><span class="pre">cudaMemAdvise</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemPreftchAsync</span></code>, may be used on System-Allocated Memory.
These APIs are covered below in the <a class="reference internal" href="#um-tuning-usage"><span class="std std-ref">Data Usage Hints</span></a> section.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">printme</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Allocate 100 bytes of memory, accessible to both Host and Device code</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Physical allocation placed in CPU memory because host accesses &quot;s&quot; first</span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello Unified Memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">99</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Here we pass &quot;s&quot; to a kernel without explicitly copying</span>
<span class="w">  </span><span class="n">printme</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Free as for normal CUDA allocations</span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocation-api-for-cuda-managed-memory-cudamallocmanaged">
<span id="um-explicit-allocation"></span><h4><span class="section-number">21.1.2.2. </span>Allocation API for CUDA Managed Memory: <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code><a class="headerlink" href="#allocation-api-for-cuda-managed-memory-cudamallocmanaged" title="Permalink to this headline">ï</a></h4>
<p>On systems with CUDA Managed Memory support, unified memory may be allocated using:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__host__</span><span class="w"> </span><span class="n">cudaError_t</span><span class="w"> </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">devPtr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This API is syntactically identical to <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>: it allocates <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of managed memory and
sets <code class="docutils literal notranslate"><span class="pre">devPtr</span></code> to refer to the allocation.
CUDA Managed Memory is also deallocated with <code class="docutils literal notranslate"><span class="pre">cudaFree()</span></code>.</p>
<p>On <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Managed Memory support</span></a>, managed memory allocations
may be accessed concurrently by all CPUs and GPUs in the system.
Replacing host calls to <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code> with <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> does not impact program semantics on these systems;
device code is not able to call <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>.</p>
<p>The following example shows the use of <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>:</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">printme</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Allocate 100 bytes of memory, accessible to both Host and Device code</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Note direct Host-code use of &quot;s&quot;</span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello Unified Memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">99</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Here we pass &quot;s&quot; to a kernel without explicitly copying</span>
<span class="w">  </span><span class="n">printme</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Free as for normal CUDA allocations</span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For systems that support CUDA Managed Memory allocations, but do not provide full support,
see <a class="reference internal" href="#um-coherency-hd"><span class="std std-ref">Coherency and Concurrency</span></a>.
Implementation details (may change any time):</p>
<ul class="simple">
<li><p>Devices of compute capability 5.x allocate CUDA Managed Memory on the GPU.</p></li>
<li><p>Devices of compute capability 6.x and greater populate the memory on first touch, just like System-Allocated Memory APIs.</p></li>
</ul>
</div>
</section>
<section id="global-scope-managed-variables-using-managed">
<span id="um-language-integration"></span><span id="um-global-scope"></span><h4><span class="section-number">21.1.2.3. </span>Global-Scope Managed Variables Using <code class="docutils literal notranslate"><span class="pre">__managed__</span></code><a class="headerlink" href="#global-scope-managed-variables-using-managed" title="Permalink to this headline">ï</a></h4>
<p>CUDA <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variables behave as if they were allocated via <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code>
(see <a class="reference internal" href="#um-explicit-allocation"><span class="std std-ref">Allocation API for CUDA Managed Memory: cudaMallocManaged()</span></a>).
They simplify programs with global variables, making it particularly easy to exchange data between host and device
without manual allocations or copying.</p>
<p>On <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a>,
file-scope or global-scope variables cannot be directly accessed by device code.
But a pointer to these variables may be passed to the kernel as an argument,
see <a class="reference internal" href="#um-system-allocator"><span class="std std-ref">System-Allocated Memory: in-depth examples</span></a> for examples.</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="6cae463e-9d12-493f-acff-f38a295d88eb" name="4318054a-e47b-44b8-8ea6-aa5e5242a262" type="radio">
</input><label class="sd-tab-label" for="6cae463e-9d12-493f-acff-f38a295d88eb">
System Allocator</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Requires System-Allocated Memory support</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="25196843-7290-4683-82bd-a6ce02e2f04b" name="4318054a-e47b-44b8-8ea6-aa5e5242a262" type="radio">
</input><label class="sd-tab-label" for="25196843-7290-4683-82bd-a6ce02e2f04b">
Managed</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write_value</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Requires CUDA Managed Memory support</span>
<span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">write_value</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Synchronize required</span>
<span class="w">  </span><span class="c1">// (before, cudaMemcpy was synchronizing)</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>Note the absence of explicit <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code> commands and the fact that the written value <code class="docutils literal notranslate"><span class="pre">value</span></code> is visible on both CPU and GPU.</p>
<p>CUDA <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variable implies <code class="docutils literal notranslate"><span class="pre">__device__</span></code> and is equivalent to <code class="docutils literal notranslate"><span class="pre">__managed__</span> <span class="pre">__device__</span></code>, which is also allowed.
Variables marked <code class="docutils literal notranslate"><span class="pre">__constant__</span></code> may not be marked as <code class="docutils literal notranslate"><span class="pre">__managed__</span></code>.</p>
<p>A valid CUDA context is necessary for the correct operation of <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variables.
Accessing <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variables can trigger CUDA context creation if a context for the current device hasnât already been created.
In the example above, accessing <code class="docutils literal notranslate"><span class="pre">value</span></code> before the kernel launch triggers context creation on the default device.
In the absence of that access, the kernel launch would have triggered context creation.</p>
<p>C++ objects declared as <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> are subject to certain specific constraints, particularly where static initializers are concerned.
Please refer to <a class="reference internal" href="#c-cplusplus-language-support"><span class="std std-ref">C++ Language Support</span></a> for a list of these constraints.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For <a class="reference internal" href="#um-requirements"><span class="std std-ref">devices with CUDA Managed Memory without full support</span></a>,
visibility of <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variables for asynchronous operations executing in CUDA streams
is discussed in the section on
<a class="reference internal" href="#um-managing-data"><span class="std std-ref">Managing Data Visibility and Concurrent CPU + GPU Access with Streams</span></a>.</p>
</div>
</section>
<section id="difference-between-unified-memory-and-mapped-memory">
<span id="um-difference-with-mapped-memory"></span><h4><span class="section-number">21.1.2.4. </span>Difference between Unified Memory and Mapped Memory<a class="headerlink" href="#difference-between-unified-memory-and-mapped-memory" title="Permalink to this headline">ï</a></h4>
<p>The main difference between Unified Memory and <a class="reference internal" href="#mapped-memory"><span class="std std-ref">Mapped Memory</span></a> is that
CUDA Mapped Memory does not guarantee that all kinds of memory accesses (for example atomics) are supported on all systems,
while Unified Memory does. The limited set of memory operations that are guaranteed to be portably supported by CUDA Mapped Memory
is available on more systems than Unified Memory.</p>
</section>
<section id="um-pointer-attributes">
<span id="id448"></span><h4><span class="section-number">21.1.2.5. </span>Pointer Attributes<a class="headerlink" href="#um-pointer-attributes" title="Permalink to this headline">ï</a></h4>
<p>CUDA Programs may check whether a pointer addresses a CUDA Managed Memory allocation by calling <code class="docutils literal notranslate"><span class="pre">cudaPointerGetAttributes()</span></code> and
testing whether the pointer attribute <code class="docutils literal notranslate"><span class="pre">value</span></code> is <code class="docutils literal notranslate"><span class="pre">cudaMemoryTypeManaged</span></code>.</p>
<p>This API returns <code class="docutils literal notranslate"><span class="pre">cudaMemoryTypeHost</span></code> for System-Allocated Memory that has been registered with <code class="docutils literal notranslate"><span class="pre">cudaHostRegister()</span></code>
and <code class="docutils literal notranslate"><span class="pre">cudaMemoryTypeUnregistered</span></code> for System-Allocated Memory that CUDA is unaware of.</p>
<p>Pointer attributes do not state where the memory resides, they state how the memory was allocated or registered.</p>
<p>The following example shows how to detect the type of pointer at runtime:</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="o">*</span><span class="w"> </span><span class="n">kind</span><span class="p">(</span><span class="n">cudaPointerAttributes</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pma</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">cma</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">cudaMemoryTypeHost</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">pma</span><span class="o">?</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Unified: CUDA Host or Registered Memory&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Not Unified: CUDA Host or Registered Memory&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">cudaMemoryTypeDevice</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Not Unified: CUDA Device Memory&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">cudaMemoryTypeManaged</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cma</span><span class="o">?</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Unified: CUDA Managed Memory&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Not Unified: CUDA Managed Memory&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">cudaMemoryTypeUnregistered</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">pma</span><span class="o">?</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Unified: System-Allocated Memory&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"></span>
<span class="w">      </span><span class="s">&quot;Not Unified: System-Allocated Memory&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;unknown&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">check_pointer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaPointerAttributes</span><span class="w"> </span><span class="n">attr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaPointerGetAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaGetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pma</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrPageableMemoryAccess</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrConcurrentManagedAccess</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Pointer %d: memory is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">kind</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">pma</span><span class="p">,</span><span class="w"> </span><span class="n">cma</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">managed_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocHost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">ptr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">managed_var</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">check_pointer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFreeHost</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="runtime-detection-of-unified-memory-support-level">
<span id="um-portability"></span><h4><span class="section-number">21.1.2.6. </span>Runtime detection of Unified Memory Support Level<a class="headerlink" href="#runtime-detection-of-unified-memory-support-level" title="Permalink to this headline">ï</a></h4>
<p>The following example shows how to detect the Unified Memory support level at runtime:</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaGetDevice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pma</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrPageableMemoryAccess</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Full Unified Memory Support: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">?</span><span class="w"> </span><span class="s">&quot;YES&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;NO&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">cma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma</span><span class="p">,</span><span class="w"> </span><span class="n">cudaDevAttrConcurrentManagedAccess</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;CUDA Managed Memory with full support: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cma</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="o">?</span><span class="w"> </span><span class="s">&quot;YES&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;NO&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="gpu-memory-oversubscription">
<span id="um-oversubscription"></span><h4><span class="section-number">21.1.2.7. </span>GPU Memory Oversubscription<a class="headerlink" href="#gpu-memory-oversubscription" title="Permalink to this headline">ï</a></h4>
<p>Unified Memory enables applications to <em>oversubscribe</em> the memory of any individual processor:
in other words they can allocate and share arrays larger than
the memory capacity of any individual processor in the system,
enabling among others out-of-core processing of datasets that do not fit within
a single GPU, without adding significant complexity to the programming model.</p>
</section>
<section id="performance-hints">
<span id="um-perf-hints"></span><h4><span class="section-number">21.1.2.8. </span>Performance Hints<a class="headerlink" href="#performance-hints" title="Permalink to this headline">ï</a></h4>
<p>The following sections describes the available unified memory performance hints,
which may be used on all Unified Memory, for example, CUDA Managed memory or,
on <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a>,
also all System-Allocated Memory.
These APIs are hints, that is, they do not impact the semantics of applications, only their peformance.
That is, they can be added or removed anywhere on any application without impacting its results.</p>
<p>CUDA Unified Memory may not always have all the information necessary to make
the best performance decisions related to unified memory.
These performance hints enable the application to provide CUDA with more information.</p>
<p>Note that applications should only use these hints if they improve their performance.</p>
<section id="data-prefetching">
<span id="um-tuning-prefetch"></span><h5><span class="section-number">21.1.2.8.1. </span>Data Prefetching<a class="headerlink" href="#data-prefetching" title="Permalink to this headline">ï</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaMemPrefetchAsync</span></code> API is an asynchronous stream-ordered API that may migrate data to reside closer to the specified processor.
The data may be accessed while it is being prefetched.
The migration does not begin until all prior operations in the stream have completed,
and completes before any subsequent operation in the stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaMemPrefetchAsync</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">devPtr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="kt">int</span><span class="w"> </span><span class="n">dstDevice</span><span class="p">,</span><span class="w"></span>
<span class="w">                                 </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>A memory region containing <code class="docutils literal notranslate"><span class="pre">[devPtr,</span> <span class="pre">devPtr</span> <span class="pre">+</span> <span class="pre">count)</span></code> may be migrated to
the destination device <code class="docutils literal notranslate"><span class="pre">dstDevice</span></code> - or CPU if <code class="docutils literal notranslate"><span class="pre">cudaCpuDeviceId</span></code> used -
when the prefetch task is executed in the given <code class="docutils literal notranslate"><span class="pre">stream</span></code>.</p>
<p>Consider a simple code example below:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="3abb3955-81ef-4191-8666-0f1962d568dd" name="9a25b79d-29fe-47c8-ab83-16df4455fd7d" type="radio">
</input><label class="sd-tab-label" for="3abb3955-81ef-4191-8666-0f1962d568dd">
System Allocator</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_prefetch_sam</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">init_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w">                                     </span><span class="c1">// execute on CPU</span>
<span class="w">  </span><span class="n">cudaMemPrefetchAsync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">myGpuId</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">              </span><span class="c1">// prefetch to GPU</span>
<span class="w">  </span><span class="n">mykernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TPB</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">TPB</span><span class="p">,</span><span class="w"> </span><span class="n">TPB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w">  </span><span class="c1">// execute on GPU</span>
<span class="w">  </span><span class="n">cudaMemPrefetchAsync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">cudaCpuDeviceId</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">      </span><span class="c1">// prefetch to CPU</span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">use_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="533bf52d-5c2f-4819-a335-ad2327cfe87e" name="9a25b79d-29fe-47c8-ab83-16df4455fd7d" type="radio">
</input><label class="sd-tab-label" for="533bf52d-5c2f-4819-a335-ad2327cfe87e">
Managed</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_prefetch_managed</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">init_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w">                                     </span><span class="c1">// execute on CPU</span>
<span class="w">  </span><span class="n">cudaMemPrefetchAsync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">myGpuId</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">              </span><span class="c1">// prefetch to GPU</span>
<span class="w">  </span><span class="n">mykernel</span><span class="o">&lt;&lt;&lt;</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TPB</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">TPB</span><span class="p">,</span><span class="w"> </span><span class="n">TPB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w">  </span><span class="c1">// execute on GPU</span>
<span class="w">  </span><span class="n">cudaMemPrefetchAsync</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">cudaCpuDeviceId</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">      </span><span class="c1">// prefetch to CPU</span>
<span class="w">  </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">use_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="data-usage-hints">
<span id="um-tuning-usage"></span><h5><span class="section-number">21.1.2.8.2. </span>Data Usage Hints<a class="headerlink" href="#data-usage-hints" title="Permalink to this headline">ï</a></h5>
<p>When multiple processors simultaneously access the same data,
<code class="docutils literal notranslate"><span class="pre">cudaMemAdvise</span></code> may be used to hint how the data at
<code class="docutils literal notranslate"><span class="pre">[devPtr,</span> <span class="pre">devPtr</span> <span class="pre">+</span> <span class="pre">count)</span></code> will be accessed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaMemAdvise</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">devPtr</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaMemoryAdvise</span><span class="w"> </span><span class="n">advice</span><span class="p">,</span><span class="w"></span>
<span class="w">                          </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">advice</span></code> may take the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetReadMostly</span></code>:
This implies that the data is mostly going to be read from and only occasionally written to.
In general, it allows trading off read bandwidth for write bandwidth on this region.
Example:</p></li>
</ul>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_advise_managed</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dataPtr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">TPB</span><span class="p">;</span><span class="w">  </span><span class="c1">// 16 KiB</span>
<span class="w">  </span><span class="c1">// Allocate memory using cudaMallocManaged</span>
<span class="w">  </span><span class="c1">// (malloc may be used on systems with full CUDA Unified memory support)</span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dataPtr</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Set the advice on the memory region</span>
<span class="w">  </span><span class="n">cudaMemAdvise</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemAdviseSetReadMostly</span><span class="p">,</span><span class="w"> </span><span class="n">myGpuId</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">outerLoopIter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">outerLoopIter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxOuterLoopIter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The data is written to in the outer loop on the CPU</span>
<span class="w">    </span><span class="n">init_data</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The data is made available to all GPUs by prefetching.</span>
<span class="w">    </span><span class="c1">// Prefetching here causes read duplication of data instead</span>
<span class="w">    </span><span class="c1">// of data migration</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxDevices</span><span class="p">;</span><span class="w"> </span><span class="n">device</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">cudaMemPrefetchAsync</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// The kernel only reads this data in the inner loop</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">innerLoopIter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">innerLoopIter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">maxInnerLoopIter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">mykernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">TPB</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="o">&gt;&gt;&gt;</span><span class="p">((</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">dataPtr</span><span class="p">,</span><span class="w"> </span><span class="n">dataSize</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">innerLoopIter</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">outerLoopIter</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">dataPtr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetPreferredLocation</span></code>:
In general, any memory may be migrated at any time to any location, for example,
when a given processor is running out of physical memory.
This hint tells the system that migrating this memory region away from
its preferred location is undesired, by setting the preferred location for
the data to be the physical memory belonging to device.
Passing in a value of <code class="docutils literal notranslate"><span class="pre">cudaCpuDeviceId</span></code> for device sets the preferred location as CPU memory.
Other hints, like <code class="docutils literal notranslate"><span class="pre">cudaMemPrefetchAsync</span></code>, may override this hint,
leading the memory to be migrated away from its preferred location.</p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetAccessedBy</span></code>:
In some systems, it may be beneficial for performance to establish a
mapping into memory before accessing the data from a given processor.
This hint tells the system that the data will be frequently accessed by <code class="docutils literal notranslate"><span class="pre">device</span></code>,
enabling the system to assume that creating these mappings pays off.
This hint does not imply where the data should reside,
but it can be combined with <code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetPreferredLocation</span></code> to specify that.</p></li>
</ul>
<p>Each advice can be also unset by using one of the following values:
<code class="docutils literal notranslate"><span class="pre">cudaMemAdviseUnsetReadMostly</span></code>, <code class="docutils literal notranslate"><span class="pre">cudaMemAdviseUnsetPreferredLocation</span></code> and
<code class="docutils literal notranslate"><span class="pre">cudaMemAdviseUnsetAccessedBy</span></code>.</p>
</section>
<section id="querying-data-usage-attributes-on-managed-memory">
<span id="um-querying-usage"></span><h5><span class="section-number">21.1.2.8.3. </span>Querying Data Usage Attributes on Managed Memory<a class="headerlink" href="#querying-data-usage-attributes-on-managed-memory" title="Permalink to this headline">ï</a></h5>
<p>A program can query memory range attributes assigned through <code class="docutils literal notranslate"><span class="pre">cudaMemAdvise</span></code>
or <code class="docutils literal notranslate"><span class="pre">cudaMemPrefetchAsync</span></code> on CUDA Managed Memory by using the following API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMemRangeGetAttribute</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">dataSize</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">enum</span><span class="w"> </span><span class="nc">cudaMemRangeAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">devPtr</span><span class="p">,</span><span class="w"></span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>This function queries an attribute of the memory range starting at <code class="docutils literal notranslate"><span class="pre">devPtr</span></code> with a size of <code class="docutils literal notranslate"><span class="pre">count</span></code> bytes.
The memory range must refer to managed memory allocated via <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged</span></code> or
declared via <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variables. It is possible to query the following attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemRangeAttributeReadMostly</span></code>:
the result returned will be 1 if the entire memory range has the <code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetReadMostly</span></code> attribute set, or 0 otherwise.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemRangeAttributePreferredLocation</span></code>:
the result returned will be a GPU device id or <code class="docutils literal notranslate"><span class="pre">cudaCpuDeviceId</span></code> if the entire
memory range has the corresponding processor as preferred location,
otherwise <code class="docutils literal notranslate"><span class="pre">cudaInvalidDeviceId</span></code> will be returned.
An application can use this query API to make decision about staging data through
CPU or GPU depending on the preferred location attribute of the managed pointer.
Note that the actual location of the memory range at the time
of the query may be different from the preferred location.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemRangeAttributeAccessedBy</span></code>:
will return the list of devices that have that advise set for that memory range.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cudaMemRangeAttributeLastPrefetchLocation</span></code>:
will return the last location to which the memory range was prefetched
explicitly using <code class="docutils literal notranslate"><span class="pre">cudaMemPrefetchAsync</span></code>.
Note that this simply returns the last location that the application requested to prefetch the memory range to.
It gives no indication as to whether the prefetch operation to that location has completed or even begun.</p></li>
</ul>
<p>Additionally, multiple attributes can be queried by using corresponding <code class="docutils literal notranslate"><span class="pre">cudaMemRangeGetAttributes</span></code> function.</p>
</section>
</section>
</section>
</section>
<section id="unified-memory-on-devices-with-full-cuda-unified-memory-support">
<span id="um-pageable-systems"></span><h2><span class="section-number">21.2. </span>Unified memory on devices with full CUDA Unified Memory support<a class="headerlink" href="#unified-memory-on-devices-with-full-cuda-unified-memory-support" title="Permalink to this headline">ï</a></h2>
<section id="system-allocated-memory-in-depth-examples">
<span id="um-system-allocator"></span><span id="um-fork-managed-memory"></span><span id="um-advanced-topics-hd"></span><h3><span class="section-number">21.2.1. </span>System-Allocated Memory: in-depth examples<a class="headerlink" href="#system-allocated-memory-in-depth-examples" title="Permalink to this headline">ï</a></h3>
<p><a class="reference internal" href="#um-requirements"><span class="std std-ref">Systems with full CUDA Unified Memory support</span></a>
allow the device to access any memory owned by the host process interacting with the device.
This section shows a few advanced use-cases, using a kernel that simply prints
the first 8 characters of an input character array to the standard output stream:</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s - first %d characters: &#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">n_char</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_char</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The following tabs show various ways of how this kernel may be called:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="c1a8badd-fa48-4be1-9894-680abd58344a" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="c1a8badd-fa48-4be1-9894-680abd58344a">
Malloc</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_malloc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">test_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">heap_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_string</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">heap_data</span><span class="p">,</span><span class="w"> </span><span class="n">test_string</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_string</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;malloc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">heap_data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">heap_data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="5658e0b4-6fd9-41d8-b826-b4f0b907b7e5" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="5658e0b4-6fd9-41d8-b826-b4f0b907b7e5">
Managed</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_managed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">test_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_string</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">test_string</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_string</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;managed&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="e8f130d2-510f-4f3c-b5c5-5c3aba4f65fe" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="e8f130d2-510f-4f3c-b5c5-5c3aba4f65fe">
Stack variable</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_stack</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">test_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;stack&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test_string</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="760afc8b-680f-4f5b-a0ae-962b34966e66" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="760afc8b-680f-4f5b-a0ae-962b34966e66">
File-scope static variable</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_static</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">test_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;static&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test_string</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="90735b74-04de-44d5-b69e-17aea8f99020" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="90735b74-04de-44d5-b69e-17aea8f99020">
Global-scope variable</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">global_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">test_global</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;global&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">global_string</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="154a9256-525b-4897-a6bc-e9c48d892677" name="fb079056-19d3-497a-a0c8-a05e1b212960" type="radio">
</input><label class="sd-tab-label" for="154a9256-525b-4897-a6bc-e9c48d892677">
Global-scope extern variable</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="c1">// declared in separate file, see below</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ext_data</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">test_extern</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;extern&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ext_data</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/** This may be a non-CUDA file */</span><span class="w"></span>
<span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">ext_data</span><span class="p">;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">global_string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span><span class="w"> </span><span class="n">setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ext_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">global_string</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">ext_data</span><span class="p">,</span><span class="w"> </span><span class="n">global_string</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">global_string</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">destructor</span><span class="p">))</span><span class="w"> </span><span class="n">tear_down</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">ext_data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>The first three tabs above show the example as already detailed in the
<a class="reference internal" href="#um-programming-model"><span class="std std-ref">Programming Model section</span></a>.
The next three tabs show various ways a file-scope or global-scope variable can
be accessed from the device.</p>
<p>Note that for the extern variable, it could be declared and its memory
owned and managed by a third-party library, which does not interact with CUDA at all.</p>
<p>Also note that stack variables as well as file-scope and global-scope variables can
only be accessed through a pointer by the GPU. In this specific example, this is
convenient because the character array is already declared as a pointer: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>.
However, consider the following example with a global-scope integer:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// this variable is declared at global scope</span>
<span class="kt">int</span><span class="w"> </span><span class="n">global_variable</span><span class="p">;</span><span class="w"></span>

<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel_uncompilable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this causes a compilation error: global (__host__) variables must not</span>
<span class="w">  </span><span class="c1">// be accessed from __device__ / __global__ code</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">global_variable</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// On systems with pageableMemoryAccess set to 1, we can access the address</span>
<span class="c1">// of a global variable. The below kernel takes that address as an argument</span>
<span class="n">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">global_variable_addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">global_variable_addr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global_variable</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the example above, we need to ensure to pass a <em>pointer</em> to the global variable
to the kernel instead of directly accessing the global variable in the kernel.
This is because global variables without the <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> specifier are declared
as <code class="docutils literal notranslate"><span class="pre">__host__</span></code>-only by default, thus most compilers wonât allow using these
variables directly in device code as of now.</p>
<section id="file-backed-unified-memory">
<span id="um-sam-file-backed"></span><h4><span class="section-number">21.2.1.1. </span>File-backed Unified Memory<a class="headerlink" href="#file-backed-unified-memory" title="Permalink to this headline">ï</a></h4>
<p>Since <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a>
allow the device to access any memory owned by the host process,
they can directly access file-backed memory.</p>
<p>Here, we show a modified version of the initial example shown in the previous section to use
file-backed memory in order to print a string from the GPU, read directly from an input file.
In the following example, the memory is backed by a physical file, but the example
applies to memory-backed files, too, as detailed in the section on
<a class="reference internal" href="#um-sam-ipc"><span class="std std-ref">Inter-Process Communication (IPC) with Unified Memory</span></a>.</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s - first %d characters: &#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">n_char</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_char</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_file_backed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="n">INPUT_FILE_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid file handle&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">stat</span><span class="w"> </span><span class="n">file_stat</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">file_stat</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Invalid file stats&quot;</span><span class="p">);</span><span class="w"></span>
<span class="hll"><span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">file_stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_PRIVATE</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</span><span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">mapped</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot map file into memory&quot;</span><span class="p">);</span><span class="w"></span>
<span class="hll"><span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="s">&quot;file-backed&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mapped</span><span class="p">);</span><span class="w"></span>
</span><span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">cudaDeviceSynchronize</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cudaSuccess</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;CUDA failed with &#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">cudaGetLastError</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span><span class="w"> </span><span class="n">file_stat</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot unmap file&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ASSERT</span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot close file&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note that on systems without the <code class="docutils literal notranslate"><span class="pre">hostNativeAtomicSupported</span></code> property, including
<a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with Linux HMM enabled</span></a>,
atomic accesses to file-backed memory are not supported.</p>
</section>
<section id="inter-process-communication-ipc-with-unified-memory">
<span id="um-sam-ipc"></span><h4><span class="section-number">21.2.1.2. </span>Inter-Process Communication (IPC) with Unified Memory<a class="headerlink" href="#inter-process-communication-ipc-with-unified-memory" title="Permalink to this headline">ï</a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As of now, using IPC with Unified Memory can have significant performance implications.</p>
</div>
<p>Many applications prefer to manage one GPU per process, but still need to use Unified Memory,
for example for over-subscription, and access it from multiple GPUs.</p>
<p>CUDA IPC (see <a class="reference internal" href="#interprocess-communication"><span class="std std-ref">Interprocess Communication</span></a>)
does not support Managed Memory: handles to this type of memory may not be shared through
any of the mechanisms discussed in this section.
On <a class="reference internal" href="#um-requirements"><span class="std std-ref">systems with full CUDA Unified Memory support</span></a>,
System-Allocated Memory is Inter-Process Communication (IPC) capable.
Once access to System-Allocated Memory has been shared with other processes,
the same <a class="reference internal" href="#um-programming-model"><span class="std std-ref">Programming Model</span></a> applies,
similar to <a class="reference internal" href="#um-sam-file-backed"><span class="std std-ref">File-backed Unified Memory</span></a>.</p>
<p>See the following references for more information on various ways of creating
IPC-capable System-Allocated Memory under Linux:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap with MAP_SHARED</a></p></li>
<li><p><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/007904875/functions/shm_open.html">POSIX IPC APIs</a></p></li>
<li><p><a class="reference external" href="https://man7.org/linux/man-pages/man2/memfd_create.2.html">Linux memfd_create</a></p></li>
</ul>
<p>Note that it is not possible to share memory between different hosts and their devices using this technique.</p>
</section>
</section>
<section id="performance-tuning">
<span id="um-async-access"></span><span id="um-traffic-hd"></span><span id="um-hugetlb"></span><span id="um-thp"></span><span id="um-huge-pages"></span><span id="um-tlb-misses"></span><span id="um-access-counters"></span><span id="um-allocators"></span><span id="um-performance-tuning"></span><h3><span class="section-number">21.2.2. </span>Performance Tuning<a class="headerlink" href="#performance-tuning" title="Permalink to this headline">ï</a></h3>
<p>In order to achieve good performance with Unified Memory, it is important to:</p>
<ul class="simple">
<li><p>Understand how paging works on your system, and how to avoid unnecessary page faults.</p></li>
<li><p>Understand the various mechanisms allowing you to keep data local to the accessing processor.</p></li>
<li><p>Consider tuning your application for the granularity of memory transfers of your system.</p></li>
</ul>
<p>As general advice, <a class="reference internal" href="#um-perf-hints"><span class="std std-ref">Performance Hints</span></a>
might provide improved performance, but using them incorrectly might degrade performance
compared to the default behavior.
Also note that any hint has a performance cost associated with it on the host,
thus useful hints must at the very least improve performance enough to overcome this cost.</p>
<section id="memory-paging-and-page-sizes">
<span id="um-page-sizes"></span><h4><span class="section-number">21.2.2.1. </span>Memory Paging and Page Sizes<a class="headerlink" href="#memory-paging-and-page-sizes" title="Permalink to this headline">ï</a></h4>
<p>Many of the sections for unified memory performance tuning assume prior knowledge on virtual addressing,
memory pages and page sizes.
This section attempts to define all necessary terms and explain why paging matters for performance.</p>
<p>All currently supported systems for Unified Memory use a virtual address space:
this means that memory addresses used by an application represent a <em>virtual</em> location
which might be <em>mapped</em> to a physical location where the memory actually resides.</p>
<p>All currently supported processors, including both CPUs and GPUs, additionally use
memory <em>paging</em>. Because all systems use a virtual address space, there are two types
of memory pages:</p>
<ul class="simple">
<li><p>Virtual pages: this represents a fixed-size contiguous chunk of virtual memory
per process tracked by the operating system, which can be <em>mapped</em> into physical memory.
Note that the virtual page is linked to the <em>mapping</em>: for example, a single
virtual address might be mapped into physical memory using different page sizes.</p></li>
<li><p>Physical pages: this represents a fixed-size contiguous chunk of memory
the processorâs main Memory Management Unit (MMU) supports and into which
a virtual page can be mapped.</p></li>
</ul>
<p>Currently, all x86_64 CPUs use 4KiB physical pages.
Arm CPUs support multiple physical page sizes - 4KiB, 16KiB, 32KiB and 64KiB - depending on the exact CPU.
Finally, NVIDIA GPUs support multiple physical page sizes, but prefer 2MiB physical pages or larger.
Note that these sizes are subject to change in future hardware.</p>
<p>The default page size of virtual pages usually corresponds to the physical page size,
but an application may use different page sizes as long as they are supported by the
operating system and the hardware. Typically, supported virtual page sizes must be
powers of 2 and multiples of the physical page size.</p>
<p>The logical entity tracking the mapping of virtual pages into physical pages will be referred to as a <em>page table</em>,
and each mapping of a given virtual page with a given virtual size to physical pages is called a <em>page table entry (PTE)</em>.
All supported processors provide specific caches for the page table to speed up the translation of
virtual addresses to physical addresses. These caches are called <em>translation lookaside buffers (TLBs)</em>.</p>
<p>There are two important aspects for performance tuning of applications:</p>
<ul class="simple">
<li><p>the choice of virtual page size,</p></li>
<li><p>whether the system offers a combined page table used by both CPUs and GPUs,
or separate page tables for each CPU and GPU individually.</p></li>
</ul>
<section id="choosing-the-right-page-size">
<h5><span class="section-number">21.2.2.1.1. </span>Choosing the right page size<a class="headerlink" href="#choosing-the-right-page-size" title="Permalink to this headline">ï</a></h5>
<p>In general, small page sizes lead to less (virtual) memory fragmentation but more TLB misses,
whereas larger page sizes lead to more memory fragmentation but less TLB misses.
Additionally, memory migration is generally more expensive with larger page sizes compared to
smaller page sizes, because we typically migrate full memory pages. This can cause
larger latency spikes in an application using large page sizes. See also the next section
for more details on page faults.</p>
<p>One important aspect for performance tuning is that TLB misses are generally
significantly more expensive on the GPU compared to the CPU. This means that
if a GPU thread frequently accesses random locations of Unified Memory mapped
using a small enough page size, it might be significantly slower compared to
the same accesses to Unified Memory mapped using a large enough page size.
While a similar effect might occur for a CPU thread randomly accessing a large
area of memory mapped using a small page size, the slowdown is less pronounced,
meaning that the application might want to trade-off this slowdown with
having less memory fragmentation.</p>
<p>Note that in general, applications should not tune their performance to the
physical page size of a given processor, since physical page sizes are subject
to change depending on the hardware. The advice above only applies to virtual
page sizes.</p>
</section>
<section id="cpu-and-gpu-page-tables-hardware-coherency-vs-software-coherency">
<span id="um-hw-coherency"></span><h5><span class="section-number">21.2.2.1.2. </span>CPU and GPU page tables: hardware coherency vs. software coherency<a class="headerlink" href="#cpu-and-gpu-page-tables-hardware-coherency-vs-software-coherency" title="Permalink to this headline">ï</a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the remainder of the performance tuning documentation, we will refer
to systems with a combined page table for both CPUs and GPUs as <em>hardware
coherent</em> systems. Systems with separate page tables for CPUs and GPUs are
referred to as <em>software coherent</em>.</p>
</div>
<p>Hardware coherent systems such as NVIDIA Grace Hopper offer a logically combined
page table for both CPUs and GPUs.
This is important because in order to access
<a class="reference internal" href="#um-system-allocator"><span class="std std-ref">System-Allocated Memory from the GPU</span></a>,
the GPU uses whichever page table entry was created by the CPU for the requested memory.
If that page table entry uses the default CPU page size of 4KiB or 64KiB,
accesses to large virtual memory areas will cause significant TLB misses,
thus significant slowdowns.</p>
<p>See the section on <cite>configuring huge pages</cite> for examples on how to ensure
System-Allocated Memory uses large enough page sizes to avoid this type of issue.</p>
<p>On the other hand, on systems where the CPUs and GPUs each have their own logical
page table, different performance tuning aspects should be considered:
in order to <a class="reference internal" href="#um-introduction"><span class="std std-ref">guarantee coherency</span></a>, these systems
usually use <em>page faults</em> in case a processor accesses a memory address mapped
into the physical memory of a different processor. Such a page fault means that:</p>
<ul class="simple">
<li><p>it needs to be ensured that the currently owning processor (where the physical page currently resides)
cannot access this page anymore, either by deleting the page table entry or updating it.</p></li>
<li><p>it needs to be ensured that the processor requesting access can access this page,
either by creating a new page table entry or updating and existing entry, such that
it becomes valid/active.</p></li>
<li><p>the physical page backing this virtual page must be moved/migrated to the processor
requesting access: this can be an expensive operation, and the amount of work
is proportional to the page size.</p></li>
</ul>
<p>Overall, hardware coherent systems provide significant performance benefits
compared to software coherent systems in cases where frequent concurrent accesses
to the same memory page are made by both CPU and GPU threads:</p>
<ul class="simple">
<li><p>less page-faults: these systems do not need to use page-faults for emulating coherency or migrating memory,</p></li>
<li><p>less contention: these systems are coherent at cache-line granularity instead of page-size granularity, that is,
when there is contention from multiple processors within a cache line, only the cache line is exchanged which is much smaller than the smallest page-size,
and when the different processors access different cache-lines within a page, then there is no contention.</p></li>
</ul>
<p>This impacts the performance of the following scenarios:</p>
<ul class="simple">
<li><p>Atomic updates to the same address concurrently from both CPUs and GPUs.</p></li>
<li><p>Signaling a GPU thread from a CPU thread or vice-versa.</p></li>
</ul>
</section>
</section>
<section id="direct-unified-memory-access-from-host">
<span id="um-direct-from-host"></span><h4><span class="section-number">21.2.2.2. </span>Direct Unified Memory Access from host<a class="headerlink" href="#direct-unified-memory-access-from-host" title="Permalink to this headline">ï</a></h4>
<p>Some devices have hardware support for coherent reads, stores and atomic accesses
from the host on GPU-resident unified memory.
These devices have the attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrDirectManagedMemAccessFromHost</span></code> set to 1.
Note that all <a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">hardware coherent systems</span></a> have
this attribute set for NVLink-connected devices.
On these systems, the host has direct access to GPU-resident memory without page faults and
data migration (see <a class="reference internal" href="#um-tuning-usage"><span class="std std-ref">Data Usage Hints</span></a>
for more details on memory usage hints). Note that with CUDA Managed Memory,
the <code class="docutils literal notranslate"><span class="pre">cudaMemAdviseSetAccessedBy</span></code> hint with <code class="docutils literal notranslate"><span class="pre">cudaCpuDeviceId</span></code> is necessary
to enable this direct access without page faults.</p>
<p>Consider an example code below:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="a9bab897-b420-4971-997a-a7895d4de869" name="c2306fd9-edd1-43bd-8b77-8b36342da253" type="radio">
</input><label class="sd-tab-label" for="a9bab897-b420-4971-997a-a7895d4de869">
System Allocator</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="n">test_malloc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="c1">// for shared page table systems, the following hint is not necesary</span>
<span class="w">  </span><span class="n">cudaMemAdvise</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemAdviseSetAccessedBy</span><span class="p">,</span><span class="w"> </span><span class="n">cudaCpuDeviceId</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">write</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">            </span><span class="c1">// pages populated in GPU memory</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: A+B = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">        </span><span class="c1">// directManagedMemAccessFromHost=1: CPU accesses GPU memory directly without migrations</span>
<span class="w">                                                  </span><span class="c1">// directManagedMemAccessFromHost=0: CPU faults and triggers device-to-host migrations</span>
<span class="w">  </span><span class="n">append</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">            </span><span class="c1">// directManagedMemAccessFromHost=1: GPU accesses GPU memory without migrations</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w">                        </span><span class="c1">// directManagedMemAccessFromHost=0: GPU faults and triggers host-to-device migrations</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<input id="8adb1358-04de-4d95-8d2b-9ebc0bb82fa5" name="c2306fd9-edd1-43bd-8b77-8b36342da253" type="radio">
</input><label class="sd-tab-label" for="8adb1358-04de-4d95-8d2b-9ebc0bb82fa5">
Managed</label><div class="sd-tab-content docutils">
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ret</span><span class="p">[</span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">test_managed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">cudaMemAdvise</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">cudaMemAdviseSetAccessedBy</span><span class="p">,</span><span class="w"> </span><span class="n">cudaCpuDeviceId</span><span class="p">);</span><span class="w">  </span><span class="c1">// set direct access hint</span>

<span class="w">  </span><span class="n">write</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">            </span><span class="c1">// pages populated in GPU memory</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: A+B = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w">        </span><span class="c1">// directManagedMemAccessFromHost=1: CPU accesses GPU memory directly without migrations</span>
<span class="w">                                                  </span><span class="c1">// directManagedMemAccessFromHost=0: CPU faults and triggers device-to-host migrations</span>
<span class="w">  </span><span class="n">append</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">            </span><span class="c1">// directManagedMemAccessFromHost=1: GPU accesses GPU memory without migrations</span>
<span class="w">  </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w">                        </span><span class="c1">// directManagedMemAccessFromHost=0: GPU faults and triggers host-to-device migrations</span>
<span class="w">  </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
</div>
<p>After <code class="docutils literal notranslate"><span class="pre">write</span></code> kernel is completed, <code class="docutils literal notranslate"><span class="pre">ret</span></code> will be created and initialized in GPU memory.
Next, the CPU will access <code class="docutils literal notranslate"><span class="pre">ret</span></code> followed by <code class="docutils literal notranslate"><span class="pre">append</span></code> kernel using the same <code class="docutils literal notranslate"><span class="pre">ret</span></code> memory again.
This code will show different behavior depending on the system architecture and support of hardware coherency:</p>
<ul class="simple">
<li><p>On systems with <code class="docutils literal notranslate"><span class="pre">directManagedMemAccessFromHost=1</span></code>:
CPU accesses to the managed buffer will not trigger any migrations;
the data will remain resident in GPU memory and any subsequent GPU kernels
can continue to access it directly without inflicting faults or migrations.</p></li>
<li><p>On systems with <code class="docutils literal notranslate"><span class="pre">directManagedMemAccessFromHost=0</span></code>:
CPU accesses to the managed buffer will page fault and initiate data migration;
any GPU kernel trying to access the same data first time will page fault and
migrate pages back to GPU memory.</p></li>
</ul>
</section>
<section id="host-native-atomics">
<span id="um-host-native-atomics"></span><h4><span class="section-number">21.2.2.3. </span>Host Native Atomics<a class="headerlink" href="#host-native-atomics" title="Permalink to this headline">ï</a></h4>
<p>Some devices, including NVLink-connected devices in
<a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">hardware coherent systems</span></a>, support hardware-accelerated
atomic accesses to CPU-resident memory. This implies that atomic accesses to host memory
do not have to be emulated with a page fault.
For these devices, the attribute <code class="docutils literal notranslate"><span class="pre">cudaDevAttrHostNativeAtomicSupported</span></code> is set to 1.</p>
</section>
<section id="atomic-accesses-synchronization-primitives">
<span id="um-atomics"></span><h4><span class="section-number">21.2.2.4. </span>Atomic accesses &amp; synchronization primitives<a class="headerlink" href="#atomic-accesses-synchronization-primitives" title="Permalink to this headline">ï</a></h4>
<p>CUDA Unified Memory supports all atomic operations available to host and device threads,
enabling all threads to cooperate by concurrently accessing the same shared memory location.
The <a class="reference external" href="https://nvidia.github.io/cccl/libcudacxx/extended_api/synchronization_primitives.html">CUDA C++ standard library</a>
provides many heterogeneous synchronization primitives tuned for concurrent use between host and device threads,
including <code class="docutils literal notranslate"><span class="pre">cuda::atomic</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda::atomic_ref</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda::barrier</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda::semaphore</span></code>, among many others.</p>
<p>On systems without <a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">CPU and GPU page tables: hardware coherency vs. software coherency</span></a>,
atomic accesses from the device to file-backed host memory are not supported.
The following example code is valid on systems with <a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">CPU and GPU page tables: hardware coherency vs. software coherency</span></a>
but exhibits undefined behavior on other systems:</p>
<div class="highlight-cuda notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda/atomic&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp"></span>

<span class="cp">#define ERR(msg, ...) { fprintf(stderr, msg, ##__VA_ARGS__); return EXIT_FAILURE; }</span>

<span class="kr">__global__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic_ref</span><span class="p">{</span><span class="o">*</span><span class="n">ptr</span><span class="p">}.</span><span class="n">store</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this will be closed/deleted by default on exit</span>
<span class="w">  </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">tmp_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmpfile64</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="c1">// need to allcate space in the file, we do this with posix_fallocate here</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">posix_fallocate</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">tmp_file</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Failed to allocate space in temp file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_PRIVATE</span><span class="p">,</span><span class="w"> </span><span class="n">fileno</span><span class="p">(</span><span class="n">tmp_file</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span><span class="w"> </span><span class="n">ERR</span><span class="p">(</span><span class="s">&quot;Failed to map temp file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// initialize the value in our file-backed memory</span>
<span class="w">  </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Atom value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// device and host thread access ptr concurrently, using cuda::atomic_ref</span>
<span class="w">  </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cuda</span><span class="o">::</span><span class="n">atomic_ref</span><span class="p">{</span><span class="o">*</span><span class="n">ptr</span><span class="p">}.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// this will always be 2</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Atom value: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>On systems without <a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">CPU and GPU page tables: hardware coherency vs. software coherency</span></a>,
atomic accesses to unified memory may incur page faults which can lead to significant latencies.
Note that this is not the case for all GPU atomics to CPU memory on these systems:
operations listed by <code class="docutils literal notranslate"><span class="pre">nvidia-smi</span> <span class="pre">-q</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">&quot;Atomic</span> <span class="pre">Caps</span> <span class="pre">Outbound&quot;</span></code> may avoid page faults.</p>
<p>On systems with <a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">CPU and GPU page tables: hardware coherency vs. software coherency</span></a>,
atomics between host and device do not require page faults,
but may still fault for other reasons that any memory access can fault for.</p>
</section>
<section id="memcpy-memset-behavior-with-unified-memory">
<span id="um-memcpy-memset"></span><h4><span class="section-number">21.2.2.5. </span>Memcpy()/Memset() Behavior With Unified Memory<a class="headerlink" href="#memcpy-memset-behavior-with-unified-memory" title="Permalink to this headline">ï</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemset*()</span></code> accept any unified memory pointer as arguments.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code>, the direction specified as <code class="docutils literal notranslate"><span class="pre">cudaMemcpyKind</span></code> is a performance hint,
which can have a higher performance impact if any of the arguments is a unified memory pointer.</p>
<p>Thus, it is recommended to follow the following performance advice:</p>
<ul class="simple">
<li><p>When the physical location of unified memory is known, use an accurate <code class="docutils literal notranslate"><span class="pre">cudaMemcpyKind</span></code> hint.</p></li>
<li><p>Prefer <code class="docutils literal notranslate"><span class="pre">cudaMemcpyDefault</span></code> over an inaccurate <code class="docutils literal notranslate"><span class="pre">cudaMemcpyKind</span></code> hint.</p></li>
<li><p>Always use populated (initialized) buffers: avoid using these APIs to initialize memory.</p></li>
<li><p>Avoid using <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> if both pointers point to System-Allocated Memory:
launch a kernel or use a CPU memory copy algorithm such as <code class="docutils literal notranslate"><span class="pre">std::memcpy</span></code> instead.</p></li>
</ul>
</section>
</section>
</section>
<section id="unified-memory-on-devices-without-full-cuda-unified-memory-support">
<span id="um-no-pageable-systems"></span><h2><span class="section-number">21.3. </span>Unified memory on devices without full CUDA Unified Memory support<a class="headerlink" href="#unified-memory-on-devices-without-full-cuda-unified-memory-support" title="Permalink to this headline">ï</a></h2>
<section id="unified-memory-on-devices-with-only-cuda-managed-memory-support">
<span id="um-cc60"></span><h3><span class="section-number">21.3.1. </span>Unified memory on devices with only CUDA Managed Memory support<a class="headerlink" href="#unified-memory-on-devices-with-only-cuda-managed-memory-support" title="Permalink to this headline">ï</a></h3>
<p>For devices with compute capability 6.x or higher but without <a class="reference internal" href="#um-requirements"><span class="std std-ref">pageable memory access</span></a>,
CUDA Managed Memory is fully supported and coherent.
The programming model and performance tuning of unified memory is largely similar
to the model as described in
<a class="reference internal" href="#um-pageable-systems"><span class="std std-ref">Unified memory on devices with full CUDA Unified Memory support</span></a>,
with the notable exception that system allocators cannot be used to allocate memory.
Thus, the following list of sub-sections do not apply:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#um-system-allocator"><span class="std std-ref">System-Allocated Memory: in-depth examples</span></a></p></li>
<li><p><a class="reference internal" href="#um-hw-coherency"><span class="std std-ref">Hardware/Software Coherency</span></a></p></li>
</ul>
</section>
<section id="unified-memory-on-windows-or-devices-with-compute-capability-5-x">
<span id="um-legacy-devices"></span><h3><span class="section-number">21.3.2. </span>Unified memory on Windows or devices with compute capability 5.x<a class="headerlink" href="#unified-memory-on-windows-or-devices-with-compute-capability-5-x" title="Permalink to this headline">ï</a></h3>
<p>Devices with compute capability lower than 6.0 or Windows platforms support CUDA Managed Memory v1.0 with limited support for data migration and coherency as well as memory oversubscription. The following sub-sections describe in more detail how to use and optimize Managed Memory on these platforms.</p>
<section id="data-migration-and-coherency">
<span id="um-legacy-migration"></span><h4><span class="section-number">21.3.2.1. </span>Data Migration and Coherency<a class="headerlink" href="#data-migration-and-coherency" title="Permalink to this headline">ï</a></h4>
<p>GPU architectures of compute capability lower than 6.0 do not support fine-grained movement of the managed data to GPU on-demand. Whenever a GPU kernel is launched all managed memory generally has to be transferred to GPU memory to avoid faulting on memory access. With compute capability 6.x a new GPU page faulting mechanism is introduced that provides more seamless Unified Memory functionality. Combined with the system-wide virtual address space, page faulting provides several benefits. First, page faulting means that the CUDA system software doesnât need to synchronize all managed memory allocations to the GPU before each kernel launch. If a kernel running on the GPU accesses a page that is not resident in its memory, it faults, allowing the page to be automatically migrated to the GPU memory on-demand. Alternatively, the page may be mapped into the GPU address space for access over the PCIe or NVLink interconnects (mapping on access can sometimes be faster than migration). Note that Unified Memory is system-wide: GPUs (and CPUs) can fault on and migrate memory pages either from CPU memory or from the memory of other GPUs in the system.</p>
</section>
<section id="um-legacy-oversubscription">
<span id="id449"></span><h4><span class="section-number">21.3.2.2. </span>GPU Memory Oversubscription<a class="headerlink" href="#um-legacy-oversubscription" title="Permalink to this headline">ï</a></h4>
<p>Devices of compute capability lower than 6.0 cannot allocate more managed memory than the physical size of GPU memory.</p>
</section>
<section id="multi-gpu">
<span id="um-legacy-nulti-gpu"></span><h4><span class="section-number">21.3.2.3. </span>Multi-GPU<a class="headerlink" href="#multi-gpu" title="Permalink to this headline">ï</a></h4>
<p>On systems with devices of compute capabilities lower than 6.0 managed allocations are automatically visible to all GPUs in a system via the peer-to-peer capabilities of the GPUs. Managed memory allocations behave similar to unmanaged memory allocated using <code class="docutils literal notranslate"><span class="pre">cudaMalloc()</span></code>: the current active device is the home for the physical allocation but other GPUs in the system will access the memory at reduced bandwidth over the PCIe bus.</p>
<p>On Linux the managed memory is allocated in GPU memory as long as all GPUs that are actively being used by a program have the peer-to-peer support. If at any time the application starts using a GPU that doesnât have peer-to-peer support with any of the other GPUs that have managed allocations on them, then the driver will migrate all managed allocations to system memory. In this case, all GPUs experience PCIe bandwidth restrictions.</p>
<p>On Windows, if peer mappings are not available (for example, between GPUs of different architectures), then the system will automatically fall back to using zero-copy memory, regardless of whether both GPUs are actually used by a program. If only one GPU is actually going to be used, it is necessary to set the <code class="docutils literal notranslate"><span class="pre">CUDA_VISIBLE_DEVICES</span></code> environment variable before launching the program. This constrains which GPUs are visible and allows managed memory to be allocated in GPU memory.</p>
<p>Alternatively, on Windows users can also set <code class="docutils literal notranslate"><span class="pre">CUDA_MANAGED_FORCE_DEVICE_ALLOC</span></code> to a non-zero value to force the driver to always use device memory for physical storage. When this environment variable is set to a non-zero value, all devices used in that process that support managed memory have to be peer-to-peer compatible with each other. The error <code class="docutils literal notranslate"><span class="pre">::cudaErrorInvalidDevice</span></code> will be returned if a device that supports managed memory is used and it is not peer-to-peer compatible with any of the other managed memory supporting devices that were previously used in that process, even if <code class="docutils literal notranslate"><span class="pre">::cudaDeviceReset</span></code> has been called on those devices. These environment variables are described in <a class="reference internal" href="#env-vars"><span class="std std-ref">CUDA Environment Variables</span></a>. Note that starting from CUDA 8.0 <code class="docutils literal notranslate"><span class="pre">CUDA_MANAGED_FORCE_DEVICE_ALLOC</span></code> has no effect on Linux operating systems.</p>
</section>
<section id="coherency-and-concurrency">
<span id="um-coherency-hd"></span><span id="um-programming-model-hd"></span><h4><span class="section-number">21.3.2.4. </span>Coherency and Concurrency<a class="headerlink" href="#coherency-and-concurrency" title="Permalink to this headline">ï</a></h4>
<p>Simultaneous access to managed memory on devices of compute capability lower than 6.0 is not possible, because coherence could not be guaranteed if the CPU accessed a Unified Memory allocation while a GPU kernel was active.</p>
<section id="gpu-exclusive-access-to-managed-memory">
<span id="um-gpu-exclusive"></span><h5><span class="section-number">21.3.2.4.1. </span>GPU Exclusive Access To Managed Memory<a class="headerlink" href="#gpu-exclusive-access-to-managed-memory" title="Permalink to this headline">ï</a></h5>
<p>To ensure coherency on pre-6.x GPU architectures, the Unified Memory programming model puts constraints on data accesses while both the CPU and GPU are executing concurrently. In effect, the GPU has exclusive access to all managed data while any kernel operation is executing, regardless of whether the specific kernel is actively using the data. When managed data is used with <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMemset*()</span></code>, the system may choose to access the source or destination from the host or the device, which will put constraints on concurrent CPU access to that data while the <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*()</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMemset*()</span></code> is executing. See <a class="reference internal" href="#um-memcpy-memset"><span class="std std-ref">Memcpy()/Memset() Behavior With Unified Memory</span></a> for further details.</p>
<p>It is not permitted for the CPU to access any managed allocations or variables while the GPU is active for devices with <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code> property set to 0. On these systems concurrent CPU/GPU accesses, even to different managed memory allocations, will cause a segmentation fault because the page is considered inaccessible to the CPU.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">            </span><span class="c1">// Error on GPUs not supporting concurrent access</span>

<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In example above, the GPU program <code class="docutils literal notranslate"><span class="pre">kernel</span></code> is still active when the CPU touches <code class="docutils literal notranslate"><span class="pre">y</span></code>. (Note how it occurs before <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>.) The code runs successfully on devices of compute capability 6.x due to the GPU page faulting capability which lifts all restrictions on simultaneous access. However, such memory access is invalid on pre-6.x architectures even though the CPU is accessing different data than the GPU. The program must explicitly synchronize with the GPU before accessing <code class="docutils literal notranslate"><span class="pre">y</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">            </span><span class="c1">//  Success on GPUs not supporing concurrent access</span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As this example shows, on systems with pre-6.x GPU architectures, a CPU thread may not access any managed data in between performing a kernel launch and a subsequent synchronization call, regardless of whether the GPU kernel actually touches that same data (or any managed data at all). The mere potential for concurrent CPU and GPU access is sufficient for a process-level exception to be raised.</p>
<p>Note that if memory is dynamically allocated with <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> or <code class="docutils literal notranslate"><span class="pre">cuMemAllocManaged()</span></code> while the GPU is active, the behavior of the memory is unspecified until additional work is launched or the GPU is synchronized. Attempting to access the memory on the CPU during this time may or may not cause a segmentation fault. This does not apply to memory allocated using the flag <code class="docutils literal notranslate"><span class="pre">cudaMemAttachHost</span></code> or <code class="docutils literal notranslate"><span class="pre">CU_MEM_ATTACH_HOST</span></code>.</p>
</section>
<section id="explicit-synchronization-and-logical-gpu-activity">
<span id="um-explicit-synchronization"></span><h5><span class="section-number">21.3.2.4.2. </span>Explicit Synchronization and Logical GPU Activity<a class="headerlink" href="#explicit-synchronization-and-logical-gpu-activity" title="Permalink to this headline">ï</a></h5>
<p>Note that explicit synchronization is required even if <code class="docutils literal notranslate"><span class="pre">kernel</span></code> runs quickly and finishes before the CPU touches <code class="docutils literal notranslate"><span class="pre">y</span></code> in the above example. Unified Memory uses logical activity to determine whether the GPU is idle. This aligns with the CUDA programming model, which specifies that a kernel can run at any time following a launch and is not guaranteed to have finished until the host issues a synchronization call.</p>
<p>Any function call that logically guarantees the GPU completes its work is valid. This includes <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code>; <code class="docutils literal notranslate"><span class="pre">cudaStreamSynchronize()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaStreamQuery()</span></code> (provided it returns <code class="docutils literal notranslate"><span class="pre">cudaSuccess</span></code> and not <code class="docutils literal notranslate"><span class="pre">cudaErrorNotReady</span></code>) where the specified stream is the only stream still executing on the GPU; <code class="docutils literal notranslate"><span class="pre">cudaEventSynchronize()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaEventQuery()</span></code> in cases where the specified event is not followed by any device work; as well as uses of <code class="docutils literal notranslate"><span class="pre">cudaMemcpy()</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemset()</span></code> that are documented as being fully synchronous with respect to the host.</p>
<p>Dependencies created between streams will be followed to infer completion of other streams by synchronizing on a stream or event. Dependencies can be created via <code class="docutils literal notranslate"><span class="pre">cudaStreamWaitEvent()</span></code> or implicitly when using the default (NULL) stream.</p>
<p>It is legal for the CPU to access managed data from within a stream callback, provided no other stream that could potentially be accessing managed data is active on the GPU. In addition, a callback that is not followed by any device work can be used for synchronization: for example, by signaling a condition variable from inside the callback; otherwise, CPU access is valid only for the duration of the callback(s).</p>
<p>There are several important points of note:</p>
<ul class="simple">
<li><p>It is always permitted for the CPU to access non-managed zero-copy data while the GPU is active.</p></li>
<li><p>The GPU is considered active when it is running any kernel, even if that kernel does not make use of managed data. If a kernel might use data, then access is forbidden, unless device property <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code> is 1.</p></li>
<li><p>There are no constraints on concurrent inter-GPU access of managed memory, other than those that apply to multi-GPU access of non-managed memory.</p></li>
<li><p>There are no constraints on concurrent GPU kernels accessing managed data.</p></li>
</ul>
<p>Note how the last point allows for races between GPU kernels, as is currently the case for non-managed GPU memory. As mentioned previously, managed memory functions identically to non-managed memory from the perspective of the GPU. The following code example illustrates these points:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream1</span><span class="p">,</span><span class="w"> </span><span class="n">stream2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">non_managed</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">managed</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">also_managed</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocHost</span><span class="p">(</span><span class="o">&amp;</span><span class="n">non_managed</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">    </span><span class="c1">// Non-managed, CPU-accessible memory</span>
<span class="w">    </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">managed</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocManaged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">also_managed</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Point 1: CPU can access non-managed data.</span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">managed</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">non_managed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Point 2: CPU cannot access any managed data while GPU is busy,</span>
<span class="w">    </span><span class="c1">//          unless concurrentManagedAccess = 1</span>
<span class="w">    </span><span class="c1">// Note we have not yet synchronized, so &quot;kernel&quot; is still active.</span>
<span class="w">    </span><span class="o">*</span><span class="n">also_managed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">      </span><span class="c1">// Will issue segmentation fault</span>
<span class="w">    </span><span class="c1">// Point 3: Concurrent GPU kernels can access the same data.</span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">managed</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Point 4: Multi-GPU concurrent access is also permitted.</span>
<span class="w">    </span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">managed</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="managing-data-visibility-and-concurrent-cpu-gpu-access-with-streams">
<span id="um-managing-data"></span><h5><span class="section-number">21.3.2.4.3. </span>Managing Data Visibility and Concurrent CPU + GPU Access with Streams<a class="headerlink" href="#managing-data-visibility-and-concurrent-cpu-gpu-access-with-streams" title="Permalink to this headline">ï</a></h5>
<p>Until now it was assumed that for SM architectures before 6.x: 1) any active kernel may use any managed memory, and 2) it was invalid to use managed memory from the CPU while a kernel is active. Here we present a system for finer-grained control of managed memory designed to work on all devices supporting managed memory, including older architectures with <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code> equal to 0.</p>
<p>The CUDA programming model provides streams as a mechanism for programs to indicate dependence and independence among kernel launches. Kernels launched into the same stream are guaranteed to execute consecutively, while kernels launched into different streams are permitted to execute concurrently. Streams describe independence between work items and hence allow potentially greater efficiency through concurrency.</p>
<p>Unified Memory builds upon the stream-independence model by allowing a CUDA program to explicitly associate managed allocations with a CUDA stream. In this way, the programmer indicates the use of data by kernels based on whether they are launched into a specified stream or not. This enables opportunities for concurrency based on program-specific data access patterns. The function to control this behavior is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaError_t</span><span class="w"> </span><span class="nf">cudaStreamAttachMemAsync</span><span class="p">(</span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">                                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code> function associates <code class="docutils literal notranslate"><span class="pre">length</span></code> bytes of memory starting from <code class="docutils literal notranslate"><span class="pre">ptr</span></code> with the specified <code class="docutils literal notranslate"><span class="pre">stream</span></code>. (Currently, <code class="docutils literal notranslate"><span class="pre">length</span></code> must always be 0 to indicate that the entire region should be attached.) Because of this association, the Unified Memory system allows CPU access to this memory region so long as all operations in <code class="docutils literal notranslate"><span class="pre">stream</span></code> have completed, regardless of whether other streams are active. In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per-stream activity instead of whole-GPU activity.</p>
<p>Most importantly, if an allocation is not associated with a specific stream, it is visible to all running kernels regardless of their stream. This is the default visibility for a <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> allocation or a <code class="docutils literal notranslate"><span class="pre">__managed__</span></code> variable; hence, the simple-case rule that the CPU may not touch the data while any kernel is running.</p>
<p>By associating an allocation with a specific stream, the program makes a guarantee that only kernels launched into that stream will touch that data. No error checking is performed by the Unified Memory system: it is the programmerâs responsibility to ensure that guarantee is honored.</p>
<p>In addition to allowing greater concurrency, the use of <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code> can (and typically does) enable data transfer optimizations within the Unified Memory system that may affect latencies and other overhead.</p>
</section>
<section id="stream-association-examples">
<span id="um-stream-association"></span><h5><span class="section-number">21.3.2.4.4. </span>Stream Association Examples<a class="headerlink" href="#stream-association-examples" title="Permalink to this headline">ï</a></h5>
<p>Associating data with a stream allows fine-grained control over CPU + GPU concurrency, but what data is visible to which streams must be kept in mind when using devices of compute capability lower than 6.0. Looking at the earlier synchronization example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamAttachMemAsync</span><span class="p">(</span><span class="n">stream1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemAttachHost</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w">          </span><span class="c1">// Wait for Host attachment to occur.</span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Note: Launches into stream1.</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">                           </span><span class="c1">// Success â a kernel is running but âyâ</span>
<span class="w">                                      </span><span class="c1">// has been associated with no stream.</span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Here we explicitly associate <code class="docutils literal notranslate"><span class="pre">y</span></code> with host accessibility, thus enabling access at all times from the CPU. (As before, note the absence of <code class="docutils literal notranslate"><span class="pre">cudaDeviceSynchronize()</span></code> before the access.) Accesses to <code class="docutils literal notranslate"><span class="pre">y</span></code> by the GPU running <code class="docutils literal notranslate"><span class="pre">kernel</span></code> will now produce undefined results.</p>
<p>Note that associating a variable with a stream does not change the associating of any other variable. For example, associating <code class="docutils literal notranslate"><span class="pre">x</span></code> with <code class="docutils literal notranslate"><span class="pre">stream1</span></code> does not ensure that only <code class="docutils literal notranslate"><span class="pre">x</span></code> is accessed by kernels launched in <code class="docutils literal notranslate"><span class="pre">stream1</span></code>, thus an error is caused by this code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">__device__</span><span class="w"> </span><span class="n">__managed__</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="n">__global__</span><span class="w">  </span><span class="kt">void</span><span class="w">  </span><span class="n">kernel</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamAttachMemAsync</span><span class="p">(</span><span class="n">stream1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="c1">// Associate âxâ with stream1.</span>
<span class="w">    </span><span class="n">cudaDeviceSynchronize</span><span class="p">();</span><span class="w">              </span><span class="c1">// Wait for âxâ attachment to occur.</span>
<span class="w">    </span><span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span><span class="w">     </span><span class="c1">// Note: Launches into stream1.</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">                               </span><span class="c1">// ERROR: âyâ is still associated globally</span>
<span class="w">                                          </span><span class="c1">// with all streams by default</span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Note how the access to <code class="docutils literal notranslate"><span class="pre">y</span></code> will cause an error because, even though <code class="docutils literal notranslate"><span class="pre">x</span></code> has been associated with a stream, we have told the system nothing about who can see <code class="docutils literal notranslate"><span class="pre">y</span></code>. The system therefore conservatively assumes that <code class="docutils literal notranslate"><span class="pre">kernel</span></code> might access it and prevents the CPU from doing so.</p>
</section>
<section id="stream-attach-with-multithreaded-host-programs">
<span id="um-stream-attach"></span><h5><span class="section-number">21.3.2.4.5. </span>Stream Attach With Multithreaded Host Programs<a class="headerlink" href="#stream-attach-with-multithreaded-host-programs" title="Permalink to this headline">ï</a></h5>
<p>The primary use for <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code> is to enable independent task parallelism using CPU threads. Typically in such a program, a CPU thread creates its own stream for all work that it generates because using CUDAâs NULL stream would cause dependencies between threads.</p>
<p>The default global visibility of managed data to any GPU stream can make it difficult to avoid interactions between CPU threads in a multi-threaded program. Function <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code> is therefore used to associate a threadâs managed allocations with that threadâs own stream, and the association is typically not changed for the life of the thread.</p>
<p>Such a program would simply add a single call to <code class="docutils literal notranslate"><span class="pre">cudaStreamAttachMemAsync()</span></code> to use unified memory for its data accesses:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// This function performs some task, in its own private stream.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">run_task</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a stream for us to use.</span>
<span class="w">    </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Allocate some managed data and associate with our stream.</span>
<span class="w">    </span><span class="c1">// Note the use of the host-attach flag to cudaMallocManaged();</span>
<span class="w">    </span><span class="c1">// we then associate the allocation with our stream so that</span>
<span class="w">    </span><span class="c1">// our GPU kernel launches can access it.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaMallocManaged</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">cudaMemAttachHost</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamAttachMemAsync</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Iterate on the data in some way, using both Host &amp; Device.</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">transform</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">host_process</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w">    </span><span class="c1">// CPU uses managed data.</span>
<span class="w">        </span><span class="n">convert</span><span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamSynchronize</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaStreamDestroy</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, the allocation-stream association is established just once, and then <code class="docutils literal notranslate"><span class="pre">data</span></code> is used repeatedly by both the host and device. The result is much simpler code than occurs with explicitly copying data between host and device, although the result is the same.</p>
</section>
<section id="advanced-topic-modular-programs-and-data-access-constraints">
<span id="um-advanced-modular"></span><h5><span class="section-number">21.3.2.4.6. </span>Advanced Topic: Modular Programs and Data Access Constraints<a class="headerlink" href="#advanced-topic-modular-programs-and-data-access-constraints" title="Permalink to this headline">ï</a></h5>
<p>In the previous example <code class="docutils literal notranslate"><span class="pre">cudaMallocManaged()</span></code> specifies the <code class="docutils literal notranslate"><span class="pre">cudaMemAttachHost</span></code> flag, which creates an allocation that is initially invisible to device-side execution. (The default allocation would be visible to all GPU kernels on all streams.) This ensures that there is no accidental interaction with another threadâs execution in the interval between the data allocation and when the data is acquired for a specific stream.</p>
<p>Without this flag, a new allocation would be considered in-use on the GPU if a kernel launched by another thread happens to be running. This might impact the threadâs ability to access the newly allocated data from the CPU (for example, within a base-class constructor) before it is able to explicitly attach it to a private stream. To enable safe independence between threads, therefore, allocations should be made specifying this flag.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An alternative would be to place a process-wide barrier across all threads after the allocation has been attached to the stream. This would ensure that all threads complete their data/stream associations before any kernels are launched, avoiding the hazard. A second barrier would be needed before the stream is destroyed because stream destruction causes allocations to revert to their default visibility. The <code class="docutils literal notranslate"><span class="pre">cudaMemAttachHost</span></code> flag exists both to simplify this process, and because it is not always possible to insert global barriers where required.</p>
</div>
</section>
<section id="memcpy-memset-behavior-with-stream-associated-unified-memory">
<span id="um-legacy-memcpy"></span><h5><span class="section-number">21.3.2.4.7. </span>Memcpy()/Memset() Behavior With Stream-associated Unified Memory<a class="headerlink" href="#memcpy-memset-behavior-with-stream-associated-unified-memory" title="Permalink to this headline">ï</a></h5>
<p>See <a class="reference internal" href="#um-memcpy-memset"><span class="std std-ref">Memcpy()/Memset() Behavior With Unified Memory</span></a> for a general overview of <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*</span></code> / <code class="docutils literal notranslate"><span class="pre">cudaMemset*</span></code> behavior on devices with <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code> set. On devices where <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code> is not set, the following rules apply:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">cudaMemcpyHostTo*</span></code> is specified and the source data is unified memory, then it will be accessed from the host if it is coherently accessible from the host in the copy stream <a class="reference internal" href="#um-legacy-memcpy-cit1"><span class="std std-ref">(1)</span></a>; otherwise it will be accessed from the device. Similar rules apply to the destination when <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*ToHost</span></code> is specified and the destination is unified memory.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">cudaMemcpyDeviceTo*</span></code> is specified and the source data is unified memory, then it will be accessed from the device. The source must be coherently accessible from the device in the copy stream <a class="reference internal" href="#um-legacy-memcpy-cit2"><span class="std std-ref">(2)</span></a>; otherwise, an error is returned. Similar rules apply to the destination when <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*ToDevice</span></code> is specified and the destination is unified memory.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">cudaMemcpyDefault</span></code> is specified, then unified memory will be accessed from the host either if it cannot be coherently accessed from the device in the copy stream <a class="reference internal" href="#um-legacy-memcpy-cit2"><span class="std std-ref">(2)</span></a> or if the preferred location for the data is <code class="docutils literal notranslate"><span class="pre">cudaCpuDeviceId</span></code> and it can be coherently accessed from the host in the copy stream <a class="reference internal" href="#um-legacy-memcpy-cit1"><span class="std std-ref">(1)</span></a>; otherwise, it will be accessed from the device.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">cudaMemset*()</span></code> with unified memory, the data must be coherently accessible from the device in the stream being used for the <code class="docutils literal notranslate"><span class="pre">cudaMemset()</span></code> operation <a class="reference internal" href="#um-legacy-memcpy-cit2"><span class="std std-ref">(2)</span></a>; otherwise, an error is returned.</p>
<p>When data is accessed from the device either by <code class="docutils literal notranslate"><span class="pre">cudaMemcpy*</span></code> or <code class="docutils literal notranslate"><span class="pre">cudaMemset*</span></code>, the stream of operation is considered to be active on the GPU. During this time, any CPU access of data that is associated with that stream or data that has global visibility, will result in a segmentation fault if the GPU has a zero value for the device attribute <code class="docutils literal notranslate"><span class="pre">concurrentManagedAccess</span></code>. The program must synchronize appropriately to ensure the operation has completed before accessing any associated data from the CPU.</p>
<blockquote id="um-legacy-memcpy-cit1">
<div><ol class="arabic simple">
<li><p>Coherently accessible from the host in a given stream means that the memory neither has global visibility nor is it associated with the given stream.</p></li>
</ol>
</div></blockquote>
<blockquote id="um-legacy-memcpy-cit2">
<div><ol class="arabic simple" start="2">
<li><p>Coherently accessible from the device in a given stream means that the memory either has global visibility or is associated with the given stream.</p></li>
</ol>
</div></blockquote>
</section>
</section>
</section>
</section>
</section>
<section id="lazy-loading">
<span id="id450"></span><h1><span class="section-number">22. </span>Lazy Loading<a class="headerlink" href="#lazy-loading" title="Permalink to this headline">ï</a></h1>
<section id="what-is-lazy-loading">
<span id="what-is-ll"></span><h2><span class="section-number">22.1. </span>What is Lazy Loading?<a class="headerlink" href="#what-is-lazy-loading" title="Permalink to this headline">ï</a></h2>
<p>Lazy Loading delays loading of CUDA modules and kernels from program initalization closer to kernels execution.
If a program does not use every single kernel it has included, then some kernels will be loaded unneccesarily.
This is very common, especially if you include any libraries.
Most of the time, programs only use a small amount of kernels from libraries they include.</p>
<p>Thanks to Lazy Loading, programs are able to only load kernels they are actually going to use, saving time on initialization.
This reduces memory overhead, both on GPU memory and host memory.</p>
<p>Lazy Loading is enabled by setting the <code class="docutils literal notranslate"><span class="pre">CUDA_MODULE_LOADING</span></code> environment variable to <code class="docutils literal notranslate"><span class="pre">LAZY</span></code>.</p>
<p>Firstly, CUDA Runtime will no longer load all modules during program initialization, with the exception of modules containing managed variables.
Each module will be loaded on first usage of a variable or a kernel from that module.
This optimization is only relevant to CUDA Runtime users, CUDA Driver users who use <code class="docutils literal notranslate"><span class="pre">cuModuleLoad</span></code> are unaffected. This optimization shipped in CUDA 11.8.
The behavior for CUDA Driver users who use <code class="docutils literal notranslate"><span class="pre">cuLibraryLoad</span></code> to load module data into memory can be changed by
setting the <code class="docutils literal notranslate"><span class="pre">CUDA_MODULE_DATA_LOADING</span></code> environment variable.</p>
<p>Secondly, loading a module (<code class="docutils literal notranslate"><span class="pre">cuModuleLoad*()</span></code> family of functions) will not be loading kernels immediately,
instead it will delay loading of a kernel until <code class="docutils literal notranslate"><span class="pre">cuModuleGetFunction()</span></code> is called.
There are certain exceptions here, some kernels have to be loaded during <code class="docutils literal notranslate"><span class="pre">cuModuleLoad*()</span></code>,
such as kernels of which pointers are stored in global variables.
This optimization is relevant to both CUDA Runtime and CUDA Driver users.
CUDA Runtime will only call <code class="docutils literal notranslate"><span class="pre">cuModuleGetFunction()</span></code> when a kernel is used/referenced for the first time.
This optimization shipped in CUDA 11.7.</p>
<p>Both of these optimizations are designed to be invisible to the user, assuming CUDA Programming Model is followed.</p>
</section>
<section id="lazy-loading-version-support">
<span id="ll-version"></span><h2><span class="section-number">22.2. </span>Lazy Loading version support<a class="headerlink" href="#lazy-loading-version-support" title="Permalink to this headline">ï</a></h2>
<p>Lazy Loading is a CUDA Runtime and CUDA Driver feature. Upgrades to both might be necessary to utilize the feature.</p>
<section id="driver">
<h3><span class="section-number">22.2.1. </span>Driver<a class="headerlink" href="#driver" title="Permalink to this headline">ï</a></h3>
<p>Lazy Loading requires R515+ user-mode library, but it supports Forward Compatibility, meaning it can run on top of older kernel mode drivers.</p>
<p>Without R515+ user-mode library, Lazy Loading is not available in any shape or form, even if toolkit version is 11.7+.</p>
</section>
<section id="toolkit">
<h3><span class="section-number">22.2.2. </span>Toolkit<a class="headerlink" href="#toolkit" title="Permalink to this headline">ï</a></h3>
<p>Lazy Loading was introduced in CUDA 11.7, and received a significant upgrade in CUDA 11.8.</p>
<p>If your application uses CUDA Runtime, then in order to see benefits from Lazy Loading your application must use 11.7+ CUDA Runtime.</p>
<p>As CUDA Runtime is usually linked statically into programs and libraries,
this means that you have to recompile your program with CUDA 11.7+ toolkit and use CUDA 11.7+ libraries.</p>
<p>Otherwise you will not see the benefits of Lazy Loading, even if your driver version supports it.</p>
<p>If only some of your libraries are 11.7+, you will only see benefits of Lazy Loading in those libraries.
Other libraries will still load everything eagerly.</p>
</section>
<section id="compiler">
<h3><span class="section-number">22.2.3. </span>Compiler<a class="headerlink" href="#compiler" title="Permalink to this headline">ï</a></h3>
<p>Lazy Loading does not require any compiler support. Both SASS and PTX compiled with pre-11.7 compilers can be loaded with Lazy Loading enabled,
and will see full benefits of the feature. However, 11.7+ CUDA Runtime is still required, as described above.</p>
</section>
</section>
<section id="triggering-loading-of-kernels-in-lazy-mode">
<span id="ll-impact"></span><h2><span class="section-number">22.3. </span>Triggering loading of kernels in lazy mode<a class="headerlink" href="#triggering-loading-of-kernels-in-lazy-mode" title="Permalink to this headline">ï</a></h2>
<p>Loading kernels and variables happens automatically, without any need for explicit loading.
Simply launching a kernel or referencing a variable or a kernel will automatically load relevant modules and kernels.</p>
<p>However, if for any reason you wish to load a kernel without executing it or modifying it in any way, we recommend the following.</p>
<section id="cuda-driver-api">
<h3><span class="section-number">22.3.1. </span>CUDA Driver API<a class="headerlink" href="#cuda-driver-api" title="Permalink to this headline">ï</a></h3>
<p>Loading of kernels happens during <code class="docutils literal notranslate"><span class="pre">cuModuleGetFunction()</span></code> call.
This call is necessary even without Lazy Loading, as it is the only way to obtain a kernel handle.</p>
<p>However, you can also use this API to control with finer granularity when kernels are loaded.</p>
</section>
<section id="cuda-runtime-api">
<h3><span class="section-number">22.3.2. </span>CUDA Runtime API<a class="headerlink" href="#cuda-runtime-api" title="Permalink to this headline">ï</a></h3>
<p>CUDA Runtime API manages module management automatically,
so we recommend simply using <code class="docutils literal notranslate"><span class="pre">cudaFuncGetAttributes()</span></code> to reference the kernel.</p>
<p>This will ensure that the kernel is loaded without changing the state.</p>
</section>
</section>
<section id="querying-whether-lazy-loading-is-turned-on">
<h2><span class="section-number">22.4. </span>Querying whether Lazy Loading is Turned On<a class="headerlink" href="#querying-whether-lazy-loading-is-turned-on" title="Permalink to this headline">ï</a></h2>
<p>In order to check whether user enabled Lazy Loading, <code class="docutils literal notranslate"><span class="pre">CUresult</span> <span class="pre">cuModuleGetLoadingMode</span> <span class="pre">(</span> <span class="pre">CUmoduleLoadingMode*</span> <span class="pre">mode</span> <span class="pre">)</span></code> can be used.</p>
<p>Itâs important to note that CUDA must be initialized before running this function. Sample usage can be seen in the snippet below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cuda.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;assert.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;iostream&quot;</span><span class="cp"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">CUmoduleLoadingMode</span><span class="w"> </span><span class="n">mode</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cuInit</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">CUDA_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cuModuleGetLoadingMode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">));</span><span class="w"></span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CUDA Module Loading Mode is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">((</span><span class="n">mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CU_MODULE_LAZY_LOADING</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;lazy&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;eager&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="possible-issues-when-adopting-lazy-loading">
<span id="ll-caveats"></span><h2><span class="section-number">22.5. </span>Possible Issues when Adopting Lazy Loading<a class="headerlink" href="#possible-issues-when-adopting-lazy-loading" title="Permalink to this headline">ï</a></h2>
<p>Lazy Loading is designed so that it should not require any modifications to applications to use it.
That said, there are some caveats, especially when applications are not fully compliant with CUDA Programming Model.</p>
<section id="concurrent-execution">
<h3><span class="section-number">22.5.1. </span>Concurrent Execution<a class="headerlink" href="#concurrent-execution" title="Permalink to this headline">ï</a></h3>
<p>Loading kernels might require context synchronization.
Some programs incorrectly treat the possibility of concurrent execution of kernels as a guarantee.
In such cases, if program assumes that two kernels will be able to execute concurrently,
and one of the kernels will not return without the other kernel executing, there is a possibility of a deadlock.</p>
<p>If kernel A will be spinning in an infinite loop until kernel B is executing.
In such case launching kernel B will trigger lazy loading of kernel B. If this loading will require context synchronization,
then we have a deadlock: kernel A is waiting for kernel B, but loading kernel B is stuck waiting for kernel A to finish to synchronize the context.</p>
<p>Such program is an anti-pattern, but if for any reason you want to keep it you can do the following:</p>
<ul class="simple">
<li><p>preload all kernels that you hope to execute concurrently prior to launching them</p></li>
<li><p>run application with <code class="docutils literal notranslate"><span class="pre">CUDA_MODULE_DATA_LOADING=EAGER</span></code> to force loading data eagerly without forcing each function to load eagerly</p></li>
</ul>
</section>
<section id="allocators">
<h3><span class="section-number">22.5.2. </span>Allocators<a class="headerlink" href="#allocators" title="Permalink to this headline">ï</a></h3>
<p>Lazy Loading delays loading code from initialization phase of the program closer to execution phase.
Loading code onto the GPU requires memory allocation.</p>
<p>If your application tries to allocate the entire VRAM on startup, for example, to use it for its own allocator,
then it might turn out that there will be no more memory left to load the kernels.
This is despite the fact that overall Lazy Loading frees up more memory for the user.
CUDA will need to allocate some memory to load each kernel, which usually happens at first launch time of each kernel.
If your application allocator greedily allocated everything, CUDA will fail to allocate memory.</p>
<p>Possible solutions:</p>
<ul class="simple">
<li><p>use <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync()</span></code> instead of an allocator that allocates the entire VRAM on startup</p></li>
<li><p>add some buffer to compensate for the delayed loading of kernels</p></li>
<li><p>preload all kernels that will be used in the program before trying to initialize your allocator</p></li>
</ul>
</section>
<section id="autotuning">
<h3><span class="section-number">22.5.3. </span>Autotuning<a class="headerlink" href="#autotuning" title="Permalink to this headline">ï</a></h3>
<p>Some applications launch several kernels implementing the same functionality to determine which one is the fastest.
While it is overall advisable to run at least one warmup iteration, it becomes especially important with Lazy Loading.
After all, including time taken to load the kernel will skew your results.</p>
<p>Possible solutions:</p>
<ul class="simple">
<li><p>do at least one warmup interaction prior to measurement</p></li>
<li><p>preload the benchmarked kernel prior to launching it</p></li>
</ul>
</section>
</section>
</section>
<section id="extended-gpu-memory">
<h1><span class="section-number">23. </span>Extended GPU Memory<a class="headerlink" href="#extended-gpu-memory" title="Permalink to this headline">ï</a></h1>
<p>The Extended GPU Memory (EGM) feature, utilizing the high-bandwidth
NVLink-C2C, facilitates efficient access to all system memory by GPUs,
in a single-node system.
EGM applies to integrated CPU-GPU NVIDIA systems by allowing physical memory
allocation that can be accessed from any GPU
thread within the setup. EGM ensures that all GPUs can access
its resources at the speed of either GPU-GPU NVLink or NVLink-C2C.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/egm-c2c-intro.png"><img alt="EGM" src="_images/egm-c2c-intro.png" style="width: 800px;" /></a>
</figure>
<p>In this setup, memory accesses occur via the local high-bandwidth
NVLink-C2C. For remote memory accesses,
GPU NVLink and, in some cases, NVLink-C2C are used. With EGM, GPU
threads gain the capability to access all available memory resources,
including CPU attached memory and HBM3, over the NVSwitch fabric.</p>
<section id="preliminaries">
<h2><span class="section-number">23.1. </span>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">ï</a></h2>
<p>Before diving into API changes for EGM functionalities, we are going to
cover currently supported topologies, identifier assignment,
prerequisites for virtual memory management, and CUDA types for EGM.</p>
<section id="egm-platforms-system-topology">
<h3><span class="section-number">23.1.1. </span>EGM Platforms: System topology<a class="headerlink" href="#egm-platforms-system-topology" title="Permalink to this headline">ï</a></h3>
<p>Currently, EGM can be enabled in three platforms: <strong>(1) Single-Node, Single-GPU</strong>:
Consists of an Arm-based CPU, CPU attached memory, and a GPU. Between the CPU
and the GPU there is a high bandwidth C2C (Chip-to-Chip) interconnect.
<strong>(2) Single-Node, Multi-GPU</strong>: Consists of fully connected four
single-node, single-GPU platforms. <strong>(3) Multi-Node, Single-GPU</strong>:
Two or more single-node multi-socket systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">cgroups</span></code> to limit available devices will block routing over EGM
and cause performance issues. Use <code class="docutils literal notranslate"><span class="pre">CUDA_VISIBLE_DEVICES</span></code> instead.</p>
</div>
</section>
<section id="socket-identifiers-what-are-they-how-to-access-them">
<h3><span class="section-number">23.1.2. </span>Socket Identifiers: What are they? How to access them?<a class="headerlink" href="#socket-identifiers-what-are-they-how-to-access-them" title="Permalink to this headline">ï</a></h3>
<p>NUMA (Non-Uniform Memory Access) is a memory architecture used in
multi-processor computer systems such that the memory is divided into
multiple nodes. Each node has its own processors and memory. In such a
system, NUMA divides the system into nodes and assigns a unique
identifier (<cite>numaID</cite>) to every node.</p>
<p>EGM uses the NUMA node identifier which is assigned by the operating
system. Note that, this identifier is different from the ordinal of a
device and it is associated with the closest host node. In addition to
the existing methods, the user can obtain the identifier of the host
node (<cite>numaID</cite>) by calling <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266">cuDeviceGetAttribute</a>
with <code class="docutils literal notranslate"><span class="pre">CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID</span></code> attribute type as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">numaId</span><span class="p">;</span><span class="w"></span>
<span class="n">cuDeviceGetAttribute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numaId</span><span class="p">,</span><span class="w"> </span><span class="n">CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID</span><span class="p">,</span><span class="w"> </span><span class="n">deviceOrdinal</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocators-and-egm-support">
<h3><span class="section-number">23.1.3. </span>Allocators and EGM support<a class="headerlink" href="#allocators-and-egm-support" title="Permalink to this headline">ï</a></h3>
<p>Mapping system memory as EGM does not cause any performance issues. In
fact, accessing a remote socketâs system memory mapped as EGM is going
to be faster. Because, with EGM traffic is guaranteed to be routed over
NVLinks. Currently, <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> and <code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code> allocators are
supported with appropriate location type and NUMA identifiers.</p>
</section>
<section id="memory-management-extensions-to-current-apis">
<h3><span class="section-number">23.1.4. </span>Memory management extensions to current APIs<a class="headerlink" href="#memory-management-extensions-to-current-apis" title="Permalink to this headline">ï</a></h3>
<p>Currently, EGM memory can be mapped with Virtual Memory (<code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>) Â or
Stream Ordered Memory (<code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code>) allocators. The user is
responsible for allocating physical memory and mapping it to a virtual
memory address space on all sockets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multi-node, single-GPU platforms require interprocess
communication. Therefore we encourage the reader to see <a class="reference external" href="#interprocess-communication">Chapter 3</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We encourage readers to read CUDA Programming Guideâs <a class="reference external" href="#virtual-memory-management">Chapter 10</a> and <a class="reference external" href="#stream-ordered-memory-allocator">Chapter 11</a> for a better understanding.</p>
</div>
<p>New CUDA property types have been added to APIs for allowing those
approaches to understand allocation locations using NUMA-like node
identifiers:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>CUDA Type</strong></p></td>
<td><p><strong>Used with</strong></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CU_MEM_LOCATION_TYPE_HOST_NUMA</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">CUmemAllocationProp</span></code> for
<code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cudaMemLocationTypeHostNuma</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">cudaMemPoolProps</span></code> for
<code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code></p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please see  <a class="reference external" href="https://www.google.com/url?q=https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TYPES.html&amp;sa=D&amp;source=editors&amp;ust=1696873412599124&amp;usg=AOvVaw0Ru93Acs_FpJG0gl02BLMX">CUDA Driver API</a>
and <a class="reference external" href="https://www.google.com/url?q=https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TYPES.html%23group__CUDART__TYPES_1gg2279aa08666f329f3ba4afe397fa60f024dc63fb938dee27b41e3842da35d2d0&amp;sa=D&amp;source=editors&amp;ust=1696873412599344&amp;usg=AOvVaw2O-SyvDt1G37IjcpFzc-4C">CUDA Runtime Data Types</a>
to find more about NUMA specific CUDA types.</p>
</div>
</section>
</section>
<section id="using-the-egm-interface">
<h2><span class="section-number">23.2. </span>Using the EGM Interface<a class="headerlink" href="#using-the-egm-interface" title="Permalink to this headline">ï</a></h2>
<section id="single-node-single-gpu">
<h3><span class="section-number">23.2.1. </span>Single-Node, Single-GPU<a class="headerlink" href="#single-node-single-gpu" title="Permalink to this headline">ï</a></h3>
<p>Any of the existing CUDA host allocators as well as system allocated
memory can be used to benefit from high-bandwidth C2C. To the user,
local access is what a host allocation is today.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refer to the tuning guide for more information about memory allocators and page sizes.</p>
</div>
</section>
<section id="single-node-multi-gpu">
<h3><span class="section-number">23.2.2. </span>Single-Node, Multi-GPU<a class="headerlink" href="#single-node-multi-gpu" title="Permalink to this headline">ï</a></h3>
<p>In a multi-GPU system, the user has to provide host information for
the placement. As we mentioned, a natural way to express that
information would be by using NUMA node IDs and EGM follows this
approach. Therefore, using the <code class="docutils literal notranslate"><span class="pre">cuDeviceGetAttribute</span></code> function the
user should be able to learn the closest NUMA node id. (See <a class="reference external" href="#socket-identifiers-what-are-they-how-to-access-them">Socket Identifiers: What are they? How to access them?</a>).
Then the user can allocate and manage EGM memory using VMM (Virtual
Memory Management) API or CUDA Memory Pool.</p>
<section id="using-vmm-apis">
<h4><span class="section-number">23.2.2.1. </span>Using VMM APIs<a class="headerlink" href="#using-vmm-apis" title="Permalink to this headline">ï</a></h4>
<p>The first step in memory allocation using Virtual Memory Management APIs
is to create a physical memory chunk that will provide a backing for the
allocation. See CUDA Programming Guideâs <a class="reference external" href="#virtual-memory-management">Virtual Memory Management section</a>
for more details. In EGM allocations the user has to explicitly provide
<code class="docutils literal notranslate"><span class="pre">CU_MEM_LOCATION_TYPE_HOST_NUMA</span></code> Â as the location type and
<cite>numaID</cite> as the location identifier. Also in EGM, allocationsÂ must
be aligned to appropriate granularity of the platform. The following
code snippet shows allocating physical memory with <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">prop</span><span class="p">{};</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_TYPE_PINNED</span><span class="p">;</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_HOST_NUMA</span><span class="p">;</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numaId</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemGetAllocationGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="n">MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span><span class="w"></span>
<span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>After physical memory allocation, we have to reserve an address space
and map it to a pointer. These procedures do not have EGM-specific
changes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dptr</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemAddressReserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemMap</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Finally, the user has to explicitly protect mapped virtual address
ranges. Otherwise access to the mapped space would result in a crash.
Similar to the memory allocation, the user has to provide
<code class="docutils literal notranslate"><span class="pre">CU_MEM_LOCATION_TYPE_HOST_NUMA</span></code> as the location type and
<cite>numaId</cite> as the location identifier. Following code snippet create
an access descriptors for the host node and the GPU to give read and
write access for the mapped memory to both of them:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemAccessDesc</span><span class="w"> </span><span class="n">accessDesc</span><span class="p">[</span><span class="mi">2</span><span class="p">]{{}};</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_HOST_NUMA</span><span class="p">;</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numaId</span><span class="p">;</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ACCESS_FLAGS_PROT_READWRITE</span><span class="p">;</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_DEVICE</span><span class="p">;</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentDev</span><span class="p">;</span><span class="w"></span>
<span class="n">accessDesc</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ACCESS_FLAGS_PROT_READWRITE</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemSetAccess</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">accessDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="using-cuda-memory-pool">
<h4><span class="section-number">23.2.2.2. </span>Using CUDA Memory Pool<a class="headerlink" href="#using-cuda-memory-pool" title="Permalink to this headline">ï</a></h4>
<p>To define EGM, the user can create a memory pool on a node and give
access to peers. In this case, the user has to explicitly define
<code class="docutils literal notranslate"><span class="pre">cudaMemLocationTypeHostNuma</span></code> as the location type and <cite>numaId</cite>
as the location identifier. The following code snippet shows creating a
memory pool <code class="docutils literal notranslate"><span class="pre">cudaMemPoolCreate</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">homeDevice</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMemPoolProps</span><span class="w"> </span><span class="n">props</span><span class="p">{};</span><span class="w"></span>
<span class="n">props</span><span class="p">.</span><span class="n">allocType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAllocationTypePinned</span><span class="p">;</span><span class="w"></span>
<span class="n">props</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeHostNuma</span><span class="p">;</span><span class="w"></span>
<span class="n">props</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numaId</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">props</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Additionally, for direct connect peer access, it is also possible to use
the existing peer access API, <code class="docutils literal notranslate"><span class="pre">cudaMemPoolSetAccess</span></code>. An example
for an <cite>accessingDevice</cite> is shown in the following code snippet:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaMemAccessDesc</span><span class="w"> </span><span class="n">desc</span><span class="p">{};</span><span class="w"></span>
<span class="n">desc</span><span class="p">.</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemAccessFlagsProtReadWrite</span><span class="p">;</span><span class="w"></span>
<span class="n">desc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaMemLocationTypeDevice</span><span class="p">;</span><span class="w"></span>
<span class="n">desc</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accessingDevice</span><span class="p">;</span><span class="w"></span>
<span class="n">cudaMemPoolSetAccess</span><span class="p">(</span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When the memory pool is created, and accesses are given, the user can
set created memory pool to the <cite>residentDevice</cite> and start allocating
memory using <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cudaDeviceSetMemPool</span><span class="p">(</span><span class="n">residentDevice</span><span class="p">,</span><span class="w"> </span><span class="n">memPool</span><span class="p">);</span><span class="w"></span>
<span class="n">cudaMallocAsync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">memPool</span><span class="p">,</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>EGM is mapped with 2MB pages. Therefore, users may encounter more TLB
misses when accessing very large allocations.</p>
</div>
</section>
</section>
<section id="multi-node-single-gpu">
<h3><span class="section-number">23.2.3. </span>Multi-Node, Single-GPU<a class="headerlink" href="#multi-node-single-gpu" title="Permalink to this headline">ï</a></h3>
<p>Beyond memory allocation, remote peer access does not have EGM-specific
modification and it follows CUDA inter process (IPC) protocol. See
<a class="reference external" href="https://www.google.com/url?q=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%23allocating-physical-memory&amp;sa=D&amp;source=editors&amp;ust=1696873412606850&amp;usg=AOvVaw0IF8bdtDWgRlAiW3tIoyXg">CUDA Programming Guide</a>
for more details in IPC.</p>
<p>The user should allocate memory using <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> and again the
user has to explicitly provide <code class="docutils literal notranslate"><span class="pre">CU_MEM_LOCATION_TYPE_HOST_NUMA</span></code> as
the location type and <cite>numaID</cite> as the location identifier. In
addition <code class="docutils literal notranslate"><span class="pre">CU_MEM_HANDLE_TYPE_FABRIC</span></code> should be defined as the
requested handle type. The following code snippet shows allocating
physical memory onÂ Node A:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">CUmemAllocationProp</span><span class="w"> </span><span class="n">prop</span><span class="p">{};</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ALLOCATION_TYPE_PINNED</span><span class="p">;</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">requestedHandleTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_HANDLE_TYPE_FABRIC</span><span class="p">;</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_HOST_NUMA</span><span class="p">;</span><span class="w"></span>
<span class="n">prop</span><span class="p">.</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numaId</span><span class="p">;</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemGetAllocationGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">page_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">padded_size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">page_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemCreate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>After creating allocation handle using <code class="docutils literal notranslate"><span class="pre">cuMemCreate</span></code> the user can
export that handle to the other node, Node B, calling
<code class="docutils literal notranslate"><span class="pre">cuMemExportToShareableHandle</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cuMemExportToShareableHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fabricHandle</span><span class="p">,</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">,</span><span class="w"></span>
<span class="w">                             </span><span class="n">CU_MEM_HANDLE_TYPE_FABRIC</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="c1">// At this point, fabricHandle should be sent to Node B via TCP/IP.</span>
</pre></div>
</div>
<p>On Node B, the handle can be imported using
<code class="docutils literal notranslate"><span class="pre">cuMemImportFromShareableHandle</span></code> and treated as any other fabric
handle</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// At this point, fabricHandle should be received from Node A via TCP/IP.</span>
<span class="n">CUmemGenericAllocationHandle</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemImportFromShareableHandle</span><span class="p">(</span><span class="o">&amp;</span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fabricHandle</span><span class="p">,</span><span class="w"></span>
<span class="w">                               </span><span class="n">CU_MEM_HANDLE_TYPE_FABRIC</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When handle is imported at Node B, then the user can reserve an address
space and map it locally in a regular fashion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">granularity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemGetAllocationGranularity</span><span class="p">(</span><span class="o">&amp;</span><span class="n">granularity</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">prop</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="n">MEM_ALLOC_GRANULARITY_MINIMUM</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">padded_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ROUND_UP</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">granularity</span><span class="p">);</span><span class="w"></span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">page_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">padded_size</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">page_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">CUdeviceptr</span><span class="w"> </span><span class="n">dptr</span><span class="p">;</span><span class="w"></span>
<span class="n">cuMemAddressReserve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="n">cuMemMap</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">padded_size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">allocHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As the final step, the user should give appropriate accesses to each of
the local GPUs at Node B. An example code snippet that gives read and
write access to eight local GPUs:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Give all 8 local Â GPUS access to exported EGM memory located on Node A.                                                               |</span>
<span class="n">CUmemAccessDesc</span><span class="w"> </span><span class="n">accessDesc</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">accessDesc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_LOCATION_TYPE_DEVICE</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">accessDesc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">location</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">accessDesc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CU_MEM_ACCESS_FLAGS_PROT_READWRITE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">cuMemSetAccess</span><span class="p">(</span><span class="n">dptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">accessDesc</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="notices">
<h1><span class="section-number">24. </span>Notices<a class="headerlink" href="#notices" title="Permalink to this headline">ï</a></h1>
<section id="notice">
<h2><span class="section-number">24.1. </span>Notice<a class="headerlink" href="#notice" title="Permalink to this headline">ï</a></h2>
<p>This document is provided for information purposes only and shall not be regarded as a warranty of a certain functionality, condition, or quality of a product. NVIDIA Corporation (âNVIDIAâ) makes no representations or warranties, expressed or implied, as to the accuracy or completeness of the information contained in this document and assumes no responsibility for any errors contained herein. NVIDIA shall have no liability for the consequences or use of such information or for any infringement of patents or other rights of third parties that may result from its use. This document is not a commitment to develop, release, or deliver any Material (defined below), code, or functionality.</p>
<p>NVIDIA reserves the right to make corrections, modifications, enhancements, improvements, and any other changes to this document, at any time without notice.</p>
<p>Customer should obtain the latest relevant information before placing orders and should verify that such information is current and complete.</p>
<p>NVIDIA products are sold subject to the NVIDIA standard terms and conditions of sale supplied at the time of order acknowledgement, unless otherwise agreed in an individual sales agreement signed by authorized representatives of NVIDIA and customer (âTerms of Saleâ). NVIDIA hereby expressly objects to applying any customer general terms and conditions with regards to the purchase of the NVIDIA product referenced in this document. No contractual obligations are formed either directly or indirectly by this document.</p>
<p>NVIDIA products are not designed, authorized, or warranted to be suitable for use in medical, military, aircraft, space, or life support equipment, nor in applications where failure or malfunction of the NVIDIA product can reasonably be expected to result in personal injury, death, or property or environmental damage. NVIDIA accepts no liability for inclusion and/or use of NVIDIA products in such equipment or applications and therefore such inclusion and/or use is at customerâs own risk.</p>
<p>NVIDIA makes no representation or warranty that products based on this document will be suitable for any specified use. Testing of all parameters of each product is not necessarily performed by NVIDIA. It is customerâs sole responsibility to evaluate and determine the applicability of any information contained in this document, ensure the product is suitable and fit for the application planned by customer, and perform the necessary testing for the application in order to avoid a default of the application or the product. Weaknesses in customerâs product designs may affect the quality and reliability of the NVIDIA product and may result in additional or different conditions and/or requirements beyond those contained in this document. NVIDIA accepts no liability related to any default, damage, costs, or problem which may be based on or attributable to: (i) the use of the NVIDIA product in any manner that is contrary to this document or (ii) customer product designs.</p>
<p>No license, either expressed or implied, is granted under any NVIDIA patent right, copyright, or other NVIDIA intellectual property right under this document. Information published by NVIDIA regarding third-party products or services does not constitute a license from NVIDIA to use such products or services or a warranty or endorsement thereof. Use of such information may require a license from a third party under the patents or other intellectual property rights of the third party, or a license from NVIDIA under the patents or other intellectual property rights of NVIDIA.</p>
<p>Reproduction of information in this document is permissible only if approved in advance by NVIDIA in writing, reproduced without alteration and in full compliance with all applicable export laws and regulations, and accompanied by all associated conditions, limitations, and notices.</p>
<p>THIS DOCUMENT AND ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND SEPARATELY, âMATERIALSâ) ARE BEING PROVIDED âAS IS.â NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL NVIDIA BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF ANY USE OF THIS DOCUMENT, EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Notwithstanding any damages that customer might incur for any reason whatsoever, NVIDIAâs aggregate and cumulative liability towards customer for the products described herein shall be limited in accordance with the Terms of Sale for the product.</p>
</section>
<section id="opencl">
<h2><span class="section-number">24.2. </span>OpenCL<a class="headerlink" href="#opencl" title="Permalink to this headline">ï</a></h2>
<p>OpenCL is a trademark of Apple Inc. used under license to the Khronos Group Inc.</p>
</section>
<section id="trademarks">
<h2><span class="section-number">24.3. </span>Trademarks<a class="headerlink" href="#trademarks" title="Permalink to this headline">ï</a></h2>
<p>NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation in the U.S. and other countries. Other company and product names may be trademarks of the respective companies with which they are associated.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
<img src="../_static/NVIDIA-LogoBlack.svg" class="only-light"/>
<img src="../_static/NVIDIA-LogoWhite.svg" class="only-dark"/>

<p class="notices">
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-policy/" target="_blank">Privacy Policy</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/privacy-center/" target="_blank">Manage My Privacy</a>
|
<a href="https://www.nvidia.com/en-us/preferences/start/" target="_blank">Do Not Sell or Share My Data</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/terms-of-service/" target="_blank">Terms of Service</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/accessibility/" target="_blank">Accessibility</a>
|
<a href="https://www.nvidia.com/en-us/about-nvidia/company-policies/" target="_blank">Corporate Policies</a>
|
<a href="https://www.nvidia.com/en-us/product-security/" target="_blank">Product Security</a>
|
<a href="https://www.nvidia.com/en-us/contact/" target="_blank">Contact</a>
</p>

<p>
  Copyright &#169; 2007-2025, NVIDIA Corporation &amp; affiliates. All rights reserved.
</p>

    <p>
      <span class="lastupdated">Last updated on May 16, 2025.
      </span></p>

  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
 



</body>
</html>